(function () { const e = document.createElement("link").relList; if (e && e.supports && e.supports("modulepreload")) return; for (const i of document.querySelectorAll('link[rel="modulepreload"]')) r(i); new MutationObserver(i => { for (const a of i) if (a.type === "childList") for (const o of a.addedNodes) o.tagName === "LINK" && o.rel === "modulepreload" && r(o) }).observe(document, { childList: !0, subtree: !0 }); function t(i) { const a = {}; return i.integrity && (a.integrity = i.integrity), i.referrerPolicy && (a.referrerPolicy = i.referrerPolicy), i.crossOrigin === "use-credentials" ? a.credentials = "include" : i.crossOrigin === "anonymous" ? a.credentials = "omit" : a.credentials = "same-origin", a } function r(i) { if (i.ep) return; i.ep = !0; const a = t(i); fetch(i.href, a) } })();/**
* @vue/shared v3.5.16
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**//*! #__NO_SIDE_EFFECTS__ */function xL(n) { const e = Object.create(null); for (const t of n.split(",")) e[t] = 1; return t => t in e } const Tn = {}, Nm = [], Do = () => { }, Ome = () => !1, UT = n => n.charCodeAt(0) === 111 && n.charCodeAt(1) === 110 && (n.charCodeAt(2) > 122 || n.charCodeAt(2) < 97), zW = n => n.startsWith("onUpdate:"), Dr = Object.assign, SL = (n, e) => { const t = n.indexOf(e); t > -1 && n.splice(t, 1) }, Dme = Object.prototype.hasOwnProperty, On = (n, e) => Dme.call(n, e), Mt = Array.isArray, Bm = n => J_(n) === "[object Map]", VW = n => J_(n) === "[object Set]", jme = n => J_(n) === "[object RegExp]", Lt = n => typeof n == "function", Sr = n => typeof n == "string", Bd = n => typeof n == "symbol", Jn = n => n !== null && typeof n == "object", TL = n => (Jn(n) || Lt(n)) && Lt(n.then) && Lt(n.catch), HW = Object.prototype.toString, J_ = n => HW.call(n), Pme = n => J_(n).slice(8, -1), UW = n => J_(n) === "[object Object]", kL = n => Sr(n) && n !== "NaN" && n[0] !== "-" && "" + parseInt(n, 10) === n, $m = xL(",key,ref,ref_for,ref_key,onVnodeBeforeMount,onVnodeMounted,onVnodeBeforeUpdate,onVnodeUpdated,onVnodeBeforeUnmount,onVnodeUnmounted"), GT = n => { const e = Object.create(null); return t => e[t] || (e[t] = n(t)) }, Ime = /-(\w)/g, Ta = GT(n => n.replace(Ime, (e, t) => t ? t.toUpperCase() : "")), Lme = /\B([A-Z])/g, Ng = GT(n => n.replace(Lme, "-$1").toLowerCase()), CL = GT(n => n.charAt(0).toUpperCase() + n.slice(1)), $y = GT(n => n ? `on${CL(n)}` : ""), Yi = (n, e) => !Object.is(n, e), Fy = (n, ...e) => { for (let t = 0; t < n.length; t++)n[t](...e) }, GW = (n, e, t, r = !1) => { Object.defineProperty(n, e, { configurable: !0, enumerable: !1, writable: r, value: t }) }, Rme = n => { const e = parseFloat(n); return isNaN(e) ? n : e }, Nme = n => { const e = Sr(n) ? Number(n) : NaN; return isNaN(e) ? n : e }; let d4; const WT = () => d4 || (d4 = typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : typeof window < "u" ? window : typeof global < "u" ? global : {}), Bme = "Infinity,undefined,NaN,isFinite,isNaN,parseFloat,parseInt,decodeURI,decodeURIComponent,encodeURI,encodeURIComponent,Math,Number,Date,Array,Object,Boolean,String,RegExp,Map,Set,JSON,Intl,BigInt,console,Error,Symbol", $me = xL(Bme); function aa(n) { if (Mt(n)) { const e = {}; for (let t = 0; t < n.length; t++) { const r = n[t], i = Sr(r) ? Hme(r) : aa(r); if (i) for (const a in i) e[a] = i[a] } return e } else if (Sr(n) || Jn(n)) return n } const Fme = /;(?![^(]*\))/g, zme = /:([^]+)/, Vme = /\/\*[^]*?\*\//g; function Hme(n) { const e = {}; return n.replace(Vme, "").split(Fme).forEach(t => { if (t) { const r = t.split(zme); r.length > 1 && (e[r[0].trim()] = r[1].trim()) } }), e } function Tt(n) { let e = ""; if (Sr(n)) e = n; else if (Mt(n)) for (let t = 0; t < n.length; t++) { const r = Tt(n[t]); r && (e += r + " ") } else if (Jn(n)) for (const t in n) n[t] && (e += t + " "); return e.trim() } function Eo(n) { if (!n) return null; let { class: e, style: t } = n; return e && !Sr(e) && (n.class = Tt(e)), t && (n.style = aa(t)), n } const WW = n => !!(n && n.__v_isRef === !0), Ht = n => Sr(n) ? n : n == null ? "" : Mt(n) || Jn(n) && (n.toString === HW || !Lt(n.toString)) ? WW(n) ? Ht(n.value) : JSON.stringify(n, KW, 2) : String(n), KW = (n, e) => WW(e) ? KW(n, e.value) : Bm(e) ? { [`Map(${e.size})`]: [...e.entries()].reduce((t, [r, i], a) => (t[YA(r, a) + " =>"] = i, t), {}) } : VW(e) ? { [`Set(${e.size})`]: [...e.values()].map(t => YA(t)) } : Bd(e) ? YA(e) : Jn(e) && !Mt(e) && !UW(e) ? String(e) : e, YA = (n, e = "") => { var t; return Bd(n) ? `Symbol(${(t = n.description) != null ? t : e})` : n };/**
* @vue/reactivity v3.5.16
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/let xi; class qW { constructor(e = !1) { this.detached = e, this._active = !0, this._on = 0, this.effects = [], this.cleanups = [], this._isPaused = !1, this.parent = xi, !e && xi && (this.index = (xi.scopes || (xi.scopes = [])).push(this) - 1) } get active() { return this._active } pause() { if (this._active) { this._isPaused = !0; let e, t; if (this.scopes) for (e = 0, t = this.scopes.length; e < t; e++)this.scopes[e].pause(); for (e = 0, t = this.effects.length; e < t; e++)this.effects[e].pause() } } resume() { if (this._active && this._isPaused) { this._isPaused = !1; let e, t; if (this.scopes) for (e = 0, t = this.scopes.length; e < t; e++)this.scopes[e].resume(); for (e = 0, t = this.effects.length; e < t; e++)this.effects[e].resume() } } run(e) { if (this._active) { const t = xi; try { return xi = this, e() } finally { xi = t } } } on() { ++this._on === 1 && (this.prevScope = xi, xi = this) } off() { this._on > 0 && --this._on === 0 && (xi = this.prevScope, this.prevScope = void 0) } stop(e) { if (this._active) { this._active = !1; let t, r; for (t = 0, r = this.effects.length; t < r; t++)this.effects[t].stop(); for (this.effects.length = 0, t = 0, r = this.cleanups.length; t < r; t++)this.cleanups[t](); if (this.cleanups.length = 0, this.scopes) { for (t = 0, r = this.scopes.length; t < r; t++)this.scopes[t].stop(!0); this.scopes.length = 0 } if (!this.detached && this.parent && !e) { const i = this.parent.scopes.pop(); i && i !== this && (this.parent.scopes[this.index] = i, i.index = this.index) } this.parent = void 0 } } } function YW(n) { return new qW(n) } function Q_() { return xi } function eb(n, e = !1) { xi && xi.cleanups.push(n) } let Wn; const ZA = new WeakSet; class yS { constructor(e) { this.fn = e, this.deps = void 0, this.depsTail = void 0, this.flags = 5, this.next = void 0, this.cleanup = void 0, this.scheduler = void 0, xi && xi.active && xi.effects.push(this) } pause() { this.flags |= 64 } resume() { this.flags & 64 && (this.flags &= -65, ZA.has(this) && (ZA.delete(this), this.trigger())) } notify() { this.flags & 2 && !(this.flags & 32) || this.flags & 8 || XW(this) } run() { if (!(this.flags & 1)) return this.fn(); this.flags |= 2, f4(this), JW(this); const e = Wn, t = vs; Wn = this, vs = !0; try { return this.fn() } finally { QW(this), Wn = e, vs = t, this.flags &= -3 } } stop() { if (this.flags & 1) { for (let e = this.deps; e; e = e.nextDep)ML(e); this.deps = this.depsTail = void 0, f4(this), this.onStop && this.onStop(), this.flags &= -2 } } trigger() { this.flags & 64 ? ZA.add(this) : this.scheduler ? this.scheduler() : this.runIfDirty() } runIfDirty() { jD(this) && this.run() } get dirty() { return jD(this) } } let ZW = 0, zy, Vy; function XW(n, e = !1) { if (n.flags |= 8, e) { n.next = Vy, Vy = n; return } n.next = zy, zy = n } function AL() { ZW++ } function EL() { if (--ZW > 0) return; if (Vy) { let e = Vy; for (Vy = void 0; e;) { const t = e.next; e.next = void 0, e.flags &= -9, e = t } } let n; for (; zy;) { let e = zy; for (zy = void 0; e;) { const t = e.next; if (e.next = void 0, e.flags &= -9, e.flags & 1) try { e.trigger() } catch (r) { n || (n = r) } e = t } } if (n) throw n } function JW(n) { for (let e = n.deps; e; e = e.nextDep)e.version = -1, e.prevActiveLink = e.dep.activeLink, e.dep.activeLink = e } function QW(n) { let e, t = n.depsTail, r = t; for (; r;) { const i = r.prevDep; r.version === -1 ? (r === t && (t = i), ML(r), Ume(r)) : e = r, r.dep.activeLink = r.prevActiveLink, r.prevActiveLink = void 0, r = i } n.deps = e, n.depsTail = t } function jD(n) { for (let e = n.deps; e; e = e.nextDep)if (e.dep.version !== e.version || e.dep.computed && (eK(e.dep.computed) || e.dep.version !== e.version)) return !0; return !!n._dirty } function eK(n) { if (n.flags & 4 && !(n.flags & 16) || (n.flags &= -17, n.globalVersion === A0) || (n.globalVersion = A0, !n.isSSR && n.flags & 128 && (!n.deps && !n._dirty || !jD(n)))) return; n.flags |= 2; const e = n.dep, t = Wn, r = vs; Wn = n, vs = !0; try { JW(n); const i = n.fn(n._value); (e.version === 0 || Yi(i, n._value)) && (n.flags |= 128, n._value = i, e.version++) } catch (i) { throw e.version++, i } finally { Wn = t, vs = r, QW(n), n.flags &= -3 } } function ML(n, e = !1) { const { dep: t, prevSub: r, nextSub: i } = n; if (r && (r.nextSub = i, n.prevSub = void 0), i && (i.prevSub = r, n.nextSub = void 0), t.subs === n && (t.subs = r, !r && t.computed)) { t.computed.flags &= -5; for (let a = t.computed.deps; a; a = a.nextDep)ML(a, !0) } !e && !--t.sc && t.map && t.map.delete(t.key) } function Ume(n) { const { prevDep: e, nextDep: t } = n; e && (e.nextDep = t, n.prevDep = void 0), t && (t.prevDep = e, n.nextDep = void 0) } function Iut(n, e) { n.effect instanceof yS && (n = n.effect.fn); const t = new yS(n); e && Dr(t, e); try { t.run() } catch (i) { throw t.stop(), i } const r = t.run.bind(t); return r.effect = t, r } function Lut(n) { n.effect.stop() } let vs = !0; const tK = []; function Tc() { tK.push(vs), vs = !1 } function kc() { const n = tK.pop(); vs = n === void 0 ? !0 : n } function f4(n) { const { cleanup: e } = n; if (n.cleanup = void 0, e) { const t = Wn; Wn = void 0; try { e() } finally { Wn = t } } } let A0 = 0, Gme = class { constructor(e, t) { this.sub = e, this.dep = t, this.version = t.version, this.nextDep = this.prevDep = this.nextSub = this.prevSub = this.prevActiveLink = void 0 } }; class KT { constructor(e) { this.computed = e, this.version = 0, this.activeLink = void 0, this.subs = void 0, this.map = void 0, this.key = void 0, this.sc = 0 } track(e) { if (!Wn || !vs || Wn === this.computed) return; let t = this.activeLink; if (t === void 0 || t.sub !== Wn) t = this.activeLink = new Gme(Wn, this), Wn.deps ? (t.prevDep = Wn.depsTail, Wn.depsTail.nextDep = t, Wn.depsTail = t) : Wn.deps = Wn.depsTail = t, nK(t); else if (t.version === -1 && (t.version = this.version, t.nextDep)) { const r = t.nextDep; r.prevDep = t.prevDep, t.prevDep && (t.prevDep.nextDep = r), t.prevDep = Wn.depsTail, t.nextDep = void 0, Wn.depsTail.nextDep = t, Wn.depsTail = t, Wn.deps === t && (Wn.deps = r) } return t } trigger(e) { this.version++, A0++, this.notify(e) } notify(e) { AL(); try { for (let t = this.subs; t; t = t.prevSub)t.sub.notify() && t.sub.dep.notify() } finally { EL() } } } function nK(n) { if (n.dep.sc++, n.sub.flags & 4) { const e = n.dep.computed; if (e && !n.dep.subs) { e.flags |= 20; for (let r = e.deps; r; r = r.nextDep)nK(r) } const t = n.dep.subs; t !== n && (n.prevSub = t, t && (t.nextSub = n)), n.dep.subs = n } } const _S = new WeakMap, sh = Symbol(""), PD = Symbol(""), E0 = Symbol(""); function Ci(n, e, t) { if (vs && Wn) { let r = _S.get(n); r || _S.set(n, r = new Map); let i = r.get(t); i || (r.set(t, i = new KT), i.map = r, i.key = t), i.track() } } function lc(n, e, t, r, i, a) { const o = _S.get(n); if (!o) { A0++; return } const s = l => { l && l.trigger() }; if (AL(), e === "clear") o.forEach(s); else { const l = Mt(n), c = l && kL(t); if (l && t === "length") { const u = Number(r); o.forEach((d, f) => { (f === "length" || f === E0 || !Bd(f) && f >= u) && s(d) }) } else switch ((t !== void 0 || o.has(void 0)) && s(o.get(t)), c && s(o.get(E0)), e) { case "add": l ? c && s(o.get("length")) : (s(o.get(sh)), Bm(n) && s(o.get(PD))); break; case "delete": l || (s(o.get(sh)), Bm(n) && s(o.get(PD))); break; case "set": Bm(n) && s(o.get(sh)); break } } EL() } function Wme(n, e) { const t = _S.get(n); return t && t.get(e) } function Mp(n) { const e = Vt(n); return e === n ? e : (Ci(e, "iterate", E0), jo(n) ? e : e.map(si)) } function qT(n) { return Ci(n = Vt(n), "iterate", E0), n } const Kme = { __proto__: null, [Symbol.iterator]() { return XA(this, Symbol.iterator, si) }, concat(...n) { return Mp(this).concat(...n.map(e => Mt(e) ? Mp(e) : e)) }, entries() { return XA(this, "entries", n => (n[1] = si(n[1]), n)) }, every(n, e) { return Kl(this, "every", n, e, void 0, arguments) }, filter(n, e) { return Kl(this, "filter", n, e, t => t.map(si), arguments) }, find(n, e) { return Kl(this, "find", n, e, si, arguments) }, findIndex(n, e) { return Kl(this, "findIndex", n, e, void 0, arguments) }, findLast(n, e) { return Kl(this, "findLast", n, e, si, arguments) }, findLastIndex(n, e) { return Kl(this, "findLastIndex", n, e, void 0, arguments) }, forEach(n, e) { return Kl(this, "forEach", n, e, void 0, arguments) }, includes(...n) { return JA(this, "includes", n) }, indexOf(...n) { return JA(this, "indexOf", n) }, join(n) { return Mp(this).join(n) }, lastIndexOf(...n) { return JA(this, "lastIndexOf", n) }, map(n, e) { return Kl(this, "map", n, e, void 0, arguments) }, pop() { return Mv(this, "pop") }, push(...n) { return Mv(this, "push", n) }, reduce(n, ...e) { return h4(this, "reduce", n, e) }, reduceRight(n, ...e) { return h4(this, "reduceRight", n, e) }, shift() { return Mv(this, "shift") }, some(n, e) { return Kl(this, "some", n, e, void 0, arguments) }, splice(...n) { return Mv(this, "splice", n) }, toReversed() { return Mp(this).toReversed() }, toSorted(n) { return Mp(this).toSorted(n) }, toSpliced(...n) { return Mp(this).toSpliced(...n) }, unshift(...n) { return Mv(this, "unshift", n) }, values() { return XA(this, "values", si) } }; function XA(n, e, t) { const r = qT(n), i = r[e](); return r !== n && !jo(n) && (i._next = i.next, i.next = () => { const a = i._next(); return a.value && (a.value = t(a.value)), a }), i } const qme = Array.prototype; function Kl(n, e, t, r, i, a) { const o = qT(n), s = o !== n && !jo(n), l = o[e]; if (l !== qme[e]) { const d = l.apply(n, a); return s ? si(d) : d } let c = t; o !== n && (s ? c = function (d, f) { return t.call(this, si(d), f, n) } : t.length > 2 && (c = function (d, f) { return t.call(this, d, f, n) })); const u = l.call(o, c, r); return s && i ? i(u) : u } function h4(n, e, t, r) { const i = qT(n); let a = t; return i !== n && (jo(n) ? t.length > 3 && (a = function (o, s, l) { return t.call(this, o, s, l, n) }) : a = function (o, s, l) { return t.call(this, o, si(s), l, n) }), i[e](a, ...r) } function JA(n, e, t) { const r = Vt(n); Ci(r, "iterate", E0); const i = r[e](...t); return (i === -1 || i === !1) && OL(t[0]) ? (t[0] = Vt(t[0]), r[e](...t)) : i } function Mv(n, e, t = []) { Tc(), AL(); const r = Vt(n)[e].apply(n, t); return EL(), kc(), r } const Yme = xL("__proto__,__v_isRef,__isVue"), rK = new Set(Object.getOwnPropertyNames(Symbol).filter(n => n !== "arguments" && n !== "caller").map(n => Symbol[n]).filter(Bd)); function Zme(n) { Bd(n) || (n = String(n)); const e = Vt(this); return Ci(e, "has", n), e.hasOwnProperty(n) } class iK { constructor(e = !1, t = !1) { this._isReadonly = e, this._isShallow = t } get(e, t, r) { if (t === "__v_skip") return e.__v_skip; const i = this._isReadonly, a = this._isShallow; if (t === "__v_isReactive") return !i; if (t === "__v_isReadonly") return i; if (t === "__v_isShallow") return a; if (t === "__v_raw") return r === (i ? a ? uK : cK : a ? lK : sK).get(e) || Object.getPrototypeOf(e) === Object.getPrototypeOf(r) ? e : void 0; const o = Mt(e); if (!i) { let l; if (o && (l = Kme[t])) return l; if (t === "hasOwnProperty") return Zme } const s = Reflect.get(e, t, Kn(e) ? e : r); return (Bd(t) ? rK.has(t) : Yme(t)) || (i || Ci(e, "get", t), a) ? s : Kn(s) ? o && kL(t) ? s : s.value : Jn(s) ? i ? ba(s) : vr(s) : s } } class aK extends iK { constructor(e = !1) { super(!1, e) } set(e, t, r, i) { let a = e[t]; if (!this._isShallow) { const l = dd(a); if (!jo(r) && !dd(r) && (a = Vt(a), r = Vt(r)), !Mt(e) && Kn(a) && !Kn(r)) return l ? !1 : (a.value = r, !0) } const o = Mt(e) && kL(t) ? Number(t) < e.length : On(e, t), s = Reflect.set(e, t, r, Kn(e) ? e : i); return e === Vt(i) && (o ? Yi(r, a) && lc(e, "set", t, r) : lc(e, "add", t, r)), s } deleteProperty(e, t) { const r = On(e, t); e[t]; const i = Reflect.deleteProperty(e, t); return i && r && lc(e, "delete", t, void 0), i } has(e, t) { const r = Reflect.has(e, t); return (!Bd(t) || !rK.has(t)) && Ci(e, "has", t), r } ownKeys(e) { return Ci(e, "iterate", Mt(e) ? "length" : sh), Reflect.ownKeys(e) } } class oK extends iK { constructor(e = !1) { super(!0, e) } set(e, t) { return !0 } deleteProperty(e, t) { return !0 } } const Xme = new aK, Jme = new oK, Qme = new aK(!0), ege = new oK(!0), ID = n => n, O1 = n => Reflect.getPrototypeOf(n); function tge(n, e, t) { return function (...r) { const i = this.__v_raw, a = Vt(i), o = Bm(a), s = n === "entries" || n === Symbol.iterator && o, l = n === "keys" && o, c = i[n](...r), u = t ? ID : e ? bS : si; return !e && Ci(a, "iterate", l ? PD : sh), { next() { const { value: d, done: f } = c.next(); return f ? { value: d, done: f } : { value: s ? [u(d[0]), u(d[1])] : u(d), done: f } }, [Symbol.iterator]() { return this } } } } function D1(n) { return function (...e) { return n === "delete" ? !1 : n === "clear" ? void 0 : this } } function nge(n, e) { const t = { get(i) { const a = this.__v_raw, o = Vt(a), s = Vt(i); n || (Yi(i, s) && Ci(o, "get", i), Ci(o, "get", s)); const { has: l } = O1(o), c = e ? ID : n ? bS : si; if (l.call(o, i)) return c(a.get(i)); if (l.call(o, s)) return c(a.get(s)); a !== o && a.get(i) }, get size() { const i = this.__v_raw; return !n && Ci(Vt(i), "iterate", sh), Reflect.get(i, "size", i) }, has(i) { const a = this.__v_raw, o = Vt(a), s = Vt(i); return n || (Yi(i, s) && Ci(o, "has", i), Ci(o, "has", s)), i === s ? a.has(i) : a.has(i) || a.has(s) }, forEach(i, a) { const o = this, s = o.__v_raw, l = Vt(s), c = e ? ID : n ? bS : si; return !n && Ci(l, "iterate", sh), s.forEach((u, d) => i.call(a, c(u), c(d), o)) } }; return Dr(t, n ? { add: D1("add"), set: D1("set"), delete: D1("delete"), clear: D1("clear") } : { add(i) { !e && !jo(i) && !dd(i) && (i = Vt(i)); const a = Vt(this); return O1(a).has.call(a, i) || (a.add(i), lc(a, "add", i, i)), this }, set(i, a) { !e && !jo(a) && !dd(a) && (a = Vt(a)); const o = Vt(this), { has: s, get: l } = O1(o); let c = s.call(o, i); c || (i = Vt(i), c = s.call(o, i)); const u = l.call(o, i); return o.set(i, a), c ? Yi(a, u) && lc(o, "set", i, a) : lc(o, "add", i, a), this }, delete(i) { const a = Vt(this), { has: o, get: s } = O1(a); let l = o.call(a, i); l || (i = Vt(i), l = o.call(a, i)), s && s.call(a, i); const c = a.delete(i); return l && lc(a, "delete", i, void 0), c }, clear() { const i = Vt(this), a = i.size !== 0, o = i.clear(); return a && lc(i, "clear", void 0, void 0), o } }), ["keys", "values", "entries", Symbol.iterator].forEach(i => { t[i] = tge(i, n, e) }), t } function YT(n, e) { const t = nge(n, e); return (r, i, a) => i === "__v_isReactive" ? !n : i === "__v_isReadonly" ? n : i === "__v_raw" ? r : Reflect.get(On(t, i) && i in r ? t : r, i, a) } const rge = { get: YT(!1, !1) }, ige = { get: YT(!1, !0) }, age = { get: YT(!0, !1) }, oge = { get: YT(!0, !0) }, sK = new WeakMap, lK = new WeakMap, cK = new WeakMap, uK = new WeakMap; function sge(n) { switch (n) { case "Object": case "Array": return 1; case "Map": case "Set": case "WeakMap": case "WeakSet": return 2; default: return 0 } } function lge(n) { return n.__v_skip || !Object.isExtensible(n) ? 0 : sge(Pme(n)) } function vr(n) { return dd(n) ? n : ZT(n, !1, Xme, rge, sK) } function dK(n) { return ZT(n, !1, Qme, ige, lK) } function ba(n) { return ZT(n, !0, Jme, age, cK) } function Op(n) { return ZT(n, !0, ege, oge, uK) } function ZT(n, e, t, r, i) { if (!Jn(n) || n.__v_raw && !(e && n.__v_isReactive)) return n; const a = lge(n); if (a === 0) return n; const o = i.get(n); if (o) return o; const s = new Proxy(n, a === 2 ? r : t); return i.set(n, s), s } function ul(n) { return dd(n) ? ul(n.__v_raw) : !!(n && n.__v_isReactive) } function dd(n) { return !!(n && n.__v_isReadonly) } function jo(n) { return !!(n && n.__v_isShallow) } function OL(n) { return n ? !!n.__v_raw : !1 } function Vt(n) { const e = n && n.__v_raw; return e ? Vt(e) : n } function dn(n) { return !On(n, "__v_skip") && Object.isExtensible(n) && GW(n, "__v_skip", !0), n } const si = n => Jn(n) ? vr(n) : n, bS = n => Jn(n) ? ba(n) : n; function Kn(n) { return n ? n.__v_isRef === !0 : !1 } function he(n) { return fK(n, !1) } function Fa(n) { return fK(n, !0) } function fK(n, e) { return Kn(n) ? n : new cge(n, e) } class cge { constructor(e, t) { this.dep = new KT, this.__v_isRef = !0, this.__v_isShallow = !1, this._rawValue = t ? e : Vt(e), this._value = t ? e : si(e), this.__v_isShallow = t } get value() { return this.dep.track(), this._value } set value(e) { const t = this._rawValue, r = this.__v_isShallow || jo(e) || dd(e); e = r ? e : Vt(e), Yi(e, t) && (this._rawValue = e, this._value = r ? e : si(e), this.dep.trigger()) } } function p4(n) { n.dep && n.dep.trigger() } function X(n) { return Kn(n) ? n.value : n } function Po(n) { return Lt(n) ? n() : X(n) } const uge = { get: (n, e, t) => e === "__v_raw" ? n : X(Reflect.get(n, e, t)), set: (n, e, t, r) => { const i = n[e]; return Kn(i) && !Kn(t) ? (i.value = t, !0) : Reflect.set(n, e, t, r) } }; function hK(n) { return ul(n) ? n : new Proxy(n, uge) } class dge { constructor(e) { this.__v_isRef = !0, this._value = void 0; const t = this.dep = new KT, { get: r, set: i } = e(t.track.bind(t), t.trigger.bind(t)); this._get = r, this._set = i } get value() { return this._value = this._get() } set value(e) { this._set(e) } } function XT(n) { return new dge(n) } function tb(n) { const e = Mt(n) ? new Array(n.length) : {}; for (const t in n) e[t] = pK(n, t); return e } class fge { constructor(e, t, r) { this._object = e, this._key = t, this._defaultValue = r, this.__v_isRef = !0, this._value = void 0 } get value() { const e = this._object[this._key]; return this._value = e === void 0 ? this._defaultValue : e } set value(e) { this._object[this._key] = e } get dep() { return Wme(Vt(this._object), this._key) } } class hge { constructor(e) { this._getter = e, this.__v_isRef = !0, this.__v_isReadonly = !0, this._value = void 0 } get value() { return this._value = this._getter() } } function M0(n, e, t) { return Kn(n) ? n : Lt(n) ? new hge(n) : Jn(n) && arguments.length > 1 ? pK(n, e, t) : he(n) } function pK(n, e, t) { const r = n[e]; return Kn(r) ? r : new fge(n, e, t) } class pge { constructor(e, t, r) { this.fn = e, this.setter = t, this._value = void 0, this.dep = new KT(this), this.__v_isRef = !0, this.deps = void 0, this.depsTail = void 0, this.flags = 16, this.globalVersion = A0 - 1, this.next = void 0, this.effect = this, this.__v_isReadonly = !t, this.isSSR = r } notify() { if (this.flags |= 16, !(this.flags & 8) && Wn !== this) return XW(this, !0), !0 } get value() { const e = this.dep.track(); return eK(this), e && (e.version = this.dep.version), this._value } set value(e) { this.setter && this.setter(e) } } function mge(n, e, t = !1) { let r, i; return Lt(n) ? r = n : (r = n.get, i = n.set), new pge(r, i, t) } const Nut = { GET: "get", HAS: "has", ITERATE: "iterate" }, But = { SET: "set", ADD: "add", DELETE: "delete", CLEAR: "clear" }, j1 = {}, wS = new WeakMap; let _u; function $ut() { return _u } function gge(n, e = !1, t = _u) { if (t) { let r = wS.get(t); r || wS.set(t, r = []), r.push(n) } } function vge(n, e, t = Tn) { const { immediate: r, deep: i, once: a, scheduler: o, augmentJob: s, call: l } = t, c = v => i ? v : jo(v) || i === !1 || i === 0 ? cc(v, 1) : cc(v); let u, d, f, h, p = !1, m = !1; if (Kn(n) ? (d = () => n.value, p = jo(n)) : ul(n) ? (d = () => c(n), p = !0) : Mt(n) ? (m = !0, p = n.some(v => ul(v) || jo(v)), d = () => n.map(v => { if (Kn(v)) return v.value; if (ul(v)) return c(v); if (Lt(v)) return l ? l(v, 2) : v() })) : Lt(n) ? e ? d = l ? () => l(n, 2) : n : d = () => { if (f) { Tc(); try { f() } finally { kc() } } const v = _u; _u = u; try { return l ? l(n, 3, [h]) : n(h) } finally { _u = v } } : d = Do, e && i) { const v = d, S = i === !0 ? 1 / 0 : i; d = () => cc(v(), S) } const g = Q_(), y = () => { u.stop(), g && g.active && SL(g.effects, u) }; if (a && e) { const v = e; e = (...S) => { v(...S), y() } } let b = m ? new Array(n.length).fill(j1) : j1; const w = v => { if (!(!(u.flags & 1) || !u.dirty && !v)) if (e) { const S = u.run(); if (i || p || (m ? S.some((x, k) => Yi(x, b[k])) : Yi(S, b))) { f && f(); const x = _u; _u = u; try { const k = [S, b === j1 ? void 0 : m && b[0] === j1 ? [] : b, h]; b = S, l ? l(e, 3, k) : e(...k) } finally { _u = x } } } else u.run() }; return s && s(w), u = new yS(d), u.scheduler = o ? () => o(w, !1) : w, h = v => gge(v, !1, u), f = u.onStop = () => { const v = wS.get(u); if (v) { if (l) l(v, 4); else for (const S of v) S(); wS.delete(u) } }, e ? r ? w(!0) : b = u.run() : o ? o(w.bind(null, !0), !0) : u.run(), y.pause = u.pause.bind(u), y.resume = u.resume.bind(u), y.stop = y, y } function cc(n, e = 1 / 0, t) { if (e <= 0 || !Jn(n) || n.__v_skip || (t = t || new Set, t.has(n))) return n; if (t.add(n), e--, Kn(n)) cc(n.value, e, t); else if (Mt(n)) for (let r = 0; r < n.length; r++)cc(n[r], e, t); else if (VW(n) || Bm(n)) n.forEach(r => { cc(r, e, t) }); else if (UW(n)) { for (const r in n) cc(n[r], e, t); for (const r of Object.getOwnPropertySymbols(n)) Object.prototype.propertyIsEnumerable.call(n, r) && cc(n[r], e, t) } return n }/**
* @vue/runtime-core v3.5.16
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/const mK = []; function yge(n) { mK.push(n) } function _ge() { mK.pop() } function Fut(n, e) { } const zut = { SETUP_FUNCTION: 0, 0: "SETUP_FUNCTION", RENDER_FUNCTION: 1, 1: "RENDER_FUNCTION", NATIVE_EVENT_HANDLER: 5, 5: "NATIVE_EVENT_HANDLER", COMPONENT_EVENT_HANDLER: 6, 6: "COMPONENT_EVENT_HANDLER", VNODE_HOOK: 7, 7: "VNODE_HOOK", DIRECTIVE_HOOK: 8, 8: "DIRECTIVE_HOOK", TRANSITION_HOOK: 9, 9: "TRANSITION_HOOK", APP_ERROR_HANDLER: 10, 10: "APP_ERROR_HANDLER", APP_WARN_HANDLER: 11, 11: "APP_WARN_HANDLER", FUNCTION_REF: 12, 12: "FUNCTION_REF", ASYNC_COMPONENT_LOADER: 13, 13: "ASYNC_COMPONENT_LOADER", SCHEDULER: 14, 14: "SCHEDULER", COMPONENT_UPDATE: 15, 15: "COMPONENT_UPDATE", APP_UNMOUNT_CLEANUP: 16, 16: "APP_UNMOUNT_CLEANUP" }, bge = { sp: "serverPrefetch hook", bc: "beforeCreate hook", c: "created hook", bm: "beforeMount hook", m: "mounted hook", bu: "beforeUpdate hook", u: "updated", bum: "beforeUnmount hook", um: "unmounted hook", a: "activated hook", da: "deactivated hook", ec: "errorCaptured hook", rtc: "renderTracked hook", rtg: "renderTriggered hook", 0: "setup function", 1: "render function", 2: "watcher getter", 3: "watcher callback", 4: "watcher cleanup function", 5: "native event handler", 6: "component event handler", 7: "vnode hook", 8: "directive hook", 9: "transition hook", 10: "app errorHandler", 11: "app warnHandler", 12: "ref function", 13: "async component loader", 14: "scheduler flush", 15: "component update", 16: "app unmount cleanup function" }; function nb(n, e, t, r) { try { return r ? n(...r) : n() } catch (i) { Bg(i, e, t) } } function xs(n, e, t, r) { if (Lt(n)) { const i = nb(n, e, t, r); return i && TL(i) && i.catch(a => { Bg(a, e, t) }), i } if (Mt(n)) { const i = []; for (let a = 0; a < n.length; a++)i.push(xs(n[a], e, t, r)); return i } } function Bg(n, e, t, r = !0) { const i = e ? e.vnode : null, { errorHandler: a, throwUnhandledErrorInProduction: o } = e && e.appContext.config || Tn; if (e) { let s = e.parent; const l = e.proxy, c = `https://vuejs.org/error-reference/#runtime-${t}`; for (; s;) { const u = s.ec; if (u) { for (let d = 0; d < u.length; d++)if (u[d](n, l, c) === !1) return } s = s.parent } if (a) { Tc(), nb(a, null, 10, [n, l, c]), kc(); return } } wge(n, t, i, r, o) } function wge(n, e, t, r = !0, i = !1) { if (i) throw n; console.error(n) } const Zi = []; let Ws = -1; const Fm = []; let bu = null, um = 0; const gK = Promise.resolve(); let xS = null; function Pr(n) { const e = xS || gK; return n ? e.then(this ? n.bind(this) : n) : e } function xge(n) { let e = Ws + 1, t = Zi.length; for (; e < t;) { const r = e + t >>> 1, i = Zi[r], a = O0(i); a < n || a === n && i.flags & 2 ? e = r + 1 : t = r } return e } function DL(n) { if (!(n.flags & 1)) { const e = O0(n), t = Zi[Zi.length - 1]; !t || !(n.flags & 2) && e >= O0(t) ? Zi.push(n) : Zi.splice(xge(e), 0, n), n.flags |= 1, vK() } } function vK() { xS || (xS = gK.then(yK)) } function SS(n) { Mt(n) ? Fm.push(...n) : bu && n.id === -1 ? bu.splice(um + 1, 0, n) : n.flags & 1 || (Fm.push(n), n.flags |= 1), vK() } function m4(n, e, t = Ws + 1) { for (; t < Zi.length; t++) { const r = Zi[t]; if (r && r.flags & 2) { if (n && r.id !== n.uid) continue; Zi.splice(t, 1), t--, r.flags & 4 && (r.flags &= -2), r(), r.flags & 4 || (r.flags &= -2) } } } function TS(n) { if (Fm.length) { const e = [...new Set(Fm)].sort((t, r) => O0(t) - O0(r)); if (Fm.length = 0, bu) { bu.push(...e); return } for (bu = e, um = 0; um < bu.length; um++) { const t = bu[um]; t.flags & 4 && (t.flags &= -2), t.flags & 8 || t(), t.flags &= -2 } bu = null, um = 0 } } const O0 = n => n.id == null ? n.flags & 2 ? -1 : 1 / 0 : n.id; function yK(n) { const e = Do; try { for (Ws = 0; Ws < Zi.length; Ws++) { const t = Zi[Ws]; t && !(t.flags & 8) && (t.flags & 4 && (t.flags &= -2), nb(t, t.i, t.i ? 15 : 14), t.flags & 4 || (t.flags &= -2)) } } finally { for (; Ws < Zi.length; Ws++) { const t = Zi[Ws]; t && (t.flags &= -2) } Ws = -1, Zi.length = 0, TS(), xS = null, (Zi.length || Fm.length) && yK() } } let dm, P1 = []; function _K(n, e) { var t, r; dm = n, dm ? (dm.enabled = !0, P1.forEach(({ event: i, args: a }) => dm.emit(i, ...a)), P1 = []) : typeof window < "u" && window.HTMLElement && !((r = (t = window.navigator) == null ? void 0 : t.userAgent) != null && r.includes("jsdom")) ? ((e.__VUE_DEVTOOLS_HOOK_REPLAY__ = e.__VUE_DEVTOOLS_HOOK_REPLAY__ || []).push(a => { _K(a, e) }), setTimeout(() => { dm || (e.__VUE_DEVTOOLS_HOOK_REPLAY__ = null, P1 = []) }, 3e3)) : P1 = [] } let Fr = null, JT = null; function D0(n) { const e = Fr; return Fr = n, JT = n && n.type.__scopeId || null, e } function Vut(n) { JT = n } function Hut() { JT = null } const Uut = n => Ue; function Ue(n, e = Fr, t) { if (!e || n._n) return n; const r = (...i) => { r._d && M4(-1); const a = D0(e); let o; try { o = n(...i) } finally { D0(a), r._d && M4(1) } return o }; return r._n = !0, r._c = !0, r._d = !0, r } function Dh(n, e) { if (Fr === null) return n; const t = sb(Fr), r = n.dirs || (n.dirs = []); for (let i = 0; i < e.length; i++) { let [a, o, s, l = Tn] = e[i]; a && (Lt(a) && (a = { mounted: a, updated: a }), a.deep && cc(o), r.push({ dir: a, instance: t, value: o, oldValue: void 0, arg: s, modifiers: l })) } return n } function Js(n, e, t, r) { const i = n.dirs, a = e && e.dirs; for (let o = 0; o < i.length; o++) { const s = i[o]; a && (s.oldValue = a[o].value); let l = s.dir[r]; l && (Tc(), xs(l, t, 8, [n.el, s, n, e]), kc()) } } const bK = Symbol("_vte"), wK = n => n.__isTeleport, Hy = n => n && (n.disabled || n.disabled === ""), g4 = n => n && (n.defer || n.defer === ""), v4 = n => typeof SVGElement < "u" && n instanceof SVGElement, y4 = n => typeof MathMLElement == "function" && n instanceof MathMLElement, LD = (n, e) => { const t = n && n.to; return Sr(t) ? e ? e(t) : null : t }, xK = { name: "Teleport", __isTeleport: !0, process(n, e, t, r, i, a, o, s, l, c) { const { mc: u, pc: d, pbc: f, o: { insert: h, querySelector: p, createText: m, createComment: g } } = c, y = Hy(e.props); let { shapeFlag: b, children: w, dynamicChildren: v } = e; if (n == null) { const S = e.el = m(""), x = e.anchor = m(""); h(S, t, r), h(x, t, r); const k = (C, E) => { b & 16 && (i && i.isCE && (i.ce._teleportTarget = C), u(w, C, E, i, a, o, s, l)) }, A = () => { const C = e.target = LD(e.props, p), E = SK(C, e, m, h); C && (o !== "svg" && v4(C) ? o = "svg" : o !== "mathml" && y4(C) && (o = "mathml"), y || (k(C, E), Ex(e, !1))) }; y && (k(t, x), Ex(e, !0)), g4(e.props) ? (e.el.__isMounted = !1, Rr(() => { A(), delete e.el.__isMounted }, a)) : A() } else { if (g4(e.props) && n.el.__isMounted === !1) { Rr(() => { xK.process(n, e, t, r, i, a, o, s, l, c) }, a); return } e.el = n.el, e.targetStart = n.targetStart; const S = e.anchor = n.anchor, x = e.target = n.target, k = e.targetAnchor = n.targetAnchor, A = Hy(n.props), C = A ? t : x, E = A ? S : k; if (o === "svg" || v4(x) ? o = "svg" : (o === "mathml" || y4(x)) && (o = "mathml"), v ? (f(n.dynamicChildren, v, C, i, a, o, s), VL(n, e, !0)) : l || d(n, e, C, E, i, a, o, s, !1), y) A ? e.props && n.props && e.props.to !== n.props.to && (e.props.to = n.props.to) : I1(e, t, S, c, 1); else if ((e.props && e.props.to) !== (n.props && n.props.to)) { const O = e.target = LD(e.props, p); O && I1(e, O, null, c, 0) } else A && I1(e, x, k, c, 1); Ex(e, y) } }, remove(n, e, t, { um: r, o: { remove: i } }, a) { const { shapeFlag: o, children: s, anchor: l, targetStart: c, targetAnchor: u, target: d, props: f } = n; if (d && (i(c), i(u)), a && i(l), o & 16) { const h = a || !Hy(f); for (let p = 0; p < s.length; p++) { const m = s[p]; r(m, e, t, h, !!m.dynamicChildren) } } }, move: I1, hydrate: Sge }; function I1(n, e, t, { o: { insert: r }, m: i }, a = 2) { a === 0 && r(n.targetAnchor, e, t); const { el: o, anchor: s, shapeFlag: l, children: c, props: u } = n, d = a === 2; if (d && r(o, e, t), (!d || Hy(u)) && l & 16) for (let f = 0; f < c.length; f++)i(c[f], e, t, 2); d && r(s, e, t) } function Sge(n, e, t, r, i, a, { o: { nextSibling: o, parentNode: s, querySelector: l, insert: c, createText: u } }, d) { const f = e.target = LD(e.props, l); if (f) { const h = Hy(e.props), p = f._lpa || f.firstChild; if (e.shapeFlag & 16) if (h) e.anchor = d(o(n), e, s(n), t, r, i, a), e.targetStart = p, e.targetAnchor = p && o(p); else { e.anchor = o(n); let m = p; for (; m;) { if (m && m.nodeType === 8) { if (m.data === "teleport start anchor") e.targetStart = m; else if (m.data === "teleport anchor") { e.targetAnchor = m, f._lpa = e.targetAnchor && o(e.targetAnchor); break } } m = o(m) } e.targetAnchor || SK(f, e, u, c), d(p && o(p), e, f, t, r, i, a) } Ex(e, h) } return e.anchor && o(e.anchor) } const rb = xK; function Ex(n, e) { const t = n.ctx; if (t && t.ut) { let r, i; for (e ? (r = n.el, i = n.anchor) : (r = n.targetStart, i = n.targetAnchor); r && r !== i;)r.nodeType === 1 && r.setAttribute("data-v-owner", t.uid), r = r.nextSibling; t.ut() } } function SK(n, e, t, r) { const i = e.targetStart = t(""), a = e.targetAnchor = t(""); return i[bK] = a, n && (r(i, n), r(a, n)), a } const wu = Symbol("_leaveCb"), L1 = Symbol("_enterCb"); function TK() { const n = { isMounted: !1, isLeaving: !1, isUnmounting: !1, leavingVNodes: new Map }; return un(() => { n.isMounted = !0 }), $g(() => { n.isUnmounting = !0 }), n } const ao = [Function, Array], kK = { mode: String, appear: Boolean, persisted: Boolean, onBeforeEnter: ao, onEnter: ao, onAfterEnter: ao, onEnterCancelled: ao, onBeforeLeave: ao, onLeave: ao, onAfterLeave: ao, onLeaveCancelled: ao, onBeforeAppear: ao, onAppear: ao, onAfterAppear: ao, onAppearCancelled: ao }, CK = n => { const e = n.subTree; return e.component ? CK(e.component) : e }, Tge = { name: "BaseTransition", props: kK, setup(n, { slots: e }) { const t = kr(), r = TK(); return () => { const i = e.default && jL(e.default(), !0); if (!i || !i.length) return; const a = AK(i), o = Vt(n), { mode: s } = o; if (r.isLeaving) return QA(a); const l = _4(a); if (!l) return QA(a); let c = j0(l, o, r, t, d => c = d); l.type !== mr && fd(l, c); let u = t.subTree && _4(t.subTree); if (u && u.type !== mr && !us(l, u) && CK(t).type !== mr) { let d = j0(u, o, r, t); if (fd(u, d), s === "out-in" && l.type !== mr) return r.isLeaving = !0, d.afterLeave = () => { r.isLeaving = !1, t.job.flags & 8 || t.update(), delete d.afterLeave, u = void 0 }, QA(a); s === "in-out" && l.type !== mr ? d.delayLeave = (f, h, p) => { const m = EK(r, u); m[String(u.key)] = u, f[wu] = () => { h(), f[wu] = void 0, delete c.delayedLeave, u = void 0 }, c.delayedLeave = () => { p(), delete c.delayedLeave, u = void 0 } } : u = void 0 } else u && (u = void 0); return a } } }; function AK(n) { let e = n[0]; if (n.length > 1) { for (const t of n) if (t.type !== mr) { e = t; break } } return e } const kge = Tge; function EK(n, e) { const { leavingVNodes: t } = n; let r = t.get(e.type); return r || (r = Object.create(null), t.set(e.type, r)), r } function j0(n, e, t, r, i) { const { appear: a, mode: o, persisted: s = !1, onBeforeEnter: l, onEnter: c, onAfterEnter: u, onEnterCancelled: d, onBeforeLeave: f, onLeave: h, onAfterLeave: p, onLeaveCancelled: m, onBeforeAppear: g, onAppear: y, onAfterAppear: b, onAppearCancelled: w } = e, v = String(n.key), S = EK(t, n), x = (C, E) => { C && xs(C, r, 9, E) }, k = (C, E) => { const O = E[1]; x(C, E), Mt(C) ? C.every(j => j.length <= 1) && O() : C.length <= 1 && O() }, A = { mode: o, persisted: s, beforeEnter(C) { let E = l; if (!t.isMounted) if (a) E = g || l; else return; C[wu] && C[wu](!0); const O = S[v]; O && us(n, O) && O.el[wu] && O.el[wu](), x(E, [C]) }, enter(C) { let E = c, O = u, j = d; if (!t.isMounted) if (a) E = y || c, O = b || u, j = w || d; else return; let I = !1; const L = C[L1] = R => { I || (I = !0, R ? x(j, [C]) : x(O, [C]), A.delayedLeave && A.delayedLeave(), C[L1] = void 0) }; E ? k(E, [C, L]) : L() }, leave(C, E) { const O = String(n.key); if (C[L1] && C[L1](!0), t.isUnmounting) return E(); x(f, [C]); let j = !1; const I = C[wu] = L => { j || (j = !0, E(), L ? x(m, [C]) : x(p, [C]), C[wu] = void 0, S[O] === n && delete S[O]) }; S[O] = n, h ? k(h, [C, I]) : I() }, clone(C) { const E = j0(C, e, t, r, i); return i && i(E), E } }; return A } function QA(n) { if (ib(n)) return n = $o(n), n.children = null, n } function _4(n) { if (!ib(n)) return wK(n.type) && n.children ? AK(n.children) : n; if (n.component) return n.component.subTree; const { shapeFlag: e, children: t } = n; if (t) { if (e & 16) return t[0]; if (e & 32 && Lt(t.default)) return t.default() } } function fd(n, e) { n.shapeFlag & 6 && n.component ? (n.transition = e, fd(n.component.subTree, e)) : n.shapeFlag & 128 ? (n.ssContent.transition = e.clone(n.ssContent), n.ssFallback.transition = e.clone(n.ssFallback)) : n.transition = e } function jL(n, e = !1, t) { let r = [], i = 0; for (let a = 0; a < n.length; a++) { let o = n[a]; const s = t == null ? o.key : String(t) + String(o.key != null ? o.key : a); o.type === Qt ? (o.patchFlag & 128 && i++, r = r.concat(jL(o.children, e, s))) : (e || o.type !== mr) && r.push(s != null ? $o(o, { key: s }) : o) } if (i > 1) for (let a = 0; a < r.length; a++)r[a].patchFlag = -2; return r }/*! #__NO_SIDE_EFFECTS__ */function We(n, e) { return Lt(n) ? (() => Dr({ name: n.name }, e, { setup: n }))() : n } function RD() { const n = kr(); return n ? (n.appContext.config.idPrefix || "v") + "-" + n.ids[0] + n.ids[1]++ : "" } function PL(n) { n.ids = [n.ids[0] + n.ids[2]++ + "-", 0, 0] } function Mx(n) { const e = kr(), t = Fa(null); if (e) { const i = e.refs === Tn ? e.refs = {} : e.refs; Object.defineProperty(i, n, { enumerable: !0, get: () => t.value, set: a => t.value = a }) } return t } function P0(n, e, t, r, i = !1) { if (Mt(n)) { n.forEach((p, m) => P0(p, e && (Mt(e) ? e[m] : e), t, r, i)); return } if (Ju(r) && !i) { r.shapeFlag & 512 && r.type.__asyncResolved && r.component.subTree.component && P0(n, e, t, r.component.subTree); return } const a = r.shapeFlag & 4 ? sb(r.component) : r.el, o = i ? null : a, { i: s, r: l } = n, c = e && e.r, u = s.refs === Tn ? s.refs = {} : s.refs, d = s.setupState, f = Vt(d), h = d === Tn ? () => !1 : p => On(f, p); if (c != null && c !== l && (Sr(c) ? (u[c] = null, h(c) && (d[c] = null)) : Kn(c) && (c.value = null)), Lt(l)) nb(l, s, 12, [o, u]); else { const p = Sr(l), m = Kn(l); if (p || m) { const g = () => { if (n.f) { const y = p ? h(l) ? d[l] : u[l] : l.value; i ? Mt(y) && SL(y, a) : Mt(y) ? y.includes(a) || y.push(a) : p ? (u[l] = [a], h(l) && (d[l] = u[l])) : (l.value = [a], n.k && (u[n.k] = l.value)) } else p ? (u[l] = o, h(l) && (d[l] = o)) : m && (l.value = o, n.k && (u[n.k] = o)) }; o ? (g.id = -1, Rr(g, t)) : g() } } } let b4 = !1; const Dp = () => { b4 || (console.error("Hydration completed but contains mismatches."), b4 = !0) }, Cge = n => n.namespaceURI.includes("svg") && n.tagName !== "foreignObject", Age = n => n.namespaceURI.includes("MathML"), R1 = n => { if (n.nodeType === 1) { if (Cge(n)) return "svg"; if (Age(n)) return "mathml" } }, Am = n => n.nodeType === 8; function Ege(n) {
  const { mt: e, p: t, o: { patchProp: r, createText: i, nextSibling: a, parentNode: o, remove: s, insert: l, createComment: c } } = n, u = (w, v) => { if (!v.hasChildNodes()) { t(null, w, v), TS(), v._vnode = w; return } d(v.firstChild, w, null, null, null), TS(), v._vnode = w }, d = (w, v, S, x, k, A = !1) => { A = A || !!v.dynamicChildren; const C = Am(w) && w.data === "[", E = () => m(w, v, S, x, k, C), { type: O, ref: j, shapeFlag: I, patchFlag: L } = v; let R = w.nodeType; v.el = w, L === -2 && (A = !1, v.dynamicChildren = null); let D = null; switch (O) { case ch: R !== 3 ? v.children === "" ? (l(v.el = i(""), o(w), w), D = w) : D = E() : (w.data !== v.children && (Dp(), w.data = v.children), D = a(w)); break; case mr: b(w) ? (D = a(w), y(v.el = w.content.firstChild, w, S)) : R !== 8 || C ? D = E() : D = a(w); break; case Vm: if (C && (w = a(w), R = w.nodeType), R === 1 || R === 3) { D = w; const P = !v.children.length; for (let B = 0; B < v.staticCount; B++)P && (v.children += D.nodeType === 1 ? D.outerHTML : D.data), B === v.staticCount - 1 && (v.anchor = D), D = a(D); return C ? a(D) : D } else E(); break; case Qt: C ? D = p(w, v, S, x, k, A) : D = E(); break; default: if (I & 1) (R !== 1 || v.type.toLowerCase() !== w.tagName.toLowerCase()) && !b(w) ? D = E() : D = f(w, v, S, x, k, A); else if (I & 6) { v.slotScopeIds = k; const P = o(w); if (C ? D = g(w) : Am(w) && w.data === "teleport start" ? D = g(w, w.data, "teleport end") : D = a(w), e(v, P, null, S, x, R1(P), A), Ju(v) && !v.type.__asyncResolved) { let B; C ? (B = $e(Qt), B.anchor = D ? D.previousSibling : P.lastChild) : B = w.nodeType === 3 ? Fo("") : $e("div"), B.el = w, v.component.subTree = B } } else I & 64 ? R !== 8 ? D = E() : D = v.type.hydrate(w, v, S, x, k, A, n, h) : I & 128 && (D = v.type.hydrate(w, v, S, x, R1(o(w)), k, A, n, d)) }return j != null && P0(j, null, x, v), D }, f = (w, v, S, x, k, A) => {
    A = A || !!v.dynamicChildren; const { type: C, props: E, patchFlag: O, shapeFlag: j, dirs: I, transition: L } = v, R = C === "input" || C === "option"; if (R || O !== -1) {
      I && Js(v, null, S, "created"); let D = !1; if (b(w)) { D = HK(null, L) && S && S.vnode.props && S.vnode.props.appear; const B = w.content.firstChild; if (D) { const F = B.getAttribute("class"); F && (B.$cls = F), L.beforeEnter(B) } y(B, w, S), v.el = w = B } if (j & 16 && !(E && (E.innerHTML || E.textContent))) { let B = h(w.firstChild, v, w, S, x, k, A); for (; B;) { N1(w, 1) || Dp(); const F = B; B = B.nextSibling, s(F) } } else if (j & 8) {
        let B = v.children; B[0] === `
`&& (w.tagName === "PRE" || w.tagName === "TEXTAREA") && (B = B.slice(1)), w.textContent !== B && (N1(w, 0) || Dp(), w.textContent = v.children)
      } if (E) { if (R || !A || O & 48) { const B = w.tagName.includes("-"); for (const F in E) (R && (F.endsWith("value") || F === "indeterminate") || UT(F) && !$m(F) || F[0] === "." || B) && r(w, F, null, E[F], void 0, S) } else if (E.onClick) r(w, "onClick", null, E.onClick, void 0, S); else if (O & 4 && ul(E.style)) for (const B in E.style) E.style[B] } let P; (P = E && E.onVnodeBeforeMount) && pa(P, S, v), I && Js(v, null, S, "beforeMount"), ((P = E && E.onVnodeMounted) || I || D) && ZK(() => { P && pa(P, S, v), D && L.enter(w), I && Js(v, null, S, "mounted") }, x)
    } return w.nextSibling
  }, h = (w, v, S, x, k, A, C) => { C = C || !!v.dynamicChildren; const E = v.children, O = E.length; for (let j = 0; j < O; j++) { const I = C ? E[j] : E[j] = ma(E[j]), L = I.type === ch; w ? (L && !C && j + 1 < O && ma(E[j + 1]).type === ch && (l(i(w.data.slice(I.children.length)), S, a(w)), w.data = I.children), w = d(w, I, x, k, A, C)) : L && !I.children ? l(I.el = i(""), S) : (N1(S, 1) || Dp(), t(null, I, S, null, x, k, R1(S), A)) } return w }, p = (w, v, S, x, k, A) => { const { slotScopeIds: C } = v; C && (k = k ? k.concat(C) : C); const E = o(w), O = h(a(w), v, E, S, x, k, A); return O && Am(O) && O.data === "]" ? a(v.anchor = O) : (Dp(), l(v.anchor = c("]"), E, O), O) }, m = (w, v, S, x, k, A) => { if (N1(w.parentElement, 1) || Dp(), v.el = null, A) { const O = g(w); for (; ;) { const j = a(w); if (j && j !== O) s(j); else break } } const C = a(w), E = o(w); return s(w), t(null, v, E, C, S, x, R1(E), k), S && (S.vnode.el = v.el, nk(S, v.el)), C }, g = (w, v = "[", S = "]") => { let x = 0; for (; w;)if (w = a(w), w && Am(w) && (w.data === v && x++, w.data === S)) { if (x === 0) return a(w); x-- } return w }, y = (w, v, S) => { const x = v.parentNode; x && x.replaceChild(w, v); let k = S; for (; k;)k.vnode.el === v && (k.vnode.el = k.subTree.el = w), k = k.parent }, b = w => w.nodeType === 1 && w.tagName === "TEMPLATE"; return [u, d]
} const w4 = "data-allow-mismatch", Mge = { 0: "text", 1: "children", 2: "class", 3: "style", 4: "attribute" }; function N1(n, e) { if (e === 0 || e === 1) for (; n && !n.hasAttribute(w4);)n = n.parentElement; const t = n && n.getAttribute(w4); if (t == null) return !1; if (t === "") return !0; { const r = t.split(","); return e === 0 && r.includes("children") ? !0 : t.split(",").includes(Mge[e]) } } const Oge = WT().requestIdleCallback || (n => setTimeout(n, 1)), Dge = WT().cancelIdleCallback || (n => clearTimeout(n)), Gut = (n = 1e4) => e => { const t = Oge(e, { timeout: n }); return () => Dge(t) }; function jge(n) { const { top: e, left: t, bottom: r, right: i } = n.getBoundingClientRect(), { innerHeight: a, innerWidth: o } = window; return (e > 0 && e < a || r > 0 && r < a) && (t > 0 && t < o || i > 0 && i < o) } const Wut = n => (e, t) => { const r = new IntersectionObserver(i => { for (const a of i) if (a.isIntersecting) { r.disconnect(), e(); break } }, n); return t(i => { if (i instanceof Element) { if (jge(i)) return e(), r.disconnect(), !1; r.observe(i) } }), () => r.disconnect() }, Kut = n => e => { if (n) { const t = matchMedia(n); if (t.matches) e(); else return t.addEventListener("change", e, { once: !0 }), () => t.removeEventListener("change", e) } }, qut = (n = []) => (e, t) => { Sr(n) && (n = [n]); let r = !1; const i = o => { r || (r = !0, a(), e(), o.target.dispatchEvent(new o.constructor(o.type, o))) }, a = () => { t(o => { for (const s of n) o.removeEventListener(s, i) }) }; return t(o => { for (const s of n) o.addEventListener(s, i, { once: !0 }) }), a }; function Pge(n, e) { if (Am(n) && n.data === "[") { let t = 1, r = n.nextSibling; for (; r;) { if (r.nodeType === 1) { if (e(r) === !1) break } else if (Am(r)) if (r.data === "]") { if (--t === 0) break } else r.data === "[" && t++; r = r.nextSibling } } else e(n) } const Ju = n => !!n.type.__asyncLoader;/*! #__NO_SIDE_EFFECTS__ */function Em(n) { Lt(n) && (n = { loader: n }); const { loader: e, loadingComponent: t, errorComponent: r, delay: i = 200, hydrate: a, timeout: o, suspensible: s = !0, onError: l } = n; let c = null, u, d = 0; const f = () => (d++, c = null, h()), h = () => { let p; return c || (p = c = e().catch(m => { if (m = m instanceof Error ? m : new Error(String(m)), l) return new Promise((g, y) => { l(m, () => g(f()), () => y(m), d + 1) }); throw m }).then(m => p !== c && c ? c : (m && (m.__esModule || m[Symbol.toStringTag] === "Module") && (m = m.default), u = m, m))) }; return We({ name: "AsyncComponentWrapper", __asyncLoader: h, __asyncHydrate(p, m, g) { const y = a ? () => { const w = a(() => { g() }, v => Pge(p, v)); w && (m.bum || (m.bum = [])).push(w), (m.u || (m.u = [])).push(() => !0) } : g; u ? y() : h().then(() => !m.isUnmounted && y()) }, get __asyncResolved() { return u }, setup() { const p = $r; if (PL(p), u) return () => eE(u, p); const m = w => { c = null, Bg(w, p, 13, !r) }; if (s && p.suspense || ng) return h().then(w => () => eE(w, p)).catch(w => (m(w), () => r ? $e(r, { error: w }) : null)); const g = he(!1), y = he(), b = he(!!i); return i && setTimeout(() => { b.value = !1 }, i), o != null && setTimeout(() => { if (!g.value && !y.value) { const w = new Error(`Async component timed out after ${o}ms.`); m(w), y.value = w } }, o), h().then(() => { g.value = !0, p.parent && ib(p.parent.vnode) && p.parent.update() }).catch(w => { m(w), y.value = w }), () => { if (g.value && u) return eE(u, p); if (y.value && r) return $e(r, { error: y.value }); if (t && !b.value) return $e(t) } } }) } function eE(n, e) { const { ref: t, props: r, children: i, ce: a } = e.vnode, o = $e(n, r, i); return o.ref = t, o.ce = a, delete e.vnode.ce, o } const ib = n => n.type.__isKeepAlive, Ige = { name: "KeepAlive", __isKeepAlive: !0, props: { include: [String, RegExp, Array], exclude: [String, RegExp, Array], max: [String, Number] }, setup(n, { slots: e }) { const t = kr(), r = t.ctx; if (!r.renderer) return () => { const b = e.default && e.default(); return b && b.length === 1 ? b[0] : b }; const i = new Map, a = new Set; let o = null; const s = t.suspense, { renderer: { p: l, m: c, um: u, o: { createElement: d } } } = r, f = d("div"); r.activate = (b, w, v, S, x) => { const k = b.component; c(b, w, v, 0, s), l(k.vnode, b, w, v, k, s, S, b.slotScopeIds, x), Rr(() => { k.isDeactivated = !1, k.a && Fy(k.a); const A = b.props && b.props.onVnodeMounted; A && pa(A, k.parent, b) }, s) }, r.deactivate = b => { const w = b.component; CS(w.m), CS(w.a), c(b, f, null, 1, s), Rr(() => { w.da && Fy(w.da); const v = b.props && b.props.onVnodeUnmounted; v && pa(v, w.parent, b), w.isDeactivated = !0 }, s) }; function h(b) { tE(b), u(b, t, s, !0) } function p(b) { i.forEach((w, v) => { const S = KD(w.type); S && !b(S) && m(v) }) } function m(b) { const w = i.get(b); w && (!o || !us(w, o)) ? h(w) : o && tE(o), i.delete(b), a.delete(b) } Ct(() => [n.include, n.exclude], ([b, w]) => { b && p(v => gy(b, v)), w && p(v => !gy(w, v)) }, { flush: "post", deep: !0 }); let g = null; const y = () => { g != null && (AS(t.subTree.type) ? Rr(() => { i.set(g, B1(t.subTree)) }, t.subTree.suspense) : i.set(g, B1(t.subTree))) }; return un(y), LL(y), $g(() => { i.forEach(b => { const { subTree: w, suspense: v } = t, S = B1(w); if (b.type === S.type && b.key === S.key) { tE(S); const x = S.component.da; x && Rr(x, v); return } h(b) }) }), () => { if (g = null, !e.default) return o = null; const b = e.default(), w = b[0]; if (b.length > 1) return o = null, b; if (!hd(w) || !(w.shapeFlag & 4) && !(w.shapeFlag & 128)) return o = null, w; let v = B1(w); if (v.type === mr) return o = null, v; const S = v.type, x = KD(Ju(v) ? v.type.__asyncResolved || {} : S), { include: k, exclude: A, max: C } = n; if (k && (!x || !gy(k, x)) || A && x && gy(A, x)) return v.shapeFlag &= -257, o = v, w; const E = v.key == null ? S : v.key, O = i.get(E); return v.el && (v = $o(v), w.shapeFlag & 128 && (w.ssContent = v)), g = E, O ? (v.el = O.el, v.component = O.component, v.transition && fd(v, v.transition), v.shapeFlag |= 512, a.delete(E), a.add(E)) : (a.add(E), C && a.size > parseInt(C, 10) && m(a.values().next().value)), v.shapeFlag |= 256, o = v, AS(w.type) ? w : v } } }, Yut = Ige; function gy(n, e) { return Mt(n) ? n.some(t => gy(t, e)) : Sr(n) ? n.split(",").includes(e) : jme(n) ? (n.lastIndex = 0, n.test(e)) : !1 } function Lge(n, e) { MK(n, "a", e) } function Rge(n, e) { MK(n, "da", e) } function MK(n, e, t = $r) { const r = n.__wdc || (n.__wdc = () => { let i = t; for (; i;) { if (i.isDeactivated) return; i = i.parent } return n() }); if (QT(e, r, t), t) { let i = t.parent; for (; i && i.parent;)ib(i.parent.vnode) && Nge(r, e, t, i), i = i.parent } } function Nge(n, e, t, r) { const i = QT(e, n, r, !0); cr(() => { SL(r[e], i) }, t) } function tE(n) { n.shapeFlag &= -257, n.shapeFlag &= -513 } function B1(n) { return n.shapeFlag & 128 ? n.ssContent : n } function QT(n, e, t = $r, r = !1) { if (t) { const i = t[n] || (t[n] = []), a = e.__weh || (e.__weh = (...o) => { Tc(); const s = Ph(t), l = xs(e, t, n, o); return s(), kc(), l }); return r ? i.unshift(a) : i.push(a), a } } const $c = n => (e, t = $r) => { (!ng || n === "sp") && QT(n, (...r) => e(...r), t) }, Bge = $c("bm"), un = $c("m"), IL = $c("bu"), LL = $c("u"), $g = $c("bum"), cr = $c("um"), $ge = $c("sp"), Fge = $c("rtg"), zge = $c("rtc"); function Vge(n, e = $r) { QT("ec", n, e) } const RL = "components", Hge = "directives"; function Cc(n, e) { return NL(RL, n, !0, e) || n } const OK = Symbol.for("v-ndc"); function dl(n) { return Sr(n) ? NL(RL, n, !1) || n : n || OK } function Zut(n) { return NL(Hge, n) } function NL(n, e, t = !0, r = !1) { const i = Fr || $r; if (i) { const a = i.type; if (n === RL) { const s = KD(a, !1); if (s && (s === e || s === Ta(e) || s === CL(Ta(e)))) return a } const o = x4(i[n] || a[n], e) || x4(i.appContext[n], e); return !o && r ? a : o } } function x4(n, e) { return n && (n[e] || n[Ta(e)] || n[CL(Ta(e))]) } function Wa(n, e, t, r) { let i; const a = t && t[r], o = Mt(n); if (o || Sr(n)) { const s = o && ul(n); let l = !1, c = !1; s && (l = !jo(n), c = dd(n), n = qT(n)), i = new Array(n.length); for (let u = 0, d = n.length; u < d; u++)i[u] = e(l ? c ? bS(si(n[u])) : si(n[u]) : n[u], u, void 0, a && a[u]) } else if (typeof n == "number") { i = new Array(n); for (let s = 0; s < n; s++)i[s] = e(s + 1, s, void 0, a && a[s]) } else if (Jn(n)) if (n[Symbol.iterator]) i = Array.from(n, (s, l) => e(s, l, void 0, a && a[l])); else { const s = Object.keys(n); i = new Array(s.length); for (let l = 0, c = s.length; l < c; l++) { const u = s[l]; i[l] = e(n[u], u, l, a && a[l]) } } else i = []; return t && (t[r] = i), i } function nE(n, e) { for (let t = 0; t < e.length; t++) { const r = e[t]; if (Mt(r)) for (let i = 0; i < r.length; i++)n[r[i].name] = r[i].fn; else r && (n[r.name] = r.key ? (...i) => { const a = r.fn(...i); return a && (a.key = r.key), a } : r.fn) } return n } function ut(n, e, t = {}, r, i) { if (Fr.ce || Fr.parent && Ju(Fr.parent) && Fr.parent.ce) return e !== "default" && (t.name = e), Z(), Ye(Qt, null, [$e("slot", t, r && r())], 64); let a = n[e]; a && a._c && (a._d = !1), Z(); const o = a && BL(a(t)), s = t.key || o && o.key, l = Ye(Qt, { key: (s && !Bd(s) ? s : `_${e}`) + (!o && r ? "_fb" : "") }, o || (r ? r() : []), o && n._ === 1 ? 64 : -2); return !i && l.scopeId && (l.slotScopeIds = [l.scopeId + "-s"]), a && a._c && (a._d = !0), l } function BL(n) { return n.some(e => hd(e) ? !(e.type === mr || e.type === Qt && !BL(e.children)) : !0) ? n : null } function Uge(n, e) { const t = {}; for (const r in n) t[e && /[A-Z]/.test(r) ? `on:${r}` : $y(r)] = n[r]; return t } const ND = n => n ? tq(n) ? sb(n) : ND(n.parent) : null, Uy = Dr(Object.create(null), { $: n => n, $el: n => n.vnode.el, $data: n => n.data, $props: n => n.props, $attrs: n => n.attrs, $slots: n => n.slots, $refs: n => n.refs, $parent: n => ND(n.parent), $root: n => ND(n.root), $host: n => n.ce, $emit: n => n.emit, $options: n => $L(n), $forceUpdate: n => n.f || (n.f = () => { DL(n.update) }), $nextTick: n => n.n || (n.n = Pr.bind(n.proxy)), $watch: n => hve.bind(n) }), rE = (n, e) => n !== Tn && !n.__isScriptSetup && On(n, e), BD = { get({ _: n }, e) { if (e === "__v_skip") return !0; const { ctx: t, setupState: r, data: i, props: a, accessCache: o, type: s, appContext: l } = n; let c; if (e[0] !== "$") { const h = o[e]; if (h !== void 0) switch (h) { case 1: return r[e]; case 2: return i[e]; case 4: return t[e]; case 3: return a[e] } else { if (rE(r, e)) return o[e] = 1, r[e]; if (i !== Tn && On(i, e)) return o[e] = 2, i[e]; if ((c = n.propsOptions[0]) && On(c, e)) return o[e] = 3, a[e]; if (t !== Tn && On(t, e)) return o[e] = 4, t[e]; $D && (o[e] = 0) } } const u = Uy[e]; let d, f; if (u) return e === "$attrs" && Ci(n.attrs, "get", ""), u(n); if ((d = s.__cssModules) && (d = d[e])) return d; if (t !== Tn && On(t, e)) return o[e] = 4, t[e]; if (f = l.config.globalProperties, On(f, e)) return f[e] }, set({ _: n }, e, t) { const { data: r, setupState: i, ctx: a } = n; return rE(i, e) ? (i[e] = t, !0) : r !== Tn && On(r, e) ? (r[e] = t, !0) : On(n.props, e) || e[0] === "$" && e.slice(1) in n ? !1 : (a[e] = t, !0) }, has({ _: { data: n, setupState: e, accessCache: t, ctx: r, appContext: i, propsOptions: a } }, o) { let s; return !!t[o] || n !== Tn && On(n, o) || rE(e, o) || (s = a[0]) && On(s, o) || On(r, o) || On(Uy, o) || On(i.config.globalProperties, o) }, defineProperty(n, e, t) { return t.get != null ? n._.accessCache[e] = 0 : On(t, "value") && this.set(n, e, t.value, null), Reflect.defineProperty(n, e, t) } }, Gge = Dr({}, BD, { get(n, e) { if (e !== Symbol.unscopables) return BD.get(n, e, n) }, has(n, e) { return e[0] !== "_" && !$me(e) } }); function Xut() { return null } function Jut() { return null } function Qut(n) { } function edt(n) { } function tdt() { return null } function ndt() { } function rdt(n, e) { return null } function ek() { return DK().slots } function ab() { return DK().attrs } function DK() { const n = kr(); return n.setupContext || (n.setupContext = iq(n)) } function I0(n) { return Mt(n) ? n.reduce((e, t) => (e[t] = null, e), {}) : n } function Wge(n, e) { const t = I0(n); for (const r in e) { if (r.startsWith("__skip")) continue; let i = t[r]; i ? Mt(i) || Lt(i) ? i = t[r] = { type: i, default: e[r] } : i.default = e[r] : i === null && (i = t[r] = { default: e[r] }), i && e[`__skip_${r}`] && (i.skipFactory = !0) } return t } function idt(n, e) { return !n || !e ? n || e : Mt(n) && Mt(e) ? n.concat(e) : Dr({}, I0(n), I0(e)) } function adt(n, e) { const t = {}; for (const r in n) e.includes(r) || Object.defineProperty(t, r, { enumerable: !0, get: () => n[r] }); return t } function odt(n) { const e = kr(); let t = n(); return UD(), TL(t) && (t = t.catch(r => { throw Ph(e), r })), [t, () => Ph(e)] } let $D = !0; function Kge(n) { const e = $L(n), t = n.proxy, r = n.ctx; $D = !1, e.beforeCreate && S4(e.beforeCreate, n, "bc"); const { data: i, computed: a, methods: o, watch: s, provide: l, inject: c, created: u, beforeMount: d, mounted: f, beforeUpdate: h, updated: p, activated: m, deactivated: g, beforeDestroy: y, beforeUnmount: b, destroyed: w, unmounted: v, render: S, renderTracked: x, renderTriggered: k, errorCaptured: A, serverPrefetch: C, expose: E, inheritAttrs: O, components: j, directives: I, filters: L } = e; if (c && qge(c, r, null), o) for (const P in o) { const B = o[P]; Lt(B) && (r[P] = B.bind(t)) } if (i) { const P = i.call(t, t); Jn(P) && (n.data = vr(P)) } if ($D = !0, a) for (const P in a) { const B = a[P], F = Lt(B) ? B.bind(t, t) : Lt(B.get) ? B.get.bind(t, t) : Do, K = !Lt(B) && Lt(B.set) ? B.set.bind(t) : Do, V = ne({ get: F, set: K }); Object.defineProperty(r, P, { enumerable: !0, configurable: !0, get: () => V.value, set: W => V.value = W }) } if (s) for (const P in s) jK(s[P], r, t, P); if (l) { const P = Lt(l) ? l.call(t) : l; Reflect.ownKeys(P).forEach(B => { Or(B, P[B]) }) } u && S4(u, n, "c"); function D(P, B) { Mt(B) ? B.forEach(F => P(F.bind(t))) : B && P(B.bind(t)) } if (D(Bge, d), D(un, f), D(IL, h), D(LL, p), D(Lge, m), D(Rge, g), D(Vge, A), D(zge, x), D(Fge, k), D($g, b), D(cr, v), D($ge, C), Mt(E)) if (E.length) { const P = n.exposed || (n.exposed = {}); E.forEach(B => { Object.defineProperty(P, B, { get: () => t[B], set: F => t[B] = F }) }) } else n.exposed || (n.exposed = {}); S && n.render === Do && (n.render = S), O != null && (n.inheritAttrs = O), j && (n.components = j), I && (n.directives = I), C && PL(n) } function qge(n, e, t = Do) { Mt(n) && (n = FD(n)); for (const r in n) { const i = n[r]; let a; Jn(i) ? "default" in i ? a = zn(i.from || r, i.default, !0) : a = zn(i.from || r) : a = zn(i), Kn(a) ? Object.defineProperty(e, r, { enumerable: !0, configurable: !0, get: () => a.value, set: o => a.value = o }) : e[r] = a } } function S4(n, e, t) { xs(Mt(n) ? n.map(r => r.bind(e.proxy)) : n.bind(e.proxy), e, t) } function jK(n, e, t, r) { let i = r.includes(".") ? WK(t, r) : () => t[r]; if (Sr(n)) { const a = e[n]; Lt(a) && Ct(i, a) } else if (Lt(n)) Ct(i, n.bind(t)); else if (Jn(n)) if (Mt(n)) n.forEach(a => jK(a, e, t, r)); else { const a = Lt(n.handler) ? n.handler.bind(t) : e[n.handler]; Lt(a) && Ct(i, a, n) } } function $L(n) { const e = n.type, { mixins: t, extends: r } = e, { mixins: i, optionsCache: a, config: { optionMergeStrategies: o } } = n.appContext, s = a.get(e); let l; return s ? l = s : !i.length && !t && !r ? l = e : (l = {}, i.length && i.forEach(c => kS(l, c, o, !0)), kS(l, e, o)), Jn(e) && a.set(e, l), l } function kS(n, e, t, r = !1) { const { mixins: i, extends: a } = e; a && kS(n, a, t, !0), i && i.forEach(o => kS(n, o, t, !0)); for (const o in e) if (!(r && o === "expose")) { const s = Yge[o] || t && t[o]; n[o] = s ? s(n[o], e[o]) : e[o] } return n } const Yge = { data: T4, props: k4, emits: k4, methods: vy, computed: vy, beforeCreate: Hi, created: Hi, beforeMount: Hi, mounted: Hi, beforeUpdate: Hi, updated: Hi, beforeDestroy: Hi, beforeUnmount: Hi, destroyed: Hi, unmounted: Hi, activated: Hi, deactivated: Hi, errorCaptured: Hi, serverPrefetch: Hi, components: vy, directives: vy, watch: Xge, provide: T4, inject: Zge }; function T4(n, e) { return e ? n ? function () { return Dr(Lt(n) ? n.call(this, this) : n, Lt(e) ? e.call(this, this) : e) } : e : n } function Zge(n, e) { return vy(FD(n), FD(e)) } function FD(n) { if (Mt(n)) { const e = {}; for (let t = 0; t < n.length; t++)e[n[t]] = n[t]; return e } return n } function Hi(n, e) { return n ? [...new Set([].concat(n, e))] : e } function vy(n, e) { return n ? Dr(Object.create(null), n, e) : e } function k4(n, e) { return n ? Mt(n) && Mt(e) ? [...new Set([...n, ...e])] : Dr(Object.create(null), I0(n), I0(e ?? {})) : e } function Xge(n, e) { if (!n) return e; if (!e) return n; const t = Dr(Object.create(null), n); for (const r in e) t[r] = Hi(n[r], e[r]); return t } function PK() { return { app: null, config: { isNativeTag: Ome, performance: !1, globalProperties: {}, optionMergeStrategies: {}, errorHandler: void 0, warnHandler: void 0, compilerOptions: {} }, mixins: [], components: {}, directives: {}, provides: Object.create(null), optionsCache: new WeakMap, propsCache: new WeakMap, emitsCache: new WeakMap } } let Jge = 0; function Qge(n, e) { return function (r, i = null) { Lt(r) || (r = Dr({}, r)), i != null && !Jn(i) && (i = null); const a = PK(), o = new WeakSet, s = []; let l = !1; const c = a.app = { _uid: Jge++, _component: r, _props: i, _container: null, _context: a, _instance: null, version: jve, get config() { return a.config }, set config(u) { }, use(u, ...d) { return o.has(u) || (u && Lt(u.install) ? (o.add(u), u.install(c, ...d)) : Lt(u) && (o.add(u), u(c, ...d))), c }, mixin(u) { return a.mixins.includes(u) || a.mixins.push(u), c }, component(u, d) { return d ? (a.components[u] = d, c) : a.components[u] }, directive(u, d) { return d ? (a.directives[u] = d, c) : a.directives[u] }, mount(u, d, f) { if (!l) { const h = c._ceVNode || $e(r, i); return h.appContext = a, f === !0 ? f = "svg" : f === !1 && (f = void 0), d && e ? e(h, u) : n(h, u, f), l = !0, c._container = u, u.__vue_app__ = c, sb(h.component) } }, onUnmount(u) { s.push(u) }, unmount() { l && (xs(s, c._instance, 16), n(null, c._container), delete c._container.__vue_app__) }, provide(u, d) { return a.provides[u] = d, c }, runWithContext(u) { const d = lh; lh = c; try { return u() } finally { lh = d } } }; return c } } let lh = null; function Or(n, e) { if ($r) { let t = $r.provides; const r = $r.parent && $r.parent.provides; r === t && (t = $r.provides = Object.create(r)), t[n] = e } } function zn(n, e, t = !1) { const r = $r || Fr; if (r || lh) { let i = lh ? lh._context.provides : r ? r.parent == null || r.ce ? r.vnode.appContext && r.vnode.appContext.provides : r.parent.provides : void 0; if (i && n in i) return i[n]; if (arguments.length > 1) return t && Lt(e) ? e.call(r && r.proxy) : e } } function eve() { return !!($r || Fr || lh) } const IK = {}, LK = () => Object.create(IK), RK = n => Object.getPrototypeOf(n) === IK; function tve(n, e, t, r = !1) { const i = {}, a = LK(); n.propsDefaults = Object.create(null), NK(n, e, i, a); for (const o in n.propsOptions[0]) o in i || (i[o] = void 0); t ? n.props = r ? i : dK(i) : n.type.props ? n.props = i : n.props = a, n.attrs = a } function nve(n, e, t, r) { const { props: i, attrs: a, vnode: { patchFlag: o } } = n, s = Vt(i), [l] = n.propsOptions; let c = !1; if ((r || o > 0) && !(o & 16)) { if (o & 8) { const u = n.vnode.dynamicProps; for (let d = 0; d < u.length; d++) { let f = u[d]; if (tk(n.emitsOptions, f)) continue; const h = e[f]; if (l) if (On(a, f)) h !== a[f] && (a[f] = h, c = !0); else { const p = Ta(f); i[p] = zD(l, s, p, h, n, !1) } else h !== a[f] && (a[f] = h, c = !0) } } } else { NK(n, e, i, a) && (c = !0); let u; for (const d in s) (!e || !On(e, d) && ((u = Ng(d)) === d || !On(e, u))) && (l ? t && (t[d] !== void 0 || t[u] !== void 0) && (i[d] = zD(l, s, d, void 0, n, !0)) : delete i[d]); if (a !== s) for (const d in a) (!e || !On(e, d)) && (delete a[d], c = !0) } c && lc(n.attrs, "set", "") } function NK(n, e, t, r) { const [i, a] = n.propsOptions; let o = !1, s; if (e) for (let l in e) { if ($m(l)) continue; const c = e[l]; let u; i && On(i, u = Ta(l)) ? !a || !a.includes(u) ? t[u] = c : (s || (s = {}))[u] = c : tk(n.emitsOptions, l) || (!(l in r) || c !== r[l]) && (r[l] = c, o = !0) } if (a) { const l = Vt(t), c = s || Tn; for (let u = 0; u < a.length; u++) { const d = a[u]; t[d] = zD(i, l, d, c[d], n, !On(c, d)) } } return o } function zD(n, e, t, r, i, a) { const o = n[t]; if (o != null) { const s = On(o, "default"); if (s && r === void 0) { const l = o.default; if (o.type !== Function && !o.skipFactory && Lt(l)) { const { propsDefaults: c } = i; if (t in c) r = c[t]; else { const u = Ph(i); r = c[t] = l.call(null, e), u() } } else r = l; i.ce && i.ce._setProp(t, r) } o[0] && (a && !s ? r = !1 : o[1] && (r === "" || r === Ng(t)) && (r = !0)) } return r } const rve = new WeakMap; function BK(n, e, t = !1) { const r = t ? rve : e.propsCache, i = r.get(n); if (i) return i; const a = n.props, o = {}, s = []; let l = !1; if (!Lt(n)) { const u = d => { l = !0; const [f, h] = BK(d, e, !0); Dr(o, f), h && s.push(...h) }; !t && e.mixins.length && e.mixins.forEach(u), n.extends && u(n.extends), n.mixins && n.mixins.forEach(u) } if (!a && !l) return Jn(n) && r.set(n, Nm), Nm; if (Mt(a)) for (let u = 0; u < a.length; u++) { const d = Ta(a[u]); C4(d) && (o[d] = Tn) } else if (a) for (const u in a) { const d = Ta(u); if (C4(d)) { const f = a[u], h = o[d] = Mt(f) || Lt(f) ? { type: f } : Dr({}, f), p = h.type; let m = !1, g = !0; if (Mt(p)) for (let y = 0; y < p.length; ++y) { const b = p[y], w = Lt(b) && b.name; if (w === "Boolean") { m = !0; break } else w === "String" && (g = !1) } else m = Lt(p) && p.name === "Boolean"; h[0] = m, h[1] = g, (m || On(h, "default")) && s.push(d) } } const c = [o, s]; return Jn(n) && r.set(n, c), c } function C4(n) { return n[0] !== "$" && !$m(n) } const FL = n => n[0] === "_" || n === "$stable", zL = n => Mt(n) ? n.map(ma) : [ma(n)], ive = (n, e, t) => { if (e._n) return e; const r = Ue((...i) => zL(e(...i)), t); return r._c = !1, r }, $K = (n, e, t) => { const r = n._ctx; for (const i in n) { if (FL(i)) continue; const a = n[i]; if (Lt(a)) e[i] = ive(i, a, r); else if (a != null) { const o = zL(a); e[i] = () => o } } }, FK = (n, e) => { const t = zL(e); n.slots.default = () => t }, zK = (n, e, t) => { for (const r in e) (t || !FL(r)) && (n[r] = e[r]) }, ave = (n, e, t) => { const r = n.slots = LK(); if (n.vnode.shapeFlag & 32) { const i = e._; i ? (zK(r, e, t), t && GW(r, "_", i, !0)) : $K(e, r) } else e && FK(n, e) }, ove = (n, e, t) => { const { vnode: r, slots: i } = n; let a = !0, o = Tn; if (r.shapeFlag & 32) { const s = e._; s ? t && s === 1 ? a = !1 : zK(i, e, t) : (a = !e.$stable, $K(e, i)), o = e } else e && (FK(n, e), o = { default: 1 }); if (a) for (const s in i) !FL(s) && o[s] == null && delete i[s] }, Rr = ZK; function sve(n) { return VK(n) } function lve(n) { return VK(n, Ege) } function VK(n, e) { const t = WT(); t.__VUE__ = !0; const { insert: r, remove: i, patchProp: a, createElement: o, createText: s, createComment: l, setText: c, setElementText: u, parentNode: d, nextSibling: f, setScopeId: h = Do, insertStaticContent: p } = n, m = (U, q, ee, de = null, me = null, fe = null, we = void 0, Oe = null, ve = !!q.dynamicChildren) => { if (U === q) return; U && !us(U, q) && (de = ae(U), W(U, me, fe, !0), U = null), q.patchFlag === -2 && (ve = !1, q.dynamicChildren = null); const { type: Se, ref: Ke, shapeFlag: ze } = q; switch (Se) { case ch: g(U, q, ee, de); break; case mr: y(U, q, ee, de); break; case Vm: U == null && b(q, ee, de, we); break; case Qt: j(U, q, ee, de, me, fe, we, Oe, ve); break; default: ze & 1 ? S(U, q, ee, de, me, fe, we, Oe, ve) : ze & 6 ? I(U, q, ee, de, me, fe, we, Oe, ve) : (ze & 64 || ze & 128) && Se.process(U, q, ee, de, me, fe, we, Oe, ve, ge) }Ke != null && me && P0(Ke, U && U.ref, fe, q || U, !q) }, g = (U, q, ee, de) => { if (U == null) r(q.el = s(q.children), ee, de); else { const me = q.el = U.el; q.children !== U.children && c(me, q.children) } }, y = (U, q, ee, de) => { U == null ? r(q.el = l(q.children || ""), ee, de) : q.el = U.el }, b = (U, q, ee, de) => { [U.el, U.anchor] = p(U.children, q, ee, de, U.el, U.anchor) }, w = ({ el: U, anchor: q }, ee, de) => { let me; for (; U && U !== q;)me = f(U), r(U, ee, de), U = me; r(q, ee, de) }, v = ({ el: U, anchor: q }) => { let ee; for (; U && U !== q;)ee = f(U), i(U), U = ee; i(q) }, S = (U, q, ee, de, me, fe, we, Oe, ve) => { q.type === "svg" ? we = "svg" : q.type === "math" && (we = "mathml"), U == null ? x(q, ee, de, me, fe, we, Oe, ve) : C(U, q, me, fe, we, Oe, ve) }, x = (U, q, ee, de, me, fe, we, Oe) => { let ve, Se; const { props: Ke, shapeFlag: ze, transition: Xe, dirs: Ee } = U; if (ve = U.el = o(U.type, fe, Ke && Ke.is, Ke), ze & 8 ? u(ve, U.children) : ze & 16 && A(U.children, ve, null, de, me, iE(U, fe), we, Oe), Ee && Js(U, null, de, "created"), k(ve, U, U.scopeId, we, de), Ke) { for (const Te in Ke) Te !== "value" && !$m(Te) && a(ve, Te, null, Ke[Te], fe, de); "value" in Ke && a(ve, "value", null, Ke.value, fe), (Se = Ke.onVnodeBeforeMount) && pa(Se, de, U) } Ee && Js(U, null, de, "beforeMount"); const ce = HK(me, Xe); ce && Xe.beforeEnter(ve), r(ve, q, ee), ((Se = Ke && Ke.onVnodeMounted) || ce || Ee) && Rr(() => { Se && pa(Se, de, U), ce && Xe.enter(ve), Ee && Js(U, null, de, "mounted") }, me) }, k = (U, q, ee, de, me) => { if (ee && h(U, ee), de) for (let fe = 0; fe < de.length; fe++)h(U, de[fe]); if (me) { let fe = me.subTree; if (q === fe || AS(fe.type) && (fe.ssContent === q || fe.ssFallback === q)) { const we = me.vnode; k(U, we, we.scopeId, we.slotScopeIds, me.parent) } } }, A = (U, q, ee, de, me, fe, we, Oe, ve = 0) => { for (let Se = ve; Se < U.length; Se++) { const Ke = U[Se] = Oe ? xu(U[Se]) : ma(U[Se]); m(null, Ke, q, ee, de, me, fe, we, Oe) } }, C = (U, q, ee, de, me, fe, we) => { const Oe = q.el = U.el; let { patchFlag: ve, dynamicChildren: Se, dirs: Ke } = q; ve |= U.patchFlag & 16; const ze = U.props || Tn, Xe = q.props || Tn; let Ee; if (ee && rf(ee, !1), (Ee = Xe.onVnodeBeforeUpdate) && pa(Ee, ee, q, U), Ke && Js(q, U, ee, "beforeUpdate"), ee && rf(ee, !0), (ze.innerHTML && Xe.innerHTML == null || ze.textContent && Xe.textContent == null) && u(Oe, ""), Se ? E(U.dynamicChildren, Se, Oe, ee, de, iE(q, me), fe) : we || B(U, q, Oe, null, ee, de, iE(q, me), fe, !1), ve > 0) { if (ve & 16) O(Oe, ze, Xe, ee, me); else if (ve & 2 && ze.class !== Xe.class && a(Oe, "class", null, Xe.class, me), ve & 4 && a(Oe, "style", ze.style, Xe.style, me), ve & 8) { const ce = q.dynamicProps; for (let Te = 0; Te < ce.length; Te++) { const Le = ce[Te], st = ze[Le], jt = Xe[Le]; (jt !== st || Le === "value") && a(Oe, Le, st, jt, me, ee) } } ve & 1 && U.children !== q.children && u(Oe, q.children) } else !we && Se == null && O(Oe, ze, Xe, ee, me); ((Ee = Xe.onVnodeUpdated) || Ke) && Rr(() => { Ee && pa(Ee, ee, q, U), Ke && Js(q, U, ee, "updated") }, de) }, E = (U, q, ee, de, me, fe, we) => { for (let Oe = 0; Oe < q.length; Oe++) { const ve = U[Oe], Se = q[Oe], Ke = ve.el && (ve.type === Qt || !us(ve, Se) || ve.shapeFlag & 198) ? d(ve.el) : ee; m(ve, Se, Ke, null, de, me, fe, we, !0) } }, O = (U, q, ee, de, me) => { if (q !== ee) { if (q !== Tn) for (const fe in q) !$m(fe) && !(fe in ee) && a(U, fe, q[fe], null, me, de); for (const fe in ee) { if ($m(fe)) continue; const we = ee[fe], Oe = q[fe]; we !== Oe && fe !== "value" && a(U, fe, Oe, we, me, de) } "value" in ee && a(U, "value", q.value, ee.value, me) } }, j = (U, q, ee, de, me, fe, we, Oe, ve) => { const Se = q.el = U ? U.el : s(""), Ke = q.anchor = U ? U.anchor : s(""); let { patchFlag: ze, dynamicChildren: Xe, slotScopeIds: Ee } = q; Ee && (Oe = Oe ? Oe.concat(Ee) : Ee), U == null ? (r(Se, ee, de), r(Ke, ee, de), A(q.children || [], ee, Ke, me, fe, we, Oe, ve)) : ze > 0 && ze & 64 && Xe && U.dynamicChildren ? (E(U.dynamicChildren, Xe, ee, me, fe, we, Oe), (q.key != null || me && q === me.subTree) && VL(U, q, !0)) : B(U, q, ee, Ke, me, fe, we, Oe, ve) }, I = (U, q, ee, de, me, fe, we, Oe, ve) => { q.slotScopeIds = Oe, U == null ? q.shapeFlag & 512 ? me.ctx.activate(q, ee, de, we, ve) : L(q, ee, de, me, fe, we, ve) : R(U, q, ve) }, L = (U, q, ee, de, me, fe, we) => { const Oe = U.component = eq(U, de, me); if (ib(U) && (Oe.ctx.renderer = ge), nq(Oe, !1, we), Oe.asyncDep) { if (me && me.registerDep(Oe, D, we), !U.el) { const ve = Oe.subTree = $e(mr); y(null, ve, q, ee) } } else D(Oe, U, q, ee, me, fe, we) }, R = (U, q, ee) => { const de = q.component = U.component; if (yve(U, q, ee)) if (de.asyncDep && !de.asyncResolved) { P(de, q, ee); return } else de.next = q, de.update(); else q.el = U.el, de.vnode = q }, D = (U, q, ee, de, me, fe, we) => { const Oe = () => { if (U.isMounted) { let { next: ze, bu: Xe, u: Ee, parent: ce, vnode: Te } = U; { const rr = UK(U); if (rr) { ze && (ze.el = Te.el, P(U, ze, we)), rr.asyncDep.then(() => { U.isUnmounted || Oe() }); return } } let Le = ze, st; rf(U, !1), ze ? (ze.el = Te.el, P(U, ze, we)) : ze = Te, Xe && Fy(Xe), (st = ze.props && ze.props.onVnodeBeforeUpdate) && pa(st, ce, ze, Te), rf(U, !0); const jt = Ox(U), Dn = U.subTree; U.subTree = jt, m(Dn, jt, d(Dn.el), ae(Dn), U, me, fe), ze.el = jt.el, Le === null && nk(U, jt.el), Ee && Rr(Ee, me), (st = ze.props && ze.props.onVnodeUpdated) && Rr(() => pa(st, ce, ze, Te), me) } else { let ze; const { el: Xe, props: Ee } = q, { bm: ce, m: Te, parent: Le, root: st, type: jt } = U, Dn = Ju(q); if (rf(U, !1), ce && Fy(ce), !Dn && (ze = Ee && Ee.onVnodeBeforeMount) && pa(ze, Le, q), rf(U, !0), Xe && je) { const rr = () => { U.subTree = Ox(U), je(Xe, U.subTree, U, me, null) }; Dn && jt.__asyncHydrate ? jt.__asyncHydrate(Xe, U, rr) : rr() } else { st.ce && st.ce._injectChildStyle(jt); const rr = U.subTree = Ox(U); m(null, rr, ee, de, U, me, fe), q.el = rr.el } if (Te && Rr(Te, me), !Dn && (ze = Ee && Ee.onVnodeMounted)) { const rr = q; Rr(() => pa(ze, Le, rr), me) } (q.shapeFlag & 256 || Le && Ju(Le.vnode) && Le.vnode.shapeFlag & 256) && U.a && Rr(U.a, me), U.isMounted = !0, q = ee = de = null } }; U.scope.on(); const ve = U.effect = new yS(Oe); U.scope.off(); const Se = U.update = ve.run.bind(ve), Ke = U.job = ve.runIfDirty.bind(ve); Ke.i = U, Ke.id = U.uid, ve.scheduler = () => DL(Ke), rf(U, !0), Se() }, P = (U, q, ee) => { q.component = U; const de = U.vnode.props; U.vnode = q, U.next = null, nve(U, q.props, de, ee), ove(U, q.children, ee), Tc(), m4(U), kc() }, B = (U, q, ee, de, me, fe, we, Oe, ve = !1) => { const Se = U && U.children, Ke = U ? U.shapeFlag : 0, ze = q.children, { patchFlag: Xe, shapeFlag: Ee } = q; if (Xe > 0) { if (Xe & 128) { K(Se, ze, ee, de, me, fe, we, Oe, ve); return } else if (Xe & 256) { F(Se, ze, ee, de, me, fe, we, Oe, ve); return } } Ee & 8 ? (Ke & 16 && De(Se, me, fe), ze !== Se && u(ee, ze)) : Ke & 16 ? Ee & 16 ? K(Se, ze, ee, de, me, fe, we, Oe, ve) : De(Se, me, fe, !0) : (Ke & 8 && u(ee, ""), Ee & 16 && A(ze, ee, de, me, fe, we, Oe, ve)) }, F = (U, q, ee, de, me, fe, we, Oe, ve) => { U = U || Nm, q = q || Nm; const Se = U.length, Ke = q.length, ze = Math.min(Se, Ke); let Xe; for (Xe = 0; Xe < ze; Xe++) { const Ee = q[Xe] = ve ? xu(q[Xe]) : ma(q[Xe]); m(U[Xe], Ee, ee, null, me, fe, we, Oe, ve) } Se > Ke ? De(U, me, fe, !0, !1, ze) : A(q, ee, de, me, fe, we, Oe, ve, ze) }, K = (U, q, ee, de, me, fe, we, Oe, ve) => { let Se = 0; const Ke = q.length; let ze = U.length - 1, Xe = Ke - 1; for (; Se <= ze && Se <= Xe;) { const Ee = U[Se], ce = q[Se] = ve ? xu(q[Se]) : ma(q[Se]); if (us(Ee, ce)) m(Ee, ce, ee, null, me, fe, we, Oe, ve); else break; Se++ } for (; Se <= ze && Se <= Xe;) { const Ee = U[ze], ce = q[Xe] = ve ? xu(q[Xe]) : ma(q[Xe]); if (us(Ee, ce)) m(Ee, ce, ee, null, me, fe, we, Oe, ve); else break; ze--, Xe-- } if (Se > ze) { if (Se <= Xe) { const Ee = Xe + 1, ce = Ee < Ke ? q[Ee].el : de; for (; Se <= Xe;)m(null, q[Se] = ve ? xu(q[Se]) : ma(q[Se]), ee, ce, me, fe, we, Oe, ve), Se++ } } else if (Se > Xe) for (; Se <= ze;)W(U[Se], me, fe, !0), Se++; else { const Ee = Se, ce = Se, Te = new Map; for (Se = ce; Se <= Xe; Se++) { const ct = q[Se] = ve ? xu(q[Se]) : ma(q[Se]); ct.key != null && Te.set(ct.key, Se) } let Le, st = 0; const jt = Xe - ce + 1; let Dn = !1, rr = 0; const Ce = new Array(jt); for (Se = 0; Se < jt; Se++)Ce[Se] = 0; for (Se = Ee; Se <= ze; Se++) { const ct = U[Se]; if (st >= jt) { W(ct, me, fe, !0); continue } let $t; if (ct.key != null) $t = Te.get(ct.key); else for (Le = ce; Le <= Xe; Le++)if (Ce[Le - ce] === 0 && us(ct, q[Le])) { $t = Le; break } $t === void 0 ? W(ct, me, fe, !0) : (Ce[$t - ce] = Se + 1, $t >= rr ? rr = $t : Dn = !0, m(ct, q[$t], ee, null, me, fe, we, Oe, ve), st++) } const it = Dn ? cve(Ce) : Nm; for (Le = it.length - 1, Se = jt - 1; Se >= 0; Se--) { const ct = ce + Se, $t = q[ct], sn = ct + 1 < Ke ? q[ct + 1].el : de; Ce[Se] === 0 ? m(null, $t, ee, sn, me, fe, we, Oe, ve) : Dn && (Le < 0 || Se !== it[Le] ? V($t, ee, sn, 2) : Le--) } } }, V = (U, q, ee, de, me = null) => { const { el: fe, type: we, transition: Oe, children: ve, shapeFlag: Se } = U; if (Se & 6) { V(U.component.subTree, q, ee, de); return } if (Se & 128) { U.suspense.move(q, ee, de); return } if (Se & 64) { we.move(U, q, ee, ge); return } if (we === Qt) { r(fe, q, ee); for (let ze = 0; ze < ve.length; ze++)V(ve[ze], q, ee, de); r(U.anchor, q, ee); return } if (we === Vm) { w(U, q, ee); return } if (de !== 2 && Se & 1 && Oe) if (de === 0) Oe.beforeEnter(fe), r(fe, q, ee), Rr(() => Oe.enter(fe), me); else { const { leave: ze, delayLeave: Xe, afterLeave: Ee } = Oe, ce = () => { U.ctx.isUnmounted ? i(fe) : r(fe, q, ee) }, Te = () => { ze(fe, () => { ce(), Ee && Ee() }) }; Xe ? Xe(fe, ce, Te) : Te() } else r(fe, q, ee) }, W = (U, q, ee, de = !1, me = !1) => { const { type: fe, props: we, ref: Oe, children: ve, dynamicChildren: Se, shapeFlag: Ke, patchFlag: ze, dirs: Xe, cacheIndex: Ee } = U; if (ze === -2 && (me = !1), Oe != null && (Tc(), P0(Oe, null, ee, U, !0), kc()), Ee != null && (q.renderCache[Ee] = void 0), Ke & 256) { q.ctx.deactivate(U); return } const ce = Ke & 1 && Xe, Te = !Ju(U); let Le; if (Te && (Le = we && we.onVnodeBeforeUnmount) && pa(Le, q, U), Ke & 6) le(U.component, ee, de); else { if (Ke & 128) { U.suspense.unmount(ee, de); return } ce && Js(U, null, q, "beforeUnmount"), Ke & 64 ? U.type.remove(U, q, ee, ge, de) : Se && !Se.hasOnce && (fe !== Qt || ze > 0 && ze & 64) ? De(Se, q, ee, !1, !0) : (fe === Qt && ze & 384 || !me && Ke & 16) && De(ve, q, ee), de && J(U) } (Te && (Le = we && we.onVnodeUnmounted) || ce) && Rr(() => { Le && pa(Le, q, U), ce && Js(U, null, q, "unmounted") }, ee) }, J = U => { const { type: q, el: ee, anchor: de, transition: me } = U; if (q === Qt) { ie(ee, de); return } if (q === Vm) { v(U); return } const fe = () => { i(ee), me && !me.persisted && me.afterLeave && me.afterLeave() }; if (U.shapeFlag & 1 && me && !me.persisted) { const { leave: we, delayLeave: Oe } = me, ve = () => we(ee, fe); Oe ? Oe(U.el, fe, ve) : ve() } else fe() }, ie = (U, q) => { let ee; for (; U !== q;)ee = f(U), i(U), U = ee; i(q) }, le = (U, q, ee) => { const { bum: de, scope: me, job: fe, subTree: we, um: Oe, m: ve, a: Se, parent: Ke, slots: { __: ze } } = U; CS(ve), CS(Se), de && Fy(de), Ke && Mt(ze) && ze.forEach(Xe => { Ke.renderCache[Xe] = void 0 }), me.stop(), fe && (fe.flags |= 8, W(we, U, q, ee)), Oe && Rr(Oe, q), Rr(() => { U.isUnmounted = !0 }, q), q && q.pendingBranch && !q.isUnmounted && U.asyncDep && !U.asyncResolved && U.suspenseId === q.pendingId && (q.deps--, q.deps === 0 && q.resolve()) }, De = (U, q, ee, de = !1, me = !1, fe = 0) => { for (let we = fe; we < U.length; we++)W(U[we], q, ee, de, me) }, ae = U => { if (U.shapeFlag & 6) return ae(U.component.subTree); if (U.shapeFlag & 128) return U.suspense.next(); const q = f(U.anchor || U.el), ee = q && q[bK]; return ee ? f(ee) : q }; let pe = !1; const se = (U, q, ee) => { U == null ? q._vnode && W(q._vnode, null, null, !0) : m(q._vnode || null, U, q, null, null, null, ee), q._vnode = U, pe || (pe = !0, m4(), TS(), pe = !1) }, ge = { p: m, um: W, m: V, r: J, mt: L, mc: A, pc: B, pbc: E, n: ae, o: n }; let _e, je; return e && ([_e, je] = e(ge)), { render: se, hydrate: _e, createApp: Qge(se, _e) } } function iE({ type: n, props: e }, t) { return t === "svg" && n === "foreignObject" || t === "mathml" && n === "annotation-xml" && e && e.encoding && e.encoding.includes("html") ? void 0 : t } function rf({ effect: n, job: e }, t) { t ? (n.flags |= 32, e.flags |= 4) : (n.flags &= -33, e.flags &= -5) } function HK(n, e) { return (!n || n && !n.pendingBranch) && e && !e.persisted } function VL(n, e, t = !1) { const r = n.children, i = e.children; if (Mt(r) && Mt(i)) for (let a = 0; a < r.length; a++) { const o = r[a]; let s = i[a]; s.shapeFlag & 1 && !s.dynamicChildren && ((s.patchFlag <= 0 || s.patchFlag === 32) && (s = i[a] = xu(i[a]), s.el = o.el), !t && s.patchFlag !== -2 && VL(o, s)), s.type === ch && (s.el = o.el), s.type === mr && !s.el && (s.el = o.el) } } function cve(n) { const e = n.slice(), t = [0]; let r, i, a, o, s; const l = n.length; for (r = 0; r < l; r++) { const c = n[r]; if (c !== 0) { if (i = t[t.length - 1], n[i] < c) { e[r] = i, t.push(r); continue } for (a = 0, o = t.length - 1; a < o;)s = a + o >> 1, n[t[s]] < c ? a = s + 1 : o = s; c < n[t[a]] && (a > 0 && (e[r] = t[a - 1]), t[a] = r) } } for (a = t.length, o = t[a - 1]; a-- > 0;)t[a] = o, o = e[o]; return t } function UK(n) { const e = n.subTree.component; if (e) return e.asyncDep && !e.asyncResolved ? e : UK(e) } function CS(n) { if (n) for (let e = 0; e < n.length; e++)n[e].flags |= 8 } const uve = Symbol.for("v-scx"), dve = () => zn(uve); function Bn(n, e) { return ob(n, null, e) } function GK(n, e) { return ob(n, null, { flush: "post" }) } function fve(n, e) { return ob(n, null, { flush: "sync" }) } function Ct(n, e, t) { return ob(n, e, t) } function ob(n, e, t = Tn) { const { immediate: r, deep: i, flush: a, once: o } = t, s = Dr({}, t), l = e && r || !e && a !== "post"; let c; if (ng) { if (a === "sync") { const h = dve(); c = h.__watcherHandles || (h.__watcherHandles = []) } else if (!l) { const h = () => { }; return h.stop = Do, h.resume = Do, h.pause = Do, h } } const u = $r; s.call = (h, p, m) => xs(h, u, p, m); let d = !1; a === "post" ? s.scheduler = h => { Rr(h, u && u.suspense) } : a !== "sync" && (d = !0, s.scheduler = (h, p) => { p ? h() : DL(h) }), s.augmentJob = h => { e && (h.flags |= 4), d && (h.flags |= 2, u && (h.id = u.uid, h.i = u)) }; const f = vge(n, e, s); return ng && (c ? c.push(f) : l && f()), f } function hve(n, e, t) { const r = this.proxy, i = Sr(n) ? n.includes(".") ? WK(r, n) : () => r[n] : n.bind(r, r); let a; Lt(e) ? a = e : (a = e.handler, t = e); const o = Ph(this), s = ob(i, a.bind(r), t); return o(), s } function WK(n, e) { const t = e.split("."); return () => { let r = n; for (let i = 0; i < t.length && r; i++)r = r[t[i]]; return r } } function sdt(n, e, t = Tn) { const r = kr(), i = Ta(e), a = Ng(e), o = KK(n, i), s = XT((l, c) => { let u, d = Tn, f; return fve(() => { const h = n[i]; Yi(u, h) && (u = h, c()) }), { get() { return l(), t.get ? t.get(u) : u }, set(h) { const p = t.set ? t.set(h) : h; if (!Yi(p, u) && !(d !== Tn && Yi(h, d))) return; const m = r.vnode.props; m && (e in m || i in m || a in m) && (`onUpdate:${e}` in m || `onUpdate:${i}` in m || `onUpdate:${a}` in m) || (u = h, c()), r.emit(`update:${e}`, p), Yi(h, p) && Yi(h, d) && !Yi(p, f) && c(), d = h, f = p } } }); return s[Symbol.iterator] = () => { let l = 0; return { next() { return l < 2 ? { value: l++ ? o || Tn : s, done: !1 } : { done: !0 } } } }, s } const KK = (n, e) => e === "modelValue" || e === "model-value" ? n.modelModifiers : n[`${e}Modifiers`] || n[`${Ta(e)}Modifiers`] || n[`${Ng(e)}Modifiers`]; function pve(n, e, ...t) { if (n.isUnmounted) return; const r = n.vnode.props || Tn; let i = t; const a = e.startsWith("update:"), o = a && KK(r, e.slice(7)); o && (o.trim && (i = t.map(u => Sr(u) ? u.trim() : u)), o.number && (i = t.map(Rme))); let s, l = r[s = $y(e)] || r[s = $y(Ta(e))]; !l && a && (l = r[s = $y(Ng(e))]), l && xs(l, n, 6, i); const c = r[s + "Once"]; if (c) { if (!n.emitted) n.emitted = {}; else if (n.emitted[s]) return; n.emitted[s] = !0, xs(c, n, 6, i) } } function qK(n, e, t = !1) { const r = e.emitsCache, i = r.get(n); if (i !== void 0) return i; const a = n.emits; let o = {}, s = !1; if (!Lt(n)) { const l = c => { const u = qK(c, e, !0); u && (s = !0, Dr(o, u)) }; !t && e.mixins.length && e.mixins.forEach(l), n.extends && l(n.extends), n.mixins && n.mixins.forEach(l) } return !a && !s ? (Jn(n) && r.set(n, null), null) : (Mt(a) ? a.forEach(l => o[l] = null) : Dr(o, a), Jn(n) && r.set(n, o), o) } function tk(n, e) { return !n || !UT(e) ? !1 : (e = e.slice(2).replace(/Once$/, ""), On(n, e[0].toLowerCase() + e.slice(1)) || On(n, Ng(e)) || On(n, e)) } function Ox(n) { const { type: e, vnode: t, proxy: r, withProxy: i, propsOptions: [a], slots: o, attrs: s, emit: l, render: c, renderCache: u, props: d, data: f, setupState: h, ctx: p, inheritAttrs: m } = n, g = D0(n); let y, b; try { if (t.shapeFlag & 4) { const v = i || r, S = v; y = ma(c.call(S, v, u, d, h, f, p)), b = s } else { const v = e; y = ma(v.length > 1 ? v(d, { attrs: s, slots: o, emit: l }) : v(d, null)), b = e.props ? s : gve(s) } } catch (v) { Gy.length = 0, Bg(v, n, 1), y = $e(mr) } let w = y; if (b && m !== !1) { const v = Object.keys(b), { shapeFlag: S } = w; v.length && S & 7 && (a && v.some(zW) && (b = vve(b, a)), w = $o(w, b, !1, !0)) } return t.dirs && (w = $o(w, null, !1, !0), w.dirs = w.dirs ? w.dirs.concat(t.dirs) : t.dirs), t.transition && fd(w, t.transition), y = w, D0(g), y } function mve(n, e = !0) { let t; for (let r = 0; r < n.length; r++) { const i = n[r]; if (hd(i)) { if (i.type !== mr || i.children === "v-if") { if (t) return; t = i } } else return } return t } const gve = n => { let e; for (const t in n) (t === "class" || t === "style" || UT(t)) && ((e || (e = {}))[t] = n[t]); return e }, vve = (n, e) => { const t = {}; for (const r in n) (!zW(r) || !(r.slice(9) in e)) && (t[r] = n[r]); return t }; function yve(n, e, t) { const { props: r, children: i, component: a } = n, { props: o, children: s, patchFlag: l } = e, c = a.emitsOptions; if (e.dirs || e.transition) return !0; if (t && l >= 0) { if (l & 1024) return !0; if (l & 16) return r ? A4(r, o, c) : !!o; if (l & 8) { const u = e.dynamicProps; for (let d = 0; d < u.length; d++) { const f = u[d]; if (o[f] !== r[f] && !tk(c, f)) return !0 } } } else return (i || s) && (!s || !s.$stable) ? !0 : r === o ? !1 : r ? o ? A4(r, o, c) : !0 : !!o; return !1 } function A4(n, e, t) { const r = Object.keys(e); if (r.length !== Object.keys(n).length) return !0; for (let i = 0; i < r.length; i++) { const a = r[i]; if (e[a] !== n[a] && !tk(t, a)) return !0 } return !1 } function nk({ vnode: n, parent: e }, t) { for (; e;) { const r = e.subTree; if (r.suspense && r.suspense.activeBranch === n && (r.el = n.el), r === n) (n = e.vnode).el = t, e = e.parent; else break } } const AS = n => n.__isSuspense; let VD = 0; const _ve = { name: "Suspense", __isSuspense: !0, process(n, e, t, r, i, a, o, s, l, c) { if (n == null) bve(e, t, r, i, a, o, s, l, c); else { if (a && a.deps > 0 && !n.suspense.isInFallback) { e.suspense = n.suspense, e.suspense.vnode = e, e.el = n.el; return } wve(n, e, t, r, i, o, s, l, c) } }, hydrate: xve, normalize: Sve }, ldt = _ve; function L0(n, e) { const t = n.props && n.props[e]; Lt(t) && t() } function bve(n, e, t, r, i, a, o, s, l) { const { p: c, o: { createElement: u } } = l, d = u("div"), f = n.suspense = YK(n, i, r, e, d, t, a, o, s, l); c(null, f.pendingBranch = n.ssContent, d, null, r, f, a, o), f.deps > 0 ? (L0(n, "onPending"), L0(n, "onFallback"), c(null, n.ssFallback, e, t, r, null, a, o), zm(f, n.ssFallback)) : f.resolve(!1, !0) } function wve(n, e, t, r, i, a, o, s, { p: l, um: c, o: { createElement: u } }) { const d = e.suspense = n.suspense; d.vnode = e, e.el = n.el; const f = e.ssContent, h = e.ssFallback, { activeBranch: p, pendingBranch: m, isInFallback: g, isHydrating: y } = d; if (m) d.pendingBranch = f, us(f, m) ? (l(m, f, d.hiddenContainer, null, i, d, a, o, s), d.deps <= 0 ? d.resolve() : g && (y || (l(p, h, t, r, i, null, a, o, s), zm(d, h)))) : (d.pendingId = VD++, y ? (d.isHydrating = !1, d.activeBranch = m) : c(m, i, d), d.deps = 0, d.effects.length = 0, d.hiddenContainer = u("div"), g ? (l(null, f, d.hiddenContainer, null, i, d, a, o, s), d.deps <= 0 ? d.resolve() : (l(p, h, t, r, i, null, a, o, s), zm(d, h))) : p && us(f, p) ? (l(p, f, t, r, i, d, a, o, s), d.resolve(!0)) : (l(null, f, d.hiddenContainer, null, i, d, a, o, s), d.deps <= 0 && d.resolve())); else if (p && us(f, p)) l(p, f, t, r, i, d, a, o, s), zm(d, f); else if (L0(e, "onPending"), d.pendingBranch = f, f.shapeFlag & 512 ? d.pendingId = f.component.suspenseId : d.pendingId = VD++, l(null, f, d.hiddenContainer, null, i, d, a, o, s), d.deps <= 0) d.resolve(); else { const { timeout: b, pendingId: w } = d; b > 0 ? setTimeout(() => { d.pendingId === w && d.fallback(h) }, b) : b === 0 && d.fallback(h) } } function YK(n, e, t, r, i, a, o, s, l, c, u = !1) { const { p: d, m: f, um: h, n: p, o: { parentNode: m, remove: g } } = c; let y; const b = Tve(n); b && e && e.pendingBranch && (y = e.pendingId, e.deps++); const w = n.props ? Nme(n.props.timeout) : void 0, v = a, S = { vnode: n, parent: e, parentComponent: t, namespace: o, container: r, hiddenContainer: i, deps: 0, pendingId: VD++, timeout: typeof w == "number" ? w : -1, activeBranch: null, pendingBranch: null, isInFallback: !u, isHydrating: u, isUnmounted: !1, effects: [], resolve(x = !1, k = !1) { const { vnode: A, activeBranch: C, pendingBranch: E, pendingId: O, effects: j, parentComponent: I, container: L } = S; let R = !1; S.isHydrating ? S.isHydrating = !1 : x || (R = C && E.transition && E.transition.mode === "out-in", R && (C.transition.afterLeave = () => { O === S.pendingId && (f(E, L, a === v ? p(C) : a, 0), SS(j)) }), C && (m(C.el) === L && (a = p(C)), h(C, I, S, !0)), R || f(E, L, a, 0)), zm(S, E), S.pendingBranch = null, S.isInFallback = !1; let D = S.parent, P = !1; for (; D;) { if (D.pendingBranch) { D.effects.push(...j), P = !0; break } D = D.parent } !P && !R && SS(j), S.effects = [], b && e && e.pendingBranch && y === e.pendingId && (e.deps--, e.deps === 0 && !k && e.resolve()), L0(A, "onResolve") }, fallback(x) { if (!S.pendingBranch) return; const { vnode: k, activeBranch: A, parentComponent: C, container: E, namespace: O } = S; L0(k, "onFallback"); const j = p(A), I = () => { S.isInFallback && (d(null, x, E, j, C, null, O, s, l), zm(S, x)) }, L = x.transition && x.transition.mode === "out-in"; L && (A.transition.afterLeave = I), S.isInFallback = !0, h(A, C, null, !0), L || I() }, move(x, k, A) { S.activeBranch && f(S.activeBranch, x, k, A), S.container = x }, next() { return S.activeBranch && p(S.activeBranch) }, registerDep(x, k, A) { const C = !!S.pendingBranch; C && S.deps++; const E = x.vnode.el; x.asyncDep.catch(O => { Bg(O, x, 0) }).then(O => { if (x.isUnmounted || S.isUnmounted || S.pendingId !== x.suspenseId) return; x.asyncResolved = !0; const { vnode: j } = x; GD(x, O, !1), E && (j.el = E); const I = !E && x.subTree.el; k(x, j, m(E || x.subTree.el), E ? null : p(x.subTree), S, o, A), I && g(I), nk(x, j.el), C && --S.deps === 0 && S.resolve() }) }, unmount(x, k) { S.isUnmounted = !0, S.activeBranch && h(S.activeBranch, t, x, k), S.pendingBranch && h(S.pendingBranch, t, x, k) } }; return S } function xve(n, e, t, r, i, a, o, s, l) { const c = e.suspense = YK(e, r, t, n.parentNode, document.createElement("div"), null, i, a, o, s, !0), u = l(n, c.pendingBranch = e.ssContent, t, c, a, o); return c.deps === 0 && c.resolve(!1, !0), u } function Sve(n) { const { shapeFlag: e, children: t } = n, r = e & 32; n.ssContent = E4(r ? t.default : t), n.ssFallback = r ? E4(t.fallback) : $e(mr) } function E4(n) { let e; if (Lt(n)) { const t = jh && n._c; t && (n._d = !1, Z()), n = n(), t && (n._d = !0, e = Ei, XK()) } return Mt(n) && (n = mve(n)), n = ma(n), e && !n.dynamicChildren && (n.dynamicChildren = e.filter(t => t !== n)), n } function ZK(n, e) { e && e.pendingBranch ? Mt(n) ? e.effects.push(...n) : e.effects.push(n) : SS(n) } function zm(n, e) { n.activeBranch = e; const { vnode: t, parentComponent: r } = n; let i = e.el; for (; !i && e.component;)e = e.component.subTree, i = e.el; t.el = i, r && r.subTree === t && (r.vnode.el = i, nk(r, i)) } function Tve(n) { const e = n.props && n.props.suspensible; return e != null && e !== !1 } const Qt = Symbol.for("v-fgt"), ch = Symbol.for("v-txt"), mr = Symbol.for("v-cmt"), Vm = Symbol.for("v-stc"), Gy = []; let Ei = null; function Z(n = !1) { Gy.push(Ei = n ? null : []) } function XK() { Gy.pop(), Ei = Gy[Gy.length - 1] || null } let jh = 1; function M4(n, e = !1) { jh += n, n < 0 && Ei && e && (Ei.hasOnce = !0) } function JK(n) { return n.dynamicChildren = jh > 0 ? Ei || Nm : null, XK(), jh > 0 && Ei && Ei.push(n), n } function ye(n, e, t, r, i, a) { return JK(re(n, e, t, r, i, a, !0)) } function Ye(n, e, t, r, i) { return JK($e(n, e, t, r, i, !0)) } function hd(n) { return n ? n.__v_isVNode === !0 : !1 } function us(n, e) { return n.type === e.type && n.key === e.key } function cdt(n) { } const QK = ({ key: n }) => n ?? null, Dx = ({ ref: n, ref_key: e, ref_for: t }) => (typeof n == "number" && (n = "" + n), n != null ? Sr(n) || Kn(n) || Lt(n) ? { i: Fr, r: n, k: e, f: !!t } : n : null); function re(n, e = null, t = null, r = 0, i = null, a = n === Qt ? 0 : 1, o = !1, s = !1) { const l = { __v_isVNode: !0, __v_skip: !0, type: n, props: e, key: e && QK(e), ref: e && Dx(e), scopeId: JT, slotScopeIds: null, children: t, component: null, suspense: null, ssContent: null, ssFallback: null, dirs: null, transition: null, el: null, anchor: null, target: null, targetStart: null, targetAnchor: null, staticCount: 0, shapeFlag: a, patchFlag: r, dynamicProps: i, dynamicChildren: null, appContext: null, ctx: Fr }; return s ? (HL(l, t), a & 128 && n.normalize(l)) : t && (l.shapeFlag |= Sr(t) ? 8 : 16), jh > 0 && !o && Ei && (l.patchFlag > 0 || a & 6) && l.patchFlag !== 32 && Ei.push(l), l } const $e = kve; function kve(n, e = null, t = null, r = 0, i = null, a = !1) { if ((!n || n === OK) && (n = mr), hd(n)) { const s = $o(n, e, !0); return t && HL(s, t), jh > 0 && !a && Ei && (s.shapeFlag & 6 ? Ei[Ei.indexOf(n)] = s : Ei.push(s)), s.patchFlag = -2, s } if (Ove(n) && (n = n.__vccOpts), e) { e = Mo(e); let { class: s, style: l } = e; s && !Sr(s) && (e.class = Tt(s)), Jn(l) && (OL(l) && !Mt(l) && (l = Dr({}, l)), e.style = aa(l)) } const o = Sr(n) ? 1 : AS(n) ? 128 : wK(n) ? 64 : Jn(n) ? 4 : Lt(n) ? 2 : 0; return re(n, e, t, r, i, o, a, !0) } function Mo(n) { return n ? OL(n) || RK(n) ? Dr({}, n) : n : null } function $o(n, e, t = !1, r = !1) { const { props: i, ref: a, patchFlag: o, children: s, transition: l } = n, c = e ? Sn(i || {}, e) : i, u = { __v_isVNode: !0, __v_skip: !0, type: n.type, props: c, key: c && QK(c), ref: e && e.ref ? t && a ? Mt(a) ? a.concat(Dx(e)) : [a, Dx(e)] : Dx(e) : a, scopeId: n.scopeId, slotScopeIds: n.slotScopeIds, children: s, target: n.target, targetStart: n.targetStart, targetAnchor: n.targetAnchor, staticCount: n.staticCount, shapeFlag: n.shapeFlag, patchFlag: e && n.type !== Qt ? o === -1 ? 16 : o | 16 : o, dynamicProps: n.dynamicProps, dynamicChildren: n.dynamicChildren, appContext: n.appContext, dirs: n.dirs, transition: l, component: n.component, suspense: n.suspense, ssContent: n.ssContent && $o(n.ssContent), ssFallback: n.ssFallback && $o(n.ssFallback), el: n.el, anchor: n.anchor, ctx: n.ctx, ce: n.ce }; return l && r && fd(u, l.clone(u)), u } function Fo(n = " ", e = 0) { return $e(ch, null, n, e) } function rk(n, e) { const t = $e(Vm, null, n); return t.staticCount = e, t } function mt(n = "", e = !1) { return e ? (Z(), Ye(mr, null, n)) : $e(mr, null, n) } function ma(n) { return n == null || typeof n == "boolean" ? $e(mr) : Mt(n) ? $e(Qt, null, n.slice()) : hd(n) ? xu(n) : $e(ch, null, String(n)) } function xu(n) { return n.el === null && n.patchFlag !== -1 || n.memo ? n : $o(n) } function HL(n, e) { let t = 0; const { shapeFlag: r } = n; if (e == null) e = null; else if (Mt(e)) t = 16; else if (typeof e == "object") if (r & 65) { const i = e.default; i && (i._c && (i._d = !1), HL(n, i()), i._c && (i._d = !0)); return } else { t = 32; const i = e._; !i && !RK(e) ? e._ctx = Fr : i === 3 && Fr && (Fr.slots._ === 1 ? e._ = 1 : (e._ = 2, n.patchFlag |= 1024)) } else Lt(e) ? (e = { default: e, _ctx: Fr }, t = 32) : (e = String(e), r & 64 ? (t = 16, e = [Fo(e)]) : t = 8); n.children = e, n.shapeFlag |= t } function Sn(...n) { const e = {}; for (let t = 0; t < n.length; t++) { const r = n[t]; for (const i in r) if (i === "class") e.class !== r.class && (e.class = Tt([e.class, r.class])); else if (i === "style") e.style = aa([e.style, r.style]); else if (UT(i)) { const a = e[i], o = r[i]; o && a !== o && !(Mt(a) && a.includes(o)) && (e[i] = a ? [].concat(a, o) : o) } else i !== "" && (e[i] = r[i]) } return e } function pa(n, e, t, r = null) { xs(n, e, 7, [t, r]) } const Cve = PK(); let Ave = 0; function eq(n, e, t) { const r = n.type, i = (e ? e.appContext : n.appContext) || Cve, a = { uid: Ave++, vnode: n, type: r, parent: e, appContext: i, root: null, next: null, subTree: null, effect: null, update: null, job: null, scope: new qW(!0), render: null, proxy: null, exposed: null, exposeProxy: null, withProxy: null, provides: e ? e.provides : Object.create(i.provides), ids: e ? e.ids : ["", 0, 0], accessCache: null, renderCache: [], components: null, directives: null, propsOptions: BK(r, i), emitsOptions: qK(r, i), emit: null, emitted: null, propsDefaults: Tn, inheritAttrs: r.inheritAttrs, ctx: Tn, data: Tn, props: Tn, attrs: Tn, slots: Tn, refs: Tn, setupState: Tn, setupContext: null, suspense: t, suspenseId: t ? t.pendingId : 0, asyncDep: null, asyncResolved: !1, isMounted: !1, isUnmounted: !1, isDeactivated: !1, bc: null, c: null, bm: null, m: null, bu: null, u: null, um: null, bum: null, da: null, a: null, rtg: null, rtc: null, ec: null, sp: null }; return a.ctx = { _: a }, a.root = e ? e.root : a, a.emit = pve.bind(null, a), n.ce && n.ce(a), a } let $r = null; const kr = () => $r || Fr; let ES, HD; { const n = WT(), e = (t, r) => { let i; return (i = n[t]) || (i = n[t] = []), i.push(r), a => { i.length > 1 ? i.forEach(o => o(a)) : i[0](a) } }; ES = e("__VUE_INSTANCE_SETTERS__", t => $r = t), HD = e("__VUE_SSR_SETTERS__", t => ng = t) } const Ph = n => { const e = $r; return ES(n), n.scope.on(), () => { n.scope.off(), ES(e) } }, UD = () => { $r && $r.scope.off(), ES(null) }; function tq(n) { return n.vnode.shapeFlag & 4 } let ng = !1; function nq(n, e = !1, t = !1) { e && HD(e); const { props: r, children: i } = n.vnode, a = tq(n); tve(n, r, a, e), ave(n, i, t || e); const o = a ? Eve(n, e) : void 0; return e && HD(!1), o } function Eve(n, e) { const t = n.type; n.accessCache = Object.create(null), n.proxy = new Proxy(n.ctx, BD); const { setup: r } = t; if (r) { Tc(); const i = n.setupContext = r.length > 1 ? iq(n) : null, a = Ph(n), o = nb(r, n, 0, [n.props, i]), s = TL(o); if (kc(), a(), (s || n.sp) && !Ju(n) && PL(n), s) { if (o.then(UD, UD), e) return o.then(l => { GD(n, l, e) }).catch(l => { Bg(l, n, 0) }); n.asyncDep = o } else GD(n, o, e) } else rq(n, e) } function GD(n, e, t) { Lt(e) ? n.type.__ssrInlineRender ? n.ssrRender = e : n.render = e : Jn(e) && (n.setupState = hK(e)), rq(n, t) } let MS, WD; function udt(n) { MS = n, WD = e => { e.render._rc && (e.withProxy = new Proxy(e.ctx, Gge)) } } const ddt = () => !MS; function rq(n, e, t) { const r = n.type; if (!n.render) { if (!e && MS && !r.render) { const i = r.template || $L(n).template; if (i) { const { isCustomElement: a, compilerOptions: o } = n.appContext.config, { delimiters: s, compilerOptions: l } = r, c = Dr(Dr({ isCustomElement: a, delimiters: s }, o), l); r.render = MS(i, c) } } n.render = r.render || Do, WD && WD(n) } { const i = Ph(n); Tc(); try { Kge(n) } finally { kc(), i() } } } const Mve = { get(n, e) { return Ci(n, "get", ""), n[e] } }; function iq(n) { const e = t => { n.exposed = t || {} }; return { attrs: new Proxy(n.attrs, Mve), slots: n.slots, emit: n.emit, expose: e } } function sb(n) { return n.exposed ? n.exposeProxy || (n.exposeProxy = new Proxy(hK(dn(n.exposed)), { get(e, t) { if (t in e) return e[t]; if (t in Uy) return Uy[t](n) }, has(e, t) { return t in e || t in Uy } })) : n.proxy } function KD(n, e = !0) { return Lt(n) ? n.displayName || n.name : n.name || e && n.__name } function Ove(n) { return Lt(n) && "__vccOpts" in n } const ne = (n, e) => mge(n, e, ng); function Gt(n, e, t) { const r = arguments.length; return r === 2 ? Jn(e) && !Mt(e) ? hd(e) ? $e(n, null, [e]) : $e(n, e) : $e(n, null, e) : (r > 3 ? t = Array.prototype.slice.call(arguments, 2) : r === 3 && hd(t) && (t = [t]), $e(n, e, t)) } function fdt() { } function hdt(n, e, t, r) { const i = t[r]; if (i && Dve(i, n)) return i; const a = e(); return a.memo = n.slice(), a.cacheIndex = r, t[r] = a } function Dve(n, e) { const t = n.memo; if (t.length != e.length) return !1; for (let r = 0; r < t.length; r++)if (Yi(t[r], e[r])) return !1; return jh > 0 && Ei && Ei.push(n), !0 } const jve = "3.5.16", pdt = Do, mdt = bge, gdt = dm, vdt = _K, Pve = { createComponentInstance: eq, setupComponent: nq, renderComponentRoot: Ox, setCurrentRenderingInstance: D0, isVNode: hd, normalizeVNode: ma, getComponentPublicInstance: sb, ensureValidVNode: BL, pushWarningContext: yge, popWarningContext: _ge }, ydt = Pve, _dt = null, bdt = null, wdt = null;/**
* @vue/shared v3.5.16
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**//*! #__NO_SIDE_EFFECTS__ */function Ive(n) { const e = Object.create(null); for (const t of n.split(",")) e[t] = 1; return t => t in e } const aE = {}, Lve = () => { }, Rve = n => n.charCodeAt(0) === 111 && n.charCodeAt(1) === 110 && (n.charCodeAt(2) > 122 || n.charCodeAt(2) < 97), Nve = n => n.startsWith("onUpdate:"), Ih = Object.assign, Bve = Object.prototype.hasOwnProperty, $ve = (n, e) => Bve.call(n, e), Ka = Array.isArray, lb = n => UL(n) === "[object Set]", O4 = n => UL(n) === "[object Date]", aq = n => typeof n == "function", rg = n => typeof n == "string", qD = n => typeof n == "symbol", YD = n => n !== null && typeof n == "object", Fve = Object.prototype.toString, UL = n => Fve.call(n), oq = n => UL(n) === "[object Object]", GL = n => { const e = Object.create(null); return t => e[t] || (e[t] = n(t)) }, zve = /-(\w)/g, jx = GL(n => n.replace(zve, (e, t) => t ? t.toUpperCase() : "")), Vve = /\B([A-Z])/g, Mu = GL(n => n.replace(Vve, "-$1").toLowerCase()), Hve = GL(n => n.charAt(0).toUpperCase() + n.slice(1)), Uve = (n, ...e) => { for (let t = 0; t < n.length; t++)n[t](...e) }, ZD = n => { const e = parseFloat(n); return isNaN(e) ? n : e }, XD = n => { const e = rg(n) ? Number(n) : NaN; return isNaN(e) ? n : e }, Gve = "itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly", Wve = Ive(Gve); function sq(n) { return !!n || n === "" } function Kve(n, e) { if (n.length !== e.length) return !1; let t = !0; for (let r = 0; t && r < n.length; r++)t = pd(n[r], e[r]); return t } function pd(n, e) { if (n === e) return !0; let t = O4(n), r = O4(e); if (t || r) return t && r ? n.getTime() === e.getTime() : !1; if (t = qD(n), r = qD(e), t || r) return n === e; if (t = Ka(n), r = Ka(e), t || r) return t && r ? Kve(n, e) : !1; if (t = YD(n), r = YD(e), t || r) { if (!t || !r) return !1; const i = Object.keys(n).length, a = Object.keys(e).length; if (i !== a) return !1; for (const o in n) { const s = n.hasOwnProperty(o), l = e.hasOwnProperty(o); if (s && !l || !s && l || !pd(n[o], e[o])) return !1 } } return String(n) === String(e) } function ik(n, e) { return n.findIndex(t => pd(t, e)) }/**
* @vue/runtime-dom v3.5.16
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/let JD; const D4 = typeof window < "u" && window.trustedTypes; if (D4) try { JD = D4.createPolicy("vue", { createHTML: n => n }) } catch { } const lq = JD ? n => JD.createHTML(n) : n => n, qve = "http://www.w3.org/2000/svg", Yve = "http://www.w3.org/1998/Math/MathML", nc = typeof document < "u" ? document : null, j4 = nc && nc.createElement("template"), Zve = { insert: (n, e, t) => { e.insertBefore(n, t || null) }, remove: n => { const e = n.parentNode; e && e.removeChild(n) }, createElement: (n, e, t, r) => { const i = e === "svg" ? nc.createElementNS(qve, n) : e === "mathml" ? nc.createElementNS(Yve, n) : t ? nc.createElement(n, { is: t }) : nc.createElement(n); return n === "select" && r && r.multiple != null && i.setAttribute("multiple", r.multiple), i }, createText: n => nc.createTextNode(n), createComment: n => nc.createComment(n), setText: (n, e) => { n.nodeValue = e }, setElementText: (n, e) => { n.textContent = e }, parentNode: n => n.parentNode, nextSibling: n => n.nextSibling, querySelector: n => nc.querySelector(n), setScopeId(n, e) { n.setAttribute(e, "") }, insertStaticContent(n, e, t, r, i, a) { const o = t ? t.previousSibling : e.lastChild; if (i && (i === a || i.nextSibling)) for (; e.insertBefore(i.cloneNode(!0), t), !(i === a || !(i = i.nextSibling));); else { j4.innerHTML = lq(r === "svg" ? `<svg>${n}</svg>` : r === "mathml" ? `<math>${n}</math>` : n); const s = j4.content; if (r === "svg" || r === "mathml") { const l = s.firstChild; for (; l.firstChild;)s.appendChild(l.firstChild); s.removeChild(l) } e.insertBefore(s, t) } return [o ? o.nextSibling : e.firstChild, t ? t.previousSibling : e.lastChild] } }, tu = "transition", Ov = "animation", ig = Symbol("_vtc"), cq = { name: String, type: String, css: { type: Boolean, default: !0 }, duration: [String, Number, Object], enterFromClass: String, enterActiveClass: String, enterToClass: String, appearFromClass: String, appearActiveClass: String, appearToClass: String, leaveFromClass: String, leaveActiveClass: String, leaveToClass: String }, uq = Ih({}, kK, cq), Xve = n => (n.displayName = "Transition", n.props = uq, n), dq = Xve((n, { slots: e }) => Gt(kge, fq(n), e)), af = (n, e = []) => { Ka(n) ? n.forEach(t => t(...e)) : n && n(...e) }, P4 = n => n ? Ka(n) ? n.some(e => e.length > 1) : n.length > 1 : !1; function fq(n) { const e = {}; for (const j in n) j in cq || (e[j] = n[j]); if (n.css === !1) return e; const { name: t = "v", type: r, duration: i, enterFromClass: a = `${t}-enter-from`, enterActiveClass: o = `${t}-enter-active`, enterToClass: s = `${t}-enter-to`, appearFromClass: l = a, appearActiveClass: c = o, appearToClass: u = s, leaveFromClass: d = `${t}-leave-from`, leaveActiveClass: f = `${t}-leave-active`, leaveToClass: h = `${t}-leave-to` } = n, p = Jve(i), m = p && p[0], g = p && p[1], { onBeforeEnter: y, onEnter: b, onEnterCancelled: w, onLeave: v, onLeaveCancelled: S, onBeforeAppear: x = y, onAppear: k = b, onAppearCancelled: A = w } = e, C = (j, I, L, R) => { j._enterCancelled = R, hu(j, I ? u : s), hu(j, I ? c : o), L && L() }, E = (j, I) => { j._isLeaving = !1, hu(j, d), hu(j, h), hu(j, f), I && I() }, O = j => (I, L) => { const R = j ? k : b, D = () => C(I, j, L); af(R, [I, D]), I4(() => { hu(I, j ? l : a), Vs(I, j ? u : s), P4(R) || L4(I, r, m, D) }) }; return Ih(e, { onBeforeEnter(j) { af(y, [j]), Vs(j, a), Vs(j, o) }, onBeforeAppear(j) { af(x, [j]), Vs(j, l), Vs(j, c) }, onEnter: O(!1), onAppear: O(!0), onLeave(j, I) { j._isLeaving = !0; const L = () => E(j, I); Vs(j, d), j._enterCancelled ? (Vs(j, f), QD()) : (QD(), Vs(j, f)), I4(() => { j._isLeaving && (hu(j, d), Vs(j, h), P4(v) || L4(j, r, g, L)) }), af(v, [j, L]) }, onEnterCancelled(j) { C(j, !1, void 0, !0), af(w, [j]) }, onAppearCancelled(j) { C(j, !0, void 0, !0), af(A, [j]) }, onLeaveCancelled(j) { E(j), af(S, [j]) } }) } function Jve(n) { if (n == null) return null; if (YD(n)) return [oE(n.enter), oE(n.leave)]; { const e = oE(n); return [e, e] } } function oE(n) { return XD(n) } function Vs(n, e) { e.split(/\s+/).forEach(t => t && n.classList.add(t)), (n[ig] || (n[ig] = new Set)).add(e) } function hu(n, e) { e.split(/\s+/).forEach(r => r && n.classList.remove(r)); const t = n[ig]; t && (t.delete(e), t.size || (n[ig] = void 0)) } function I4(n) { requestAnimationFrame(() => { requestAnimationFrame(n) }) } let Qve = 0; function L4(n, e, t, r) { const i = n._endId = ++Qve, a = () => { i === n._endId && r() }; if (t != null) return setTimeout(a, t); const { type: o, timeout: s, propCount: l } = hq(n, e); if (!o) return r(); const c = o + "end"; let u = 0; const d = () => { n.removeEventListener(c, f), a() }, f = h => { h.target === n && ++u >= l && d() }; setTimeout(() => { u < l && d() }, s + 1), n.addEventListener(c, f) } function hq(n, e) { const t = window.getComputedStyle(n), r = p => (t[p] || "").split(", "), i = r(`${tu}Delay`), a = r(`${tu}Duration`), o = R4(i, a), s = r(`${Ov}Delay`), l = r(`${Ov}Duration`), c = R4(s, l); let u = null, d = 0, f = 0; e === tu ? o > 0 && (u = tu, d = o, f = a.length) : e === Ov ? c > 0 && (u = Ov, d = c, f = l.length) : (d = Math.max(o, c), u = d > 0 ? o > c ? tu : Ov : null, f = u ? u === tu ? a.length : l.length : 0); const h = u === tu && /\b(transform|all)(,|$)/.test(r(`${tu}Property`).toString()); return { type: u, timeout: d, propCount: f, hasTransform: h } } function R4(n, e) { for (; n.length < e.length;)n = n.concat(n); return Math.max(...e.map((t, r) => N4(t) + N4(n[r]))) } function N4(n) { return n === "auto" ? 0 : Number(n.slice(0, -1).replace(",", ".")) * 1e3 } function QD() { return document.body.offsetHeight } function eye(n, e, t) { const r = n[ig]; r && (e = (e ? [e, ...r] : [...r]).join(" ")), e == null ? n.removeAttribute("class") : t ? n.setAttribute("class", e) : n.className = e } const OS = Symbol("_vod"), pq = Symbol("_vsh"), ag = { beforeMount(n, { value: e }, { transition: t }) { n[OS] = n.style.display === "none" ? "" : n.style.display, t && e ? t.beforeEnter(n) : Dv(n, e) }, mounted(n, { value: e }, { transition: t }) { t && e && t.enter(n) }, updated(n, { value: e, oldValue: t }, { transition: r }) { !e != !t && (r ? e ? (r.beforeEnter(n), Dv(n, !0), r.enter(n)) : r.leave(n, () => { Dv(n, !1) }) : Dv(n, e)) }, beforeUnmount(n, { value: e }) { Dv(n, e) } }; function Dv(n, e) { n.style.display = e ? n[OS] : "none", n[pq] = !e } function tye() { ag.getSSRProps = ({ value: n }) => { if (!n) return { style: { display: "none" } } } } const mq = Symbol(""); function xdt(n) { const e = kr(); if (!e) return; const t = e.ut = (i = n(e.proxy)) => { Array.from(document.querySelectorAll(`[data-v-owner="${e.uid}"]`)).forEach(a => DS(a, i)) }, r = () => { const i = n(e.proxy); e.ce ? DS(e.ce, i) : ej(e.subTree, i), t(i) }; IL(() => { SS(r) }), un(() => { Ct(r, Lve, { flush: "post" }); const i = new MutationObserver(r); i.observe(e.subTree.el.parentNode, { childList: !0 }), cr(() => i.disconnect()) }) } function ej(n, e) { if (n.shapeFlag & 128) { const t = n.suspense; n = t.activeBranch, t.pendingBranch && !t.isHydrating && t.effects.push(() => { ej(t.activeBranch, e) }) } for (; n.component;)n = n.component.subTree; if (n.shapeFlag & 1 && n.el) DS(n.el, e); else if (n.type === Qt) n.children.forEach(t => ej(t, e)); else if (n.type === Vm) { let { el: t, anchor: r } = n; for (; t && (DS(t, e), t !== r);)t = t.nextSibling } } function DS(n, e) { if (n.nodeType === 1) { const t = n.style; let r = ""; for (const i in e) t.setProperty(`--${i}`, e[i]), r += `--${i}: ${e[i]};`; t[mq] = r } } const nye = /(^|;)\s*display\s*:/; function rye(n, e, t) { const r = n.style, i = rg(t); let a = !1; if (t && !i) { if (e) if (rg(e)) for (const o of e.split(";")) { const s = o.slice(0, o.indexOf(":")).trim(); t[s] == null && Px(r, s, "") } else for (const o in e) t[o] == null && Px(r, o, ""); for (const o in t) o === "display" && (a = !0), Px(r, o, t[o]) } else if (i) { if (e !== t) { const o = r[mq]; o && (t += ";" + o), r.cssText = t, a = nye.test(t) } } else e && n.removeAttribute("style"); OS in n && (n[OS] = a ? r.display : "", n[pq] && (r.display = "none")) } const B4 = /\s*!important$/; function Px(n, e, t) { if (Ka(t)) t.forEach(r => Px(n, e, r)); else if (t == null && (t = ""), e.startsWith("--")) n.setProperty(e, t); else { const r = iye(n, e); B4.test(t) ? n.setProperty(Mu(r), t.replace(B4, ""), "important") : n[r] = t } } const $4 = ["Webkit", "Moz", "ms"], sE = {}; function iye(n, e) { const t = sE[e]; if (t) return t; let r = Ta(e); if (r !== "filter" && r in n) return sE[e] = r; r = Hve(r); for (let i = 0; i < $4.length; i++) { const a = $4[i] + r; if (a in n) return sE[e] = a } return e } const F4 = "http://www.w3.org/1999/xlink"; function z4(n, e, t, r, i, a = Wve(e)) { r && e.startsWith("xlink:") ? t == null ? n.removeAttributeNS(F4, e.slice(6, e.length)) : n.setAttributeNS(F4, e, t) : t == null || a && !sq(t) ? n.removeAttribute(e) : n.setAttribute(e, a ? "" : qD(t) ? String(t) : t) } function V4(n, e, t, r, i) { if (e === "innerHTML" || e === "textContent") { t != null && (n[e] = e === "innerHTML" ? lq(t) : t); return } const a = n.tagName; if (e === "value" && a !== "PROGRESS" && !a.includes("-")) { const s = a === "OPTION" ? n.getAttribute("value") || "" : n.value, l = t == null ? n.type === "checkbox" ? "on" : "" : String(t); (s !== l || !("_value" in n)) && (n.value = l), t == null && n.removeAttribute(e), n._value = t; return } let o = !1; if (t === "" || t == null) { const s = typeof n[e]; s === "boolean" ? t = sq(t) : t == null && s === "string" ? (t = "", o = !0) : s === "number" && (t = 0, o = !0) } try { n[e] = t } catch { } o && n.removeAttribute(i || e) } function uc(n, e, t, r) { n.addEventListener(e, t, r) } function aye(n, e, t, r) { n.removeEventListener(e, t, r) } const H4 = Symbol("_vei"); function oye(n, e, t, r, i = null) { const a = n[H4] || (n[H4] = {}), o = a[e]; if (r && o) o.value = r; else { const [s, l] = sye(e); if (r) { const c = a[e] = uye(r, i); uc(n, s, c, l) } else o && (aye(n, s, o, l), a[e] = void 0) } } const U4 = /(?:Once|Passive|Capture)$/; function sye(n) { let e; if (U4.test(n)) { e = {}; let r; for (; r = n.match(U4);)n = n.slice(0, n.length - r[0].length), e[r[0].toLowerCase()] = !0 } return [n[2] === ":" ? n.slice(3) : Mu(n.slice(2)), e] } let lE = 0; const lye = Promise.resolve(), cye = () => lE || (lye.then(() => lE = 0), lE = Date.now()); function uye(n, e) { const t = r => { if (!r._vts) r._vts = Date.now(); else if (r._vts <= t.attached) return; xs(dye(r, t.value), e, 5, [r]) }; return t.value = n, t.attached = cye(), t } function dye(n, e) { if (Ka(e)) { const t = n.stopImmediatePropagation; return n.stopImmediatePropagation = () => { t.call(n), n._stopped = !0 }, e.map(r => i => !i._stopped && r && r(i)) } else return e } const G4 = n => n.charCodeAt(0) === 111 && n.charCodeAt(1) === 110 && n.charCodeAt(2) > 96 && n.charCodeAt(2) < 123, fye = (n, e, t, r, i, a) => { const o = i === "svg"; e === "class" ? eye(n, r, o) : e === "style" ? rye(n, t, r) : Rve(e) ? Nve(e) || oye(n, e, t, r, a) : (e[0] === "." ? (e = e.slice(1), !0) : e[0] === "^" ? (e = e.slice(1), !1) : hye(n, e, r, o)) ? (V4(n, e, r), !n.tagName.includes("-") && (e === "value" || e === "checked" || e === "selected") && z4(n, e, r, o, a, e !== "value")) : n._isVueCE && (/[A-Z]/.test(e) || !rg(r)) ? V4(n, jx(e), r, a, e) : (e === "true-value" ? n._trueValue = r : e === "false-value" && (n._falseValue = r), z4(n, e, r, o)) }; function hye(n, e, t, r) { if (r) return !!(e === "innerHTML" || e === "textContent" || e in n && G4(e) && aq(t)); if (e === "spellcheck" || e === "draggable" || e === "translate" || e === "autocorrect" || e === "form" || e === "list" && n.tagName === "INPUT" || e === "type" && n.tagName === "TEXTAREA") return !1; if (e === "width" || e === "height") { const i = n.tagName; if (i === "IMG" || i === "VIDEO" || i === "CANVAS" || i === "SOURCE") return !1 } return G4(e) && rg(t) ? !1 : e in n } const W4 = {};/*! #__NO_SIDE_EFFECTS__ */function pye(n, e, t) { const r = We(n, e); oq(r) && Ih(r, e); class i extends WL { constructor(o) { super(r, o, t) } } return i.def = r, i }/*! #__NO_SIDE_EFFECTS__ */const Sdt = (n, e) => pye(n, e, Mye), mye = typeof HTMLElement < "u" ? HTMLElement : class { }; class WL extends mye { constructor(e, t = {}, r = R0) { super(), this._def = e, this._props = t, this._createApp = r, this._isVueCE = !0, this._instance = null, this._app = null, this._nonce = this._def.nonce, this._connected = !1, this._resolved = !1, this._numberProps = null, this._styleChildren = new WeakSet, this._ob = null, this.shadowRoot && r !== R0 ? this._root = this.shadowRoot : e.shadowRoot !== !1 ? (this.attachShadow({ mode: "open" }), this._root = this.shadowRoot) : this._root = this } connectedCallback() { if (!this.isConnected) return; !this.shadowRoot && !this._resolved && this._parseSlots(), this._connected = !0; let e = this; for (; e = e && (e.parentNode || e.host);)if (e instanceof WL) { this._parent = e; break } this._instance || (this._resolved ? this._mount(this._def) : e && e._pendingResolve ? this._pendingResolve = e._pendingResolve.then(() => { this._pendingResolve = void 0, this._resolveDef() }) : this._resolveDef()) } _setParent(e = this._parent) { e && (this._instance.parent = e._instance, this._inheritParentContext(e)) } _inheritParentContext(e = this._parent) { e && this._app && Object.setPrototypeOf(this._app._context.provides, e._instance.provides) } disconnectedCallback() { this._connected = !1, Pr(() => { this._connected || (this._ob && (this._ob.disconnect(), this._ob = null), this._app && this._app.unmount(), this._instance && (this._instance.ce = void 0), this._app = this._instance = null) }) } _resolveDef() { if (this._pendingResolve) return; for (let r = 0; r < this.attributes.length; r++)this._setAttr(this.attributes[r].name); this._ob = new MutationObserver(r => { for (const i of r) this._setAttr(i.attributeName) }), this._ob.observe(this, { attributes: !0 }); const e = (r, i = !1) => { this._resolved = !0, this._pendingResolve = void 0; const { props: a, styles: o } = r; let s; if (a && !Ka(a)) for (const l in a) { const c = a[l]; (c === Number || c && c.type === Number) && (l in this._props && (this._props[l] = XD(this._props[l])), (s || (s = Object.create(null)))[jx(l)] = !0) } this._numberProps = s, this._resolveProps(r), this.shadowRoot && this._applyStyles(o), this._mount(r) }, t = this._def.__asyncLoader; t ? this._pendingResolve = t().then(r => e(this._def = r, !0)) : e(this._def) } _mount(e) { this._app = this._createApp(e), this._inheritParentContext(), e.configureApp && e.configureApp(this._app), this._app._ceVNode = this._createVNode(), this._app.mount(this._root); const t = this._instance && this._instance.exposed; if (t) for (const r in t) $ve(this, r) || Object.defineProperty(this, r, { get: () => X(t[r]) }) } _resolveProps(e) { const { props: t } = e, r = Ka(t) ? t : Object.keys(t || {}); for (const i of Object.keys(this)) i[0] !== "_" && r.includes(i) && this._setProp(i, this[i]); for (const i of r.map(jx)) Object.defineProperty(this, i, { get() { return this._getProp(i) }, set(a) { this._setProp(i, a, !0, !0) } }) } _setAttr(e) { if (e.startsWith("data-v-")) return; const t = this.hasAttribute(e); let r = t ? this.getAttribute(e) : W4; const i = jx(e); t && this._numberProps && this._numberProps[i] && (r = XD(r)), this._setProp(i, r, !1, !0) } _getProp(e) { return this._props[e] } _setProp(e, t, r = !0, i = !1) { if (t !== this._props[e] && (t === W4 ? delete this._props[e] : (this._props[e] = t, e === "key" && this._app && (this._app._ceVNode.key = t)), i && this._instance && this._update(), r)) { const a = this._ob; a && a.disconnect(), t === !0 ? this.setAttribute(Mu(e), "") : typeof t == "string" || typeof t == "number" ? this.setAttribute(Mu(e), t + "") : t || this.removeAttribute(Mu(e)), a && a.observe(this, { attributes: !0 }) } } _update() { const e = this._createVNode(); this._app && (e.appContext = this._app._context), tj(e, this._root) } _createVNode() { const e = {}; this.shadowRoot || (e.onVnodeMounted = e.onVnodeUpdated = this._renderSlots.bind(this)); const t = $e(this._def, Ih(e, this._props)); return this._instance || (t.ce = r => { this._instance = r, r.ce = this, r.isCE = !0; const i = (a, o) => { this.dispatchEvent(new CustomEvent(a, oq(o[0]) ? Ih({ detail: o }, o[0]) : { detail: o })) }; r.emit = (a, ...o) => { i(a, o), Mu(a) !== a && i(Mu(a), o) }, this._setParent() }), t } _applyStyles(e, t) { if (!e) return; if (t) { if (t === this._def || this._styleChildren.has(t)) return; this._styleChildren.add(t) } const r = this._nonce; for (let i = e.length - 1; i >= 0; i--) { const a = document.createElement("style"); r && a.setAttribute("nonce", r), a.textContent = e[i], this.shadowRoot.prepend(a) } } _parseSlots() { const e = this._slots = {}; let t; for (; t = this.firstChild;) { const r = t.nodeType === 1 && t.getAttribute("slot") || "default"; (e[r] || (e[r] = [])).push(t), this.removeChild(t) } } _renderSlots() { const e = (this._teleportTarget || this).querySelectorAll("slot"), t = this._instance.type.__scopeId; for (let r = 0; r < e.length; r++) { const i = e[r], a = i.getAttribute("name") || "default", o = this._slots[a], s = i.parentNode; if (o) for (const l of o) { if (t && l.nodeType === 1) { const c = t + "-s", u = document.createTreeWalker(l, 1); l.setAttribute(c, ""); let d; for (; d = u.nextNode();)d.setAttribute(c, "") } s.insertBefore(l, i) } else for (; i.firstChild;)s.insertBefore(i.firstChild, i); s.removeChild(i) } } _injectChildStyle(e) { this._applyStyles(e.styles, e) } _removeChildStyle(e) { } } function gye(n) { const e = kr(), t = e && e.ce; return t || null } function Tdt() { const n = gye(); return n && n.shadowRoot } function kdt(n = "$style") { { const e = kr(); if (!e) return aE; const t = e.type.__cssModules; if (!t) return aE; const r = t[n]; return r || aE } } const gq = new WeakMap, vq = new WeakMap, jS = Symbol("_moveCb"), K4 = Symbol("_enterCb"), vye = n => (delete n.props.mode, n), yye = vye({ name: "TransitionGroup", props: Ih({}, uq, { tag: String, moveClass: String }), setup(n, { slots: e }) { const t = kr(), r = TK(); let i, a; return LL(() => { if (!i.length) return; const o = n.moveClass || `${n.name || "v"}-move`; if (!xye(i[0].el, t.vnode.el, o)) { i = []; return } i.forEach(_ye), i.forEach(bye); const s = i.filter(wye); QD(), s.forEach(l => { const c = l.el, u = c.style; Vs(c, o), u.transform = u.webkitTransform = u.transitionDuration = ""; const d = c[jS] = f => { f && f.target !== c || (!f || /transform$/.test(f.propertyName)) && (c.removeEventListener("transitionend", d), c[jS] = null, hu(c, o)) }; c.addEventListener("transitionend", d) }), i = [] }), () => { const o = Vt(n), s = fq(o); let l = o.tag || Qt; if (i = [], a) for (let c = 0; c < a.length; c++) { const u = a[c]; u.el && u.el instanceof Element && (i.push(u), fd(u, j0(u, s, r, t)), gq.set(u, u.el.getBoundingClientRect())) } a = e.default ? jL(e.default()) : []; for (let c = 0; c < a.length; c++) { const u = a[c]; u.key != null && fd(u, j0(u, s, r, t)) } return $e(l, null, a) } } }), Cdt = yye; function _ye(n) { const e = n.el; e[jS] && e[jS](), e[K4] && e[K4]() } function bye(n) { vq.set(n, n.el.getBoundingClientRect()) } function wye(n) { const e = gq.get(n), t = vq.get(n), r = e.left - t.left, i = e.top - t.top; if (r || i) { const a = n.el.style; return a.transform = a.webkitTransform = `translate(${r}px,${i}px)`, a.transitionDuration = "0s", n } } function xye(n, e, t) { const r = n.cloneNode(), i = n[ig]; i && i.forEach(s => { s.split(/\s+/).forEach(l => l && r.classList.remove(l)) }), t.split(/\s+/).forEach(s => s && r.classList.add(s)), r.style.display = "none"; const a = e.nodeType === 1 ? e : e.parentNode; a.appendChild(r); const { hasTransform: o } = hq(r); return a.removeChild(r), o } const md = n => { const e = n.props["onUpdate:modelValue"] || !1; return Ka(e) ? t => Uve(e, t) : e }; function Sye(n) { n.target.composing = !0 } function q4(n) { const e = n.target; e.composing && (e.composing = !1, e.dispatchEvent(new Event("input"))) } const Io = Symbol("_assign"), PS = { created(n, { modifiers: { lazy: e, trim: t, number: r } }, i) { n[Io] = md(i); const a = r || i.props && i.props.type === "number"; uc(n, e ? "change" : "input", o => { if (o.target.composing) return; let s = n.value; t && (s = s.trim()), a && (s = ZD(s)), n[Io](s) }), t && uc(n, "change", () => { n.value = n.value.trim() }), e || (uc(n, "compositionstart", Sye), uc(n, "compositionend", q4), uc(n, "change", q4)) }, mounted(n, { value: e }) { n.value = e ?? "" }, beforeUpdate(n, { value: e, oldValue: t, modifiers: { lazy: r, trim: i, number: a } }, o) { if (n[Io] = md(o), n.composing) return; const s = (a || n.type === "number") && !/^0\d/.test(n.value) ? ZD(n.value) : n.value, l = e ?? ""; s !== l && (document.activeElement === n && n.type !== "range" && (r && e === t || i && n.value.trim() === l) || (n.value = l)) } }, yq = { deep: !0, created(n, e, t) { n[Io] = md(t), uc(n, "change", () => { const r = n._modelValue, i = og(n), a = n.checked, o = n[Io]; if (Ka(r)) { const s = ik(r, i), l = s !== -1; if (a && !l) o(r.concat(i)); else if (!a && l) { const c = [...r]; c.splice(s, 1), o(c) } } else if (lb(r)) { const s = new Set(r); a ? s.add(i) : s.delete(i), o(s) } else o(wq(n, a)) }) }, mounted: Y4, beforeUpdate(n, e, t) { n[Io] = md(t), Y4(n, e, t) } }; function Y4(n, { value: e, oldValue: t }, r) { n._modelValue = e; let i; if (Ka(e)) i = ik(e, r.props.value) > -1; else if (lb(e)) i = e.has(r.props.value); else { if (e === t) return; i = pd(e, wq(n, !0)) } n.checked !== i && (n.checked = i) } const _q = { created(n, { value: e }, t) { n.checked = pd(e, t.props.value), n[Io] = md(t), uc(n, "change", () => { n[Io](og(n)) }) }, beforeUpdate(n, { value: e, oldValue: t }, r) { n[Io] = md(r), e !== t && (n.checked = pd(e, r.props.value)) } }, bq = { deep: !0, created(n, { value: e, modifiers: { number: t } }, r) { const i = lb(e); uc(n, "change", () => { const a = Array.prototype.filter.call(n.options, o => o.selected).map(o => t ? ZD(og(o)) : og(o)); n[Io](n.multiple ? i ? new Set(a) : a : a[0]), n._assigning = !0, Pr(() => { n._assigning = !1 }) }), n[Io] = md(r) }, mounted(n, { value: e }) { Z4(n, e) }, beforeUpdate(n, e, t) { n[Io] = md(t) }, updated(n, { value: e }) { n._assigning || Z4(n, e) } }; function Z4(n, e) { const t = n.multiple, r = Ka(e); if (!(t && !r && !lb(e))) { for (let i = 0, a = n.options.length; i < a; i++) { const o = n.options[i], s = og(o); if (t) if (r) { const l = typeof s; l === "string" || l === "number" ? o.selected = e.some(c => String(c) === String(s)) : o.selected = ik(e, s) > -1 } else o.selected = e.has(s); else if (pd(og(o), e)) { n.selectedIndex !== i && (n.selectedIndex = i); return } } !t && n.selectedIndex !== -1 && (n.selectedIndex = -1) } } function og(n) { return "_value" in n ? n._value : n.value } function wq(n, e) { const t = e ? "_trueValue" : "_falseValue"; return t in n ? n[t] : e } const Tye = { created(n, e, t) { $1(n, e, t, null, "created") }, mounted(n, e, t) { $1(n, e, t, null, "mounted") }, beforeUpdate(n, e, t, r) { $1(n, e, t, r, "beforeUpdate") }, updated(n, e, t, r) { $1(n, e, t, r, "updated") } }; function xq(n, e) { switch (n) { case "SELECT": return bq; case "TEXTAREA": return PS; default: switch (e) { case "checkbox": return yq; case "radio": return _q; default: return PS } } } function $1(n, e, t, r, i) { const o = xq(n.tagName, t.props && t.props.type)[i]; o && o(n, e, t, r) } function kye() { PS.getSSRProps = ({ value: n }) => ({ value: n }), _q.getSSRProps = ({ value: n }, e) => { if (e.props && pd(e.props.value, n)) return { checked: !0 } }, yq.getSSRProps = ({ value: n }, e) => { if (Ka(n)) { if (e.props && ik(n, e.props.value) > -1) return { checked: !0 } } else if (lb(n)) { if (e.props && n.has(e.props.value)) return { checked: !0 } } else if (n) return { checked: !0 } }, Tye.getSSRProps = (n, e) => { if (typeof e.type != "string") return; const t = xq(e.type.toUpperCase(), e.props && e.props.type); if (t.getSSRProps) return t.getSSRProps(n, e) } } const Cye = ["ctrl", "shift", "alt", "meta"], Aye = { stop: n => n.stopPropagation(), prevent: n => n.preventDefault(), self: n => n.target !== n.currentTarget, ctrl: n => !n.ctrlKey, shift: n => !n.shiftKey, alt: n => !n.altKey, meta: n => !n.metaKey, left: n => "button" in n && n.button !== 0, middle: n => "button" in n && n.button !== 1, right: n => "button" in n && n.button !== 2, exact: (n, e) => Cye.some(t => n[`${t}Key`] && !e.includes(t)) }, ar = (n, e) => { const t = n._withMods || (n._withMods = {}), r = e.join("."); return t[r] || (t[r] = (i, ...a) => { for (let o = 0; o < e.length; o++) { const s = Aye[e[o]]; if (s && s(i, e)) return } return n(i, ...a) }) }, Eye = { esc: "escape", space: " ", up: "arrow-up", left: "arrow-left", right: "arrow-right", down: "arrow-down", delete: "backspace" }, X4 = (n, e) => { const t = n._withKeys || (n._withKeys = {}), r = e.join("."); return t[r] || (t[r] = i => { if (!("key" in i)) return; const a = Mu(i.key); if (e.some(o => o === a || Eye[o] === a)) return n(i) }) }, Sq = Ih({ patchProp: fye }, Zve); let Wy, J4 = !1; function Tq() { return Wy || (Wy = sve(Sq)) } function kq() { return Wy = J4 ? Wy : lve(Sq), J4 = !0, Wy } const tj = (...n) => { Tq().render(...n) }, Adt = (...n) => { kq().hydrate(...n) }, R0 = (...n) => { const e = Tq().createApp(...n), { mount: t } = e; return e.mount = r => { const i = Aq(r); if (!i) return; const a = e._component; !aq(a) && !a.render && !a.template && (a.template = i.innerHTML), i.nodeType === 1 && (i.textContent = ""); const o = t(i, !1, Cq(i)); return i instanceof Element && (i.removeAttribute("v-cloak"), i.setAttribute("data-v-app", "")), o }, e }, Mye = (...n) => { const e = kq().createApp(...n), { mount: t } = e; return e.mount = r => { const i = Aq(r); if (i) return t(i, !0, Cq(i)) }, e }; function Cq(n) { if (n instanceof SVGElement) return "svg"; if (typeof MathMLElement == "function" && n instanceof MathMLElement) return "mathml" } function Aq(n) { return rg(n) ? document.querySelector(n) : n } let Q4 = !1; const Edt = () => { Q4 || (Q4 = !0, kye(), tye()) }; function jp(n, e, t) {
  let r = t.initialDeps ?? [], i; return () => {
    var a, o, s, l; let c; t.key && ((a = t.debug) != null && a.call(t)) && (c = Date.now()); const u = n(); if (!(u.length !== r.length || u.some((h, p) => r[p] !== h))) return i; r = u; let f; if (t.key && ((o = t.debug) != null && o.call(t)) && (f = Date.now()), i = e(...u), t.key && ((s = t.debug) != null && s.call(t))) {
      const h = Math.round((Date.now() - c) * 100) / 100, p = Math.round((Date.now() - f) * 100) / 100, m = p / 16, g = (y, b) => { for (y = String(y); y.length < b;)y = " " + y; return y }; console.info(`%c ${g(p, 5)} /${g(h, 5)} ms`, `
            font-size: .6rem;
            font-weight: bold;
            color: hsl(${Math.max(0, Math.min(120 - 120 * m, 120))}deg 100% 31%);`, t == null ? void 0 : t.key)
    } return (l = t == null ? void 0 : t.onChange) == null || l.call(t, i), i
  }
} function cE(n, e) { if (n === void 0) throw new Error(`Unexpected undefined${e ? `: ${e}` : ""}`); return n } const Oye = (n, e) => Math.abs(n - e) < 1, Dye = (n, e, t) => { let r; return function (...i) { n.clearTimeout(r), r = n.setTimeout(() => e.apply(this, i), t) } }, jye = n => n, Pye = n => { const e = Math.max(n.startIndex - n.overscan, 0), t = Math.min(n.endIndex + n.overscan, n.count - 1), r = []; for (let i = e; i <= t; i++)r.push(i); return r }, Iye = (n, e) => { const t = n.scrollElement; if (!t) return; const r = n.targetWindow; if (!r) return; const i = o => { const { width: s, height: l } = o; e({ width: Math.round(s), height: Math.round(l) }) }; if (i(t.getBoundingClientRect()), !r.ResizeObserver) return () => { }; const a = new r.ResizeObserver(o => { const s = o[0]; if (s != null && s.borderBoxSize) { const l = s.borderBoxSize[0]; if (l) { i({ width: l.inlineSize, height: l.blockSize }); return } } i(t.getBoundingClientRect()) }); return a.observe(t, { box: "border-box" }), () => { a.unobserve(t) } }, e$ = { passive: !0 }, Lye = typeof window > "u" ? !0 : "onscrollend" in window, Rye = (n, e) => { const t = n.scrollElement; if (!t) return; const r = n.targetWindow; if (!r) return; let i = 0; const a = Lye ? () => { } : Dye(r, () => { e(i, !1) }, n.options.isScrollingResetDelay), o = c => () => { const { horizontal: u, isRtl: d } = n.options; i = u ? t.scrollLeft * (d && -1 || 1) : t.scrollTop, a(), e(i, c) }, s = o(!0), l = o(!1); return l(), t.addEventListener("scroll", s, e$), t.addEventListener("scrollend", l, e$), () => { t.removeEventListener("scroll", s), t.removeEventListener("scrollend", l) } }, Nye = (n, e, t) => { if (e != null && e.borderBoxSize) { const r = e.borderBoxSize[0]; if (r) return Math.round(r[t.options.horizontal ? "inlineSize" : "blockSize"]) } return Math.round(n.getBoundingClientRect()[t.options.horizontal ? "width" : "height"]) }, Bye = (n, { adjustments: e = 0, behavior: t }, r) => { var i, a; const o = n + e; (a = (i = r.scrollElement) == null ? void 0 : i.scrollTo) == null || a.call(i, { [r.options.horizontal ? "left" : "top"]: o, behavior: t }) }; class $ye { constructor(e) { this.unsubs = [], this.scrollElement = null, this.targetWindow = null, this.isScrolling = !1, this.scrollToIndexTimeoutId = null, this.measurementsCache = [], this.itemSizeCache = new Map, this.pendingMeasuredCacheIndexes = [], this.scrollRect = null, this.scrollOffset = null, this.scrollDirection = null, this.scrollAdjustments = 0, this.elementsCache = new Map, this.observer = (() => { let t = null; const r = () => t || (!this.targetWindow || !this.targetWindow.ResizeObserver ? null : t = new this.targetWindow.ResizeObserver(i => { i.forEach(a => { this._measureElement(a.target, a) }) })); return { disconnect: () => { var i; (i = r()) == null || i.disconnect(), t = null }, observe: i => { var a; return (a = r()) == null ? void 0 : a.observe(i, { box: "border-box" }) }, unobserve: i => { var a; return (a = r()) == null ? void 0 : a.unobserve(i) } } })(), this.range = null, this.setOptions = t => { Object.entries(t).forEach(([r, i]) => { typeof i > "u" && delete t[r] }), this.options = { debug: !1, initialOffset: 0, overscan: 1, paddingStart: 0, paddingEnd: 0, scrollPaddingStart: 0, scrollPaddingEnd: 0, horizontal: !1, getItemKey: jye, rangeExtractor: Pye, onChange: () => { }, measureElement: Nye, initialRect: { width: 0, height: 0 }, scrollMargin: 0, gap: 0, indexAttribute: "data-index", initialMeasurementsCache: [], lanes: 1, isScrollingResetDelay: 150, enabled: !0, isRtl: !1, ...t } }, this.notify = t => { var r, i; (i = (r = this.options).onChange) == null || i.call(r, this, t) }, this.maybeNotify = jp(() => (this.calculateRange(), [this.isScrolling, this.range ? this.range.startIndex : null, this.range ? this.range.endIndex : null]), t => { this.notify(t) }, { key: !1, debug: () => this.options.debug, initialDeps: [this.isScrolling, this.range ? this.range.startIndex : null, this.range ? this.range.endIndex : null] }), this.cleanup = () => { this.unsubs.filter(Boolean).forEach(t => t()), this.unsubs = [], this.observer.disconnect(), this.scrollElement = null, this.targetWindow = null }, this._didMount = () => () => { this.cleanup() }, this._willUpdate = () => { var t; const r = this.options.enabled ? this.options.getScrollElement() : null; if (this.scrollElement !== r) { if (this.cleanup(), !r) { this.maybeNotify(); return } this.scrollElement = r, this.scrollElement && "ownerDocument" in this.scrollElement ? this.targetWindow = this.scrollElement.ownerDocument.defaultView : this.targetWindow = ((t = this.scrollElement) == null ? void 0 : t.window) ?? null, this.elementsCache.forEach(i => { this.observer.observe(i) }), this._scrollToOffset(this.getScrollOffset(), { adjustments: void 0, behavior: void 0 }), this.unsubs.push(this.options.observeElementRect(this, i => { this.scrollRect = i, this.maybeNotify() })), this.unsubs.push(this.options.observeElementOffset(this, (i, a) => { this.scrollAdjustments = 0, this.scrollDirection = a ? this.getScrollOffset() < i ? "forward" : "backward" : null, this.scrollOffset = i, this.isScrolling = a, this.maybeNotify() })) } }, this.getSize = () => this.options.enabled ? (this.scrollRect = this.scrollRect ?? this.options.initialRect, this.scrollRect[this.options.horizontal ? "width" : "height"]) : (this.scrollRect = null, 0), this.getScrollOffset = () => this.options.enabled ? (this.scrollOffset = this.scrollOffset ?? (typeof this.options.initialOffset == "function" ? this.options.initialOffset() : this.options.initialOffset), this.scrollOffset) : (this.scrollOffset = null, 0), this.getFurthestMeasurement = (t, r) => { const i = new Map, a = new Map; for (let o = r - 1; o >= 0; o--) { const s = t[o]; if (i.has(s.lane)) continue; const l = a.get(s.lane); if (l == null || s.end > l.end ? a.set(s.lane, s) : s.end < l.end && i.set(s.lane, !0), i.size === this.options.lanes) break } return a.size === this.options.lanes ? Array.from(a.values()).sort((o, s) => o.end === s.end ? o.index - s.index : o.end - s.end)[0] : void 0 }, this.getMeasurementOptions = jp(() => [this.options.count, this.options.paddingStart, this.options.scrollMargin, this.options.getItemKey, this.options.enabled], (t, r, i, a, o) => (this.pendingMeasuredCacheIndexes = [], { count: t, paddingStart: r, scrollMargin: i, getItemKey: a, enabled: o }), { key: !1 }), this.getMeasurements = jp(() => [this.getMeasurementOptions(), this.itemSizeCache], ({ count: t, paddingStart: r, scrollMargin: i, getItemKey: a, enabled: o }, s) => { if (!o) return this.measurementsCache = [], this.itemSizeCache.clear(), []; this.measurementsCache.length === 0 && (this.measurementsCache = this.options.initialMeasurementsCache, this.measurementsCache.forEach(u => { this.itemSizeCache.set(u.key, u.size) })); const l = this.pendingMeasuredCacheIndexes.length > 0 ? Math.min(...this.pendingMeasuredCacheIndexes) : 0; this.pendingMeasuredCacheIndexes = []; const c = this.measurementsCache.slice(0, l); for (let u = l; u < t; u++) { const d = a(u), f = this.options.lanes === 1 ? c[u - 1] : this.getFurthestMeasurement(c, u), h = f ? f.end + this.options.gap : r + i, p = s.get(d), m = typeof p == "number" ? p : this.options.estimateSize(u), g = h + m, y = f ? f.lane : u % this.options.lanes; c[u] = { index: u, start: h, size: m, end: g, key: d, lane: y } } return this.measurementsCache = c, c }, { key: !1, debug: () => this.options.debug }), this.calculateRange = jp(() => [this.getMeasurements(), this.getSize(), this.getScrollOffset()], (t, r, i) => this.range = t.length > 0 && r > 0 ? Fye({ measurements: t, outerSize: r, scrollOffset: i }) : null, { key: !1, debug: () => this.options.debug }), this.getIndexes = jp(() => [this.options.rangeExtractor, this.calculateRange(), this.options.overscan, this.options.count], (t, r, i, a) => r === null ? [] : t({ startIndex: r.startIndex, endIndex: r.endIndex, overscan: i, count: a }), { key: !1, debug: () => this.options.debug }), this.indexFromElement = t => { const r = this.options.indexAttribute, i = t.getAttribute(r); return i ? parseInt(i, 10) : (console.warn(`Missing attribute name '${r}={index}' on measured element.`), -1) }, this._measureElement = (t, r) => { const i = this.indexFromElement(t), a = this.measurementsCache[i]; if (!a) return; const o = a.key, s = this.elementsCache.get(o); s !== t && (s && this.observer.unobserve(s), this.observer.observe(t), this.elementsCache.set(o, t)), t.isConnected && this.resizeItem(i, this.options.measureElement(t, r, this)) }, this.resizeItem = (t, r) => { const i = this.measurementsCache[t]; if (!i) return; const a = this.itemSizeCache.get(i.key) ?? i.size, o = r - a; o !== 0 && ((this.shouldAdjustScrollPositionOnItemSizeChange !== void 0 ? this.shouldAdjustScrollPositionOnItemSizeChange(i, o, this) : i.start < this.getScrollOffset() + this.scrollAdjustments) && this._scrollToOffset(this.getScrollOffset(), { adjustments: this.scrollAdjustments += o, behavior: void 0 }), this.pendingMeasuredCacheIndexes.push(i.index), this.itemSizeCache = new Map(this.itemSizeCache.set(i.key, r)), this.notify(!1)) }, this.measureElement = t => { if (!t) { this.elementsCache.forEach((r, i) => { r.isConnected || (this.observer.unobserve(r), this.elementsCache.delete(i)) }); return } this._measureElement(t, void 0) }, this.getVirtualItems = jp(() => [this.getIndexes(), this.getMeasurements()], (t, r) => { const i = []; for (let a = 0, o = t.length; a < o; a++) { const s = t[a], l = r[s]; i.push(l) } return i }, { key: !1, debug: () => this.options.debug }), this.getVirtualItemForOffset = t => { const r = this.getMeasurements(); if (r.length !== 0) return cE(r[Eq(0, r.length - 1, i => cE(r[i]).start, t)]) }, this.getOffsetForAlignment = (t, r) => { const i = this.getSize(), a = this.getScrollOffset(); r === "auto" && (t <= a ? r = "start" : t >= a + i ? r = "end" : r = "start"), r === "start" ? t = t : r === "end" ? t = t - i : r === "center" && (t = t - i / 2); const o = this.options.horizontal ? "scrollWidth" : "scrollHeight", l = (this.scrollElement ? "document" in this.scrollElement ? this.scrollElement.document.documentElement[o] : this.scrollElement[o] : 0) - i; return Math.max(Math.min(l, t), 0) }, this.getOffsetForIndex = (t, r = "auto") => { t = Math.max(0, Math.min(t, this.options.count - 1)); const i = this.measurementsCache[t]; if (!i) return; const a = this.getSize(), o = this.getScrollOffset(); if (r === "auto") if (i.end >= o + a - this.options.scrollPaddingEnd) r = "end"; else if (i.start <= o + this.options.scrollPaddingStart) r = "start"; else return [o, r]; const s = r === "end" ? i.end + this.options.scrollPaddingEnd : i.start - this.options.scrollPaddingStart; return [this.getOffsetForAlignment(s, r), r] }, this.isDynamicMode = () => this.elementsCache.size > 0, this.cancelScrollToIndex = () => { this.scrollToIndexTimeoutId !== null && this.targetWindow && (this.targetWindow.clearTimeout(this.scrollToIndexTimeoutId), this.scrollToIndexTimeoutId = null) }, this.scrollToOffset = (t, { align: r = "start", behavior: i } = {}) => { this.cancelScrollToIndex(), i === "smooth" && this.isDynamicMode() && console.warn("The `smooth` scroll behavior is not fully supported with dynamic size."), this._scrollToOffset(this.getOffsetForAlignment(t, r), { adjustments: void 0, behavior: i }) }, this.scrollToIndex = (t, { align: r = "auto", behavior: i } = {}) => { t = Math.max(0, Math.min(t, this.options.count - 1)), this.cancelScrollToIndex(), i === "smooth" && this.isDynamicMode() && console.warn("The `smooth` scroll behavior is not fully supported with dynamic size."); const a = this.getOffsetForIndex(t, r); if (!a) return; const [o, s] = a; this._scrollToOffset(o, { adjustments: void 0, behavior: i }), i !== "smooth" && this.isDynamicMode() && this.targetWindow && (this.scrollToIndexTimeoutId = this.targetWindow.setTimeout(() => { if (this.scrollToIndexTimeoutId = null, this.elementsCache.has(this.options.getItemKey(t))) { const [c] = cE(this.getOffsetForIndex(t, s)); Oye(c, this.getScrollOffset()) || this.scrollToIndex(t, { align: s, behavior: i }) } else this.scrollToIndex(t, { align: s, behavior: i }) })) }, this.scrollBy = (t, { behavior: r } = {}) => { this.cancelScrollToIndex(), r === "smooth" && this.isDynamicMode() && console.warn("The `smooth` scroll behavior is not fully supported with dynamic size."), this._scrollToOffset(this.getScrollOffset() + t, { adjustments: void 0, behavior: r }) }, this.getTotalSize = () => { var t; const r = this.getMeasurements(); let i; return r.length === 0 ? i = this.options.paddingStart : i = this.options.lanes === 1 ? ((t = r[r.length - 1]) == null ? void 0 : t.end) ?? 0 : Math.max(...r.slice(-this.options.lanes).map(a => a.end)), Math.max(i - this.options.scrollMargin + this.options.paddingEnd, 0) }, this._scrollToOffset = (t, { adjustments: r, behavior: i }) => { this.options.scrollToFn(t, { behavior: i, adjustments: r }, this) }, this.measure = () => { this.itemSizeCache = new Map, this.notify(!1) }, this.setOptions(e) } } const Eq = (n, e, t, r) => { for (; n <= e;) { const i = (n + e) / 2 | 0, a = t(i); if (a < r) n = i + 1; else if (a > r) e = i - 1; else return i } return n > 0 ? n - 1 : 0 }; function Fye({ measurements: n, outerSize: e, scrollOffset: t }) { const r = n.length - 1, a = Eq(0, r, s => n[s].start, t); let o = a; for (; o < r && n[o].end < t + e;)o++; return { startIndex: a, endIndex: o } } function zye(n) { const e = new $ye(X(n)), t = Fa(e), r = e._didMount(); return Ct(() => X(n).getScrollElement(), i => { i && e._willUpdate() }, { immediate: !0 }), Ct(() => X(n), i => { e.setOptions({ ...i, onChange: (a, o) => { var s; p4(t), (s = i.onChange) == null || s.call(i, a, o) } }), e._willUpdate(), p4(t) }, { immediate: !0 }), eb(r), t } function Vye(n) { return zye(ne(() => ({ observeElementRect: Iye, observeElementOffset: Rye, scrollToFn: Bye, ...X(n) }))) } function Hye(n, e, t) { let r = he(t == null ? void 0 : t.value), i = ne(() => n.value !== void 0); return [ne(() => i.value ? n.value : r.value), function (a) { return i.value || (r.value = a), e == null ? void 0 : e(a) }] } function KL(n) { typeof queueMicrotask == "function" ? queueMicrotask(n) : Promise.resolve().then(n).catch(e => setTimeout(() => { throw e })) } function gd() { let n = [], e = { addEventListener(t, r, i, a) { return t.addEventListener(r, i, a), e.add(() => t.removeEventListener(r, i, a)) }, requestAnimationFrame(...t) { let r = requestAnimationFrame(...t); e.add(() => cancelAnimationFrame(r)) }, nextFrame(...t) { e.requestAnimationFrame(() => { e.requestAnimationFrame(...t) }) }, setTimeout(...t) { let r = setTimeout(...t); e.add(() => clearTimeout(r)) }, microTask(...t) { let r = { current: !0 }; return KL(() => { r.current && t[0]() }), e.add(() => { r.current = !1 }) }, style(t, r, i) { let a = t.style.getPropertyValue(r); return Object.assign(t.style, { [r]: i }), this.add(() => { Object.assign(t.style, { [r]: a }) }) }, group(t) { let r = gd(); return t(r), this.add(() => r.dispose()) }, add(t) { return n.push(t), () => { let r = n.indexOf(t); if (r >= 0) for (let i of n.splice(r, 1)) i() } }, dispose() { for (let t of n.splice(0)) t() } }; return e } function Uye() { let n = gd(); return cr(() => n.dispose()), n } function Gye() { let n = Uye(); return e => { n.dispose(), n.nextFrame(e) } } var t$; let Wye = Symbol("headlessui.useid"), Kye = 0; const $d = (t$ = RD) != null ? t$ : function () { return zn(Wye, () => `${++Kye}`)() }; function Ut(n) { var e; if (n == null || n.value == null) return null; let t = (e = n.value.$el) != null ? e : n.value; return t instanceof Node ? t : null } function Mi(n, e, ...t) { if (n in e) { let i = e[n]; return typeof i == "function" ? i(...t) : i } let r = new Error(`Tried to handle "${n}" but there is no handler defined. Only defined handlers are: ${Object.keys(e).map(i => `"${i}"`).join(", ")}.`); throw Error.captureStackTrace && Error.captureStackTrace(r, Mi), r } var qye = Object.defineProperty, Yye = (n, e, t) => e in n ? qye(n, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : n[e] = t, n$ = (n, e, t) => (Yye(n, typeof e != "symbol" ? e + "" : e, t), t); let Zye = class { constructor() { n$(this, "current", this.detect()), n$(this, "currentId", 0) } set(e) { this.current !== e && (this.currentId = 0, this.current = e) } reset() { this.set(this.detect()) } nextId() { return ++this.currentId } get isServer() { return this.current === "server" } get isClient() { return this.current === "client" } detect() { return typeof window > "u" || typeof document > "u" ? "server" : "client" } }, cb = new Zye; function Fc(n) { if (cb.isServer) return null; if (n instanceof Node) return n.ownerDocument; if (n != null && n.hasOwnProperty("value")) { let e = Ut(n); if (e) return e.ownerDocument } return document } let nj = ["[contentEditable=true]", "[tabindex]", "a[href]", "area[href]", "button:not([disabled])", "iframe", "input:not([disabled])", "select:not([disabled])", "textarea:not([disabled])"].map(n => `${n}:not([tabindex='-1'])`).join(","); var Ou = (n => (n[n.First = 1] = "First", n[n.Previous = 2] = "Previous", n[n.Next = 4] = "Next", n[n.Last = 8] = "Last", n[n.WrapAround = 16] = "WrapAround", n[n.NoScroll = 32] = "NoScroll", n))(Ou || {}), Mq = (n => (n[n.Error = 0] = "Error", n[n.Overflow = 1] = "Overflow", n[n.Success = 2] = "Success", n[n.Underflow = 3] = "Underflow", n))(Mq || {}), Xye = (n => (n[n.Previous = -1] = "Previous", n[n.Next = 1] = "Next", n))(Xye || {}); function Oq(n = document.body) { return n == null ? [] : Array.from(n.querySelectorAll(nj)).sort((e, t) => Math.sign((e.tabIndex || Number.MAX_SAFE_INTEGER) - (t.tabIndex || Number.MAX_SAFE_INTEGER))) } var Dq = (n => (n[n.Strict = 0] = "Strict", n[n.Loose = 1] = "Loose", n))(Dq || {}); function jq(n, e = 0) { var t; return n === ((t = Fc(n)) == null ? void 0 : t.body) ? !1 : Mi(e, { 0() { return n.matches(nj) }, 1() { let r = n; for (; r !== null;) { if (r.matches(nj)) return !0; r = r.parentElement } return !1 } }) } function Odt(n) { let e = Fc(n); Pr(() => { e && !jq(e.activeElement, 0) && Qu(n) }) } var Jye = (n => (n[n.Keyboard = 0] = "Keyboard", n[n.Mouse = 1] = "Mouse", n))(Jye || {}); typeof window < "u" && typeof document < "u" && (document.addEventListener("keydown", n => { n.metaKey || n.altKey || n.ctrlKey || (document.documentElement.dataset.headlessuiFocusVisible = "") }, !0), document.addEventListener("click", n => { n.detail === 1 ? delete document.documentElement.dataset.headlessuiFocusVisible : n.detail === 0 && (document.documentElement.dataset.headlessuiFocusVisible = "") }, !0)); function Qu(n) { n == null || n.focus({ preventScroll: !0 }) } let Qye = ["textarea", "input"].join(","); function e0e(n) { var e, t; return (t = (e = n == null ? void 0 : n.matches) == null ? void 0 : e.call(n, Qye)) != null ? t : !1 } function Pq(n, e = t => t) { return n.slice().sort((t, r) => { let i = e(t), a = e(r); if (i === null || a === null) return 0; let o = i.compareDocumentPosition(a); return o & Node.DOCUMENT_POSITION_FOLLOWING ? -1 : o & Node.DOCUMENT_POSITION_PRECEDING ? 1 : 0 }) } function Ddt(n, e) { return Ky(Oq(), e, { relativeTo: n }) } function Ky(n, e, { sorted: t = !0, relativeTo: r = null, skipElements: i = [] } = {}) { var a; let o = (a = Array.isArray(n) ? n.length > 0 ? n[0].ownerDocument : document : n == null ? void 0 : n.ownerDocument) != null ? a : document, s = Array.isArray(n) ? t ? Pq(n) : n : Oq(n); i.length > 0 && s.length > 1 && (s = s.filter(p => !i.includes(p))), r = r ?? o.activeElement; let l = (() => { if (e & 5) return 1; if (e & 10) return -1; throw new Error("Missing Focus.First, Focus.Previous, Focus.Next or Focus.Last") })(), c = (() => { if (e & 1) return 0; if (e & 2) return Math.max(0, s.indexOf(r)) - 1; if (e & 4) return Math.max(0, s.indexOf(r)) + 1; if (e & 8) return s.length - 1; throw new Error("Missing Focus.First, Focus.Previous, Focus.Next or Focus.Last") })(), u = e & 32 ? { preventScroll: !0 } : {}, d = 0, f = s.length, h; do { if (d >= f || d + f <= 0) return 0; let p = c + d; if (e & 16) p = (p + f) % f; else { if (p < 0) return 3; if (p >= f) return 1 } h = s[p], h == null || h.focus(u), d += l } while (h !== o.activeElement); return e & 6 && e0e(h) && h.select(), 2 } function Iq() { return /iPhone/gi.test(window.navigator.platform) || /Mac/gi.test(window.navigator.platform) && window.navigator.maxTouchPoints > 0 } function t0e() { return /Android/gi.test(window.navigator.userAgent) } function Lq() { return Iq() || t0e() } function F1(n, e, t) { cb.isServer || Bn(r => { document.addEventListener(n, e, t), r(() => document.removeEventListener(n, e, t)) }) } function Rq(n, e, t) { cb.isServer || Bn(r => { window.addEventListener(n, e, t), r(() => window.removeEventListener(n, e, t)) }) } function Nq(n, e, t = ne(() => !0)) { function r(a, o) { if (!t.value || a.defaultPrevented) return; let s = o(a); if (s === null || !s.getRootNode().contains(s)) return; let l = function c(u) { return typeof u == "function" ? c(u()) : Array.isArray(u) || u instanceof Set ? u : [u] }(n); for (let c of l) { if (c === null) continue; let u = c instanceof HTMLElement ? c : Ut(c); if (u != null && u.contains(s) || a.composed && a.composedPath().includes(u)) return } return !jq(s, Dq.Loose) && s.tabIndex !== -1 && a.preventDefault(), e(a, s) } let i = he(null); F1("pointerdown", a => { var o, s; t.value && (i.value = ((s = (o = a.composedPath) == null ? void 0 : o.call(a)) == null ? void 0 : s[0]) || a.target) }, !0), F1("mousedown", a => { var o, s; t.value && (i.value = ((s = (o = a.composedPath) == null ? void 0 : o.call(a)) == null ? void 0 : s[0]) || a.target) }, !0), F1("click", a => { Lq() || i.value && (r(a, () => i.value), i.value = null) }, !0), F1("touchend", a => r(a, () => a.target instanceof HTMLElement ? a.target : null), !0), Rq("blur", a => r(a, () => window.document.activeElement instanceof HTMLIFrameElement ? window.document.activeElement : null), !0) } function r$(n) { return [n.screenX, n.screenY] } function n0e() { let n = he([-1, -1]); return { wasMoved(e) { let t = r$(e); return n.value[0] === t[0] && n.value[1] === t[1] ? !1 : (n.value = t, !0) }, update(e) { n.value = r$(e) } } } function r0e({ container: n, accept: e, walk: t, enabled: r }) { Bn(() => { let i = n.value; if (!i || r !== void 0 && !r.value) return; let a = Fc(n); if (!a) return; let o = Object.assign(l => e(l), { acceptNode: e }), s = a.createTreeWalker(i, NodeFilter.SHOW_ELEMENT, o, !1); for (; s.nextNode();)t(s.currentNode) }) } var vd = (n => (n[n.None = 0] = "None", n[n.RenderStrategy = 1] = "RenderStrategy", n[n.Static = 2] = "Static", n))(vd || {}), Ru = (n => (n[n.Unmount = 0] = "Unmount", n[n.Hidden = 1] = "Hidden", n))(Ru || {}); function oa({ visible: n = !0, features: e = 0, ourProps: t, theirProps: r, ...i }) { var a; let o = $q(r, t), s = Object.assign(i, { props: o }); if (n || e & 2 && o.static) return uE(s); if (e & 1) { let l = (a = o.unmount) == null || a ? 0 : 1; return Mi(l, { 0() { return null }, 1() { return uE({ ...i, props: { ...o, hidden: !0, style: { display: "none" } } }) } }) } return uE(s) } function uE({ props: n, attrs: e, slots: t, slot: r, name: i }) {
  var a, o; let { as: s, ...l } = ub(n, ["unmount", "static"]), c = (a = t.default) == null ? void 0 : a.call(t, r), u = {}; if (r) { let d = !1, f = []; for (let [h, p] of Object.entries(r)) typeof p == "boolean" && (d = !0), p === !0 && f.push(h); d && (u["data-headlessui-state"] = f.join(" ")) } if (s === "template") {
    if (c = Bq(c ?? []), Object.keys(l).length > 0 || Object.keys(e).length > 0) {
      let [d, ...f] = c ?? []; if (!a0e(d) || f.length > 0) throw new Error(['Passing props on "template"!', "", `The current component <${i} /> is rendering a "template".`, "However we need to passthrough the following props:", Object.keys(l).concat(Object.keys(e)).map(m => m.trim()).filter((m, g, y) => y.indexOf(m) === g).sort((m, g) => m.localeCompare(g)).map(m => `  - ${m}`).join(`
`), "", "You can apply a few solutions:", ['Add an `as="..."` prop, to ensure that we render an actual element instead of a "template".', "Render a single element as the child so that we can forward the props onto that element."].map(m => `  - ${m}`).join(`
`)].join(`
`)); let h = $q((o = d.props) != null ? o : {}, l, u), p = $o(d, h, !0); for (let m in h) m.startsWith("on") && (p.props || (p.props = {}), p.props[m] = h[m]); return p
    } return Array.isArray(c) && c.length === 1 ? c[0] : c
  } return Gt(s, Object.assign({}, l, u), { default: () => c })
} function Bq(n) { return n.flatMap(e => e.type === Qt ? Bq(e.children) : [e]) } function $q(...n) { if (n.length === 0) return {}; if (n.length === 1) return n[0]; let e = {}, t = {}; for (let r of n) for (let i in r) i.startsWith("on") && typeof r[i] == "function" ? (t[i] != null || (t[i] = []), t[i].push(r[i])) : e[i] = r[i]; if (e.disabled || e["aria-disabled"]) return Object.assign(e, Object.fromEntries(Object.keys(t).map(r => [r, void 0]))); for (let r in t) Object.assign(e, { [r](i, ...a) { let o = t[r]; for (let s of o) { if (i instanceof Event && i.defaultPrevented) return; s(i, ...a) } } }); return e } function i0e(n) { let e = Object.assign({}, n); for (let t in e) e[t] === void 0 && delete e[t]; return e } function ub(n, e = []) { let t = Object.assign({}, n); for (let r of e) r in t && delete t[r]; return t } function a0e(n) { return n == null ? !1 : typeof n.type == "string" || typeof n.type == "object" || typeof n.type == "function" } var N0 = (n => (n[n.None = 1] = "None", n[n.Focusable = 2] = "Focusable", n[n.Hidden = 4] = "Hidden", n))(N0 || {}); let IS = We({ name: "Hidden", props: { as: { type: [Object, String], default: "div" }, features: { type: Number, default: 1 } }, setup(n, { slots: e, attrs: t }) { return () => { var r; let { features: i, ...a } = n, o = { "aria-hidden": (i & 2) === 2 ? !0 : (r = a["aria-hidden"]) != null ? r : void 0, hidden: (i & 4) === 4 ? !0 : void 0, style: { position: "fixed", top: 1, left: 1, width: 1, height: 0, padding: 0, margin: -1, overflow: "hidden", clip: "rect(0, 0, 0, 0)", whiteSpace: "nowrap", borderWidth: "0", ...(i & 4) === 4 && (i & 2) !== 2 && { display: "none" } } }; return oa({ ourProps: o, theirProps: a, slot: {}, attrs: t, slots: e, name: "Hidden" }) } } }), Fq = Symbol("Context"); var li = (n => (n[n.Open = 1] = "Open", n[n.Closed = 2] = "Closed", n[n.Closing = 4] = "Closing", n[n.Opening = 8] = "Opening", n))(li || {}); function o0e() { return ak() !== null } function ak() { return zn(Fq, null) } function zq(n) { Or(Fq, n) } var ts = (n => (n.Space = " ", n.Enter = "Enter", n.Escape = "Escape", n.Backspace = "Backspace", n.Delete = "Delete", n.ArrowLeft = "ArrowLeft", n.ArrowUp = "ArrowUp", n.ArrowRight = "ArrowRight", n.ArrowDown = "ArrowDown", n.Home = "Home", n.End = "End", n.PageUp = "PageUp", n.PageDown = "PageDown", n.Tab = "Tab", n))(ts || {}), Vq = (n => (n[n.Left = 0] = "Left", n[n.Right = 2] = "Right", n))(Vq || {}); function s0e(n) { function e() { document.readyState !== "loading" && (n(), document.removeEventListener("DOMContentLoaded", e)) } typeof window < "u" && typeof document < "u" && (document.addEventListener("DOMContentLoaded", e), e()) } let dc = []; s0e(() => { function n(e) { e.target instanceof HTMLElement && e.target !== document.body && dc[0] !== e.target && (dc.unshift(e.target), dc = dc.filter(t => t != null && t.isConnected), dc.splice(10)) } window.addEventListener("click", n, { capture: !0 }), window.addEventListener("mousedown", n, { capture: !0 }), window.addEventListener("focus", n, { capture: !0 }), document.body.addEventListener("click", n, { capture: !0 }), document.body.addEventListener("mousedown", n, { capture: !0 }), document.body.addEventListener("focus", n, { capture: !0 }) }); function l0e(n) { throw new Error("Unexpected object: " + n) } var Ti = (n => (n[n.First = 0] = "First", n[n.Previous = 1] = "Previous", n[n.Next = 2] = "Next", n[n.Last = 3] = "Last", n[n.Specific = 4] = "Specific", n[n.Nothing = 5] = "Nothing", n))(Ti || {}); function i$(n, e) { let t = e.resolveItems(); if (t.length <= 0) return null; let r = e.resolveActiveIndex(), i = r ?? -1; switch (n.focus) { case 0: { for (let a = 0; a < t.length; ++a)if (!e.resolveDisabled(t[a], a, t)) return a; return r } case 1: { i === -1 && (i = t.length); for (let a = i - 1; a >= 0; --a)if (!e.resolveDisabled(t[a], a, t)) return a; return r } case 2: { for (let a = i + 1; a < t.length; ++a)if (!e.resolveDisabled(t[a], a, t)) return a; return r } case 3: { for (let a = t.length - 1; a >= 0; --a)if (!e.resolveDisabled(t[a], a, t)) return a; return r } case 4: { for (let a = 0; a < t.length; ++a)if (e.resolveId(t[a], a, t) === n.id) return a; return r } case 5: return null; default: l0e(n) } } function Hq(n = {}, e = null, t = []) { for (let [r, i] of Object.entries(n)) Gq(t, Uq(e, r), i); return t } function Uq(n, e) { return n ? n + "[" + e + "]" : e } function Gq(n, e, t) { if (Array.isArray(t)) for (let [r, i] of t.entries()) Gq(n, Uq(e, r.toString()), i); else t instanceof Date ? n.push([e, t.toISOString()]) : typeof t == "boolean" ? n.push([e, t ? "1" : "0"]) : typeof t == "string" ? n.push([e, t]) : typeof t == "number" ? n.push([e, `${t}`]) : t == null ? n.push([e, ""]) : Hq(t, e, n) } function jdt(n) { var e, t; let r = (e = n == null ? void 0 : n.form) != null ? e : n.closest("form"); if (r) { for (let i of r.elements) if (i !== n && (i.tagName === "INPUT" && i.type === "submit" || i.tagName === "BUTTON" && i.type === "submit" || i.nodeName === "INPUT" && i.type === "image")) { i.click(); return } (t = r.requestSubmit) == null || t.call(r) } } function c0e(n, e) { return n === e } var u0e = (n => (n[n.Open = 0] = "Open", n[n.Closed = 1] = "Closed", n))(u0e || {}), d0e = (n => (n[n.Single = 0] = "Single", n[n.Multi = 1] = "Multi", n))(d0e || {}), f0e = (n => (n[n.Pointer = 0] = "Pointer", n[n.Focus = 1] = "Focus", n[n.Other = 2] = "Other", n))(f0e || {}); let Wq = Symbol("ComboboxContext"); function db(n) { let e = zn(Wq, null); if (e === null) { let t = new Error(`<${n} /> is missing a parent <Combobox /> component.`); throw Error.captureStackTrace && Error.captureStackTrace(t, db), t } return e } let Kq = Symbol("VirtualContext"), h0e = We({ name: "VirtualProvider", setup(n, { slots: e }) { let t = db("VirtualProvider"), r = ne(() => { let s = Ut(t.optionsRef); if (!s) return { start: 0, end: 0 }; let l = window.getComputedStyle(s); return { start: parseFloat(l.paddingBlockStart || l.paddingTop), end: parseFloat(l.paddingBlockEnd || l.paddingBottom) } }), i = Vye(ne(() => ({ scrollPaddingStart: r.value.start, scrollPaddingEnd: r.value.end, count: t.virtual.value.options.length, estimateSize() { return 40 }, getScrollElement() { return Ut(t.optionsRef) }, overscan: 12 }))), a = ne(() => { var s; return (s = t.virtual.value) == null ? void 0 : s.options }), o = he(0); return Ct([a], () => { o.value += 1 }), Or(Kq, t.virtual.value ? i : null), () => [Gt("div", { style: { position: "relative", width: "100%", height: `${i.value.getTotalSize()}px` }, ref: s => { if (s) { if (typeof process < "u" && {}.JEST_WORKER_ID !== void 0 || t.activationTrigger.value === 0) return; t.activeOptionIndex.value !== null && t.virtual.value.options.length > t.activeOptionIndex.value && i.value.scrollToIndex(t.activeOptionIndex.value) } } }, i.value.getVirtualItems().map(s => $o(e.default({ option: t.virtual.value.options[s.index], open: t.comboboxState.value === 0 })[0], { key: `${o.value}-${s.index}`, "data-index": s.index, "aria-setsize": t.virtual.value.options.length, "aria-posinset": s.index + 1, style: { position: "absolute", top: 0, left: 0, transform: `translateY(${s.start}px)`, overflowAnchor: "none" } })))] } }), p0e = We({ name: "Combobox", emits: { "update:modelValue": n => !0 }, props: { as: { type: [Object, String], default: "template" }, disabled: { type: [Boolean], default: !1 }, by: { type: [String, Function], nullable: !0, default: null }, modelValue: { type: [Object, String, Number, Boolean], default: void 0 }, defaultValue: { type: [Object, String, Number, Boolean], default: void 0 }, form: { type: String, optional: !0 }, name: { type: String, optional: !0 }, nullable: { type: Boolean, default: !1 }, multiple: { type: [Boolean], default: !1 }, immediate: { type: [Boolean], default: !1 }, virtual: { type: Object, default: null } }, inheritAttrs: !1, setup(n, { slots: e, attrs: t, emit: r }) { let i = he(1), a = he(null), o = he(null), s = he(null), l = he(null), c = he({ static: !1, hold: !1 }), u = he([]), d = he(null), f = he(2), h = he(!1); function p(E = O => O) { let O = d.value !== null ? u.value[d.value] : null, j = E(u.value.slice()), I = j.length > 0 && j[0].dataRef.order.value !== null ? j.sort((R, D) => R.dataRef.order.value - D.dataRef.order.value) : Pq(j, R => Ut(R.dataRef.domRef)), L = O ? I.indexOf(O) : null; return L === -1 && (L = null), { options: I, activeOptionIndex: L } } let m = ne(() => n.multiple ? 1 : 0), g = ne(() => n.nullable), [y, b] = Hye(ne(() => n.modelValue), E => r("update:modelValue", E), ne(() => n.defaultValue)), w = ne(() => y.value === void 0 ? Mi(m.value, { 1: [], 0: void 0 }) : y.value), v = null, S = null; function x(E) { return Mi(m.value, { 0() { return b == null ? void 0 : b(E) }, 1: () => { let O = Vt(A.value.value).slice(), j = Vt(E), I = O.findIndex(L => A.compare(j, Vt(L))); return I === -1 ? O.push(j) : O.splice(I, 1), b == null ? void 0 : b(O) } }) } let k = ne(() => { }); Ct([k], ([E], [O]) => { if (A.virtual.value && E && O && d.value !== null) { let j = E.indexOf(O[d.value]); j !== -1 ? d.value = j : d.value = null } }); let A = { comboboxState: i, value: w, mode: m, compare(E, O) { if (typeof n.by == "string") { let j = n.by; return (E == null ? void 0 : E[j]) === (O == null ? void 0 : O[j]) } return n.by === null ? c0e(E, O) : n.by(E, O) }, calculateIndex(E) { return A.virtual.value ? n.by === null ? A.virtual.value.options.indexOf(E) : A.virtual.value.options.findIndex(O => A.compare(O, E)) : u.value.findIndex(O => A.compare(O.dataRef.value, E)) }, defaultValue: ne(() => n.defaultValue), nullable: g, immediate: ne(() => !1), virtual: ne(() => null), inputRef: o, labelRef: a, buttonRef: s, optionsRef: l, disabled: ne(() => n.disabled), options: u, change(E) { b(E) }, activeOptionIndex: ne(() => { if (h.value && d.value === null && (A.virtual.value ? A.virtual.value.options.length > 0 : u.value.length > 0)) { if (A.virtual.value) { let O = A.virtual.value.options.findIndex(j => { var I; return !((I = A.virtual.value) != null && I.disabled(j)) }); if (O !== -1) return O } let E = u.value.findIndex(O => !O.dataRef.disabled); if (E !== -1) return E } return d.value }), activationTrigger: f, optionsPropsRef: c, closeCombobox() { h.value = !1, !n.disabled && i.value !== 1 && (i.value = 1, d.value = null) }, openCombobox() { if (h.value = !0, !n.disabled && i.value !== 0) { if (A.value.value) { let E = A.calculateIndex(A.value.value); E !== -1 && (d.value = E) } i.value = 0 } }, setActivationTrigger(E) { f.value = E }, goToOption(E, O, j) { h.value = !1, v !== null && cancelAnimationFrame(v), v = requestAnimationFrame(() => { if (n.disabled || l.value && !c.value.static && i.value === 1) return; if (A.virtual.value) { d.value = E === Ti.Specific ? O : i$({ focus: E }, { resolveItems: () => A.virtual.value.options, resolveActiveIndex: () => { var R, D; return (D = (R = A.activeOptionIndex.value) != null ? R : A.virtual.value.options.findIndex(P => { var B; return !((B = A.virtual.value) != null && B.disabled(P)) })) != null ? D : null }, resolveDisabled: R => A.virtual.value.disabled(R), resolveId() { throw new Error("Function not implemented.") } }), f.value = j ?? 2; return } let I = p(); if (I.activeOptionIndex === null) { let R = I.options.findIndex(D => !D.dataRef.disabled); R !== -1 && (I.activeOptionIndex = R) } let L = E === Ti.Specific ? O : i$({ focus: E }, { resolveItems: () => I.options, resolveActiveIndex: () => I.activeOptionIndex, resolveId: R => R.id, resolveDisabled: R => R.dataRef.disabled }); d.value = L, f.value = j ?? 2, u.value = I.options }) }, selectOption(E) { let O = u.value.find(I => I.id === E); if (!O) return; let { dataRef: j } = O; x(j.value) }, selectActiveOption() { if (A.activeOptionIndex.value !== null) { if (A.virtual.value) x(A.virtual.value.options[A.activeOptionIndex.value]); else { let { dataRef: E } = u.value[A.activeOptionIndex.value]; x(E.value) } A.goToOption(Ti.Specific, A.activeOptionIndex.value) } }, registerOption(E, O) { let j = vr({ id: E, dataRef: O }); if (A.virtual.value) { u.value.push(j); return } S && cancelAnimationFrame(S); let I = p(L => (L.push(j), L)); d.value === null && A.isSelected(O.value.value) && (I.activeOptionIndex = I.options.indexOf(j)), u.value = I.options, d.value = I.activeOptionIndex, f.value = 2, I.options.some(L => !Ut(L.dataRef.domRef)) && (S = requestAnimationFrame(() => { let L = p(); u.value = L.options, d.value = L.activeOptionIndex })) }, unregisterOption(E, O) { if (v !== null && cancelAnimationFrame(v), O && (h.value = !0), A.virtual.value) { u.value = u.value.filter(I => I.id !== E); return } let j = p(I => { let L = I.findIndex(R => R.id === E); return L !== -1 && I.splice(L, 1), I }); u.value = j.options, d.value = j.activeOptionIndex, f.value = 2 }, isSelected(E) { return Mi(m.value, { 0: () => A.compare(Vt(A.value.value), Vt(E)), 1: () => Vt(A.value.value).some(O => A.compare(Vt(O), Vt(E))) }) }, isActive(E) { return d.value === A.calculateIndex(E) } }; Nq([o, s, l], () => A.closeCombobox(), ne(() => i.value === 0)), Or(Wq, A), zq(ne(() => Mi(i.value, { 0: li.Open, 1: li.Closed }))); let C = ne(() => { var E; return (E = Ut(o)) == null ? void 0 : E.closest("form") }); return un(() => { Ct([C], () => { if (!C.value || n.defaultValue === void 0) return; function E() { A.change(n.defaultValue) } return C.value.addEventListener("reset", E), () => { var O; (O = C.value) == null || O.removeEventListener("reset", E) } }, { immediate: !0 }) }), () => { var E, O, j; let { name: I, disabled: L, form: R, ...D } = n, P = { open: i.value === 0, disabled: L, activeIndex: A.activeOptionIndex.value, activeOption: A.activeOptionIndex.value === null ? null : A.virtual.value ? A.virtual.value.options[(E = A.activeOptionIndex.value) != null ? E : 0] : (j = (O = A.options.value[A.activeOptionIndex.value]) == null ? void 0 : O.dataRef.value) != null ? j : null, value: w.value }; return Gt(Qt, [...I != null && w.value != null ? Hq({ [I]: w.value }).map(([B, F]) => Gt(IS, i0e({ features: N0.Hidden, key: B, as: "input", type: "hidden", hidden: !0, readOnly: !0, form: R, disabled: L, name: B, value: F }))) : [], oa({ theirProps: { ...t, ...ub(D, ["by", "defaultValue", "immediate", "modelValue", "multiple", "nullable", "onUpdate:modelValue", "virtual"]) }, ourProps: {}, slot: P, slots: e, attrs: t, name: "Combobox" })]) } } }), m0e = We({ name: "ComboboxInput", props: { as: { type: [Object, String], default: "input" }, static: { type: Boolean, default: !1 }, unmount: { type: Boolean, default: !0 }, displayValue: { type: Function }, defaultValue: { type: String, default: void 0 }, id: { type: String, default: null } }, emits: { change: n => !0 }, setup(n, { emit: e, attrs: t, slots: r, expose: i }) { var a; let o = (a = n.id) != null ? a : `headlessui-combobox-input-${$d()}`, s = db("ComboboxInput"), l = ne(() => Fc(Ut(s.inputRef))), c = { value: !1 }; i({ el: s.inputRef, $el: s.inputRef }); function u() { s.change(null); let S = Ut(s.optionsRef); S && (S.scrollTop = 0), s.goToOption(Ti.Nothing) } let d = ne(() => { var S; let x = s.value.value; return Ut(s.inputRef) ? typeof n.displayValue < "u" && x !== void 0 ? (S = n.displayValue(x)) != null ? S : "" : typeof x == "string" ? x : "" : "" }); un(() => { Ct([d, s.comboboxState, l], ([S, x], [k, A]) => { if (c.value) return; let C = Ut(s.inputRef); C && ((A === 0 && x === 1 || S !== k) && (C.value = S), requestAnimationFrame(() => { var E; if (c.value || !C || ((E = l.value) == null ? void 0 : E.activeElement) !== C) return; let { selectionStart: O, selectionEnd: j } = C; Math.abs((j ?? 0) - (O ?? 0)) === 0 && O === 0 && C.setSelectionRange(C.value.length, C.value.length) })) }, { immediate: !0 }), Ct([s.comboboxState], ([S], [x]) => { if (S === 0 && x === 1) { if (c.value) return; let k = Ut(s.inputRef); if (!k) return; let A = k.value, { selectionStart: C, selectionEnd: E, selectionDirection: O } = k; k.value = "", k.value = A, O !== null ? k.setSelectionRange(C, E, O) : k.setSelectionRange(C, E) } }) }); let f = he(!1); function h() { f.value = !0 } function p() { gd().nextFrame(() => { f.value = !1 }) } let m = Gye(); function g(S) { switch (c.value = !0, m(() => { c.value = !1 }), S.key) { case ts.Enter: if (c.value = !1, s.comboboxState.value !== 0 || f.value) return; if (S.preventDefault(), S.stopPropagation(), s.activeOptionIndex.value === null) { s.closeCombobox(); return } s.selectActiveOption(), s.mode.value === 0 && s.closeCombobox(); break; case ts.ArrowDown: return c.value = !1, S.preventDefault(), S.stopPropagation(), Mi(s.comboboxState.value, { 0: () => s.goToOption(Ti.Next), 1: () => s.openCombobox() }); case ts.ArrowUp: return c.value = !1, S.preventDefault(), S.stopPropagation(), Mi(s.comboboxState.value, { 0: () => s.goToOption(Ti.Previous), 1: () => { s.openCombobox(), Pr(() => { s.value.value || s.goToOption(Ti.Last) }) } }); case ts.Home: if (S.shiftKey) break; return c.value = !1, S.preventDefault(), S.stopPropagation(), s.goToOption(Ti.First); case ts.PageUp: return c.value = !1, S.preventDefault(), S.stopPropagation(), s.goToOption(Ti.First); case ts.End: if (S.shiftKey) break; return c.value = !1, S.preventDefault(), S.stopPropagation(), s.goToOption(Ti.Last); case ts.PageDown: return c.value = !1, S.preventDefault(), S.stopPropagation(), s.goToOption(Ti.Last); case ts.Escape: if (c.value = !1, s.comboboxState.value !== 0) return; S.preventDefault(), s.optionsRef.value && !s.optionsPropsRef.value.static && S.stopPropagation(), s.nullable.value && s.mode.value === 0 && s.value.value === null && u(), s.closeCombobox(); break; case ts.Tab: if (c.value = !1, s.comboboxState.value !== 0) return; s.mode.value === 0 && s.activationTrigger.value !== 1 && s.selectActiveOption(), s.closeCombobox(); break } } function y(S) { e("change", S), s.nullable.value && s.mode.value === 0 && S.target.value === "" && u(), s.openCombobox() } function b(S) { var x, k, A; let C = (x = S.relatedTarget) != null ? x : dc.find(E => E !== S.currentTarget); if (c.value = !1, !((k = Ut(s.optionsRef)) != null && k.contains(C)) && !((A = Ut(s.buttonRef)) != null && A.contains(C)) && s.comboboxState.value === 0) return S.preventDefault(), s.mode.value === 0 && (s.nullable.value && s.value.value === null ? u() : s.activationTrigger.value !== 1 && s.selectActiveOption()), s.closeCombobox() } function w(S) { var x, k, A; let C = (x = S.relatedTarget) != null ? x : dc.find(E => E !== S.currentTarget); (k = Ut(s.buttonRef)) != null && k.contains(C) || (A = Ut(s.optionsRef)) != null && A.contains(C) || s.disabled.value || s.immediate.value && s.comboboxState.value !== 0 && (s.openCombobox(), gd().nextFrame(() => { s.setActivationTrigger(1) })) } let v = ne(() => { var S, x, k, A; return (A = (k = (x = n.defaultValue) != null ? x : s.defaultValue.value !== void 0 ? (S = n.displayValue) == null ? void 0 : S.call(n, s.defaultValue.value) : null) != null ? k : s.defaultValue.value) != null ? A : "" }); return () => { var S, x, k, A, C, E, O; let j = { open: s.comboboxState.value === 0 }, { displayValue: I, onChange: L, ...R } = n, D = { "aria-controls": (S = s.optionsRef.value) == null ? void 0 : S.id, "aria-expanded": s.comboboxState.value === 0, "aria-activedescendant": s.activeOptionIndex.value === null ? void 0 : s.virtual.value ? (x = s.options.value.find(P => !s.virtual.value.disabled(P.dataRef.value) && s.compare(P.dataRef.value, s.virtual.value.options[s.activeOptionIndex.value]))) == null ? void 0 : x.id : (k = s.options.value[s.activeOptionIndex.value]) == null ? void 0 : k.id, "aria-labelledby": (E = (A = Ut(s.labelRef)) == null ? void 0 : A.id) != null ? E : (C = Ut(s.buttonRef)) == null ? void 0 : C.id, "aria-autocomplete": "list", id: o, onCompositionstart: h, onCompositionend: p, onKeydown: g, onInput: y, onFocus: w, onBlur: b, role: "combobox", type: (O = t.type) != null ? O : "text", tabIndex: 0, ref: s.inputRef, defaultValue: v.value, disabled: s.disabled.value === !0 ? !0 : void 0 }; return oa({ ourProps: D, theirProps: R, slot: j, attrs: t, slots: r, features: vd.RenderStrategy | vd.Static, name: "ComboboxInput" }) } } }), g0e = We({ name: "ComboboxOptions", props: { as: { type: [Object, String], default: "ul" }, static: { type: Boolean, default: !1 }, unmount: { type: Boolean, default: !0 }, hold: { type: [Boolean], default: !1 } }, setup(n, { attrs: e, slots: t, expose: r }) { let i = db("ComboboxOptions"), a = `headlessui-combobox-options-${$d()}`; r({ el: i.optionsRef, $el: i.optionsRef }), Bn(() => { i.optionsPropsRef.value.static = n.static }), Bn(() => { i.optionsPropsRef.value.hold = n.hold }); let o = ak(), s = ne(() => o !== null ? (o.value & li.Open) === li.Open : i.comboboxState.value === 0); r0e({ container: ne(() => Ut(i.optionsRef)), enabled: ne(() => i.comboboxState.value === 0), accept(c) { return c.getAttribute("role") === "option" ? NodeFilter.FILTER_REJECT : c.hasAttribute("role") ? NodeFilter.FILTER_SKIP : NodeFilter.FILTER_ACCEPT }, walk(c) { c.setAttribute("role", "none") } }); function l(c) { c.preventDefault() } return () => { var c, u, d; let f = { open: i.comboboxState.value === 0 }, h = { "aria-labelledby": (d = (c = Ut(i.labelRef)) == null ? void 0 : c.id) != null ? d : (u = Ut(i.buttonRef)) == null ? void 0 : u.id, id: a, ref: i.optionsRef, role: "listbox", "aria-multiselectable": i.mode.value === 1 ? !0 : void 0, onMousedown: l }, p = ub(n, ["hold"]); return oa({ ourProps: h, theirProps: p, slot: f, attrs: e, slots: i.virtual.value && i.comboboxState.value === 0 ? { ...t, default: () => [Gt(h0e, {}, t.default)] } : t, features: vd.RenderStrategy | vd.Static, visible: s.value, name: "ComboboxOptions" }) } } }), v0e = We({ name: "ComboboxOption", props: { as: { type: [Object, String], default: "li" }, value: { type: [Object, String, Number, Boolean] }, disabled: { type: Boolean, default: !1 }, order: { type: [Number], default: null } }, setup(n, { slots: e, attrs: t, expose: r }) { let i = db("ComboboxOption"), a = `headlessui-combobox-option-${$d()}`, o = he(null), s = ne(() => n.disabled); r({ el: o, $el: o }); let l = ne(() => { var b; return i.virtual.value ? i.activeOptionIndex.value === i.calculateIndex(n.value) : i.activeOptionIndex.value === null ? !1 : ((b = i.options.value[i.activeOptionIndex.value]) == null ? void 0 : b.id) === a }), c = ne(() => i.isSelected(n.value)), u = zn(Kq, null), d = ne(() => ({ disabled: n.disabled, value: n.value, domRef: o, order: ne(() => n.order) })); un(() => i.registerOption(a, d)), cr(() => i.unregisterOption(a, l.value)), Bn(() => { let b = Ut(o); b && (u == null || u.value.measureElement(b)) }), Bn(() => { i.comboboxState.value === 0 && l.value && (i.virtual.value || i.activationTrigger.value !== 0 && Pr(() => { var b, w; return (w = (b = Ut(o)) == null ? void 0 : b.scrollIntoView) == null ? void 0 : w.call(b, { block: "nearest" }) })) }); function f(b) { b.preventDefault(), b.button === Vq.Left && (s.value || (i.selectOption(a), Lq() || requestAnimationFrame(() => { var w; return (w = Ut(i.inputRef)) == null ? void 0 : w.focus({ preventScroll: !0 }) }), i.mode.value === 0 && i.closeCombobox())) } function h() { var b; if (n.disabled || (b = i.virtual.value) != null && b.disabled(n.value)) return i.goToOption(Ti.Nothing); let w = i.calculateIndex(n.value); i.goToOption(Ti.Specific, w) } let p = n0e(); function m(b) { p.update(b) } function g(b) { var w; if (!p.wasMoved(b) || n.disabled || (w = i.virtual.value) != null && w.disabled(n.value) || l.value) return; let v = i.calculateIndex(n.value); i.goToOption(Ti.Specific, v, 0) } function y(b) { var w; p.wasMoved(b) && (n.disabled || (w = i.virtual.value) != null && w.disabled(n.value) || l.value && (i.optionsPropsRef.value.hold || i.goToOption(Ti.Nothing))) } return () => { let { disabled: b } = n, w = { active: l.value, selected: c.value, disabled: b }, v = { id: a, ref: o, role: "option", tabIndex: b === !0 ? void 0 : -1, "aria-disabled": b === !0 ? !0 : void 0, "aria-selected": c.value, disabled: void 0, onMousedown: f, onFocus: h, onPointerenter: m, onMouseenter: m, onPointermove: g, onMousemove: g, onPointerleave: y, onMouseleave: y }, S = ub(n, ["order", "value"]); return oa({ ourProps: v, theirProps: S, slot: w, attrs: t, slots: e, name: "ComboboxOption" }) } } }); function qq(n, e, t, r) { cb.isServer || Bn(i => { n = n ?? window, n.addEventListener(e, t, r), i(() => n.removeEventListener(e, t, r)) }) } var yy = (n => (n[n.Forwards = 0] = "Forwards", n[n.Backwards = 1] = "Backwards", n))(yy || {}); function y0e() { let n = he(0); return Rq("keydown", e => { e.key === "Tab" && (n.value = e.shiftKey ? 1 : 0) }), n } function Yq(n) { if (!n) return new Set; if (typeof n == "function") return new Set(n()); let e = new Set; for (let t of n.value) { let r = Ut(t); r instanceof HTMLElement && e.add(r) } return e } var Zq = (n => (n[n.None = 1] = "None", n[n.InitialFocus = 2] = "InitialFocus", n[n.TabLock = 4] = "TabLock", n[n.FocusLock = 8] = "FocusLock", n[n.RestoreFocus = 16] = "RestoreFocus", n[n.All = 30] = "All", n))(Zq || {}); let jv = Object.assign(We({ name: "FocusTrap", props: { as: { type: [Object, String], default: "div" }, initialFocus: { type: Object, default: null }, features: { type: Number, default: 30 }, containers: { type: [Object, Function], default: he(new Set) } }, inheritAttrs: !1, setup(n, { attrs: e, slots: t, expose: r }) { let i = he(null); r({ el: i, $el: i }); let a = ne(() => Fc(i)), o = he(!1); un(() => o.value = !0), cr(() => o.value = !1), b0e({ ownerDocument: a }, ne(() => o.value && !!(n.features & 16))); let s = w0e({ ownerDocument: a, container: i, initialFocus: ne(() => n.initialFocus) }, ne(() => o.value && !!(n.features & 2))); x0e({ ownerDocument: a, container: i, containers: n.containers, previousActiveElement: s }, ne(() => o.value && !!(n.features & 8))); let l = y0e(); function c(h) { let p = Ut(i); p && (m => m())(() => { Mi(l.value, { [yy.Forwards]: () => { Ky(p, Ou.First, { skipElements: [h.relatedTarget] }) }, [yy.Backwards]: () => { Ky(p, Ou.Last, { skipElements: [h.relatedTarget] }) } }) }) } let u = he(!1); function d(h) { h.key === "Tab" && (u.value = !0, requestAnimationFrame(() => { u.value = !1 })) } function f(h) { if (!o.value) return; let p = Yq(n.containers); Ut(i) instanceof HTMLElement && p.add(Ut(i)); let m = h.relatedTarget; m instanceof HTMLElement && m.dataset.headlessuiFocusGuard !== "true" && (Xq(p, m) || (u.value ? Ky(Ut(i), Mi(l.value, { [yy.Forwards]: () => Ou.Next, [yy.Backwards]: () => Ou.Previous }) | Ou.WrapAround, { relativeTo: h.target }) : h.target instanceof HTMLElement && Qu(h.target))) } return () => { let h = {}, p = { ref: i, onKeydown: d, onFocusout: f }, { features: m, initialFocus: g, containers: y, ...b } = n; return Gt(Qt, [!!(m & 4) && Gt(IS, { as: "button", type: "button", "data-headlessui-focus-guard": !0, onFocus: c, features: N0.Focusable }), oa({ ourProps: p, theirProps: { ...e, ...b }, slot: h, attrs: e, slots: t, name: "FocusTrap" }), !!(m & 4) && Gt(IS, { as: "button", type: "button", "data-headlessui-focus-guard": !0, onFocus: c, features: N0.Focusable })]) } } }), { features: Zq }); function _0e(n) { let e = he(dc.slice()); return Ct([n], ([t], [r]) => { r === !0 && t === !1 ? KL(() => { e.value.splice(0) }) : r === !1 && t === !0 && (e.value = dc.slice()) }, { flush: "post" }), () => { var t; return (t = e.value.find(r => r != null && r.isConnected)) != null ? t : null } } function b0e({ ownerDocument: n }, e) { let t = _0e(e); un(() => { Bn(() => { var r, i; e.value || ((r = n.value) == null ? void 0 : r.activeElement) === ((i = n.value) == null ? void 0 : i.body) && Qu(t()) }, { flush: "post" }) }), cr(() => { e.value && Qu(t()) }) } function w0e({ ownerDocument: n, container: e, initialFocus: t }, r) { let i = he(null), a = he(!1); return un(() => a.value = !0), cr(() => a.value = !1), un(() => { Ct([e, t, r], (o, s) => { if (o.every((c, u) => (s == null ? void 0 : s[u]) === c) || !r.value) return; let l = Ut(e); l && KL(() => { var c, u; if (!a.value) return; let d = Ut(t), f = (c = n.value) == null ? void 0 : c.activeElement; if (d) { if (d === f) { i.value = f; return } } else if (l.contains(f)) { i.value = f; return } d ? Qu(d) : Ky(l, Ou.First | Ou.NoScroll) === Mq.Error && console.warn("There are no focusable elements inside the <FocusTrap />"), i.value = (u = n.value) == null ? void 0 : u.activeElement }) }, { immediate: !0, flush: "post" }) }), i } function x0e({ ownerDocument: n, container: e, containers: t, previousActiveElement: r }, i) { var a; qq((a = n.value) == null ? void 0 : a.defaultView, "focus", o => { if (!i.value) return; let s = Yq(t); Ut(e) instanceof HTMLElement && s.add(Ut(e)); let l = r.value; if (!l) return; let c = o.target; c && c instanceof HTMLElement ? Xq(s, c) ? (r.value = c, Qu(c)) : (o.preventDefault(), o.stopPropagation(), Qu(l)) : Qu(r.value) }, !0) } function Xq(n, e) { for (let t of n) if (t.contains(e)) return !0; return !1 } function S0e(n) { let e = Fa(n.getSnapshot()); return cr(n.subscribe(() => { e.value = n.getSnapshot() })), e } function T0e(n, e) { let t = n(), r = new Set; return { getSnapshot() { return t }, subscribe(i) { return r.add(i), () => r.delete(i) }, dispatch(i, ...a) { let o = e[i].call(t, ...a); o && (t = o, r.forEach(s => s())) } } } function k0e() { let n; return { before({ doc: e }) { var t; let r = e.documentElement; n = ((t = e.defaultView) != null ? t : window).innerWidth - r.clientWidth }, after({ doc: e, d: t }) { let r = e.documentElement, i = r.clientWidth - r.offsetWidth, a = n - i; t.style(r, "paddingRight", `${a}px`) } } } function C0e() { return Iq() ? { before({ doc: n, d: e, meta: t }) { function r(i) { return t.containers.flatMap(a => a()).some(a => a.contains(i)) } e.microTask(() => { var i; if (window.getComputedStyle(n.documentElement).scrollBehavior !== "auto") { let s = gd(); s.style(n.documentElement, "scrollBehavior", "auto"), e.add(() => e.microTask(() => s.dispose())) } let a = (i = window.scrollY) != null ? i : window.pageYOffset, o = null; e.addEventListener(n, "click", s => { if (s.target instanceof HTMLElement) try { let l = s.target.closest("a"); if (!l) return; let { hash: c } = new URL(l.href), u = n.querySelector(c); u && !r(u) && (o = u) } catch { } }, !0), e.addEventListener(n, "touchstart", s => { if (s.target instanceof HTMLElement) if (r(s.target)) { let l = s.target; for (; l.parentElement && r(l.parentElement);)l = l.parentElement; e.style(l, "overscrollBehavior", "contain") } else e.style(s.target, "touchAction", "none") }), e.addEventListener(n, "touchmove", s => { if (s.target instanceof HTMLElement) { if (s.target.tagName === "INPUT") return; if (r(s.target)) { let l = s.target; for (; l.parentElement && l.dataset.headlessuiPortal !== "" && !(l.scrollHeight > l.clientHeight || l.scrollWidth > l.clientWidth);)l = l.parentElement; l.dataset.headlessuiPortal === "" && s.preventDefault() } else s.preventDefault() } }, { passive: !1 }), e.add(() => { var s; let l = (s = window.scrollY) != null ? s : window.pageYOffset; a !== l && window.scrollTo(0, a), o && o.isConnected && (o.scrollIntoView({ block: "nearest" }), o = null) }) }) } } : {} } function A0e() { return { before({ doc: n, d: e }) { e.style(n.documentElement, "overflow", "hidden") } } } function E0e(n) { let e = {}; for (let t of n) Object.assign(e, t(e)); return e } let Wf = T0e(() => new Map, { PUSH(n, e) { var t; let r = (t = this.get(n)) != null ? t : { doc: n, count: 0, d: gd(), meta: new Set }; return r.count++, r.meta.add(e), this.set(n, r), this }, POP(n, e) { let t = this.get(n); return t && (t.count--, t.meta.delete(e)), this }, SCROLL_PREVENT({ doc: n, d: e, meta: t }) { let r = { doc: n, d: e, meta: E0e(t) }, i = [C0e(), k0e(), A0e()]; i.forEach(({ before: a }) => a == null ? void 0 : a(r)), i.forEach(({ after: a }) => a == null ? void 0 : a(r)) }, SCROLL_ALLOW({ d: n }) { n.dispose() }, TEARDOWN({ doc: n }) { this.delete(n) } }); Wf.subscribe(() => { let n = Wf.getSnapshot(), e = new Map; for (let [t] of n) e.set(t, t.documentElement.style.overflow); for (let t of n.values()) { let r = e.get(t.doc) === "hidden", i = t.count !== 0; (i && !r || !i && r) && Wf.dispatch(t.count > 0 ? "SCROLL_PREVENT" : "SCROLL_ALLOW", t), t.count === 0 && Wf.dispatch("TEARDOWN", t) } }); function M0e(n, e, t) { let r = S0e(Wf), i = ne(() => { let a = n.value ? r.value.get(n.value) : void 0; return a ? a.count > 0 : !1 }); return Ct([n, e], ([a, o], [s], l) => { if (!a || !o) return; Wf.dispatch("PUSH", a, t); let c = !1; l(() => { c || (Wf.dispatch("POP", s ?? a, t), c = !0) }) }, { immediate: !0 }), i } let dE = new Map, Pv = new Map; function a$(n, e = he(!0)) { Bn(t => { var r; if (!e.value) return; let i = Ut(n); if (!i) return; t(function () { var o; if (!i) return; let s = (o = Pv.get(i)) != null ? o : 1; if (s === 1 ? Pv.delete(i) : Pv.set(i, s - 1), s !== 1) return; let l = dE.get(i); l && (l["aria-hidden"] === null ? i.removeAttribute("aria-hidden") : i.setAttribute("aria-hidden", l["aria-hidden"]), i.inert = l.inert, dE.delete(i)) }); let a = (r = Pv.get(i)) != null ? r : 0; Pv.set(i, a + 1), a === 0 && (dE.set(i, { "aria-hidden": i.getAttribute("aria-hidden"), inert: i.inert }), i.setAttribute("aria-hidden", "true"), i.inert = !0) }) } function O0e({ defaultContainers: n = [], portals: e, mainTreeNodeRef: t } = {}) { let r = he(null), i = Fc(r); function a() { var o, s, l; let c = []; for (let u of n) u !== null && (u instanceof HTMLElement ? c.push(u) : "value" in u && u.value instanceof HTMLElement && c.push(u.value)); if (e != null && e.value) for (let u of e.value) c.push(u); for (let u of (o = i == null ? void 0 : i.querySelectorAll("html > *, body > *")) != null ? o : []) u !== document.body && u !== document.head && u instanceof HTMLElement && u.id !== "headlessui-portal-root" && (u.contains(Ut(r)) || u.contains((l = (s = Ut(r)) == null ? void 0 : s.getRootNode()) == null ? void 0 : l.host) || c.some(d => u.contains(d)) || c.push(u)); return c } return { resolveContainers: a, contains(o) { return a().some(s => s.contains(o)) }, mainTreeNodeRef: r, MainTreeNode() { return t != null ? null : Gt(IS, { features: N0.Hidden, ref: r }) } } } let Jq = Symbol("ForcePortalRootContext"); function D0e() { return zn(Jq, !1) } let o$ = We({ name: "ForcePortalRoot", props: { as: { type: [Object, String], default: "template" }, force: { type: Boolean, default: !1 } }, setup(n, { slots: e, attrs: t }) { return Or(Jq, n.force), () => { let { force: r, ...i } = n; return oa({ theirProps: i, ourProps: {}, slot: {}, slots: e, attrs: t, name: "ForcePortalRoot" }) } } }), Qq = Symbol("StackContext"); var rj = (n => (n[n.Add = 0] = "Add", n[n.Remove = 1] = "Remove", n))(rj || {}); function j0e() { return zn(Qq, () => { }) } function P0e({ type: n, enabled: e, element: t, onUpdate: r }) { let i = j0e(); function a(...o) { r == null || r(...o), i(...o) } un(() => { Ct(e, (o, s) => { o ? a(0, n, t) : s === !0 && a(1, n, t) }, { immediate: !0, flush: "sync" }) }), cr(() => { e.value && a(1, n, t) }), Or(Qq, a) } let I0e = Symbol("DescriptionContext"); function L0e({ slot: n = he({}), name: e = "Description", props: t = {} } = {}) { let r = he([]); function i(a) { return r.value.push(a), () => { let o = r.value.indexOf(a); o !== -1 && r.value.splice(o, 1) } } return Or(I0e, { register: i, slot: n, name: e, props: t }), ne(() => r.value.length > 0 ? r.value.join(" ") : void 0) } function R0e(n) { let e = Fc(n); if (!e) { if (n === null) return null; throw new Error(`[Headless UI]: Cannot find ownerDocument for contextElement: ${n}`) } let t = e.getElementById("headlessui-portal-root"); if (t) return t; let r = e.createElement("div"); return r.setAttribute("id", "headlessui-portal-root"), e.body.appendChild(r) } const ij = new WeakMap; function N0e(n) { var e; return (e = ij.get(n)) != null ? e : 0 } function s$(n, e) { let t = e(N0e(n)); return t <= 0 ? ij.delete(n) : ij.set(n, t), t } let B0e = We({ name: "Portal", props: { as: { type: [Object, String], default: "div" } }, setup(n, { slots: e, attrs: t }) { let r = he(null), i = ne(() => Fc(r)), a = D0e(), o = zn(eY, null), s = he(a === !0 || o == null ? R0e(r.value) : o.resolveTarget()); s.value && s$(s.value, f => f + 1); let l = he(!1); un(() => { l.value = !0 }), Bn(() => { a || o != null && (s.value = o.resolveTarget()) }); let c = zn(aj, null), u = !1, d = kr(); return Ct(r, () => { if (u || !c) return; let f = Ut(r); f && (cr(c.register(f), d), u = !0) }), cr(() => { var f, h; let p = (f = i.value) == null ? void 0 : f.getElementById("headlessui-portal-root"); !p || s.value !== p || s$(s.value, m => m - 1) || s.value.children.length > 0 || (h = s.value.parentElement) == null || h.removeChild(s.value) }), () => { if (!l.value || s.value === null) return null; let f = { ref: r, "data-headlessui-portal": "" }; return Gt(rb, { to: s.value }, oa({ ourProps: f, theirProps: n, slot: {}, attrs: t, slots: e, name: "Portal" })) } } }), aj = Symbol("PortalParentContext"); function $0e() { let n = zn(aj, null), e = he([]); function t(a) { return e.value.push(a), n && n.register(a), () => r(a) } function r(a) { let o = e.value.indexOf(a); o !== -1 && e.value.splice(o, 1), n && n.unregister(a) } let i = { register: t, unregister: r, portals: e }; return [e, We({ name: "PortalWrapper", setup(a, { slots: o }) { return Or(aj, i), () => { var s; return (s = o.default) == null ? void 0 : s.call(o) } } })] } let eY = Symbol("PortalGroupContext"), F0e = We({ name: "PortalGroup", props: { as: { type: [Object, String], default: "template" }, target: { type: Object, default: null } }, setup(n, { attrs: e, slots: t }) { let r = vr({ resolveTarget() { return n.target } }); return Or(eY, r), () => { let { target: i, ...a } = n; return oa({ theirProps: a, ourProps: {}, slot: {}, attrs: e, slots: t, name: "PortalGroup" }) } } }); var z0e = (n => (n[n.Open = 0] = "Open", n[n.Closed = 1] = "Closed", n))(z0e || {}); let oj = Symbol("DialogContext"); function ok(n) { let e = zn(oj, null); if (e === null) { let t = new Error(`<${n} /> is missing a parent <Dialog /> component.`); throw Error.captureStackTrace && Error.captureStackTrace(t, ok), t } return e } let z1 = "DC8F892D-2EBD-447C-A4C8-A03058436FF4", V0e = We({ name: "Dialog", inheritAttrs: !1, props: { as: { type: [Object, String], default: "div" }, static: { type: Boolean, default: !1 }, unmount: { type: Boolean, default: !0 }, open: { type: [Boolean, String], default: z1 }, initialFocus: { type: Object, default: null }, id: { type: String, default: null }, role: { type: String, default: "dialog" } }, emits: { close: n => !0 }, setup(n, { emit: e, attrs: t, slots: r, expose: i }) { var a, o; let s = (a = n.id) != null ? a : `headlessui-dialog-${$d()}`, l = he(!1); un(() => { l.value = !0 }); let c = !1, u = ne(() => n.role === "dialog" || n.role === "alertdialog" ? n.role : (c || (c = !0, console.warn(`Invalid role [${u}] passed to <Dialog />. Only \`dialog\` and and \`alertdialog\` are supported. Using \`dialog\` instead.`)), "dialog")), d = he(0), f = ak(), h = ne(() => n.open === z1 && f !== null ? (f.value & li.Open) === li.Open : n.open), p = he(null), m = ne(() => Fc(p)); if (i({ el: p, $el: p }), !(n.open !== z1 || f !== null)) throw new Error("You forgot to provide an `open` prop to the `Dialog`."); if (typeof h.value != "boolean") throw new Error(`You provided an \`open\` prop to the \`Dialog\`, but the value is not a boolean. Received: ${h.value === z1 ? void 0 : n.open}`); let g = ne(() => l.value && h.value ? 0 : 1), y = ne(() => g.value === 0), b = ne(() => d.value > 1), w = zn(oj, null) !== null, [v, S] = $0e(), { resolveContainers: x, mainTreeNodeRef: k, MainTreeNode: A } = O0e({ portals: v, defaultContainers: [ne(() => { var V; return (V = P.panelRef.value) != null ? V : p.value })] }), C = ne(() => b.value ? "parent" : "leaf"), E = ne(() => f !== null ? (f.value & li.Closing) === li.Closing : !1), O = ne(() => w || E.value ? !1 : y.value), j = ne(() => { var V, W, J; return (J = Array.from((W = (V = m.value) == null ? void 0 : V.querySelectorAll("body > *")) != null ? W : []).find(ie => ie.id === "headlessui-portal-root" ? !1 : ie.contains(Ut(k)) && ie instanceof HTMLElement)) != null ? J : null }); a$(j, O); let I = ne(() => b.value ? !0 : y.value), L = ne(() => { var V, W, J; return (J = Array.from((W = (V = m.value) == null ? void 0 : V.querySelectorAll("[data-headlessui-portal]")) != null ? W : []).find(ie => ie.contains(Ut(k)) && ie instanceof HTMLElement)) != null ? J : null }); a$(L, I), P0e({ type: "Dialog", enabled: ne(() => g.value === 0), element: p, onUpdate: (V, W) => { if (W === "Dialog") return Mi(V, { [rj.Add]: () => d.value += 1, [rj.Remove]: () => d.value -= 1 }) } }); let R = L0e({ name: "DialogDescription", slot: ne(() => ({ open: h.value })) }), D = he(null), P = { titleId: D, panelRef: he(null), dialogState: g, setTitleId(V) { D.value !== V && (D.value = V) }, close() { e("close", !1) } }; Or(oj, P); let B = ne(() => !(!y.value || b.value)); Nq(x, (V, W) => { V.preventDefault(), P.close(), Pr(() => W == null ? void 0 : W.focus()) }, B); let F = ne(() => !(b.value || g.value !== 0)); qq((o = m.value) == null ? void 0 : o.defaultView, "keydown", V => { F.value && (V.defaultPrevented || V.key === ts.Escape && (V.preventDefault(), V.stopPropagation(), P.close())) }); let K = ne(() => !(E.value || g.value !== 0 || w)); return M0e(m, K, V => { var W; return { containers: [...(W = V.containers) != null ? W : [], x] } }), Bn(V => { if (g.value !== 0) return; let W = Ut(p); if (!W) return; let J = new ResizeObserver(ie => { for (let le of ie) { let De = le.target.getBoundingClientRect(); De.x === 0 && De.y === 0 && De.width === 0 && De.height === 0 && P.close() } }); J.observe(W), V(() => J.disconnect()) }), () => { let { open: V, initialFocus: W, ...J } = n, ie = { ...t, ref: p, id: s, role: u.value, "aria-modal": g.value === 0 ? !0 : void 0, "aria-labelledby": D.value, "aria-describedby": R.value }, le = { open: g.value === 0 }; return Gt(o$, { force: !0 }, () => [Gt(B0e, () => Gt(F0e, { target: p.value }, () => Gt(o$, { force: !1 }, () => Gt(jv, { initialFocus: W, containers: x, features: y.value ? Mi(C.value, { parent: jv.features.RestoreFocus, leaf: jv.features.All & ~jv.features.FocusLock }) : jv.features.None }, () => Gt(S, {}, () => oa({ ourProps: ie, theirProps: { ...J, ...t }, slot: le, attrs: t, slots: r, visible: g.value === 0, features: vd.RenderStrategy | vd.Static, name: "Dialog" })))))), Gt(A)]) } } }), Pdt = We({ name: "DialogOverlay", props: { as: { type: [Object, String], default: "div" }, id: { type: String, default: null } }, setup(n, { attrs: e, slots: t }) { var r; let i = (r = n.id) != null ? r : `headlessui-dialog-overlay-${$d()}`, a = ok("DialogOverlay"); function o(s) { s.target === s.currentTarget && (s.preventDefault(), s.stopPropagation(), a.close()) } return () => { let { ...s } = n; return oa({ ourProps: { id: i, "aria-hidden": !0, onClick: o }, theirProps: s, slot: { open: a.dialogState.value === 0 }, attrs: e, slots: t, name: "DialogOverlay" }) } } }), H0e = We({ name: "DialogPanel", props: { as: { type: [Object, String], default: "div" }, id: { type: String, default: null } }, setup(n, { attrs: e, slots: t, expose: r }) { var i; let a = (i = n.id) != null ? i : `headlessui-dialog-panel-${$d()}`, o = ok("DialogPanel"); r({ el: o.panelRef, $el: o.panelRef }); function s(l) { l.stopPropagation() } return () => { let { ...l } = n, c = { id: a, ref: o.panelRef, onClick: s }; return oa({ ourProps: c, theirProps: l, slot: { open: o.dialogState.value === 0 }, attrs: e, slots: t, name: "DialogPanel" }) } } }), U0e = We({ name: "DialogTitle", props: { as: { type: [Object, String], default: "h2" }, id: { type: String, default: null } }, setup(n, { attrs: e, slots: t }) { var r; let i = (r = n.id) != null ? r : `headlessui-dialog-title-${$d()}`, a = ok("DialogTitle"); return un(() => { a.setTitleId(i), cr(() => a.setTitleId(null)) }), () => { let { ...o } = n; return oa({ ourProps: { id: i }, theirProps: o, slot: { open: a.dialogState.value === 0 }, attrs: e, slots: t, name: "DialogTitle" }) } } }); function G0e(n) { let e = { called: !1 }; return (...t) => { if (!e.called) return e.called = !0, n(...t) } } function fE(n, ...e) { n && e.length > 0 && n.classList.add(...e) } function V1(n, ...e) { n && e.length > 0 && n.classList.remove(...e) } var sj = (n => (n.Finished = "finished", n.Cancelled = "cancelled", n))(sj || {}); function W0e(n, e) { let t = gd(); if (!n) return t.dispose; let { transitionDuration: r, transitionDelay: i } = getComputedStyle(n), [a, o] = [r, i].map(s => { let [l = 0] = s.split(",").filter(Boolean).map(c => c.includes("ms") ? parseFloat(c) : parseFloat(c) * 1e3).sort((c, u) => u - c); return l }); return a !== 0 ? t.setTimeout(() => e("finished"), a + o) : e("finished"), t.add(() => e("cancelled")), t.dispose } function l$(n, e, t, r, i, a) { let o = gd(), s = a !== void 0 ? G0e(a) : () => { }; return V1(n, ...i), fE(n, ...e, ...t), o.nextFrame(() => { V1(n, ...t), fE(n, ...r), o.add(W0e(n, l => (V1(n, ...r, ...e), fE(n, ...i), s(l)))) }), o.add(() => V1(n, ...e, ...t, ...r, ...i)), o.add(() => s("cancelled")), o.dispose } function of(n = "") { return n.split(/\s+/).filter(e => e.length > 1) } let qL = Symbol("TransitionContext"); var K0e = (n => (n.Visible = "visible", n.Hidden = "hidden", n))(K0e || {}); function q0e() { return zn(qL, null) !== null } function Y0e() { let n = zn(qL, null); if (n === null) throw new Error("A <TransitionChild /> is used but it is missing a parent <TransitionRoot />."); return n } function Z0e() { let n = zn(YL, null); if (n === null) throw new Error("A <TransitionChild /> is used but it is missing a parent <TransitionRoot />."); return n } let YL = Symbol("NestingContext"); function sk(n) { return "children" in n ? sk(n.children) : n.value.filter(({ state: e }) => e === "visible").length > 0 } function tY(n) { let e = he([]), t = he(!1); un(() => t.value = !0), cr(() => t.value = !1); function r(a, o = Ru.Hidden) { let s = e.value.findIndex(({ id: l }) => l === a); s !== -1 && (Mi(o, { [Ru.Unmount]() { e.value.splice(s, 1) }, [Ru.Hidden]() { e.value[s].state = "hidden" } }), !sk(e) && t.value && (n == null || n())) } function i(a) { let o = e.value.find(({ id: s }) => s === a); return o ? o.state !== "visible" && (o.state = "visible") : e.value.push({ id: a, state: "visible" }), () => r(a, Ru.Unmount) } return { children: e, register: i, unregister: r } } let nY = vd.RenderStrategy, lj = We({ props: { as: { type: [Object, String], default: "div" }, show: { type: [Boolean], default: null }, unmount: { type: [Boolean], default: !0 }, appear: { type: [Boolean], default: !1 }, enter: { type: [String], default: "" }, enterFrom: { type: [String], default: "" }, enterTo: { type: [String], default: "" }, entered: { type: [String], default: "" }, leave: { type: [String], default: "" }, leaveFrom: { type: [String], default: "" }, leaveTo: { type: [String], default: "" } }, emits: { beforeEnter: () => !0, afterEnter: () => !0, beforeLeave: () => !0, afterLeave: () => !0 }, setup(n, { emit: e, attrs: t, slots: r, expose: i }) { let a = he(0); function o() { a.value |= li.Opening, e("beforeEnter") } function s() { a.value &= ~li.Opening, e("afterEnter") } function l() { a.value |= li.Closing, e("beforeLeave") } function c() { a.value &= ~li.Closing, e("afterLeave") } if (!q0e() && o0e()) return () => Gt(rY, { ...n, onBeforeEnter: o, onAfterEnter: s, onBeforeLeave: l, onAfterLeave: c }, r); let u = he(null), d = ne(() => n.unmount ? Ru.Unmount : Ru.Hidden); i({ el: u, $el: u }); let { show: f, appear: h } = Y0e(), { register: p, unregister: m } = Z0e(), g = he(f.value ? "visible" : "hidden"), y = { value: !0 }, b = $d(), w = { value: !1 }, v = tY(() => { !w.value && g.value !== "hidden" && (g.value = "hidden", m(b), c()) }); un(() => { let I = p(b); cr(I) }), Bn(() => { if (d.value === Ru.Hidden && b) { if (f.value && g.value !== "visible") { g.value = "visible"; return } Mi(g.value, { hidden: () => m(b), visible: () => p(b) }) } }); let S = of(n.enter), x = of(n.enterFrom), k = of(n.enterTo), A = of(n.entered), C = of(n.leave), E = of(n.leaveFrom), O = of(n.leaveTo); un(() => { Bn(() => { if (g.value === "visible") { let I = Ut(u); if (I instanceof Comment && I.data === "") throw new Error("Did you forget to passthrough the `ref` to the actual DOM node?") } }) }); function j(I) { let L = y.value && !h.value, R = Ut(u); !R || !(R instanceof HTMLElement) || L || (w.value = !0, f.value && o(), f.value || l(), I(f.value ? l$(R, S, x, k, A, D => { w.value = !1, D === sj.Finished && s() }) : l$(R, C, E, O, A, D => { w.value = !1, D === sj.Finished && (sk(v) || (g.value = "hidden", m(b), c())) }))) } return un(() => { Ct([f], (I, L, R) => { j(R), y.value = !1 }, { immediate: !0 }) }), Or(YL, v), zq(ne(() => Mi(g.value, { visible: li.Open, hidden: li.Closed }) | a.value)), () => { let { appear: I, show: L, enter: R, enterFrom: D, enterTo: P, entered: B, leave: F, leaveFrom: K, leaveTo: V, ...W } = n, J = { ref: u }, ie = { ...W, ...h.value && f.value && cb.isServer ? { class: Tt([t.class, W.class, ...S, ...x]) } : {} }; return oa({ theirProps: ie, ourProps: J, slot: {}, slots: r, attrs: t, features: nY, visible: g.value === "visible", name: "TransitionChild" }) } } }), X0e = lj, rY = We({ inheritAttrs: !1, props: { as: { type: [Object, String], default: "div" }, show: { type: [Boolean], default: null }, unmount: { type: [Boolean], default: !0 }, appear: { type: [Boolean], default: !1 }, enter: { type: [String], default: "" }, enterFrom: { type: [String], default: "" }, enterTo: { type: [String], default: "" }, entered: { type: [String], default: "" }, leave: { type: [String], default: "" }, leaveFrom: { type: [String], default: "" }, leaveTo: { type: [String], default: "" } }, emits: { beforeEnter: () => !0, afterEnter: () => !0, beforeLeave: () => !0, afterLeave: () => !0 }, setup(n, { emit: e, attrs: t, slots: r }) { let i = ak(), a = ne(() => n.show === null && i !== null ? (i.value & li.Open) === li.Open : n.show); Bn(() => { if (![!0, !1].includes(a.value)) throw new Error('A <Transition /> is used but it is missing a `:show="true | false"` prop.') }); let o = he(a.value ? "visible" : "hidden"), s = tY(() => { o.value = "hidden" }), l = he(!0), c = { show: a, appear: ne(() => n.appear || !l.value) }; return un(() => { Bn(() => { l.value = !1, a.value ? o.value = "visible" : sk(s) || (o.value = "hidden") }) }), Or(YL, s), Or(qL, c), () => { let u = ub(n, ["show", "appear", "unmount", "onBeforeEnter", "onBeforeLeave", "onAfterEnter", "onAfterLeave"]), d = { unmount: n.unmount }; return oa({ ourProps: { ...d, as: "template" }, theirProps: {}, slot: {}, slots: { ...r, default: () => [Gt(X0e, { onBeforeEnter: () => e("beforeEnter"), onAfterEnter: () => e("afterEnter"), onBeforeLeave: () => e("beforeLeave"), onAfterLeave: () => e("afterLeave"), ...t, ...d, ...u }, r.default)] }, attrs: {}, features: nY, visible: o.value === "visible", name: "Transition" }) } } }); var wa = "top", zo = "bottom", Vo = "right", xa = "left", ZL = "auto", fb = [wa, zo, Vo, xa], sg = "start", B0 = "end", J0e = "clippingParents", iY = "viewport", Iv = "popper", Q0e = "reference", c$ = fb.reduce(function (n, e) { return n.concat([e + "-" + sg, e + "-" + B0]) }, []), aY = [].concat(fb, [ZL]).reduce(function (n, e) { return n.concat([e, e + "-" + sg, e + "-" + B0]) }, []), e_e = "beforeRead", t_e = "read", n_e = "afterRead", r_e = "beforeMain", i_e = "main", a_e = "afterMain", o_e = "beforeWrite", s_e = "write", l_e = "afterWrite", c_e = [e_e, t_e, n_e, r_e, i_e, a_e, o_e, s_e, l_e]; function yl(n) { return n ? (n.nodeName || "").toLowerCase() : null } function qa(n) { if (n == null) return window; if (n.toString() !== "[object Window]") { var e = n.ownerDocument; return e && e.defaultView || window } return n } function Lh(n) { var e = qa(n).Element; return n instanceof e || n instanceof Element } function Lo(n) { var e = qa(n).HTMLElement; return n instanceof e || n instanceof HTMLElement } function XL(n) { if (typeof ShadowRoot > "u") return !1; var e = qa(n).ShadowRoot; return n instanceof e || n instanceof ShadowRoot } function u_e(n) { var e = n.state; Object.keys(e.elements).forEach(function (t) { var r = e.styles[t] || {}, i = e.attributes[t] || {}, a = e.elements[t]; !Lo(a) || !yl(a) || (Object.assign(a.style, r), Object.keys(i).forEach(function (o) { var s = i[o]; s === !1 ? a.removeAttribute(o) : a.setAttribute(o, s === !0 ? "" : s) })) }) } function d_e(n) { var e = n.state, t = { popper: { position: e.options.strategy, left: "0", top: "0", margin: "0" }, arrow: { position: "absolute" }, reference: {} }; return Object.assign(e.elements.popper.style, t.popper), e.styles = t, e.elements.arrow && Object.assign(e.elements.arrow.style, t.arrow), function () { Object.keys(e.elements).forEach(function (r) { var i = e.elements[r], a = e.attributes[r] || {}, o = Object.keys(e.styles.hasOwnProperty(r) ? e.styles[r] : t[r]), s = o.reduce(function (l, c) { return l[c] = "", l }, {}); !Lo(i) || !yl(i) || (Object.assign(i.style, s), Object.keys(a).forEach(function (l) { i.removeAttribute(l) })) }) } } const oY = { name: "applyStyles", enabled: !0, phase: "write", fn: u_e, effect: d_e, requires: ["computeStyles"] }; function fl(n) { return n.split("-")[0] } var uh = Math.max, LS = Math.min, lg = Math.round; function cj() { var n = navigator.userAgentData; return n != null && n.brands && Array.isArray(n.brands) ? n.brands.map(function (e) { return e.brand + "/" + e.version }).join(" ") : navigator.userAgent } function sY() { return !/^((?!chrome|android).)*safari/i.test(cj()) } function cg(n, e, t) { e === void 0 && (e = !1), t === void 0 && (t = !1); var r = n.getBoundingClientRect(), i = 1, a = 1; e && Lo(n) && (i = n.offsetWidth > 0 && lg(r.width) / n.offsetWidth || 1, a = n.offsetHeight > 0 && lg(r.height) / n.offsetHeight || 1); var o = Lh(n) ? qa(n) : window, s = o.visualViewport, l = !sY() && t, c = (r.left + (l && s ? s.offsetLeft : 0)) / i, u = (r.top + (l && s ? s.offsetTop : 0)) / a, d = r.width / i, f = r.height / a; return { width: d, height: f, top: u, right: c + d, bottom: u + f, left: c, x: c, y: u } } function JL(n) { var e = cg(n), t = n.offsetWidth, r = n.offsetHeight; return Math.abs(e.width - t) <= 1 && (t = e.width), Math.abs(e.height - r) <= 1 && (r = e.height), { x: n.offsetLeft, y: n.offsetTop, width: t, height: r } } function lY(n, e) { var t = e.getRootNode && e.getRootNode(); if (n.contains(e)) return !0; if (t && XL(t)) { var r = e; do { if (r && n.isSameNode(r)) return !0; r = r.parentNode || r.host } while (r) } return !1 } function Ac(n) { return qa(n).getComputedStyle(n) } function f_e(n) { return ["table", "td", "th"].indexOf(yl(n)) >= 0 } function Fd(n) { return ((Lh(n) ? n.ownerDocument : n.document) || window.document).documentElement } function lk(n) { return yl(n) === "html" ? n : n.assignedSlot || n.parentNode || (XL(n) ? n.host : null) || Fd(n) } function u$(n) { return !Lo(n) || Ac(n).position === "fixed" ? null : n.offsetParent } function h_e(n) { var e = /firefox/i.test(cj()), t = /Trident/i.test(cj()); if (t && Lo(n)) { var r = Ac(n); if (r.position === "fixed") return null } var i = lk(n); for (XL(i) && (i = i.host); Lo(i) && ["html", "body"].indexOf(yl(i)) < 0;) { var a = Ac(i); if (a.transform !== "none" || a.perspective !== "none" || a.contain === "paint" || ["transform", "perspective"].indexOf(a.willChange) !== -1 || e && a.willChange === "filter" || e && a.filter && a.filter !== "none") return i; i = i.parentNode } return null } function hb(n) { for (var e = qa(n), t = u$(n); t && f_e(t) && Ac(t).position === "static";)t = u$(t); return t && (yl(t) === "html" || yl(t) === "body" && Ac(t).position === "static") ? e : t || h_e(n) || e } function QL(n) { return ["top", "bottom"].indexOf(n) >= 0 ? "x" : "y" } function qy(n, e, t) { return uh(n, LS(e, t)) } function p_e(n, e, t) { var r = qy(n, e, t); return r > t ? t : r } function cY() { return { top: 0, right: 0, bottom: 0, left: 0 } } function uY(n) { return Object.assign({}, cY(), n) } function dY(n, e) { return e.reduce(function (t, r) { return t[r] = n, t }, {}) } var m_e = function (e, t) { return e = typeof e == "function" ? e(Object.assign({}, t.rects, { placement: t.placement })) : e, uY(typeof e != "number" ? e : dY(e, fb)) }; function g_e(n) { var e, t = n.state, r = n.name, i = n.options, a = t.elements.arrow, o = t.modifiersData.popperOffsets, s = fl(t.placement), l = QL(s), c = [xa, Vo].indexOf(s) >= 0, u = c ? "height" : "width"; if (!(!a || !o)) { var d = m_e(i.padding, t), f = JL(a), h = l === "y" ? wa : xa, p = l === "y" ? zo : Vo, m = t.rects.reference[u] + t.rects.reference[l] - o[l] - t.rects.popper[u], g = o[l] - t.rects.reference[l], y = hb(a), b = y ? l === "y" ? y.clientHeight || 0 : y.clientWidth || 0 : 0, w = m / 2 - g / 2, v = d[h], S = b - f[u] - d[p], x = b / 2 - f[u] / 2 + w, k = qy(v, x, S), A = l; t.modifiersData[r] = (e = {}, e[A] = k, e.centerOffset = k - x, e) } } function v_e(n) { var e = n.state, t = n.options, r = t.element, i = r === void 0 ? "[data-popper-arrow]" : r; i != null && (typeof i == "string" && (i = e.elements.popper.querySelector(i), !i) || lY(e.elements.popper, i) && (e.elements.arrow = i)) } const y_e = { name: "arrow", enabled: !0, phase: "main", fn: g_e, effect: v_e, requires: ["popperOffsets"], requiresIfExists: ["preventOverflow"] }; function ug(n) { return n.split("-")[1] } var __e = { top: "auto", right: "auto", bottom: "auto", left: "auto" }; function b_e(n, e) { var t = n.x, r = n.y, i = e.devicePixelRatio || 1; return { x: lg(t * i) / i || 0, y: lg(r * i) / i || 0 } } function d$(n) { var e, t = n.popper, r = n.popperRect, i = n.placement, a = n.variation, o = n.offsets, s = n.position, l = n.gpuAcceleration, c = n.adaptive, u = n.roundOffsets, d = n.isFixed, f = o.x, h = f === void 0 ? 0 : f, p = o.y, m = p === void 0 ? 0 : p, g = typeof u == "function" ? u({ x: h, y: m }) : { x: h, y: m }; h = g.x, m = g.y; var y = o.hasOwnProperty("x"), b = o.hasOwnProperty("y"), w = xa, v = wa, S = window; if (c) { var x = hb(t), k = "clientHeight", A = "clientWidth"; if (x === qa(t) && (x = Fd(t), Ac(x).position !== "static" && s === "absolute" && (k = "scrollHeight", A = "scrollWidth")), x = x, i === wa || (i === xa || i === Vo) && a === B0) { v = zo; var C = d && x === S && S.visualViewport ? S.visualViewport.height : x[k]; m -= C - r.height, m *= l ? 1 : -1 } if (i === xa || (i === wa || i === zo) && a === B0) { w = Vo; var E = d && x === S && S.visualViewport ? S.visualViewport.width : x[A]; h -= E - r.width, h *= l ? 1 : -1 } } var O = Object.assign({ position: s }, c && __e), j = u === !0 ? b_e({ x: h, y: m }, qa(t)) : { x: h, y: m }; if (h = j.x, m = j.y, l) { var I; return Object.assign({}, O, (I = {}, I[v] = b ? "0" : "", I[w] = y ? "0" : "", I.transform = (S.devicePixelRatio || 1) <= 1 ? "translate(" + h + "px, " + m + "px)" : "translate3d(" + h + "px, " + m + "px, 0)", I)) } return Object.assign({}, O, (e = {}, e[v] = b ? m + "px" : "", e[w] = y ? h + "px" : "", e.transform = "", e)) } function w_e(n) { var e = n.state, t = n.options, r = t.gpuAcceleration, i = r === void 0 ? !0 : r, a = t.adaptive, o = a === void 0 ? !0 : a, s = t.roundOffsets, l = s === void 0 ? !0 : s, c = { placement: fl(e.placement), variation: ug(e.placement), popper: e.elements.popper, popperRect: e.rects.popper, gpuAcceleration: i, isFixed: e.options.strategy === "fixed" }; e.modifiersData.popperOffsets != null && (e.styles.popper = Object.assign({}, e.styles.popper, d$(Object.assign({}, c, { offsets: e.modifiersData.popperOffsets, position: e.options.strategy, adaptive: o, roundOffsets: l })))), e.modifiersData.arrow != null && (e.styles.arrow = Object.assign({}, e.styles.arrow, d$(Object.assign({}, c, { offsets: e.modifiersData.arrow, position: "absolute", adaptive: !1, roundOffsets: l })))), e.attributes.popper = Object.assign({}, e.attributes.popper, { "data-popper-placement": e.placement }) } const x_e = { name: "computeStyles", enabled: !0, phase: "beforeWrite", fn: w_e, data: {} }; var H1 = { passive: !0 }; function S_e(n) { var e = n.state, t = n.instance, r = n.options, i = r.scroll, a = i === void 0 ? !0 : i, o = r.resize, s = o === void 0 ? !0 : o, l = qa(e.elements.popper), c = [].concat(e.scrollParents.reference, e.scrollParents.popper); return a && c.forEach(function (u) { u.addEventListener("scroll", t.update, H1) }), s && l.addEventListener("resize", t.update, H1), function () { a && c.forEach(function (u) { u.removeEventListener("scroll", t.update, H1) }), s && l.removeEventListener("resize", t.update, H1) } } const T_e = { name: "eventListeners", enabled: !0, phase: "write", fn: function () { }, effect: S_e, data: {} }; var k_e = { left: "right", right: "left", bottom: "top", top: "bottom" }; function Ix(n) { return n.replace(/left|right|bottom|top/g, function (e) { return k_e[e] }) } var C_e = { start: "end", end: "start" }; function f$(n) { return n.replace(/start|end/g, function (e) { return C_e[e] }) } function eR(n) { var e = qa(n), t = e.pageXOffset, r = e.pageYOffset; return { scrollLeft: t, scrollTop: r } } function tR(n) { return cg(Fd(n)).left + eR(n).scrollLeft } function A_e(n, e) { var t = qa(n), r = Fd(n), i = t.visualViewport, a = r.clientWidth, o = r.clientHeight, s = 0, l = 0; if (i) { a = i.width, o = i.height; var c = sY(); (c || !c && e === "fixed") && (s = i.offsetLeft, l = i.offsetTop) } return { width: a, height: o, x: s + tR(n), y: l } } function E_e(n) { var e, t = Fd(n), r = eR(n), i = (e = n.ownerDocument) == null ? void 0 : e.body, a = uh(t.scrollWidth, t.clientWidth, i ? i.scrollWidth : 0, i ? i.clientWidth : 0), o = uh(t.scrollHeight, t.clientHeight, i ? i.scrollHeight : 0, i ? i.clientHeight : 0), s = -r.scrollLeft + tR(n), l = -r.scrollTop; return Ac(i || t).direction === "rtl" && (s += uh(t.clientWidth, i ? i.clientWidth : 0) - a), { width: a, height: o, x: s, y: l } } function nR(n) { var e = Ac(n), t = e.overflow, r = e.overflowX, i = e.overflowY; return /auto|scroll|overlay|hidden/.test(t + i + r) } function fY(n) { return ["html", "body", "#document"].indexOf(yl(n)) >= 0 ? n.ownerDocument.body : Lo(n) && nR(n) ? n : fY(lk(n)) } function Yy(n, e) { var t; e === void 0 && (e = []); var r = fY(n), i = r === ((t = n.ownerDocument) == null ? void 0 : t.body), a = qa(r), o = i ? [a].concat(a.visualViewport || [], nR(r) ? r : []) : r, s = e.concat(o); return i ? s : s.concat(Yy(lk(o))) } function uj(n) { return Object.assign({}, n, { left: n.x, top: n.y, right: n.x + n.width, bottom: n.y + n.height }) } function M_e(n, e) { var t = cg(n, !1, e === "fixed"); return t.top = t.top + n.clientTop, t.left = t.left + n.clientLeft, t.bottom = t.top + n.clientHeight, t.right = t.left + n.clientWidth, t.width = n.clientWidth, t.height = n.clientHeight, t.x = t.left, t.y = t.top, t } function h$(n, e, t) { return e === iY ? uj(A_e(n, t)) : Lh(e) ? M_e(e, t) : uj(E_e(Fd(n))) } function O_e(n) { var e = Yy(lk(n)), t = ["absolute", "fixed"].indexOf(Ac(n).position) >= 0, r = t && Lo(n) ? hb(n) : n; return Lh(r) ? e.filter(function (i) { return Lh(i) && lY(i, r) && yl(i) !== "body" }) : [] } function D_e(n, e, t, r) { var i = e === "clippingParents" ? O_e(n) : [].concat(e), a = [].concat(i, [t]), o = a[0], s = a.reduce(function (l, c) { var u = h$(n, c, r); return l.top = uh(u.top, l.top), l.right = LS(u.right, l.right), l.bottom = LS(u.bottom, l.bottom), l.left = uh(u.left, l.left), l }, h$(n, o, r)); return s.width = s.right - s.left, s.height = s.bottom - s.top, s.x = s.left, s.y = s.top, s } function hY(n) { var e = n.reference, t = n.element, r = n.placement, i = r ? fl(r) : null, a = r ? ug(r) : null, o = e.x + e.width / 2 - t.width / 2, s = e.y + e.height / 2 - t.height / 2, l; switch (i) { case wa: l = { x: o, y: e.y - t.height }; break; case zo: l = { x: o, y: e.y + e.height }; break; case Vo: l = { x: e.x + e.width, y: s }; break; case xa: l = { x: e.x - t.width, y: s }; break; default: l = { x: e.x, y: e.y } }var c = i ? QL(i) : null; if (c != null) { var u = c === "y" ? "height" : "width"; switch (a) { case sg: l[c] = l[c] - (e[u] / 2 - t[u] / 2); break; case B0: l[c] = l[c] + (e[u] / 2 - t[u] / 2); break } } return l } function $0(n, e) { e === void 0 && (e = {}); var t = e, r = t.placement, i = r === void 0 ? n.placement : r, a = t.strategy, o = a === void 0 ? n.strategy : a, s = t.boundary, l = s === void 0 ? J0e : s, c = t.rootBoundary, u = c === void 0 ? iY : c, d = t.elementContext, f = d === void 0 ? Iv : d, h = t.altBoundary, p = h === void 0 ? !1 : h, m = t.padding, g = m === void 0 ? 0 : m, y = uY(typeof g != "number" ? g : dY(g, fb)), b = f === Iv ? Q0e : Iv, w = n.rects.popper, v = n.elements[p ? b : f], S = D_e(Lh(v) ? v : v.contextElement || Fd(n.elements.popper), l, u, o), x = cg(n.elements.reference), k = hY({ reference: x, element: w, strategy: "absolute", placement: i }), A = uj(Object.assign({}, w, k)), C = f === Iv ? A : x, E = { top: S.top - C.top + y.top, bottom: C.bottom - S.bottom + y.bottom, left: S.left - C.left + y.left, right: C.right - S.right + y.right }, O = n.modifiersData.offset; if (f === Iv && O) { var j = O[i]; Object.keys(E).forEach(function (I) { var L = [Vo, zo].indexOf(I) >= 0 ? 1 : -1, R = [wa, zo].indexOf(I) >= 0 ? "y" : "x"; E[I] += j[R] * L }) } return E } function j_e(n, e) { e === void 0 && (e = {}); var t = e, r = t.placement, i = t.boundary, a = t.rootBoundary, o = t.padding, s = t.flipVariations, l = t.allowedAutoPlacements, c = l === void 0 ? aY : l, u = ug(r), d = u ? s ? c$ : c$.filter(function (p) { return ug(p) === u }) : fb, f = d.filter(function (p) { return c.indexOf(p) >= 0 }); f.length === 0 && (f = d); var h = f.reduce(function (p, m) { return p[m] = $0(n, { placement: m, boundary: i, rootBoundary: a, padding: o })[fl(m)], p }, {}); return Object.keys(h).sort(function (p, m) { return h[p] - h[m] }) } function P_e(n) { if (fl(n) === ZL) return []; var e = Ix(n); return [f$(n), e, f$(e)] } function I_e(n) { var e = n.state, t = n.options, r = n.name; if (!e.modifiersData[r]._skip) { for (var i = t.mainAxis, a = i === void 0 ? !0 : i, o = t.altAxis, s = o === void 0 ? !0 : o, l = t.fallbackPlacements, c = t.padding, u = t.boundary, d = t.rootBoundary, f = t.altBoundary, h = t.flipVariations, p = h === void 0 ? !0 : h, m = t.allowedAutoPlacements, g = e.options.placement, y = fl(g), b = y === g, w = l || (b || !p ? [Ix(g)] : P_e(g)), v = [g].concat(w).reduce(function (ie, le) { return ie.concat(fl(le) === ZL ? j_e(e, { placement: le, boundary: u, rootBoundary: d, padding: c, flipVariations: p, allowedAutoPlacements: m }) : le) }, []), S = e.rects.reference, x = e.rects.popper, k = new Map, A = !0, C = v[0], E = 0; E < v.length; E++) { var O = v[E], j = fl(O), I = ug(O) === sg, L = [wa, zo].indexOf(j) >= 0, R = L ? "width" : "height", D = $0(e, { placement: O, boundary: u, rootBoundary: d, altBoundary: f, padding: c }), P = L ? I ? Vo : xa : I ? zo : wa; S[R] > x[R] && (P = Ix(P)); var B = Ix(P), F = []; if (a && F.push(D[j] <= 0), s && F.push(D[P] <= 0, D[B] <= 0), F.every(function (ie) { return ie })) { C = O, A = !1; break } k.set(O, F) } if (A) for (var K = p ? 3 : 1, V = function (le) { var De = v.find(function (ae) { var pe = k.get(ae); if (pe) return pe.slice(0, le).every(function (se) { return se }) }); if (De) return C = De, "break" }, W = K; W > 0; W--) { var J = V(W); if (J === "break") break } e.placement !== C && (e.modifiersData[r]._skip = !0, e.placement = C, e.reset = !0) } } const L_e = { name: "flip", enabled: !0, phase: "main", fn: I_e, requiresIfExists: ["offset"], data: { _skip: !1 } }; function p$(n, e, t) { return t === void 0 && (t = { x: 0, y: 0 }), { top: n.top - e.height - t.y, right: n.right - e.width + t.x, bottom: n.bottom - e.height + t.y, left: n.left - e.width - t.x } } function m$(n) { return [wa, Vo, zo, xa].some(function (e) { return n[e] >= 0 }) } function R_e(n) { var e = n.state, t = n.name, r = e.rects.reference, i = e.rects.popper, a = e.modifiersData.preventOverflow, o = $0(e, { elementContext: "reference" }), s = $0(e, { altBoundary: !0 }), l = p$(o, r), c = p$(s, i, a), u = m$(l), d = m$(c); e.modifiersData[t] = { referenceClippingOffsets: l, popperEscapeOffsets: c, isReferenceHidden: u, hasPopperEscaped: d }, e.attributes.popper = Object.assign({}, e.attributes.popper, { "data-popper-reference-hidden": u, "data-popper-escaped": d }) } const N_e = { name: "hide", enabled: !0, phase: "main", requiresIfExists: ["preventOverflow"], fn: R_e }; function B_e(n, e, t) { var r = fl(n), i = [xa, wa].indexOf(r) >= 0 ? -1 : 1, a = typeof t == "function" ? t(Object.assign({}, e, { placement: n })) : t, o = a[0], s = a[1]; return o = o || 0, s = (s || 0) * i, [xa, Vo].indexOf(r) >= 0 ? { x: s, y: o } : { x: o, y: s } } function $_e(n) { var e = n.state, t = n.options, r = n.name, i = t.offset, a = i === void 0 ? [0, 0] : i, o = aY.reduce(function (u, d) { return u[d] = B_e(d, e.rects, a), u }, {}), s = o[e.placement], l = s.x, c = s.y; e.modifiersData.popperOffsets != null && (e.modifiersData.popperOffsets.x += l, e.modifiersData.popperOffsets.y += c), e.modifiersData[r] = o } const F_e = { name: "offset", enabled: !0, phase: "main", requires: ["popperOffsets"], fn: $_e }; function z_e(n) { var e = n.state, t = n.name; e.modifiersData[t] = hY({ reference: e.rects.reference, element: e.rects.popper, strategy: "absolute", placement: e.placement }) } const V_e = { name: "popperOffsets", enabled: !0, phase: "read", fn: z_e, data: {} }; function H_e(n) { return n === "x" ? "y" : "x" } function U_e(n) { var e = n.state, t = n.options, r = n.name, i = t.mainAxis, a = i === void 0 ? !0 : i, o = t.altAxis, s = o === void 0 ? !1 : o, l = t.boundary, c = t.rootBoundary, u = t.altBoundary, d = t.padding, f = t.tether, h = f === void 0 ? !0 : f, p = t.tetherOffset, m = p === void 0 ? 0 : p, g = $0(e, { boundary: l, rootBoundary: c, padding: d, altBoundary: u }), y = fl(e.placement), b = ug(e.placement), w = !b, v = QL(y), S = H_e(v), x = e.modifiersData.popperOffsets, k = e.rects.reference, A = e.rects.popper, C = typeof m == "function" ? m(Object.assign({}, e.rects, { placement: e.placement })) : m, E = typeof C == "number" ? { mainAxis: C, altAxis: C } : Object.assign({ mainAxis: 0, altAxis: 0 }, C), O = e.modifiersData.offset ? e.modifiersData.offset[e.placement] : null, j = { x: 0, y: 0 }; if (x) { if (a) { var I, L = v === "y" ? wa : xa, R = v === "y" ? zo : Vo, D = v === "y" ? "height" : "width", P = x[v], B = P + g[L], F = P - g[R], K = h ? -A[D] / 2 : 0, V = b === sg ? k[D] : A[D], W = b === sg ? -A[D] : -k[D], J = e.elements.arrow, ie = h && J ? JL(J) : { width: 0, height: 0 }, le = e.modifiersData["arrow#persistent"] ? e.modifiersData["arrow#persistent"].padding : cY(), De = le[L], ae = le[R], pe = qy(0, k[D], ie[D]), se = w ? k[D] / 2 - K - pe - De - E.mainAxis : V - pe - De - E.mainAxis, ge = w ? -k[D] / 2 + K + pe + ae + E.mainAxis : W + pe + ae + E.mainAxis, _e = e.elements.arrow && hb(e.elements.arrow), je = _e ? v === "y" ? _e.clientTop || 0 : _e.clientLeft || 0 : 0, U = (I = O == null ? void 0 : O[v]) != null ? I : 0, q = P + se - U - je, ee = P + ge - U, de = qy(h ? LS(B, q) : B, P, h ? uh(F, ee) : F); x[v] = de, j[v] = de - P } if (s) { var me, fe = v === "x" ? wa : xa, we = v === "x" ? zo : Vo, Oe = x[S], ve = S === "y" ? "height" : "width", Se = Oe + g[fe], Ke = Oe - g[we], ze = [wa, xa].indexOf(y) !== -1, Xe = (me = O == null ? void 0 : O[S]) != null ? me : 0, Ee = ze ? Se : Oe - k[ve] - A[ve] - Xe + E.altAxis, ce = ze ? Oe + k[ve] + A[ve] - Xe - E.altAxis : Ke, Te = h && ze ? p_e(Ee, Oe, ce) : qy(h ? Ee : Se, Oe, h ? ce : Ke); x[S] = Te, j[S] = Te - Oe } e.modifiersData[r] = j } } const G_e = { name: "preventOverflow", enabled: !0, phase: "main", fn: U_e, requiresIfExists: ["offset"] }; function W_e(n) { return { scrollLeft: n.scrollLeft, scrollTop: n.scrollTop } } function K_e(n) { return n === qa(n) || !Lo(n) ? eR(n) : W_e(n) } function q_e(n) { var e = n.getBoundingClientRect(), t = lg(e.width) / n.offsetWidth || 1, r = lg(e.height) / n.offsetHeight || 1; return t !== 1 || r !== 1 } function Y_e(n, e, t) { t === void 0 && (t = !1); var r = Lo(e), i = Lo(e) && q_e(e), a = Fd(e), o = cg(n, i, t), s = { scrollLeft: 0, scrollTop: 0 }, l = { x: 0, y: 0 }; return (r || !r && !t) && ((yl(e) !== "body" || nR(a)) && (s = K_e(e)), Lo(e) ? (l = cg(e, !0), l.x += e.clientLeft, l.y += e.clientTop) : a && (l.x = tR(a))), { x: o.left + s.scrollLeft - l.x, y: o.top + s.scrollTop - l.y, width: o.width, height: o.height } } function Z_e(n) { var e = new Map, t = new Set, r = []; n.forEach(function (a) { e.set(a.name, a) }); function i(a) { t.add(a.name); var o = [].concat(a.requires || [], a.requiresIfExists || []); o.forEach(function (s) { if (!t.has(s)) { var l = e.get(s); l && i(l) } }), r.push(a) } return n.forEach(function (a) { t.has(a.name) || i(a) }), r } function X_e(n) { var e = Z_e(n); return c_e.reduce(function (t, r) { return t.concat(e.filter(function (i) { return i.phase === r })) }, []) } function J_e(n) { var e; return function () { return e || (e = new Promise(function (t) { Promise.resolve().then(function () { e = void 0, t(n()) }) })), e } } function Q_e(n) { var e = n.reduce(function (t, r) { var i = t[r.name]; return t[r.name] = i ? Object.assign({}, i, r, { options: Object.assign({}, i.options, r.options), data: Object.assign({}, i.data, r.data) }) : r, t }, {}); return Object.keys(e).map(function (t) { return e[t] }) } var g$ = { placement: "bottom", modifiers: [], strategy: "absolute" }; function v$() { for (var n = arguments.length, e = new Array(n), t = 0; t < n; t++)e[t] = arguments[t]; return !e.some(function (r) { return !(r && typeof r.getBoundingClientRect == "function") }) } function ebe(n) { n === void 0 && (n = {}); var e = n, t = e.defaultModifiers, r = t === void 0 ? [] : t, i = e.defaultOptions, a = i === void 0 ? g$ : i; return function (s, l, c) { c === void 0 && (c = a); var u = { placement: "bottom", orderedModifiers: [], options: Object.assign({}, g$, a), modifiersData: {}, elements: { reference: s, popper: l }, attributes: {}, styles: {} }, d = [], f = !1, h = { state: u, setOptions: function (y) { var b = typeof y == "function" ? y(u.options) : y; m(), u.options = Object.assign({}, a, u.options, b), u.scrollParents = { reference: Lh(s) ? Yy(s) : s.contextElement ? Yy(s.contextElement) : [], popper: Yy(l) }; var w = X_e(Q_e([].concat(r, u.options.modifiers))); return u.orderedModifiers = w.filter(function (v) { return v.enabled }), p(), h.update() }, forceUpdate: function () { if (!f) { var y = u.elements, b = y.reference, w = y.popper; if (v$(b, w)) { u.rects = { reference: Y_e(b, hb(w), u.options.strategy === "fixed"), popper: JL(w) }, u.reset = !1, u.placement = u.options.placement, u.orderedModifiers.forEach(function (E) { return u.modifiersData[E.name] = Object.assign({}, E.data) }); for (var v = 0; v < u.orderedModifiers.length; v++) { if (u.reset === !0) { u.reset = !1, v = -1; continue } var S = u.orderedModifiers[v], x = S.fn, k = S.options, A = k === void 0 ? {} : k, C = S.name; typeof x == "function" && (u = x({ state: u, options: A, name: C, instance: h }) || u) } } } }, update: J_e(function () { return new Promise(function (g) { h.forceUpdate(), g(u) }) }), destroy: function () { m(), f = !0 } }; if (!v$(s, l)) return h; h.setOptions(c).then(function (g) { !f && c.onFirstUpdate && c.onFirstUpdate(g) }); function p() { u.orderedModifiers.forEach(function (g) { var y = g.name, b = g.options, w = b === void 0 ? {} : b, v = g.effect; if (typeof v == "function") { var S = v({ state: u, name: y, instance: h, options: w }), x = function () { }; d.push(S || x) } }) } function m() { d.forEach(function (g) { return g() }), d = [] } return h } } var tbe = [T_e, V_e, x_e, oY, F_e, L_e, G_e, y_e, N_e], pY = ebe({ defaultModifiers: tbe }); const yn = (n, e) => { const t = n.__vccOpts || n; for (const [r, i] of e) t[r] = i; return t }, nbe = { name: "Popover", inheritAttrs: !1, props: { show: { default: void 0 }, trigger: { type: String, default: "click" }, hoverDelay: { type: Number, default: 0 }, leaveDelay: { type: Number, default: 0 }, placement: { type: String, default: "bottom-start" }, popoverClass: [String, Object, Array], transition: { default: null }, hideOnBlur: { default: !0 } }, emits: ["open", "close", "update:show"], expose: ["open", "close"], data() { return { popoverContainerClass: "body-container", showPopup: !1, targetWidth: null, pointerOverTargetOrPopup: !1 } }, watch: { show(n) { n ? this.open() : this.close() } }, created() { if (!(typeof window > "u") && !document.getElementById("frappeui-popper-root")) { const n = document.createElement("div"); n.id = "frappeui-popper-root", document.body.appendChild(n) } }, mounted() { this.listener = n => { const e = n.target, t = this.$refs.reference, r = this.$refs.popover; if (e === t || e === r || (t == null ? void 0 : t.contains(e)) || (r == null ? void 0 : r.contains(e))) return; if (!document.getElementById("frappeui-popper-root").contains(e)) return this.close(); const s = `.${this.popoverContainerClass}`, l = e == null ? void 0 : e.closest(s), c = t == null ? void 0 : t.closest(s); l && c && l === c && this.close() }, this.hideOnBlur && (document.addEventListener("click", this.listener), document.addEventListener("mousedown", this.listener)), this.$nextTick(() => { this.targetWidth = this.$refs.target.clientWidth }) }, beforeDestroy() { this.popper && this.popper.destroy(), document.removeEventListener("click", this.listener), document.removeEventListener("mousedown", this.listener) }, computed: { showPropPassed() { return this.show != null }, isOpen: { get() { return this.showPropPassed ? this.show : this.showPopup }, set(n) { n = !!n, this.showPropPassed ? this.$emit("update:show", n) : this.showPopup = n, n === !1 ? this.$emit("close") : n === !0 && this.$emit("open") } }, popupTransition() { let n = { default: { enterActiveClass: "transition duration-150 ease-out", enterFromClass: "translate-y-1 opacity-0", enterToClass: "translate-y-0 opacity-100", leaveActiveClass: "transition duration-150 ease-in", leaveFromClass: "translate-y-0 opacity-100", leaveToClass: "translate-y-1 opacity-0" } }; return typeof this.transition == "string" ? n[this.transition] : this.transition } }, methods: { setupPopper() { this.popper ? this.updatePosition() : this.popper = pY(this.$refs.reference, this.$refs.popover, { placement: this.placement }) }, updatePosition() { this.popper && this.popper.update() }, togglePopover(n) { n instanceof Event && (n = null), n == null && (n = !this.isOpen), n = !!n, n ? this.open() : this.close() }, open() { this.isOpen = !0, this.$nextTick(() => this.setupPopper()) }, close() { this.isOpen = !1 }, onMouseover() { this.pointerOverTargetOrPopup = !0, this.leaveTimer && (clearTimeout(this.leaveTimer), this.leaveTimer = null), this.trigger === "hover" && (this.hoverDelay ? this.hoverTimer = setTimeout(() => { this.pointerOverTargetOrPopup && this.open() }, Number(this.hoverDelay) * 1e3) : this.open()) }, onMouseleave(n) { this.pointerOverTargetOrPopup = !1, this.hoverTimer && (clearTimeout(this.hoverTimer), this.hoverTimer = null), this.trigger === "hover" && (this.leaveTimer && clearTimeout(this.leaveTimer), this.leaveDelay ? this.leaveTimer = setTimeout(() => { this.pointerOverTargetOrPopup || this.close() }, Number(this.leaveDelay) * 1e3) : this.pointerOverTargetOrPopup || this.close()) } } }, rbe = { ref: "reference" }, ibe = { class: "rounded-lg border bg-surface-modal shadow-xl" }; function abe(n, e, t, r, i, a) { return Z(), ye("div", rbe, [re("div", { ref: "target", class: Tt(["flex", n.$attrs.class]), onClick: e[0] || (e[0] = (...o) => a.updatePosition && a.updatePosition(...o)), onFocusin: e[1] || (e[1] = (...o) => a.updatePosition && a.updatePosition(...o)), onKeydown: e[2] || (e[2] = (...o) => a.updatePosition && a.updatePosition(...o)), onMouseover: e[3] || (e[3] = (...o) => a.onMouseover && a.onMouseover(...o)), onMouseleave: e[4] || (e[4] = (...o) => a.onMouseleave && a.onMouseleave(...o)) }, [ut(n.$slots, "target", Eo(Mo({ togglePopover: a.togglePopover, updatePosition: a.updatePosition, open: a.open, close: a.close, isOpen: a.isOpen })))], 34), (Z(), Ye(rb, { to: "#frappeui-popper-root" }, [re("div", { ref: "popover", class: Tt(["relative z-[100]", [i.popoverContainerClass, t.popoverClass]]), style: aa({ minWidth: i.targetWidth ? i.targetWidth + "px" : null }), onMouseover: e[5] || (e[5] = o => i.pointerOverTargetOrPopup = !0), onMouseleave: e[6] || (e[6] = (...o) => a.onMouseleave && a.onMouseleave(...o)) }, [$e(dq, Eo(Mo(a.popupTransition)), { default: Ue(() => [Dh(re("div", null, [ut(n.$slots, "body", Eo(Mo({ togglePopover: a.togglePopover, updatePosition: a.updatePosition, open: a.open, close: a.close, isOpen: a.isOpen })), () => [re("div", ibe, [ut(n.$slots, "body-main", Eo(Mo({ togglePopover: a.togglePopover, updatePosition: a.updatePosition, open: a.open, close: a.close, isOpen: a.isOpen })))])])], 512), [[ag, a.isOpen]])]), _: 3 }, 16)], 38)]))], 512) } const mY = yn(nbe, [["render", abe]]); var Du = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {}; function ck(n) { return n && n.__esModule && Object.prototype.hasOwnProperty.call(n, "default") ? n.default : n } function Idt(n) { if (n.__esModule) return n; var e = n.default; if (typeof e == "function") { var t = function r() { return this instanceof r ? Reflect.construct(e, arguments, this.constructor) : e.apply(this, arguments) }; t.prototype = e.prototype } else t = {}; return Object.defineProperty(t, "__esModule", { value: !0 }), Object.keys(n).forEach(function (r) { var i = Object.getOwnPropertyDescriptor(n, r); Object.defineProperty(t, r, i.get ? i : { enumerable: !0, get: function () { return n[r] } }) }), t } var gY = { exports: {} }; (function (n, e) {
  (function (r, i) { n.exports = i() })(typeof self < "u" ? self : Du, function () {
    return function (t) { var r = {}; function i(a) { if (r[a]) return r[a].exports; var o = r[a] = { i: a, l: !1, exports: {} }; return t[a].call(o.exports, o, o.exports, i), o.l = !0, o.exports } return i.m = t, i.c = r, i.d = function (a, o, s) { i.o(a, o) || Object.defineProperty(a, o, { configurable: !1, enumerable: !0, get: s }) }, i.r = function (a) { Object.defineProperty(a, "__esModule", { value: !0 }) }, i.n = function (a) { var o = a && a.__esModule ? function () { return a.default } : function () { return a }; return i.d(o, "a", o), o }, i.o = function (a, o) { return Object.prototype.hasOwnProperty.call(a, o) }, i.p = "", i(i.s = 0) }({
      "./dist/icons.json": function (t) { t.exports = { activity: '<polyline points="22 12 18 12 15 21 9 3 6 12 2 12"></polyline>', airplay: '<path d="M5 17H4a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h16a2 2 0 0 1 2 2v10a2 2 0 0 1-2 2h-1"></path><polygon points="12 15 17 21 7 21 12 15"></polygon>', "alert-circle": '<circle cx="12" cy="12" r="10"></circle><line x1="12" y1="8" x2="12" y2="12"></line><line x1="12" y1="16" x2="12.01" y2="16"></line>', "alert-octagon": '<polygon points="7.86 2 16.14 2 22 7.86 22 16.14 16.14 22 7.86 22 2 16.14 2 7.86 7.86 2"></polygon><line x1="12" y1="8" x2="12" y2="12"></line><line x1="12" y1="16" x2="12.01" y2="16"></line>', "alert-triangle": '<path d="M10.29 3.86L1.82 18a2 2 0 0 0 1.71 3h16.94a2 2 0 0 0 1.71-3L13.71 3.86a2 2 0 0 0-3.42 0z"></path><line x1="12" y1="9" x2="12" y2="13"></line><line x1="12" y1="17" x2="12.01" y2="17"></line>', "align-center": '<line x1="18" y1="10" x2="6" y2="10"></line><line x1="21" y1="6" x2="3" y2="6"></line><line x1="21" y1="14" x2="3" y2="14"></line><line x1="18" y1="18" x2="6" y2="18"></line>', "align-justify": '<line x1="21" y1="10" x2="3" y2="10"></line><line x1="21" y1="6" x2="3" y2="6"></line><line x1="21" y1="14" x2="3" y2="14"></line><line x1="21" y1="18" x2="3" y2="18"></line>', "align-left": '<line x1="17" y1="10" x2="3" y2="10"></line><line x1="21" y1="6" x2="3" y2="6"></line><line x1="21" y1="14" x2="3" y2="14"></line><line x1="17" y1="18" x2="3" y2="18"></line>', "align-right": '<line x1="21" y1="10" x2="7" y2="10"></line><line x1="21" y1="6" x2="3" y2="6"></line><line x1="21" y1="14" x2="3" y2="14"></line><line x1="21" y1="18" x2="7" y2="18"></line>', anchor: '<circle cx="12" cy="5" r="3"></circle><line x1="12" y1="22" x2="12" y2="8"></line><path d="M5 12H2a10 10 0 0 0 20 0h-3"></path>', aperture: '<circle cx="12" cy="12" r="10"></circle><line x1="14.31" y1="8" x2="20.05" y2="17.94"></line><line x1="9.69" y1="8" x2="21.17" y2="8"></line><line x1="7.38" y1="12" x2="13.12" y2="2.06"></line><line x1="9.69" y1="16" x2="3.95" y2="6.06"></line><line x1="14.31" y1="16" x2="2.83" y2="16"></line><line x1="16.62" y1="12" x2="10.88" y2="21.94"></line>', archive: '<polyline points="21 8 21 21 3 21 3 8"></polyline><rect x="1" y="3" width="22" height="5"></rect><line x1="10" y1="12" x2="14" y2="12"></line>', "arrow-down-circle": '<circle cx="12" cy="12" r="10"></circle><polyline points="8 12 12 16 16 12"></polyline><line x1="12" y1="8" x2="12" y2="16"></line>', "arrow-down-left": '<line x1="17" y1="7" x2="7" y2="17"></line><polyline points="17 17 7 17 7 7"></polyline>', "arrow-down-right": '<line x1="7" y1="7" x2="17" y2="17"></line><polyline points="17 7 17 17 7 17"></polyline>', "arrow-down": '<line x1="12" y1="5" x2="12" y2="19"></line><polyline points="19 12 12 19 5 12"></polyline>', "arrow-left-circle": '<circle cx="12" cy="12" r="10"></circle><polyline points="12 8 8 12 12 16"></polyline><line x1="16" y1="12" x2="8" y2="12"></line>', "arrow-left": '<line x1="19" y1="12" x2="5" y2="12"></line><polyline points="12 19 5 12 12 5"></polyline>', "arrow-right-circle": '<circle cx="12" cy="12" r="10"></circle><polyline points="12 16 16 12 12 8"></polyline><line x1="8" y1="12" x2="16" y2="12"></line>', "arrow-right": '<line x1="5" y1="12" x2="19" y2="12"></line><polyline points="12 5 19 12 12 19"></polyline>', "arrow-up-circle": '<circle cx="12" cy="12" r="10"></circle><polyline points="16 12 12 8 8 12"></polyline><line x1="12" y1="16" x2="12" y2="8"></line>', "arrow-up-left": '<line x1="17" y1="17" x2="7" y2="7"></line><polyline points="7 17 7 7 17 7"></polyline>', "arrow-up-right": '<line x1="7" y1="17" x2="17" y2="7"></line><polyline points="7 7 17 7 17 17"></polyline>', "arrow-up": '<line x1="12" y1="19" x2="12" y2="5"></line><polyline points="5 12 12 5 19 12"></polyline>', "at-sign": '<circle cx="12" cy="12" r="4"></circle><path d="M16 8v5a3 3 0 0 0 6 0v-1a10 10 0 1 0-3.92 7.94"></path>', award: '<circle cx="12" cy="8" r="7"></circle><polyline points="8.21 13.89 7 23 12 20 17 23 15.79 13.88"></polyline>', "bar-chart-2": '<line x1="18" y1="20" x2="18" y2="10"></line><line x1="12" y1="20" x2="12" y2="4"></line><line x1="6" y1="20" x2="6" y2="14"></line>', "bar-chart": '<line x1="12" y1="20" x2="12" y2="10"></line><line x1="18" y1="20" x2="18" y2="4"></line><line x1="6" y1="20" x2="6" y2="16"></line>', "battery-charging": '<path d="M5 18H3a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h3.19M15 6h2a2 2 0 0 1 2 2v8a2 2 0 0 1-2 2h-3.19"></path><line x1="23" y1="13" x2="23" y2="11"></line><polyline points="11 6 7 12 13 12 9 18"></polyline>', battery: '<rect x="1" y="6" width="18" height="12" rx="2" ry="2"></rect><line x1="23" y1="13" x2="23" y2="11"></line>', "bell-off": '<path d="M13.73 21a2 2 0 0 1-3.46 0"></path><path d="M18.63 13A17.89 17.89 0 0 1 18 8"></path><path d="M6.26 6.26A5.86 5.86 0 0 0 6 8c0 7-3 9-3 9h14"></path><path d="M18 8a6 6 0 0 0-9.33-5"></path><line x1="1" y1="1" x2="23" y2="23"></line>', bell: '<path d="M18 8A6 6 0 0 0 6 8c0 7-3 9-3 9h18s-3-2-3-9"></path><path d="M13.73 21a2 2 0 0 1-3.46 0"></path>', bluetooth: '<polyline points="6.5 6.5 17.5 17.5 12 23 12 1 17.5 6.5 6.5 17.5"></polyline>', bold: '<path d="M6 4h8a4 4 0 0 1 4 4 4 4 0 0 1-4 4H6z"></path><path d="M6 12h9a4 4 0 0 1 4 4 4 4 0 0 1-4 4H6z"></path>', "book-open": '<path d="M2 3h6a4 4 0 0 1 4 4v14a3 3 0 0 0-3-3H2z"></path><path d="M22 3h-6a4 4 0 0 0-4 4v14a3 3 0 0 1 3-3h7z"></path>', book: '<path d="M4 19.5A2.5 2.5 0 0 1 6.5 17H20"></path><path d="M6.5 2H20v20H6.5A2.5 2.5 0 0 1 4 19.5v-15A2.5 2.5 0 0 1 6.5 2z"></path>', bookmark: '<path d="M19 21l-7-5-7 5V5a2 2 0 0 1 2-2h10a2 2 0 0 1 2 2z"></path>', box: '<path d="M21 16V8a2 2 0 0 0-1-1.73l-7-4a2 2 0 0 0-2 0l-7 4A2 2 0 0 0 3 8v8a2 2 0 0 0 1 1.73l7 4a2 2 0 0 0 2 0l7-4A2 2 0 0 0 21 16z"></path><polyline points="3.27 6.96 12 12.01 20.73 6.96"></polyline><line x1="12" y1="22.08" x2="12" y2="12"></line>', briefcase: '<rect x="2" y="7" width="20" height="14" rx="2" ry="2"></rect><path d="M16 21V5a2 2 0 0 0-2-2h-4a2 2 0 0 0-2 2v16"></path>', calendar: '<rect x="3" y="4" width="18" height="18" rx="2" ry="2"></rect><line x1="16" y1="2" x2="16" y2="6"></line><line x1="8" y1="2" x2="8" y2="6"></line><line x1="3" y1="10" x2="21" y2="10"></line>', "camera-off": '<line x1="1" y1="1" x2="23" y2="23"></line><path d="M21 21H3a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h3m3-3h6l2 3h4a2 2 0 0 1 2 2v9.34m-7.72-2.06a4 4 0 1 1-5.56-5.56"></path>', camera: '<path d="M23 19a2 2 0 0 1-2 2H3a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h4l2-3h6l2 3h4a2 2 0 0 1 2 2z"></path><circle cx="12" cy="13" r="4"></circle>', cast: '<path d="M2 16.1A5 5 0 0 1 5.9 20M2 12.05A9 9 0 0 1 9.95 20M2 8V6a2 2 0 0 1 2-2h16a2 2 0 0 1 2 2v12a2 2 0 0 1-2 2h-6"></path><line x1="2" y1="20" x2="2.01" y2="20"></line>', "check-circle": '<path d="M22 11.08V12a10 10 0 1 1-5.93-9.14"></path><polyline points="22 4 12 14.01 9 11.01"></polyline>', "check-square": '<polyline points="9 11 12 14 22 4"></polyline><path d="M21 12v7a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11"></path>', check: '<polyline points="20 6 9 17 4 12"></polyline>', "chevron-down": '<polyline points="6 9 12 15 18 9"></polyline>', "chevron-left": '<polyline points="15 18 9 12 15 6"></polyline>', "chevron-right": '<polyline points="9 18 15 12 9 6"></polyline>', "chevron-up": '<polyline points="18 15 12 9 6 15"></polyline>', "chevrons-down": '<polyline points="7 13 12 18 17 13"></polyline><polyline points="7 6 12 11 17 6"></polyline>', "chevrons-left": '<polyline points="11 17 6 12 11 7"></polyline><polyline points="18 17 13 12 18 7"></polyline>', "chevrons-right": '<polyline points="13 17 18 12 13 7"></polyline><polyline points="6 17 11 12 6 7"></polyline>', "chevrons-up": '<polyline points="17 11 12 6 7 11"></polyline><polyline points="17 18 12 13 7 18"></polyline>', chrome: '<circle cx="12" cy="12" r="10"></circle><circle cx="12" cy="12" r="4"></circle><line x1="21.17" y1="8" x2="12" y2="8"></line><line x1="3.95" y1="6.06" x2="8.54" y2="14"></line><line x1="10.88" y1="21.94" x2="15.46" y2="14"></line>', circle: '<circle cx="12" cy="12" r="10"></circle>', clipboard: '<path d="M16 4h2a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h2"></path><rect x="8" y="2" width="8" height="4" rx="1" ry="1"></rect>', clock: '<circle cx="12" cy="12" r="10"></circle><polyline points="12 6 12 12 16 14"></polyline>', "cloud-drizzle": '<line x1="8" y1="19" x2="8" y2="21"></line><line x1="8" y1="13" x2="8" y2="15"></line><line x1="16" y1="19" x2="16" y2="21"></line><line x1="16" y1="13" x2="16" y2="15"></line><line x1="12" y1="21" x2="12" y2="23"></line><line x1="12" y1="15" x2="12" y2="17"></line><path d="M20 16.58A5 5 0 0 0 18 7h-1.26A8 8 0 1 0 4 15.25"></path>', "cloud-lightning": '<path d="M19 16.9A5 5 0 0 0 18 7h-1.26a8 8 0 1 0-11.62 9"></path><polyline points="13 11 9 17 15 17 11 23"></polyline>', "cloud-off": '<path d="M22.61 16.95A5 5 0 0 0 18 10h-1.26a8 8 0 0 0-7.05-6M5 5a8 8 0 0 0 4 15h9a5 5 0 0 0 1.7-.3"></path><line x1="1" y1="1" x2="23" y2="23"></line>', "cloud-rain": '<line x1="16" y1="13" x2="16" y2="21"></line><line x1="8" y1="13" x2="8" y2="21"></line><line x1="12" y1="15" x2="12" y2="23"></line><path d="M20 16.58A5 5 0 0 0 18 7h-1.26A8 8 0 1 0 4 15.25"></path>', "cloud-snow": '<path d="M20 17.58A5 5 0 0 0 18 8h-1.26A8 8 0 1 0 4 16.25"></path><line x1="8" y1="16" x2="8.01" y2="16"></line><line x1="8" y1="20" x2="8.01" y2="20"></line><line x1="12" y1="18" x2="12.01" y2="18"></line><line x1="12" y1="22" x2="12.01" y2="22"></line><line x1="16" y1="16" x2="16.01" y2="16"></line><line x1="16" y1="20" x2="16.01" y2="20"></line>', cloud: '<path d="M18 10h-1.26A8 8 0 1 0 9 20h9a5 5 0 0 0 0-10z"></path>', code: '<polyline points="16 18 22 12 16 6"></polyline><polyline points="8 6 2 12 8 18"></polyline>', codepen: '<polygon points="12 2 22 8.5 22 15.5 12 22 2 15.5 2 8.5 12 2"></polygon><line x1="12" y1="22" x2="12" y2="15.5"></line><polyline points="22 8.5 12 15.5 2 8.5"></polyline><polyline points="2 15.5 12 8.5 22 15.5"></polyline><line x1="12" y1="2" x2="12" y2="8.5"></line>', codesandbox: '<path d="M21 16V8a2 2 0 0 0-1-1.73l-7-4a2 2 0 0 0-2 0l-7 4A2 2 0 0 0 3 8v8a2 2 0 0 0 1 1.73l7 4a2 2 0 0 0 2 0l7-4A2 2 0 0 0 21 16z"></path><polyline points="7.5 4.21 12 6.81 16.5 4.21"></polyline><polyline points="7.5 19.79 7.5 14.6 3 12"></polyline><polyline points="21 12 16.5 14.6 16.5 19.79"></polyline><polyline points="3.27 6.96 12 12.01 20.73 6.96"></polyline><line x1="12" y1="22.08" x2="12" y2="12"></line>', coffee: '<path d="M18 8h1a4 4 0 0 1 0 8h-1"></path><path d="M2 8h16v9a4 4 0 0 1-4 4H6a4 4 0 0 1-4-4V8z"></path><line x1="6" y1="1" x2="6" y2="4"></line><line x1="10" y1="1" x2="10" y2="4"></line><line x1="14" y1="1" x2="14" y2="4"></line>', columns: '<path d="M12 3h7a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2h-7m0-18H5a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h7m0-18v18"></path>', command: '<path d="M18 3a3 3 0 0 0-3 3v12a3 3 0 0 0 3 3 3 3 0 0 0 3-3 3 3 0 0 0-3-3H6a3 3 0 0 0-3 3 3 3 0 0 0 3 3 3 3 0 0 0 3-3V6a3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3h12a3 3 0 0 0 3-3 3 3 0 0 0-3-3z"></path>', compass: '<circle cx="12" cy="12" r="10"></circle><polygon points="16.24 7.76 14.12 14.12 7.76 16.24 9.88 9.88 16.24 7.76"></polygon>', copy: '<rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect><path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path>', "corner-down-left": '<polyline points="9 10 4 15 9 20"></polyline><path d="M20 4v7a4 4 0 0 1-4 4H4"></path>', "corner-down-right": '<polyline points="15 10 20 15 15 20"></polyline><path d="M4 4v7a4 4 0 0 0 4 4h12"></path>', "corner-left-down": '<polyline points="14 15 9 20 4 15"></polyline><path d="M20 4h-7a4 4 0 0 0-4 4v12"></path>', "corner-left-up": '<polyline points="14 9 9 4 4 9"></polyline><path d="M20 20h-7a4 4 0 0 1-4-4V4"></path>', "corner-right-down": '<polyline points="10 15 15 20 20 15"></polyline><path d="M4 4h7a4 4 0 0 1 4 4v12"></path>', "corner-right-up": '<polyline points="10 9 15 4 20 9"></polyline><path d="M4 20h7a4 4 0 0 0 4-4V4"></path>', "corner-up-left": '<polyline points="9 14 4 9 9 4"></polyline><path d="M20 20v-7a4 4 0 0 0-4-4H4"></path>', "corner-up-right": '<polyline points="15 14 20 9 15 4"></polyline><path d="M4 20v-7a4 4 0 0 1 4-4h12"></path>', cpu: '<rect x="4" y="4" width="16" height="16" rx="2" ry="2"></rect><rect x="9" y="9" width="6" height="6"></rect><line x1="9" y1="1" x2="9" y2="4"></line><line x1="15" y1="1" x2="15" y2="4"></line><line x1="9" y1="20" x2="9" y2="23"></line><line x1="15" y1="20" x2="15" y2="23"></line><line x1="20" y1="9" x2="23" y2="9"></line><line x1="20" y1="14" x2="23" y2="14"></line><line x1="1" y1="9" x2="4" y2="9"></line><line x1="1" y1="14" x2="4" y2="14"></line>', "credit-card": '<rect x="1" y="4" width="22" height="16" rx="2" ry="2"></rect><line x1="1" y1="10" x2="23" y2="10"></line>', crop: '<path d="M6.13 1L6 16a2 2 0 0 0 2 2h15"></path><path d="M1 6.13L16 6a2 2 0 0 1 2 2v15"></path>', crosshair: '<circle cx="12" cy="12" r="10"></circle><line x1="22" y1="12" x2="18" y2="12"></line><line x1="6" y1="12" x2="2" y2="12"></line><line x1="12" y1="6" x2="12" y2="2"></line><line x1="12" y1="22" x2="12" y2="18"></line>', database: '<ellipse cx="12" cy="5" rx="9" ry="3"></ellipse><path d="M21 12c0 1.66-4 3-9 3s-9-1.34-9-3"></path><path d="M3 5v14c0 1.66 4 3 9 3s9-1.34 9-3V5"></path>', delete: '<path d="M21 4H8l-7 8 7 8h13a2 2 0 0 0 2-2V6a2 2 0 0 0-2-2z"></path><line x1="18" y1="9" x2="12" y2="15"></line><line x1="12" y1="9" x2="18" y2="15"></line>', disc: '<circle cx="12" cy="12" r="10"></circle><circle cx="12" cy="12" r="3"></circle>', "divide-circle": '<line x1="8" y1="12" x2="16" y2="12"></line><line x1="12" y1="16" x2="12" y2="16"></line><line x1="12" y1="8" x2="12" y2="8"></line><circle cx="12" cy="12" r="10"></circle>', "divide-square": '<rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect><line x1="8" y1="12" x2="16" y2="12"></line><line x1="12" y1="16" x2="12" y2="16"></line><line x1="12" y1="8" x2="12" y2="8"></line>', divide: '<circle cx="12" cy="6" r="2"></circle><line x1="5" y1="12" x2="19" y2="12"></line><circle cx="12" cy="18" r="2"></circle>', "dollar-sign": '<line x1="12" y1="1" x2="12" y2="23"></line><path d="M17 5H9.5a3.5 3.5 0 0 0 0 7h5a3.5 3.5 0 0 1 0 7H6"></path>', "download-cloud": '<polyline points="8 17 12 21 16 17"></polyline><line x1="12" y1="12" x2="12" y2="21"></line><path d="M20.88 18.09A5 5 0 0 0 18 9h-1.26A8 8 0 1 0 3 16.29"></path>', download: '<path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path><polyline points="7 10 12 15 17 10"></polyline><line x1="12" y1="15" x2="12" y2="3"></line>', dribbble: '<circle cx="12" cy="12" r="10"></circle><path d="M8.56 2.75c4.37 6.03 6.02 9.42 8.03 17.72m2.54-15.38c-3.72 4.35-8.94 5.66-16.88 5.85m19.5 1.9c-3.5-.93-6.63-.82-8.94 0-2.58.92-5.01 2.86-7.44 6.32"></path>', droplet: '<path d="M12 2.69l5.66 5.66a8 8 0 1 1-11.31 0z"></path>', "edit-2": '<path d="M17 3a2.828 2.828 0 1 1 4 4L7.5 20.5 2 22l1.5-5.5L17 3z"></path>', "edit-3": '<path d="M12 20h9"></path><path d="M16.5 3.5a2.121 2.121 0 0 1 3 3L7 19l-4 1 1-4L16.5 3.5z"></path>', edit: '<path d="M11 4H4a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7"></path><path d="M18.5 2.5a2.121 2.121 0 0 1 3 3L12 15l-4 1 1-4 9.5-9.5z"></path>', "external-link": '<path d="M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6"></path><polyline points="15 3 21 3 21 9"></polyline><line x1="10" y1="14" x2="21" y2="3"></line>', "eye-off": '<path d="M17.94 17.94A10.07 10.07 0 0 1 12 20c-7 0-11-8-11-8a18.45 18.45 0 0 1 5.06-5.94M9.9 4.24A9.12 9.12 0 0 1 12 4c7 0 11 8 11 8a18.5 18.5 0 0 1-2.16 3.19m-6.72-1.07a3 3 0 1 1-4.24-4.24"></path><line x1="1" y1="1" x2="23" y2="23"></line>', eye: '<path d="M1 12s4-8 11-8 11 8 11 8-4 8-11 8-11-8-11-8z"></path><circle cx="12" cy="12" r="3"></circle>', facebook: '<path d="M18 2h-3a5 5 0 0 0-5 5v3H7v4h3v8h4v-8h3l1-4h-4V7a1 1 0 0 1 1-1h3z"></path>', "fast-forward": '<polygon points="13 19 22 12 13 5 13 19"></polygon><polygon points="2 19 11 12 2 5 2 19"></polygon>', feather: '<path d="M20.24 12.24a6 6 0 0 0-8.49-8.49L5 10.5V19h8.5z"></path><line x1="16" y1="8" x2="2" y2="22"></line><line x1="17.5" y1="15" x2="9" y2="15"></line>', figma: '<path d="M5 5.5A3.5 3.5 0 0 1 8.5 2H12v7H8.5A3.5 3.5 0 0 1 5 5.5z"></path><path d="M12 2h3.5a3.5 3.5 0 1 1 0 7H12V2z"></path><path d="M12 12.5a3.5 3.5 0 1 1 7 0 3.5 3.5 0 1 1-7 0z"></path><path d="M5 19.5A3.5 3.5 0 0 1 8.5 16H12v3.5a3.5 3.5 0 1 1-7 0z"></path><path d="M5 12.5A3.5 3.5 0 0 1 8.5 9H12v7H8.5A3.5 3.5 0 0 1 5 12.5z"></path>', "file-minus": '<path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"></path><polyline points="14 2 14 8 20 8"></polyline><line x1="9" y1="15" x2="15" y2="15"></line>', "file-plus": '<path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"></path><polyline points="14 2 14 8 20 8"></polyline><line x1="12" y1="18" x2="12" y2="12"></line><line x1="9" y1="15" x2="15" y2="15"></line>', "file-text": '<path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"></path><polyline points="14 2 14 8 20 8"></polyline><line x1="16" y1="13" x2="8" y2="13"></line><line x1="16" y1="17" x2="8" y2="17"></line><polyline points="10 9 9 9 8 9"></polyline>', file: '<path d="M13 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V9z"></path><polyline points="13 2 13 9 20 9"></polyline>', film: '<rect x="2" y="2" width="20" height="20" rx="2.18" ry="2.18"></rect><line x1="7" y1="2" x2="7" y2="22"></line><line x1="17" y1="2" x2="17" y2="22"></line><line x1="2" y1="12" x2="22" y2="12"></line><line x1="2" y1="7" x2="7" y2="7"></line><line x1="2" y1="17" x2="7" y2="17"></line><line x1="17" y1="17" x2="22" y2="17"></line><line x1="17" y1="7" x2="22" y2="7"></line>', filter: '<polygon points="22 3 2 3 10 12.46 10 19 14 21 14 12.46 22 3"></polygon>', flag: '<path d="M4 15s1-1 4-1 5 2 8 2 4-1 4-1V3s-1 1-4 1-5-2-8-2-4 1-4 1z"></path><line x1="4" y1="22" x2="4" y2="15"></line>', "folder-minus": '<path d="M22 19a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h5l2 3h9a2 2 0 0 1 2 2z"></path><line x1="9" y1="14" x2="15" y2="14"></line>', "folder-plus": '<path d="M22 19a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h5l2 3h9a2 2 0 0 1 2 2z"></path><line x1="12" y1="11" x2="12" y2="17"></line><line x1="9" y1="14" x2="15" y2="14"></line>', folder: '<path d="M22 19a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h5l2 3h9a2 2 0 0 1 2 2z"></path>', framer: '<path d="M5 16V9h14V2H5l14 14h-7m-7 0l7 7v-7m-7 0h7"></path>', frown: '<circle cx="12" cy="12" r="10"></circle><path d="M16 16s-1.5-2-4-2-4 2-4 2"></path><line x1="9" y1="9" x2="9.01" y2="9"></line><line x1="15" y1="9" x2="15.01" y2="9"></line>', gift: '<polyline points="20 12 20 22 4 22 4 12"></polyline><rect x="2" y="7" width="20" height="5"></rect><line x1="12" y1="22" x2="12" y2="7"></line><path d="M12 7H7.5a2.5 2.5 0 0 1 0-5C11 2 12 7 12 7z"></path><path d="M12 7h4.5a2.5 2.5 0 0 0 0-5C13 2 12 7 12 7z"></path>', "git-branch": '<line x1="6" y1="3" x2="6" y2="15"></line><circle cx="18" cy="6" r="3"></circle><circle cx="6" cy="18" r="3"></circle><path d="M18 9a9 9 0 0 1-9 9"></path>', "git-commit": '<circle cx="12" cy="12" r="4"></circle><line x1="1.05" y1="12" x2="7" y2="12"></line><line x1="17.01" y1="12" x2="22.96" y2="12"></line>', "git-merge": '<circle cx="18" cy="18" r="3"></circle><circle cx="6" cy="6" r="3"></circle><path d="M6 21V9a9 9 0 0 0 9 9"></path>', "git-pull-request": '<circle cx="18" cy="18" r="3"></circle><circle cx="6" cy="6" r="3"></circle><path d="M13 6h3a2 2 0 0 1 2 2v7"></path><line x1="6" y1="9" x2="6" y2="21"></line>', github: '<path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37 0 0 0-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44 0 0 0 20 4.77 5.07 5.07 0 0 0 19.91 1S18.73.65 16 2.48a13.38 13.38 0 0 0-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07 0 0 0 5 4.77a5.44 5.44 0 0 0-1.5 3.78c0 5.42 3.3 6.61 6.44 7A3.37 3.37 0 0 0 9 18.13V22"></path>', gitlab: '<path d="M22.65 14.39L12 22.13 1.35 14.39a.84.84 0 0 1-.3-.94l1.22-3.78 2.44-7.51A.42.42 0 0 1 4.82 2a.43.43 0 0 1 .58 0 .42.42 0 0 1 .11.18l2.44 7.49h8.1l2.44-7.51A.42.42 0 0 1 18.6 2a.43.43 0 0 1 .58 0 .42.42 0 0 1 .11.18l2.44 7.51L23 13.45a.84.84 0 0 1-.35.94z"></path>', globe: '<circle cx="12" cy="12" r="10"></circle><line x1="2" y1="12" x2="22" y2="12"></line><path d="M12 2a15.3 15.3 0 0 1 4 10 15.3 15.3 0 0 1-4 10 15.3 15.3 0 0 1-4-10 15.3 15.3 0 0 1 4-10z"></path>', grid: '<rect x="3" y="3" width="7" height="7"></rect><rect x="14" y="3" width="7" height="7"></rect><rect x="14" y="14" width="7" height="7"></rect><rect x="3" y="14" width="7" height="7"></rect>', "hard-drive": '<line x1="22" y1="12" x2="2" y2="12"></line><path d="M5.45 5.11L2 12v6a2 2 0 0 0 2 2h16a2 2 0 0 0 2-2v-6l-3.45-6.89A2 2 0 0 0 16.76 4H7.24a2 2 0 0 0-1.79 1.11z"></path><line x1="6" y1="16" x2="6.01" y2="16"></line><line x1="10" y1="16" x2="10.01" y2="16"></line>', hash: '<line x1="4" y1="9" x2="20" y2="9"></line><line x1="4" y1="15" x2="20" y2="15"></line><line x1="10" y1="3" x2="8" y2="21"></line><line x1="16" y1="3" x2="14" y2="21"></line>', headphones: '<path d="M3 18v-6a9 9 0 0 1 18 0v6"></path><path d="M21 19a2 2 0 0 1-2 2h-1a2 2 0 0 1-2-2v-3a2 2 0 0 1 2-2h3zM3 19a2 2 0 0 0 2 2h1a2 2 0 0 0 2-2v-3a2 2 0 0 0-2-2H3z"></path>', heart: '<path d="M20.84 4.61a5.5 5.5 0 0 0-7.78 0L12 5.67l-1.06-1.06a5.5 5.5 0 0 0-7.78 7.78l1.06 1.06L12 21.23l7.78-7.78 1.06-1.06a5.5 5.5 0 0 0 0-7.78z"></path>', "help-circle": '<circle cx="12" cy="12" r="10"></circle><path d="M9.09 9a3 3 0 0 1 5.83 1c0 2-3 3-3 3"></path><line x1="12" y1="17" x2="12.01" y2="17"></line>', hexagon: '<path d="M21 16V8a2 2 0 0 0-1-1.73l-7-4a2 2 0 0 0-2 0l-7 4A2 2 0 0 0 3 8v8a2 2 0 0 0 1 1.73l7 4a2 2 0 0 0 2 0l7-4A2 2 0 0 0 21 16z"></path>', home: '<path d="M3 9l9-7 9 7v11a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2z"></path><polyline points="9 22 9 12 15 12 15 22"></polyline>', image: '<rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect><circle cx="8.5" cy="8.5" r="1.5"></circle><polyline points="21 15 16 10 5 21"></polyline>', inbox: '<polyline points="22 12 16 12 14 15 10 15 8 12 2 12"></polyline><path d="M5.45 5.11L2 12v6a2 2 0 0 0 2 2h16a2 2 0 0 0 2-2v-6l-3.45-6.89A2 2 0 0 0 16.76 4H7.24a2 2 0 0 0-1.79 1.11z"></path>', info: '<circle cx="12" cy="12" r="10"></circle><line x1="12" y1="16" x2="12" y2="12"></line><line x1="12" y1="8" x2="12.01" y2="8"></line>', instagram: '<rect x="2" y="2" width="20" height="20" rx="5" ry="5"></rect><path d="M16 11.37A4 4 0 1 1 12.63 8 4 4 0 0 1 16 11.37z"></path><line x1="17.5" y1="6.5" x2="17.51" y2="6.5"></line>', italic: '<line x1="19" y1="4" x2="10" y2="4"></line><line x1="14" y1="20" x2="5" y2="20"></line><line x1="15" y1="4" x2="9" y2="20"></line>', key: '<path d="M21 2l-2 2m-7.61 7.61a5.5 5.5 0 1 1-7.778 7.778 5.5 5.5 0 0 1 7.777-7.777zm0 0L15.5 7.5m0 0l3 3L22 7l-3-3m-3.5 3.5L19 4"></path>', layers: '<polygon points="12 2 2 7 12 12 22 7 12 2"></polygon><polyline points="2 17 12 22 22 17"></polyline><polyline points="2 12 12 17 22 12"></polyline>', layout: '<rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect><line x1="3" y1="9" x2="21" y2="9"></line><line x1="9" y1="21" x2="9" y2="9"></line>', "life-buoy": '<circle cx="12" cy="12" r="10"></circle><circle cx="12" cy="12" r="4"></circle><line x1="4.93" y1="4.93" x2="9.17" y2="9.17"></line><line x1="14.83" y1="14.83" x2="19.07" y2="19.07"></line><line x1="14.83" y1="9.17" x2="19.07" y2="4.93"></line><line x1="14.83" y1="9.17" x2="18.36" y2="5.64"></line><line x1="4.93" y1="19.07" x2="9.17" y2="14.83"></line>', "link-2": '<path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line>', link: '<path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path>', linkedin: '<path d="M16 8a6 6 0 0 1 6 6v7h-4v-7a2 2 0 0 0-2-2 2 2 0 0 0-2 2v7h-4v-7a6 6 0 0 1 6-6z"></path><rect x="2" y="9" width="4" height="12"></rect><circle cx="4" cy="4" r="2"></circle>', list: '<line x1="8" y1="6" x2="21" y2="6"></line><line x1="8" y1="12" x2="21" y2="12"></line><line x1="8" y1="18" x2="21" y2="18"></line><line x1="3" y1="6" x2="3.01" y2="6"></line><line x1="3" y1="12" x2="3.01" y2="12"></line><line x1="3" y1="18" x2="3.01" y2="18"></line>', loader: '<line x1="12" y1="2" x2="12" y2="6"></line><line x1="12" y1="18" x2="12" y2="22"></line><line x1="4.93" y1="4.93" x2="7.76" y2="7.76"></line><line x1="16.24" y1="16.24" x2="19.07" y2="19.07"></line><line x1="2" y1="12" x2="6" y2="12"></line><line x1="18" y1="12" x2="22" y2="12"></line><line x1="4.93" y1="19.07" x2="7.76" y2="16.24"></line><line x1="16.24" y1="7.76" x2="19.07" y2="4.93"></line>', lock: '<rect x="3" y="11" width="18" height="11" rx="2" ry="2"></rect><path d="M7 11V7a5 5 0 0 1 10 0v4"></path>', "log-in": '<path d="M15 3h4a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2h-4"></path><polyline points="10 17 15 12 10 7"></polyline><line x1="15" y1="12" x2="3" y2="12"></line>', "log-out": '<path d="M9 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h4"></path><polyline points="16 17 21 12 16 7"></polyline><line x1="21" y1="12" x2="9" y2="12"></line>', mail: '<path d="M4 4h16c1.1 0 2 .9 2 2v12c0 1.1-.9 2-2 2H4c-1.1 0-2-.9-2-2V6c0-1.1.9-2 2-2z"></path><polyline points="22,6 12,13 2,6"></polyline>', "map-pin": '<path d="M21 10c0 7-9 13-9 13s-9-6-9-13a9 9 0 0 1 18 0z"></path><circle cx="12" cy="10" r="3"></circle>', map: '<polygon points="1 6 1 22 8 18 16 22 23 18 23 2 16 6 8 2 1 6"></polygon><line x1="8" y1="2" x2="8" y2="18"></line><line x1="16" y1="6" x2="16" y2="22"></line>', "maximize-2": '<polyline points="15 3 21 3 21 9"></polyline><polyline points="9 21 3 21 3 15"></polyline><line x1="21" y1="3" x2="14" y2="10"></line><line x1="3" y1="21" x2="10" y2="14"></line>', maximize: '<path d="M8 3H5a2 2 0 0 0-2 2v3m18 0V5a2 2 0 0 0-2-2h-3m0 18h3a2 2 0 0 0 2-2v-3M3 16v3a2 2 0 0 0 2 2h3"></path>', meh: '<circle cx="12" cy="12" r="10"></circle><line x1="8" y1="15" x2="16" y2="15"></line><line x1="9" y1="9" x2="9.01" y2="9"></line><line x1="15" y1="9" x2="15.01" y2="9"></line>', menu: '<line x1="3" y1="12" x2="21" y2="12"></line><line x1="3" y1="6" x2="21" y2="6"></line><line x1="3" y1="18" x2="21" y2="18"></line>', "message-circle": '<path d="M21 11.5a8.38 8.38 0 0 1-.9 3.8 8.5 8.5 0 0 1-7.6 4.7 8.38 8.38 0 0 1-3.8-.9L3 21l1.9-5.7a8.38 8.38 0 0 1-.9-3.8 8.5 8.5 0 0 1 4.7-7.6 8.38 8.38 0 0 1 3.8-.9h.5a8.48 8.48 0 0 1 8 8v.5z"></path>', "message-square": '<path d="M21 15a2 2 0 0 1-2 2H7l-4 4V5a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2z"></path>', "mic-off": '<line x1="1" y1="1" x2="23" y2="23"></line><path d="M9 9v3a3 3 0 0 0 5.12 2.12M15 9.34V4a3 3 0 0 0-5.94-.6"></path><path d="M17 16.95A7 7 0 0 1 5 12v-2m14 0v2a7 7 0 0 1-.11 1.23"></path><line x1="12" y1="19" x2="12" y2="23"></line><line x1="8" y1="23" x2="16" y2="23"></line>', mic: '<path d="M12 1a3 3 0 0 0-3 3v8a3 3 0 0 0 6 0V4a3 3 0 0 0-3-3z"></path><path d="M19 10v2a7 7 0 0 1-14 0v-2"></path><line x1="12" y1="19" x2="12" y2="23"></line><line x1="8" y1="23" x2="16" y2="23"></line>', "minimize-2": '<polyline points="4 14 10 14 10 20"></polyline><polyline points="20 10 14 10 14 4"></polyline><line x1="14" y1="10" x2="21" y2="3"></line><line x1="3" y1="21" x2="10" y2="14"></line>', minimize: '<path d="M8 3v3a2 2 0 0 1-2 2H3m18 0h-3a2 2 0 0 1-2-2V3m0 18v-3a2 2 0 0 1 2-2h3M3 16h3a2 2 0 0 1 2 2v3"></path>', "minus-circle": '<circle cx="12" cy="12" r="10"></circle><line x1="8" y1="12" x2="16" y2="12"></line>', "minus-square": '<rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect><line x1="8" y1="12" x2="16" y2="12"></line>', minus: '<line x1="5" y1="12" x2="19" y2="12"></line>', monitor: '<rect x="2" y="3" width="20" height="14" rx="2" ry="2"></rect><line x1="8" y1="21" x2="16" y2="21"></line><line x1="12" y1="17" x2="12" y2="21"></line>', moon: '<path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>', "more-horizontal": '<circle cx="12" cy="12" r="1"></circle><circle cx="19" cy="12" r="1"></circle><circle cx="5" cy="12" r="1"></circle>', "more-vertical": '<circle cx="12" cy="12" r="1"></circle><circle cx="12" cy="5" r="1"></circle><circle cx="12" cy="19" r="1"></circle>', "mouse-pointer": '<path d="M3 3l7.07 16.97 2.51-7.39 7.39-2.51L3 3z"></path><path d="M13 13l6 6"></path>', move: '<polyline points="5 9 2 12 5 15"></polyline><polyline points="9 5 12 2 15 5"></polyline><polyline points="15 19 12 22 9 19"></polyline><polyline points="19 9 22 12 19 15"></polyline><line x1="2" y1="12" x2="22" y2="12"></line><line x1="12" y1="2" x2="12" y2="22"></line>', music: '<path d="M9 18V5l12-2v13"></path><circle cx="6" cy="18" r="3"></circle><circle cx="18" cy="16" r="3"></circle>', "navigation-2": '<polygon points="12 2 19 21 12 17 5 21 12 2"></polygon>', navigation: '<polygon points="3 11 22 2 13 21 11 13 3 11"></polygon>', octagon: '<polygon points="7.86 2 16.14 2 22 7.86 22 16.14 16.14 22 7.86 22 2 16.14 2 7.86 7.86 2"></polygon>', package: '<line x1="16.5" y1="9.4" x2="7.5" y2="4.21"></line><path d="M21 16V8a2 2 0 0 0-1-1.73l-7-4a2 2 0 0 0-2 0l-7 4A2 2 0 0 0 3 8v8a2 2 0 0 0 1 1.73l7 4a2 2 0 0 0 2 0l7-4A2 2 0 0 0 21 16z"></path><polyline points="3.27 6.96 12 12.01 20.73 6.96"></polyline><line x1="12" y1="22.08" x2="12" y2="12"></line>', paperclip: '<path d="M21.44 11.05l-9.19 9.19a6 6 0 0 1-8.49-8.49l9.19-9.19a4 4 0 0 1 5.66 5.66l-9.2 9.19a2 2 0 0 1-2.83-2.83l8.49-8.48"></path>', "pause-circle": '<circle cx="12" cy="12" r="10"></circle><line x1="10" y1="15" x2="10" y2="9"></line><line x1="14" y1="15" x2="14" y2="9"></line>', pause: '<rect x="6" y="4" width="4" height="16"></rect><rect x="14" y="4" width="4" height="16"></rect>', "pen-tool": '<path d="M12 19l7-7 3 3-7 7-3-3z"></path><path d="M18 13l-1.5-7.5L2 2l3.5 14.5L13 18l5-5z"></path><path d="M2 2l7.586 7.586"></path><circle cx="11" cy="11" r="2"></circle>', percent: '<line x1="19" y1="5" x2="5" y2="19"></line><circle cx="6.5" cy="6.5" r="2.5"></circle><circle cx="17.5" cy="17.5" r="2.5"></circle>', "phone-call": '<path d="M15.05 5A5 5 0 0 1 19 8.95M15.05 1A9 9 0 0 1 23 8.94m-1 7.98v3a2 2 0 0 1-2.18 2 19.79 19.79 0 0 1-8.63-3.07 19.5 19.5 0 0 1-6-6 19.79 19.79 0 0 1-3.07-8.67A2 2 0 0 1 4.11 2h3a2 2 0 0 1 2 1.72 12.84 12.84 0 0 0 .7 2.81 2 2 0 0 1-.45 2.11L8.09 9.91a16 16 0 0 0 6 6l1.27-1.27a2 2 0 0 1 2.11-.45 12.84 12.84 0 0 0 2.81.7A2 2 0 0 1 22 16.92z"></path>', "phone-forwarded": '<polyline points="19 1 23 5 19 9"></polyline><line x1="15" y1="5" x2="23" y2="5"></line><path d="M22 16.92v3a2 2 0 0 1-2.18 2 19.79 19.79 0 0 1-8.63-3.07 19.5 19.5 0 0 1-6-6 19.79 19.79 0 0 1-3.07-8.67A2 2 0 0 1 4.11 2h3a2 2 0 0 1 2 1.72 12.84 12.84 0 0 0 .7 2.81 2 2 0 0 1-.45 2.11L8.09 9.91a16 16 0 0 0 6 6l1.27-1.27a2 2 0 0 1 2.11-.45 12.84 12.84 0 0 0 2.81.7A2 2 0 0 1 22 16.92z"></path>', "phone-incoming": '<polyline points="16 2 16 8 22 8"></polyline><line x1="23" y1="1" x2="16" y2="8"></line><path d="M22 16.92v3a2 2 0 0 1-2.18 2 19.79 19.79 0 0 1-8.63-3.07 19.5 19.5 0 0 1-6-6 19.79 19.79 0 0 1-3.07-8.67A2 2 0 0 1 4.11 2h3a2 2 0 0 1 2 1.72 12.84 12.84 0 0 0 .7 2.81 2 2 0 0 1-.45 2.11L8.09 9.91a16 16 0 0 0 6 6l1.27-1.27a2 2 0 0 1 2.11-.45 12.84 12.84 0 0 0 2.81.7A2 2 0 0 1 22 16.92z"></path>', "phone-missed": '<line x1="23" y1="1" x2="17" y2="7"></line><line x1="17" y1="1" x2="23" y2="7"></line><path d="M22 16.92v3a2 2 0 0 1-2.18 2 19.79 19.79 0 0 1-8.63-3.07 19.5 19.5 0 0 1-6-6 19.79 19.79 0 0 1-3.07-8.67A2 2 0 0 1 4.11 2h3a2 2 0 0 1 2 1.72 12.84 12.84 0 0 0 .7 2.81 2 2 0 0 1-.45 2.11L8.09 9.91a16 16 0 0 0 6 6l1.27-1.27a2 2 0 0 1 2.11-.45 12.84 12.84 0 0 0 2.81.7A2 2 0 0 1 22 16.92z"></path>', "phone-off": '<path d="M10.68 13.31a16 16 0 0 0 3.41 2.6l1.27-1.27a2 2 0 0 1 2.11-.45 12.84 12.84 0 0 0 2.81.7 2 2 0 0 1 1.72 2v3a2 2 0 0 1-2.18 2 19.79 19.79 0 0 1-8.63-3.07 19.42 19.42 0 0 1-3.33-2.67m-2.67-3.34a19.79 19.79 0 0 1-3.07-8.63A2 2 0 0 1 4.11 2h3a2 2 0 0 1 2 1.72 12.84 12.84 0 0 0 .7 2.81 2 2 0 0 1-.45 2.11L8.09 9.91"></path><line x1="23" y1="1" x2="1" y2="23"></line>', "phone-outgoing": '<polyline points="23 7 23 1 17 1"></polyline><line x1="16" y1="8" x2="23" y2="1"></line><path d="M22 16.92v3a2 2 0 0 1-2.18 2 19.79 19.79 0 0 1-8.63-3.07 19.5 19.5 0 0 1-6-6 19.79 19.79 0 0 1-3.07-8.67A2 2 0 0 1 4.11 2h3a2 2 0 0 1 2 1.72 12.84 12.84 0 0 0 .7 2.81 2 2 0 0 1-.45 2.11L8.09 9.91a16 16 0 0 0 6 6l1.27-1.27a2 2 0 0 1 2.11-.45 12.84 12.84 0 0 0 2.81.7A2 2 0 0 1 22 16.92z"></path>', phone: '<path d="M22 16.92v3a2 2 0 0 1-2.18 2 19.79 19.79 0 0 1-8.63-3.07 19.5 19.5 0 0 1-6-6 19.79 19.79 0 0 1-3.07-8.67A2 2 0 0 1 4.11 2h3a2 2 0 0 1 2 1.72 12.84 12.84 0 0 0 .7 2.81 2 2 0 0 1-.45 2.11L8.09 9.91a16 16 0 0 0 6 6l1.27-1.27a2 2 0 0 1 2.11-.45 12.84 12.84 0 0 0 2.81.7A2 2 0 0 1 22 16.92z"></path>', "pie-chart": '<path d="M21.21 15.89A10 10 0 1 1 8 2.83"></path><path d="M22 12A10 10 0 0 0 12 2v10z"></path>', "play-circle": '<circle cx="12" cy="12" r="10"></circle><polygon points="10 8 16 12 10 16 10 8"></polygon>', play: '<polygon points="5 3 19 12 5 21 5 3"></polygon>', "plus-circle": '<circle cx="12" cy="12" r="10"></circle><line x1="12" y1="8" x2="12" y2="16"></line><line x1="8" y1="12" x2="16" y2="12"></line>', "plus-square": '<rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect><line x1="12" y1="8" x2="12" y2="16"></line><line x1="8" y1="12" x2="16" y2="12"></line>', plus: '<line x1="12" y1="5" x2="12" y2="19"></line><line x1="5" y1="12" x2="19" y2="12"></line>', pocket: '<path d="M4 3h16a2 2 0 0 1 2 2v6a10 10 0 0 1-10 10A10 10 0 0 1 2 11V5a2 2 0 0 1 2-2z"></path><polyline points="8 10 12 14 16 10"></polyline>', power: '<path d="M18.36 6.64a9 9 0 1 1-12.73 0"></path><line x1="12" y1="2" x2="12" y2="12"></line>', printer: '<polyline points="6 9 6 2 18 2 18 9"></polyline><path d="M6 18H4a2 2 0 0 1-2-2v-5a2 2 0 0 1 2-2h16a2 2 0 0 1 2 2v5a2 2 0 0 1-2 2h-2"></path><rect x="6" y="14" width="12" height="8"></rect>', radio: '<circle cx="12" cy="12" r="2"></circle><path d="M16.24 7.76a6 6 0 0 1 0 8.49m-8.48-.01a6 6 0 0 1 0-8.49m11.31-2.82a10 10 0 0 1 0 14.14m-14.14 0a10 10 0 0 1 0-14.14"></path>', "refresh-ccw": '<polyline points="1 4 1 10 7 10"></polyline><polyline points="23 20 23 14 17 14"></polyline><path d="M20.49 9A9 9 0 0 0 5.64 5.64L1 10m22 4l-4.64 4.36A9 9 0 0 1 3.51 15"></path>', "refresh-cw": '<polyline points="23 4 23 10 17 10"></polyline><polyline points="1 20 1 14 7 14"></polyline><path d="M3.51 9a9 9 0 0 1 14.85-3.36L23 10M1 14l4.64 4.36A9 9 0 0 0 20.49 15"></path>', repeat: '<polyline points="17 1 21 5 17 9"></polyline><path d="M3 11V9a4 4 0 0 1 4-4h14"></path><polyline points="7 23 3 19 7 15"></polyline><path d="M21 13v2a4 4 0 0 1-4 4H3"></path>', rewind: '<polygon points="11 19 2 12 11 5 11 19"></polygon><polygon points="22 19 13 12 22 5 22 19"></polygon>', "rotate-ccw": '<polyline points="1 4 1 10 7 10"></polyline><path d="M3.51 15a9 9 0 1 0 2.13-9.36L1 10"></path>', "rotate-cw": '<polyline points="23 4 23 10 17 10"></polyline><path d="M20.49 15a9 9 0 1 1-2.12-9.36L23 10"></path>', rss: '<path d="M4 11a9 9 0 0 1 9 9"></path><path d="M4 4a16 16 0 0 1 16 16"></path><circle cx="5" cy="19" r="1"></circle>', save: '<path d="M19 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11l5 5v11a2 2 0 0 1-2 2z"></path><polyline points="17 21 17 13 7 13 7 21"></polyline><polyline points="7 3 7 8 15 8"></polyline>', scissors: '<circle cx="6" cy="6" r="3"></circle><circle cx="6" cy="18" r="3"></circle><line x1="20" y1="4" x2="8.12" y2="15.88"></line><line x1="14.47" y1="14.48" x2="20" y2="20"></line><line x1="8.12" y1="8.12" x2="12" y2="12"></line>', search: '<circle cx="11" cy="11" r="8"></circle><line x1="21" y1="21" x2="16.65" y2="16.65"></line>', send: '<line x1="22" y1="2" x2="11" y2="13"></line><polygon points="22 2 15 22 11 13 2 9 22 2"></polygon>', server: '<rect x="2" y="2" width="20" height="8" rx="2" ry="2"></rect><rect x="2" y="14" width="20" height="8" rx="2" ry="2"></rect><line x1="6" y1="6" x2="6.01" y2="6"></line><line x1="6" y1="18" x2="6.01" y2="18"></line>', settings: '<circle cx="12" cy="12" r="3"></circle><path d="M19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a2 2 0 0 1 0 2.83 2 2 0 0 1-2.83 0l-.06-.06a1.65 1.65 0 0 0-1.82-.33 1.65 1.65 0 0 0-1 1.51V21a2 2 0 0 1-2 2 2 2 0 0 1-2-2v-.09A1.65 1.65 0 0 0 9 19.4a1.65 1.65 0 0 0-1.82.33l-.06.06a2 2 0 0 1-2.83 0 2 2 0 0 1 0-2.83l.06-.06a1.65 1.65 0 0 0 .33-1.82 1.65 1.65 0 0 0-1.51-1H3a2 2 0 0 1-2-2 2 2 0 0 1 2-2h.09A1.65 1.65 0 0 0 4.6 9a1.65 1.65 0 0 0-.33-1.82l-.06-.06a2 2 0 0 1 0-2.83 2 2 0 0 1 2.83 0l.06.06a1.65 1.65 0 0 0 1.82.33H9a1.65 1.65 0 0 0 1-1.51V3a2 2 0 0 1 2-2 2 2 0 0 1 2 2v.09a1.65 1.65 0 0 0 1 1.51 1.65 1.65 0 0 0 1.82-.33l.06-.06a2 2 0 0 1 2.83 0 2 2 0 0 1 0 2.83l-.06.06a1.65 1.65 0 0 0-.33 1.82V9a1.65 1.65 0 0 0 1.51 1H21a2 2 0 0 1 2 2 2 2 0 0 1-2 2h-.09a1.65 1.65 0 0 0-1.51 1z"></path>', "share-2": '<circle cx="18" cy="5" r="3"></circle><circle cx="6" cy="12" r="3"></circle><circle cx="18" cy="19" r="3"></circle><line x1="8.59" y1="13.51" x2="15.42" y2="17.49"></line><line x1="15.41" y1="6.51" x2="8.59" y2="10.49"></line>', share: '<path d="M4 12v8a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2v-8"></path><polyline points="16 6 12 2 8 6"></polyline><line x1="12" y1="2" x2="12" y2="15"></line>', "shield-off": '<path d="M19.69 14a6.9 6.9 0 0 0 .31-2V5l-8-3-3.16 1.18"></path><path d="M4.73 4.73L4 5v7c0 6 8 10 8 10a20.29 20.29 0 0 0 5.62-4.38"></path><line x1="1" y1="1" x2="23" y2="23"></line>', shield: '<path d="M12 22s8-4 8-10V5l-8-3-8 3v7c0 6 8 10 8 10z"></path>', "shopping-bag": '<path d="M6 2L3 6v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2V6l-3-4z"></path><line x1="3" y1="6" x2="21" y2="6"></line><path d="M16 10a4 4 0 0 1-8 0"></path>', "shopping-cart": '<circle cx="9" cy="21" r="1"></circle><circle cx="20" cy="21" r="1"></circle><path d="M1 1h4l2.68 13.39a2 2 0 0 0 2 1.61h9.72a2 2 0 0 0 2-1.61L23 6H6"></path>', shuffle: '<polyline points="16 3 21 3 21 8"></polyline><line x1="4" y1="20" x2="21" y2="3"></line><polyline points="21 16 21 21 16 21"></polyline><line x1="15" y1="15" x2="21" y2="21"></line><line x1="4" y1="4" x2="9" y2="9"></line>', sidebar: '<rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect><line x1="9" y1="3" x2="9" y2="21"></line>', "skip-back": '<polygon points="19 20 9 12 19 4 19 20"></polygon><line x1="5" y1="19" x2="5" y2="5"></line>', "skip-forward": '<polygon points="5 4 15 12 5 20 5 4"></polygon><line x1="19" y1="5" x2="19" y2="19"></line>', slack: '<path d="M14.5 10c-.83 0-1.5-.67-1.5-1.5v-5c0-.83.67-1.5 1.5-1.5s1.5.67 1.5 1.5v5c0 .83-.67 1.5-1.5 1.5z"></path><path d="M20.5 10H19V8.5c0-.83.67-1.5 1.5-1.5s1.5.67 1.5 1.5-.67 1.5-1.5 1.5z"></path><path d="M9.5 14c.83 0 1.5.67 1.5 1.5v5c0 .83-.67 1.5-1.5 1.5S8 21.33 8 20.5v-5c0-.83.67-1.5 1.5-1.5z"></path><path d="M3.5 14H5v1.5c0 .83-.67 1.5-1.5 1.5S2 16.33 2 15.5 2.67 14 3.5 14z"></path><path d="M14 14.5c0-.83.67-1.5 1.5-1.5h5c.83 0 1.5.67 1.5 1.5s-.67 1.5-1.5 1.5h-5c-.83 0-1.5-.67-1.5-1.5z"></path><path d="M15.5 19H14v1.5c0 .83.67 1.5 1.5 1.5s1.5-.67 1.5-1.5-.67-1.5-1.5-1.5z"></path><path d="M10 9.5C10 8.67 9.33 8 8.5 8h-5C2.67 8 2 8.67 2 9.5S2.67 11 3.5 11h5c.83 0 1.5-.67 1.5-1.5z"></path><path d="M8.5 5H10V3.5C10 2.67 9.33 2 8.5 2S7 2.67 7 3.5 7.67 5 8.5 5z"></path>', slash: '<circle cx="12" cy="12" r="10"></circle><line x1="4.93" y1="4.93" x2="19.07" y2="19.07"></line>', sliders: '<line x1="4" y1="21" x2="4" y2="14"></line><line x1="4" y1="10" x2="4" y2="3"></line><line x1="12" y1="21" x2="12" y2="12"></line><line x1="12" y1="8" x2="12" y2="3"></line><line x1="20" y1="21" x2="20" y2="16"></line><line x1="20" y1="12" x2="20" y2="3"></line><line x1="1" y1="14" x2="7" y2="14"></line><line x1="9" y1="8" x2="15" y2="8"></line><line x1="17" y1="16" x2="23" y2="16"></line>', smartphone: '<rect x="5" y="2" width="14" height="20" rx="2" ry="2"></rect><line x1="12" y1="18" x2="12.01" y2="18"></line>', smile: '<circle cx="12" cy="12" r="10"></circle><path d="M8 14s1.5 2 4 2 4-2 4-2"></path><line x1="9" y1="9" x2="9.01" y2="9"></line><line x1="15" y1="9" x2="15.01" y2="9"></line>', speaker: '<rect x="4" y="2" width="16" height="20" rx="2" ry="2"></rect><circle cx="12" cy="14" r="4"></circle><line x1="12" y1="6" x2="12.01" y2="6"></line>', square: '<rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect>', star: '<polygon points="12 2 15.09 8.26 22 9.27 17 14.14 18.18 21.02 12 17.77 5.82 21.02 7 14.14 2 9.27 8.91 8.26 12 2"></polygon>', "stop-circle": '<circle cx="12" cy="12" r="10"></circle><rect x="9" y="9" width="6" height="6"></rect>', sun: '<circle cx="12" cy="12" r="5"></circle><line x1="12" y1="1" x2="12" y2="3"></line><line x1="12" y1="21" x2="12" y2="23"></line><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line><line x1="1" y1="12" x2="3" y2="12"></line><line x1="21" y1="12" x2="23" y2="12"></line><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>', sunrise: '<path d="M17 18a5 5 0 0 0-10 0"></path><line x1="12" y1="2" x2="12" y2="9"></line><line x1="4.22" y1="10.22" x2="5.64" y2="11.64"></line><line x1="1" y1="18" x2="3" y2="18"></line><line x1="21" y1="18" x2="23" y2="18"></line><line x1="18.36" y1="11.64" x2="19.78" y2="10.22"></line><line x1="23" y1="22" x2="1" y2="22"></line><polyline points="8 6 12 2 16 6"></polyline>', sunset: '<path d="M17 18a5 5 0 0 0-10 0"></path><line x1="12" y1="9" x2="12" y2="2"></line><line x1="4.22" y1="10.22" x2="5.64" y2="11.64"></line><line x1="1" y1="18" x2="3" y2="18"></line><line x1="21" y1="18" x2="23" y2="18"></line><line x1="18.36" y1="11.64" x2="19.78" y2="10.22"></line><line x1="23" y1="22" x2="1" y2="22"></line><polyline points="16 5 12 9 8 5"></polyline>', table: '<path d="M9 3H5a2 2 0 0 0-2 2v4m6-6h10a2 2 0 0 1 2 2v4M9 3v18m0 0h10a2 2 0 0 0 2-2V9M9 21H5a2 2 0 0 1-2-2V9m0 0h18"></path>', tablet: '<rect x="4" y="2" width="16" height="20" rx="2" ry="2"></rect><line x1="12" y1="18" x2="12.01" y2="18"></line>', tag: '<path d="M20.59 13.41l-7.17 7.17a2 2 0 0 1-2.83 0L2 12V2h10l8.59 8.59a2 2 0 0 1 0 2.82z"></path><line x1="7" y1="7" x2="7.01" y2="7"></line>', target: '<circle cx="12" cy="12" r="10"></circle><circle cx="12" cy="12" r="6"></circle><circle cx="12" cy="12" r="2"></circle>', terminal: '<polyline points="4 17 10 11 4 5"></polyline><line x1="12" y1="19" x2="20" y2="19"></line>', thermometer: '<path d="M14 14.76V3.5a2.5 2.5 0 0 0-5 0v11.26a4.5 4.5 0 1 0 5 0z"></path>', "thumbs-down": '<path d="M10 15v4a3 3 0 0 0 3 3l4-9V2H5.72a2 2 0 0 0-2 1.7l-1.38 9a2 2 0 0 0 2 2.3zm7-13h2.67A2.31 2.31 0 0 1 22 4v7a2.31 2.31 0 0 1-2.33 2H17"></path>', "thumbs-up": '<path d="M14 9V5a3 3 0 0 0-3-3l-4 9v11h11.28a2 2 0 0 0 2-1.7l1.38-9a2 2 0 0 0-2-2.3zM7 22H4a2 2 0 0 1-2-2v-7a2 2 0 0 1 2-2h3"></path>', "toggle-left": '<rect x="1" y="5" width="22" height="14" rx="7" ry="7"></rect><circle cx="8" cy="12" r="3"></circle>', "toggle-right": '<rect x="1" y="5" width="22" height="14" rx="7" ry="7"></rect><circle cx="16" cy="12" r="3"></circle>', tool: '<path d="M14.7 6.3a1 1 0 0 0 0 1.4l1.6 1.6a1 1 0 0 0 1.4 0l3.77-3.77a6 6 0 0 1-7.94 7.94l-6.91 6.91a2.12 2.12 0 0 1-3-3l6.91-6.91a6 6 0 0 1 7.94-7.94l-3.76 3.76z"></path>', "trash-2": '<polyline points="3 6 5 6 21 6"></polyline><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path><line x1="10" y1="11" x2="10" y2="17"></line><line x1="14" y1="11" x2="14" y2="17"></line>', trash: '<polyline points="3 6 5 6 21 6"></polyline><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path>', trello: '<rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect><rect x="7" y="7" width="3" height="9"></rect><rect x="14" y="7" width="3" height="5"></rect>', "trending-down": '<polyline points="23 18 13.5 8.5 8.5 13.5 1 6"></polyline><polyline points="17 18 23 18 23 12"></polyline>', "trending-up": '<polyline points="23 6 13.5 15.5 8.5 10.5 1 18"></polyline><polyline points="17 6 23 6 23 12"></polyline>', triangle: '<path d="M10.29 3.86L1.82 18a2 2 0 0 0 1.71 3h16.94a2 2 0 0 0 1.71-3L13.71 3.86a2 2 0 0 0-3.42 0z"></path>', truck: '<rect x="1" y="3" width="15" height="13"></rect><polygon points="16 8 20 8 23 11 23 16 16 16 16 8"></polygon><circle cx="5.5" cy="18.5" r="2.5"></circle><circle cx="18.5" cy="18.5" r="2.5"></circle>', tv: '<rect x="2" y="7" width="20" height="15" rx="2" ry="2"></rect><polyline points="17 2 12 7 7 2"></polyline>', twitch: '<path d="M21 2H3v16h5v4l4-4h5l4-4V2zm-10 9V7m5 4V7"></path>', twitter: '<path d="M23 3a10.9 10.9 0 0 1-3.14 1.53 4.48 4.48 0 0 0-7.86 3v1A10.66 10.66 0 0 1 3 4s-4 9 5 13a11.64 11.64 0 0 1-7 2c9 5 20 0 20-11.5a4.5 4.5 0 0 0-.08-.83A7.72 7.72 0 0 0 23 3z"></path>', type: '<polyline points="4 7 4 4 20 4 20 7"></polyline><line x1="9" y1="20" x2="15" y2="20"></line><line x1="12" y1="4" x2="12" y2="20"></line>', umbrella: '<path d="M23 12a11.05 11.05 0 0 0-22 0zm-5 7a3 3 0 0 1-6 0v-7"></path>', underline: '<path d="M6 3v7a6 6 0 0 0 6 6 6 6 0 0 0 6-6V3"></path><line x1="4" y1="21" x2="20" y2="21"></line>', unlock: '<rect x="3" y="11" width="18" height="11" rx="2" ry="2"></rect><path d="M7 11V7a5 5 0 0 1 9.9-1"></path>', "upload-cloud": '<polyline points="16 16 12 12 8 16"></polyline><line x1="12" y1="12" x2="12" y2="21"></line><path d="M20.39 18.39A5 5 0 0 0 18 9h-1.26A8 8 0 1 0 3 16.3"></path><polyline points="16 16 12 12 8 16"></polyline>', upload: '<path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path><polyline points="17 8 12 3 7 8"></polyline><line x1="12" y1="3" x2="12" y2="15"></line>', "user-check": '<path d="M16 21v-2a4 4 0 0 0-4-4H5a4 4 0 0 0-4 4v2"></path><circle cx="8.5" cy="7" r="4"></circle><polyline points="17 11 19 13 23 9"></polyline>', "user-minus": '<path d="M16 21v-2a4 4 0 0 0-4-4H5a4 4 0 0 0-4 4v2"></path><circle cx="8.5" cy="7" r="4"></circle><line x1="23" y1="11" x2="17" y2="11"></line>', "user-plus": '<path d="M16 21v-2a4 4 0 0 0-4-4H5a4 4 0 0 0-4 4v2"></path><circle cx="8.5" cy="7" r="4"></circle><line x1="20" y1="8" x2="20" y2="14"></line><line x1="23" y1="11" x2="17" y2="11"></line>', "user-x": '<path d="M16 21v-2a4 4 0 0 0-4-4H5a4 4 0 0 0-4 4v2"></path><circle cx="8.5" cy="7" r="4"></circle><line x1="18" y1="8" x2="23" y2="13"></line><line x1="23" y1="8" x2="18" y2="13"></line>', user: '<path d="M20 21v-2a4 4 0 0 0-4-4H8a4 4 0 0 0-4 4v2"></path><circle cx="12" cy="7" r="4"></circle>', users: '<path d="M17 21v-2a4 4 0 0 0-4-4H5a4 4 0 0 0-4 4v2"></path><circle cx="9" cy="7" r="4"></circle><path d="M23 21v-2a4 4 0 0 0-3-3.87"></path><path d="M16 3.13a4 4 0 0 1 0 7.75"></path>', "video-off": '<path d="M16 16v1a2 2 0 0 1-2 2H3a2 2 0 0 1-2-2V7a2 2 0 0 1 2-2h2m5.66 0H14a2 2 0 0 1 2 2v3.34l1 1L23 7v10"></path><line x1="1" y1="1" x2="23" y2="23"></line>', video: '<polygon points="23 7 16 12 23 17 23 7"></polygon><rect x="1" y="5" width="15" height="14" rx="2" ry="2"></rect>', voicemail: '<circle cx="5.5" cy="11.5" r="4.5"></circle><circle cx="18.5" cy="11.5" r="4.5"></circle><line x1="5.5" y1="16" x2="18.5" y2="16"></line>', "volume-1": '<polygon points="11 5 6 9 2 9 2 15 6 15 11 19 11 5"></polygon><path d="M15.54 8.46a5 5 0 0 1 0 7.07"></path>', "volume-2": '<polygon points="11 5 6 9 2 9 2 15 6 15 11 19 11 5"></polygon><path d="M19.07 4.93a10 10 0 0 1 0 14.14M15.54 8.46a5 5 0 0 1 0 7.07"></path>', "volume-x": '<polygon points="11 5 6 9 2 9 2 15 6 15 11 19 11 5"></polygon><line x1="23" y1="9" x2="17" y2="15"></line><line x1="17" y1="9" x2="23" y2="15"></line>', volume: '<polygon points="11 5 6 9 2 9 2 15 6 15 11 19 11 5"></polygon>', watch: '<circle cx="12" cy="12" r="7"></circle><polyline points="12 9 12 12 13.5 13.5"></polyline><path d="M16.51 17.35l-.35 3.83a2 2 0 0 1-2 1.82H9.83a2 2 0 0 1-2-1.82l-.35-3.83m.01-10.7l.35-3.83A2 2 0 0 1 9.83 1h4.35a2 2 0 0 1 2 1.82l.35 3.83"></path>', "wifi-off": '<line x1="1" y1="1" x2="23" y2="23"></line><path d="M16.72 11.06A10.94 10.94 0 0 1 19 12.55"></path><path d="M5 12.55a10.94 10.94 0 0 1 5.17-2.39"></path><path d="M10.71 5.05A16 16 0 0 1 22.58 9"></path><path d="M1.42 9a15.91 15.91 0 0 1 4.7-2.88"></path><path d="M8.53 16.11a6 6 0 0 1 6.95 0"></path><line x1="12" y1="20" x2="12.01" y2="20"></line>', wifi: '<path d="M5 12.55a11 11 0 0 1 14.08 0"></path><path d="M1.42 9a16 16 0 0 1 21.16 0"></path><path d="M8.53 16.11a6 6 0 0 1 6.95 0"></path><line x1="12" y1="20" x2="12.01" y2="20"></line>', wind: '<path d="M9.59 4.59A2 2 0 1 1 11 8H2m10.59 11.41A2 2 0 1 0 14 16H2m15.73-8.27A2.5 2.5 0 1 1 19.5 12H2"></path>', "x-circle": '<circle cx="12" cy="12" r="10"></circle><line x1="15" y1="9" x2="9" y2="15"></line><line x1="9" y1="9" x2="15" y2="15"></line>', "x-octagon": '<polygon points="7.86 2 16.14 2 22 7.86 22 16.14 16.14 22 7.86 22 2 16.14 2 7.86 7.86 2"></polygon><line x1="15" y1="9" x2="9" y2="15"></line><line x1="9" y1="9" x2="15" y2="15"></line>', "x-square": '<rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect><line x1="9" y1="9" x2="15" y2="15"></line><line x1="15" y1="9" x2="9" y2="15"></line>', x: '<line x1="18" y1="6" x2="6" y2="18"></line><line x1="6" y1="6" x2="18" y2="18"></line>', youtube: '<path d="M22.54 6.42a2.78 2.78 0 0 0-1.94-2C18.88 4 12 4 12 4s-6.88 0-8.6.46a2.78 2.78 0 0 0-1.94 2A29 29 0 0 0 1 11.75a29 29 0 0 0 .46 5.33A2.78 2.78 0 0 0 3.4 19c1.72.46 8.6.46 8.6.46s6.88 0 8.6-.46a2.78 2.78 0 0 0 1.94-2 29 29 0 0 0 .46-5.25 29 29 0 0 0-.46-5.33z"></path><polygon points="9.75 15.02 15.5 11.75 9.75 8.48 9.75 15.02"></polygon>', "zap-off": '<polyline points="12.41 6.75 13 2 10.57 4.92"></polyline><polyline points="18.57 12.91 21 10 15.66 10"></polyline><polyline points="8 8 3 14 12 14 11 22 16 16"></polyline><line x1="1" y1="1" x2="23" y2="23"></line>', zap: '<polygon points="13 2 3 14 12 14 11 22 21 10 12 10 13 2"></polygon>', "zoom-in": '<circle cx="11" cy="11" r="8"></circle><line x1="21" y1="21" x2="16.65" y2="16.65"></line><line x1="11" y1="8" x2="11" y2="14"></line><line x1="8" y1="11" x2="14" y2="11"></line>', "zoom-out": '<circle cx="11" cy="11" r="8"></circle><line x1="21" y1="21" x2="16.65" y2="16.65"></line><line x1="8" y1="11" x2="14" y2="11"></line>' } }, "./node_modules/classnames/dedupe.js": function (t, r, i) {
        var a, o;/*!
  Copyright (c) 2016 Jed Watson.
  Licensed under the MIT License (MIT), see
  http://jedwatson.github.io/classnames
*/(function () { var s = function () { function l() { } l.prototype = Object.create(null); function c(y, b) { for (var w = b.length, v = 0; v < w; ++v)m(y, b[v]) } var u = {}.hasOwnProperty; function d(y, b) { y[b] = !0 } function f(y, b) { for (var w in b) u.call(b, w) && (y[w] = !!b[w]) } var h = /\s+/; function p(y, b) { for (var w = b.split(h), v = w.length, S = 0; S < v; ++S)y[w[S]] = !0 } function m(y, b) { if (b) { var w = typeof b; w === "string" ? p(y, b) : Array.isArray(b) ? c(y, b) : w === "object" ? f(y, b) : w === "number" && d(y, b) } } function g() { for (var y = arguments.length, b = Array(y), w = 0; w < y; w++)b[w] = arguments[w]; var v = new l; c(v, b); var S = []; for (var x in v) v[x] && S.push(x); return S.join(" ") } return g }(); typeof t < "u" && t.exports ? t.exports = s : (a = [], o = (function () { return s }).apply(r, a), o !== void 0 && (t.exports = o)) })()
      }, "./node_modules/core-js/es/array/from.js": function (t, r, i) { i("./node_modules/core-js/modules/es.string.iterator.js"), i("./node_modules/core-js/modules/es.array.from.js"); var a = i("./node_modules/core-js/internals/path.js"); t.exports = a.Array.from }, "./node_modules/core-js/internals/a-function.js": function (t, r) { t.exports = function (i) { if (typeof i != "function") throw TypeError(String(i) + " is not a function"); return i } }, "./node_modules/core-js/internals/an-object.js": function (t, r, i) { var a = i("./node_modules/core-js/internals/is-object.js"); t.exports = function (o) { if (!a(o)) throw TypeError(String(o) + " is not an object"); return o } }, "./node_modules/core-js/internals/array-from.js": function (t, r, i) { var a = i("./node_modules/core-js/internals/bind-context.js"), o = i("./node_modules/core-js/internals/to-object.js"), s = i("./node_modules/core-js/internals/call-with-safe-iteration-closing.js"), l = i("./node_modules/core-js/internals/is-array-iterator-method.js"), c = i("./node_modules/core-js/internals/to-length.js"), u = i("./node_modules/core-js/internals/create-property.js"), d = i("./node_modules/core-js/internals/get-iterator-method.js"); t.exports = function (h) { var p = o(h), m = typeof this == "function" ? this : Array, g = arguments.length, y = g > 1 ? arguments[1] : void 0, b = y !== void 0, w = 0, v = d(p), S, x, k, A; if (b && (y = a(y, g > 2 ? arguments[2] : void 0, 2)), v != null && !(m == Array && l(v))) for (A = v.call(p), x = new m; !(k = A.next()).done; w++)u(x, w, b ? s(A, y, [k.value, w], !0) : k.value); else for (S = c(p.length), x = new m(S); S > w; w++)u(x, w, b ? y(p[w], w) : p[w]); return x.length = w, x } }, "./node_modules/core-js/internals/array-includes.js": function (t, r, i) { var a = i("./node_modules/core-js/internals/to-indexed-object.js"), o = i("./node_modules/core-js/internals/to-length.js"), s = i("./node_modules/core-js/internals/to-absolute-index.js"); t.exports = function (l) { return function (c, u, d) { var f = a(c), h = o(f.length), p = s(d, h), m; if (l && u != u) { for (; h > p;)if (m = f[p++], m != m) return !0 } else for (; h > p; p++)if ((l || p in f) && f[p] === u) return l || p || 0; return !l && -1 } } }, "./node_modules/core-js/internals/bind-context.js": function (t, r, i) { var a = i("./node_modules/core-js/internals/a-function.js"); t.exports = function (o, s, l) { if (a(o), s === void 0) return o; switch (l) { case 0: return function () { return o.call(s) }; case 1: return function (c) { return o.call(s, c) }; case 2: return function (c, u) { return o.call(s, c, u) }; case 3: return function (c, u, d) { return o.call(s, c, u, d) } }return function () { return o.apply(s, arguments) } } }, "./node_modules/core-js/internals/call-with-safe-iteration-closing.js": function (t, r, i) { var a = i("./node_modules/core-js/internals/an-object.js"); t.exports = function (o, s, l, c) { try { return c ? s(a(l)[0], l[1]) : s(l) } catch (d) { var u = o.return; throw u !== void 0 && a(u.call(o)), d } } }, "./node_modules/core-js/internals/check-correctness-of-iteration.js": function (t, r, i) { var a = i("./node_modules/core-js/internals/well-known-symbol.js"), o = a("iterator"), s = !1; try { var l = 0, c = { next: function () { return { done: !!l++ } }, return: function () { s = !0 } }; c[o] = function () { return this }, Array.from(c, function () { throw 2 }) } catch { } t.exports = function (u, d) { if (!d && !s) return !1; var f = !1; try { var h = {}; h[o] = function () { return { next: function () { return { done: f = !0 } } } }, u(h) } catch { } return f } }, "./node_modules/core-js/internals/classof-raw.js": function (t, r) { var i = {}.toString; t.exports = function (a) { return i.call(a).slice(8, -1) } }, "./node_modules/core-js/internals/classof.js": function (t, r, i) { var a = i("./node_modules/core-js/internals/classof-raw.js"), o = i("./node_modules/core-js/internals/well-known-symbol.js"), s = o("toStringTag"), l = a(function () { return arguments }()) == "Arguments", c = function (u, d) { try { return u[d] } catch { } }; t.exports = function (u) { var d, f, h; return u === void 0 ? "Undefined" : u === null ? "Null" : typeof (f = c(d = Object(u), s)) == "string" ? f : l ? a(d) : (h = a(d)) == "Object" && typeof d.callee == "function" ? "Arguments" : h } }, "./node_modules/core-js/internals/copy-constructor-properties.js": function (t, r, i) { var a = i("./node_modules/core-js/internals/has.js"), o = i("./node_modules/core-js/internals/own-keys.js"), s = i("./node_modules/core-js/internals/object-get-own-property-descriptor.js"), l = i("./node_modules/core-js/internals/object-define-property.js"); t.exports = function (c, u) { for (var d = o(u), f = l.f, h = s.f, p = 0; p < d.length; p++) { var m = d[p]; a(c, m) || f(c, m, h(u, m)) } } }, "./node_modules/core-js/internals/correct-prototype-getter.js": function (t, r, i) { var a = i("./node_modules/core-js/internals/fails.js"); t.exports = !a(function () { function o() { } return o.prototype.constructor = null, Object.getPrototypeOf(new o) !== o.prototype }) }, "./node_modules/core-js/internals/create-iterator-constructor.js": function (t, r, i) { var a = i("./node_modules/core-js/internals/iterators-core.js").IteratorPrototype, o = i("./node_modules/core-js/internals/object-create.js"), s = i("./node_modules/core-js/internals/create-property-descriptor.js"), l = i("./node_modules/core-js/internals/set-to-string-tag.js"), c = i("./node_modules/core-js/internals/iterators.js"), u = function () { return this }; t.exports = function (d, f, h) { var p = f + " Iterator"; return d.prototype = o(a, { next: s(1, h) }), l(d, p, !1, !0), c[p] = u, d } }, "./node_modules/core-js/internals/create-property-descriptor.js": function (t, r) { t.exports = function (i, a) { return { enumerable: !(i & 1), configurable: !(i & 2), writable: !(i & 4), value: a } } }, "./node_modules/core-js/internals/create-property.js": function (t, r, i) { var a = i("./node_modules/core-js/internals/to-primitive.js"), o = i("./node_modules/core-js/internals/object-define-property.js"), s = i("./node_modules/core-js/internals/create-property-descriptor.js"); t.exports = function (l, c, u) { var d = a(c); d in l ? o.f(l, d, s(0, u)) : l[d] = u } }, "./node_modules/core-js/internals/define-iterator.js": function (t, r, i) { var a = i("./node_modules/core-js/internals/export.js"), o = i("./node_modules/core-js/internals/create-iterator-constructor.js"), s = i("./node_modules/core-js/internals/object-get-prototype-of.js"), l = i("./node_modules/core-js/internals/object-set-prototype-of.js"), c = i("./node_modules/core-js/internals/set-to-string-tag.js"), u = i("./node_modules/core-js/internals/hide.js"), d = i("./node_modules/core-js/internals/redefine.js"), f = i("./node_modules/core-js/internals/well-known-symbol.js"), h = i("./node_modules/core-js/internals/is-pure.js"), p = i("./node_modules/core-js/internals/iterators.js"), m = i("./node_modules/core-js/internals/iterators-core.js"), g = m.IteratorPrototype, y = m.BUGGY_SAFARI_ITERATORS, b = f("iterator"), w = "keys", v = "values", S = "entries", x = function () { return this }; t.exports = function (k, A, C, E, O, j, I) { o(C, A, E); var L = function (ie) { if (ie === O && F) return F; if (!y && ie in P) return P[ie]; switch (ie) { case w: return function () { return new C(this, ie) }; case v: return function () { return new C(this, ie) }; case S: return function () { return new C(this, ie) } }return function () { return new C(this) } }, R = A + " Iterator", D = !1, P = k.prototype, B = P[b] || P["@@iterator"] || O && P[O], F = !y && B || L(O), K = A == "Array" && P.entries || B, V, W, J; if (K && (V = s(K.call(new k)), g !== Object.prototype && V.next && (!h && s(V) !== g && (l ? l(V, g) : typeof V[b] != "function" && u(V, b, x)), c(V, R, !0, !0), h && (p[R] = x))), O == v && B && B.name !== v && (D = !0, F = function () { return B.call(this) }), (!h || I) && P[b] !== F && u(P, b, F), p[A] = F, O) if (W = { values: L(v), keys: j ? F : L(w), entries: L(S) }, I) for (J in W) (y || D || !(J in P)) && d(P, J, W[J]); else a({ target: A, proto: !0, forced: y || D }, W); return W } }, "./node_modules/core-js/internals/descriptors.js": function (t, r, i) { var a = i("./node_modules/core-js/internals/fails.js"); t.exports = !a(function () { return Object.defineProperty({}, "a", { get: function () { return 7 } }).a != 7 }) }, "./node_modules/core-js/internals/document-create-element.js": function (t, r, i) { var a = i("./node_modules/core-js/internals/global.js"), o = i("./node_modules/core-js/internals/is-object.js"), s = a.document, l = o(s) && o(s.createElement); t.exports = function (c) { return l ? s.createElement(c) : {} } }, "./node_modules/core-js/internals/enum-bug-keys.js": function (t, r) { t.exports = ["constructor", "hasOwnProperty", "isPrototypeOf", "propertyIsEnumerable", "toLocaleString", "toString", "valueOf"] }, "./node_modules/core-js/internals/export.js": function (t, r, i) { var a = i("./node_modules/core-js/internals/global.js"), o = i("./node_modules/core-js/internals/object-get-own-property-descriptor.js").f, s = i("./node_modules/core-js/internals/hide.js"), l = i("./node_modules/core-js/internals/redefine.js"), c = i("./node_modules/core-js/internals/set-global.js"), u = i("./node_modules/core-js/internals/copy-constructor-properties.js"), d = i("./node_modules/core-js/internals/is-forced.js"); t.exports = function (f, h) { var p = f.target, m = f.global, g = f.stat, y, b, w, v, S, x; if (m ? b = a : g ? b = a[p] || c(p, {}) : b = (a[p] || {}).prototype, b) for (w in h) { if (S = h[w], f.noTargetGet ? (x = o(b, w), v = x && x.value) : v = b[w], y = d(m ? w : p + (g ? "." : "#") + w, f.forced), !y && v !== void 0) { if (typeof S == typeof v) continue; u(S, v) } (f.sham || v && v.sham) && s(S, "sham", !0), l(b, w, S, f) } } }, "./node_modules/core-js/internals/fails.js": function (t, r) { t.exports = function (i) { try { return !!i() } catch { return !0 } } }, "./node_modules/core-js/internals/function-to-string.js": function (t, r, i) { var a = i("./node_modules/core-js/internals/shared.js"); t.exports = a("native-function-to-string", Function.toString) }, "./node_modules/core-js/internals/get-iterator-method.js": function (t, r, i) { var a = i("./node_modules/core-js/internals/classof.js"), o = i("./node_modules/core-js/internals/iterators.js"), s = i("./node_modules/core-js/internals/well-known-symbol.js"), l = s("iterator"); t.exports = function (c) { if (c != null) return c[l] || c["@@iterator"] || o[a(c)] } }, "./node_modules/core-js/internals/global.js": function (t, r, i) { (function (a) { var o = "object", s = function (l) { return l && l.Math == Math && l }; t.exports = s(typeof globalThis == o && globalThis) || s(typeof window == o && window) || s(typeof self == o && self) || s(typeof a == o && a) || Function("return this")() }).call(this, i("./node_modules/webpack/buildin/global.js")) }, "./node_modules/core-js/internals/has.js": function (t, r) { var i = {}.hasOwnProperty; t.exports = function (a, o) { return i.call(a, o) } }, "./node_modules/core-js/internals/hidden-keys.js": function (t, r) { t.exports = {} }, "./node_modules/core-js/internals/hide.js": function (t, r, i) { var a = i("./node_modules/core-js/internals/descriptors.js"), o = i("./node_modules/core-js/internals/object-define-property.js"), s = i("./node_modules/core-js/internals/create-property-descriptor.js"); t.exports = a ? function (l, c, u) { return o.f(l, c, s(1, u)) } : function (l, c, u) { return l[c] = u, l } }, "./node_modules/core-js/internals/html.js": function (t, r, i) { var a = i("./node_modules/core-js/internals/global.js"), o = a.document; t.exports = o && o.documentElement }, "./node_modules/core-js/internals/ie8-dom-define.js": function (t, r, i) { var a = i("./node_modules/core-js/internals/descriptors.js"), o = i("./node_modules/core-js/internals/fails.js"), s = i("./node_modules/core-js/internals/document-create-element.js"); t.exports = !a && !o(function () { return Object.defineProperty(s("div"), "a", { get: function () { return 7 } }).a != 7 }) }, "./node_modules/core-js/internals/indexed-object.js": function (t, r, i) { var a = i("./node_modules/core-js/internals/fails.js"), o = i("./node_modules/core-js/internals/classof-raw.js"), s = "".split; t.exports = a(function () { return !Object("z").propertyIsEnumerable(0) }) ? function (l) { return o(l) == "String" ? s.call(l, "") : Object(l) } : Object }, "./node_modules/core-js/internals/internal-state.js": function (t, r, i) { var a = i("./node_modules/core-js/internals/native-weak-map.js"), o = i("./node_modules/core-js/internals/global.js"), s = i("./node_modules/core-js/internals/is-object.js"), l = i("./node_modules/core-js/internals/hide.js"), c = i("./node_modules/core-js/internals/has.js"), u = i("./node_modules/core-js/internals/shared-key.js"), d = i("./node_modules/core-js/internals/hidden-keys.js"), f = o.WeakMap, h, p, m, g = function (k) { return m(k) ? p(k) : h(k, {}) }, y = function (k) { return function (A) { var C; if (!s(A) || (C = p(A)).type !== k) throw TypeError("Incompatible receiver, " + k + " required"); return C } }; if (a) { var b = new f, w = b.get, v = b.has, S = b.set; h = function (k, A) { return S.call(b, k, A), A }, p = function (k) { return w.call(b, k) || {} }, m = function (k) { return v.call(b, k) } } else { var x = u("state"); d[x] = !0, h = function (k, A) { return l(k, x, A), A }, p = function (k) { return c(k, x) ? k[x] : {} }, m = function (k) { return c(k, x) } } t.exports = { set: h, get: p, has: m, enforce: g, getterFor: y } }, "./node_modules/core-js/internals/is-array-iterator-method.js": function (t, r, i) { var a = i("./node_modules/core-js/internals/well-known-symbol.js"), o = i("./node_modules/core-js/internals/iterators.js"), s = a("iterator"), l = Array.prototype; t.exports = function (c) { return c !== void 0 && (o.Array === c || l[s] === c) } }, "./node_modules/core-js/internals/is-forced.js": function (t, r, i) { var a = i("./node_modules/core-js/internals/fails.js"), o = /#|\.prototype\./, s = function (f, h) { var p = c[l(f)]; return p == d ? !0 : p == u ? !1 : typeof h == "function" ? a(h) : !!h }, l = s.normalize = function (f) { return String(f).replace(o, ".").toLowerCase() }, c = s.data = {}, u = s.NATIVE = "N", d = s.POLYFILL = "P"; t.exports = s }, "./node_modules/core-js/internals/is-object.js": function (t, r) { t.exports = function (i) { return typeof i == "object" ? i !== null : typeof i == "function" } }, "./node_modules/core-js/internals/is-pure.js": function (t, r) { t.exports = !1 }, "./node_modules/core-js/internals/iterators-core.js": function (t, r, i) { var a = i("./node_modules/core-js/internals/object-get-prototype-of.js"), o = i("./node_modules/core-js/internals/hide.js"), s = i("./node_modules/core-js/internals/has.js"), l = i("./node_modules/core-js/internals/well-known-symbol.js"), c = i("./node_modules/core-js/internals/is-pure.js"), u = l("iterator"), d = !1, f = function () { return this }, h, p, m;[].keys && (m = [].keys(), "next" in m ? (p = a(a(m)), p !== Object.prototype && (h = p)) : d = !0), h == null && (h = {}), !c && !s(h, u) && o(h, u, f), t.exports = { IteratorPrototype: h, BUGGY_SAFARI_ITERATORS: d } }, "./node_modules/core-js/internals/iterators.js": function (t, r) { t.exports = {} }, "./node_modules/core-js/internals/native-symbol.js": function (t, r, i) { var a = i("./node_modules/core-js/internals/fails.js"); t.exports = !!Object.getOwnPropertySymbols && !a(function () { return !String(Symbol()) }) }, "./node_modules/core-js/internals/native-weak-map.js": function (t, r, i) { var a = i("./node_modules/core-js/internals/global.js"), o = i("./node_modules/core-js/internals/function-to-string.js"), s = a.WeakMap; t.exports = typeof s == "function" && /native code/.test(o.call(s)) }, "./node_modules/core-js/internals/object-create.js": function (t, r, i) { var a = i("./node_modules/core-js/internals/an-object.js"), o = i("./node_modules/core-js/internals/object-define-properties.js"), s = i("./node_modules/core-js/internals/enum-bug-keys.js"), l = i("./node_modules/core-js/internals/hidden-keys.js"), c = i("./node_modules/core-js/internals/html.js"), u = i("./node_modules/core-js/internals/document-create-element.js"), d = i("./node_modules/core-js/internals/shared-key.js"), f = d("IE_PROTO"), h = "prototype", p = function () { }, m = function () { var g = u("iframe"), y = s.length, b = "<", w = "script", v = ">", S = "java" + w + ":", x; for (g.style.display = "none", c.appendChild(g), g.src = String(S), x = g.contentWindow.document, x.open(), x.write(b + w + v + "document.F=Object" + b + "/" + w + v), x.close(), m = x.F; y--;)delete m[h][s[y]]; return m() }; t.exports = Object.create || function (y, b) { var w; return y !== null ? (p[h] = a(y), w = new p, p[h] = null, w[f] = y) : w = m(), b === void 0 ? w : o(w, b) }, l[f] = !0 }, "./node_modules/core-js/internals/object-define-properties.js": function (t, r, i) { var a = i("./node_modules/core-js/internals/descriptors.js"), o = i("./node_modules/core-js/internals/object-define-property.js"), s = i("./node_modules/core-js/internals/an-object.js"), l = i("./node_modules/core-js/internals/object-keys.js"); t.exports = a ? Object.defineProperties : function (u, d) { s(u); for (var f = l(d), h = f.length, p = 0, m; h > p;)o.f(u, m = f[p++], d[m]); return u } }, "./node_modules/core-js/internals/object-define-property.js": function (t, r, i) { var a = i("./node_modules/core-js/internals/descriptors.js"), o = i("./node_modules/core-js/internals/ie8-dom-define.js"), s = i("./node_modules/core-js/internals/an-object.js"), l = i("./node_modules/core-js/internals/to-primitive.js"), c = Object.defineProperty; r.f = a ? c : function (d, f, h) { if (s(d), f = l(f, !0), s(h), o) try { return c(d, f, h) } catch { } if ("get" in h || "set" in h) throw TypeError("Accessors not supported"); return "value" in h && (d[f] = h.value), d } }, "./node_modules/core-js/internals/object-get-own-property-descriptor.js": function (t, r, i) { var a = i("./node_modules/core-js/internals/descriptors.js"), o = i("./node_modules/core-js/internals/object-property-is-enumerable.js"), s = i("./node_modules/core-js/internals/create-property-descriptor.js"), l = i("./node_modules/core-js/internals/to-indexed-object.js"), c = i("./node_modules/core-js/internals/to-primitive.js"), u = i("./node_modules/core-js/internals/has.js"), d = i("./node_modules/core-js/internals/ie8-dom-define.js"), f = Object.getOwnPropertyDescriptor; r.f = a ? f : function (p, m) { if (p = l(p), m = c(m, !0), d) try { return f(p, m) } catch { } if (u(p, m)) return s(!o.f.call(p, m), p[m]) } }, "./node_modules/core-js/internals/object-get-own-property-names.js": function (t, r, i) { var a = i("./node_modules/core-js/internals/object-keys-internal.js"), o = i("./node_modules/core-js/internals/enum-bug-keys.js"), s = o.concat("length", "prototype"); r.f = Object.getOwnPropertyNames || function (c) { return a(c, s) } }, "./node_modules/core-js/internals/object-get-own-property-symbols.js": function (t, r) { r.f = Object.getOwnPropertySymbols }, "./node_modules/core-js/internals/object-get-prototype-of.js": function (t, r, i) { var a = i("./node_modules/core-js/internals/has.js"), o = i("./node_modules/core-js/internals/to-object.js"), s = i("./node_modules/core-js/internals/shared-key.js"), l = i("./node_modules/core-js/internals/correct-prototype-getter.js"), c = s("IE_PROTO"), u = Object.prototype; t.exports = l ? Object.getPrototypeOf : function (d) { return d = o(d), a(d, c) ? d[c] : typeof d.constructor == "function" && d instanceof d.constructor ? d.constructor.prototype : d instanceof Object ? u : null } }, "./node_modules/core-js/internals/object-keys-internal.js": function (t, r, i) { var a = i("./node_modules/core-js/internals/has.js"), o = i("./node_modules/core-js/internals/to-indexed-object.js"), s = i("./node_modules/core-js/internals/array-includes.js"), l = i("./node_modules/core-js/internals/hidden-keys.js"), c = s(!1); t.exports = function (u, d) { var f = o(u), h = 0, p = [], m; for (m in f) !a(l, m) && a(f, m) && p.push(m); for (; d.length > h;)a(f, m = d[h++]) && (~c(p, m) || p.push(m)); return p } }, "./node_modules/core-js/internals/object-keys.js": function (t, r, i) { var a = i("./node_modules/core-js/internals/object-keys-internal.js"), o = i("./node_modules/core-js/internals/enum-bug-keys.js"); t.exports = Object.keys || function (l) { return a(l, o) } }, "./node_modules/core-js/internals/object-property-is-enumerable.js": function (t, r, i) { var a = {}.propertyIsEnumerable, o = Object.getOwnPropertyDescriptor, s = o && !a.call({ 1: 2 }, 1); r.f = s ? function (c) { var u = o(this, c); return !!u && u.enumerable } : a }, "./node_modules/core-js/internals/object-set-prototype-of.js": function (t, r, i) { var a = i("./node_modules/core-js/internals/validate-set-prototype-of-arguments.js"); t.exports = Object.setPrototypeOf || ("__proto__" in {} ? function () { var o = !1, s = {}, l; try { l = Object.getOwnPropertyDescriptor(Object.prototype, "__proto__").set, l.call(s, []), o = s instanceof Array } catch { } return function (u, d) { return a(u, d), o ? l.call(u, d) : u.__proto__ = d, u } }() : void 0) }, "./node_modules/core-js/internals/own-keys.js": function (t, r, i) { var a = i("./node_modules/core-js/internals/global.js"), o = i("./node_modules/core-js/internals/object-get-own-property-names.js"), s = i("./node_modules/core-js/internals/object-get-own-property-symbols.js"), l = i("./node_modules/core-js/internals/an-object.js"), c = a.Reflect; t.exports = c && c.ownKeys || function (d) { var f = o.f(l(d)), h = s.f; return h ? f.concat(h(d)) : f } }, "./node_modules/core-js/internals/path.js": function (t, r, i) { t.exports = i("./node_modules/core-js/internals/global.js") }, "./node_modules/core-js/internals/redefine.js": function (t, r, i) { var a = i("./node_modules/core-js/internals/global.js"), o = i("./node_modules/core-js/internals/shared.js"), s = i("./node_modules/core-js/internals/hide.js"), l = i("./node_modules/core-js/internals/has.js"), c = i("./node_modules/core-js/internals/set-global.js"), u = i("./node_modules/core-js/internals/function-to-string.js"), d = i("./node_modules/core-js/internals/internal-state.js"), f = d.get, h = d.enforce, p = String(u).split("toString"); o("inspectSource", function (m) { return u.call(m) }), (t.exports = function (m, g, y, b) { var w = b ? !!b.unsafe : !1, v = b ? !!b.enumerable : !1, S = b ? !!b.noTargetGet : !1; if (typeof y == "function" && (typeof g == "string" && !l(y, "name") && s(y, "name", g), h(y).source = p.join(typeof g == "string" ? g : "")), m === a) { v ? m[g] = y : c(g, y); return } else w ? !S && m[g] && (v = !0) : delete m[g]; v ? m[g] = y : s(m, g, y) })(Function.prototype, "toString", function () { return typeof this == "function" && f(this).source || u.call(this) }) }, "./node_modules/core-js/internals/require-object-coercible.js": function (t, r) { t.exports = function (i) { if (i == null) throw TypeError("Can't call method on " + i); return i } }, "./node_modules/core-js/internals/set-global.js": function (t, r, i) { var a = i("./node_modules/core-js/internals/global.js"), o = i("./node_modules/core-js/internals/hide.js"); t.exports = function (s, l) { try { o(a, s, l) } catch { a[s] = l } return l } }, "./node_modules/core-js/internals/set-to-string-tag.js": function (t, r, i) { var a = i("./node_modules/core-js/internals/object-define-property.js").f, o = i("./node_modules/core-js/internals/has.js"), s = i("./node_modules/core-js/internals/well-known-symbol.js"), l = s("toStringTag"); t.exports = function (c, u, d) { c && !o(c = d ? c : c.prototype, l) && a(c, l, { configurable: !0, value: u }) } }, "./node_modules/core-js/internals/shared-key.js": function (t, r, i) { var a = i("./node_modules/core-js/internals/shared.js"), o = i("./node_modules/core-js/internals/uid.js"), s = a("keys"); t.exports = function (l) { return s[l] || (s[l] = o(l)) } }, "./node_modules/core-js/internals/shared.js": function (t, r, i) { var a = i("./node_modules/core-js/internals/global.js"), o = i("./node_modules/core-js/internals/set-global.js"), s = i("./node_modules/core-js/internals/is-pure.js"), l = "__core-js_shared__", c = a[l] || o(l, {}); (t.exports = function (u, d) { return c[u] || (c[u] = d !== void 0 ? d : {}) })("versions", []).push({ version: "3.1.3", mode: s ? "pure" : "global", copyright: " 2019 Denis Pushkarev (zloirock.ru)" }) }, "./node_modules/core-js/internals/string-at.js": function (t, r, i) { var a = i("./node_modules/core-js/internals/to-integer.js"), o = i("./node_modules/core-js/internals/require-object-coercible.js"); t.exports = function (s, l, c) { var u = String(o(s)), d = a(l), f = u.length, h, p; return d < 0 || d >= f ? c ? "" : void 0 : (h = u.charCodeAt(d), h < 55296 || h > 56319 || d + 1 === f || (p = u.charCodeAt(d + 1)) < 56320 || p > 57343 ? c ? u.charAt(d) : h : c ? u.slice(d, d + 2) : (h - 55296 << 10) + (p - 56320) + 65536) } }, "./node_modules/core-js/internals/to-absolute-index.js": function (t, r, i) { var a = i("./node_modules/core-js/internals/to-integer.js"), o = Math.max, s = Math.min; t.exports = function (l, c) { var u = a(l); return u < 0 ? o(u + c, 0) : s(u, c) } }, "./node_modules/core-js/internals/to-indexed-object.js": function (t, r, i) { var a = i("./node_modules/core-js/internals/indexed-object.js"), o = i("./node_modules/core-js/internals/require-object-coercible.js"); t.exports = function (s) { return a(o(s)) } }, "./node_modules/core-js/internals/to-integer.js": function (t, r) { var i = Math.ceil, a = Math.floor; t.exports = function (o) { return isNaN(o = +o) ? 0 : (o > 0 ? a : i)(o) } }, "./node_modules/core-js/internals/to-length.js": function (t, r, i) { var a = i("./node_modules/core-js/internals/to-integer.js"), o = Math.min; t.exports = function (s) { return s > 0 ? o(a(s), 9007199254740991) : 0 } }, "./node_modules/core-js/internals/to-object.js": function (t, r, i) { var a = i("./node_modules/core-js/internals/require-object-coercible.js"); t.exports = function (o) { return Object(a(o)) } }, "./node_modules/core-js/internals/to-primitive.js": function (t, r, i) { var a = i("./node_modules/core-js/internals/is-object.js"); t.exports = function (o, s) { if (!a(o)) return o; var l, c; if (s && typeof (l = o.toString) == "function" && !a(c = l.call(o)) || typeof (l = o.valueOf) == "function" && !a(c = l.call(o)) || !s && typeof (l = o.toString) == "function" && !a(c = l.call(o))) return c; throw TypeError("Can't convert object to primitive value") } }, "./node_modules/core-js/internals/uid.js": function (t, r) { var i = 0, a = Math.random(); t.exports = function (o) { return "Symbol(".concat(o === void 0 ? "" : o, ")_", (++i + a).toString(36)) } }, "./node_modules/core-js/internals/validate-set-prototype-of-arguments.js": function (t, r, i) { var a = i("./node_modules/core-js/internals/is-object.js"), o = i("./node_modules/core-js/internals/an-object.js"); t.exports = function (s, l) { if (o(s), !a(l) && l !== null) throw TypeError("Can't set " + String(l) + " as a prototype") } }, "./node_modules/core-js/internals/well-known-symbol.js": function (t, r, i) { var a = i("./node_modules/core-js/internals/global.js"), o = i("./node_modules/core-js/internals/shared.js"), s = i("./node_modules/core-js/internals/uid.js"), l = i("./node_modules/core-js/internals/native-symbol.js"), c = a.Symbol, u = o("wks"); t.exports = function (d) { return u[d] || (u[d] = l && c[d] || (l ? c : s)("Symbol." + d)) } }, "./node_modules/core-js/modules/es.array.from.js": function (t, r, i) { var a = i("./node_modules/core-js/internals/export.js"), o = i("./node_modules/core-js/internals/array-from.js"), s = i("./node_modules/core-js/internals/check-correctness-of-iteration.js"), l = !s(function (c) { Array.from(c) }); a({ target: "Array", stat: !0, forced: l }, { from: o }) }, "./node_modules/core-js/modules/es.string.iterator.js": function (t, r, i) { var a = i("./node_modules/core-js/internals/string-at.js"), o = i("./node_modules/core-js/internals/internal-state.js"), s = i("./node_modules/core-js/internals/define-iterator.js"), l = "String Iterator", c = o.set, u = o.getterFor(l); s(String, "String", function (d) { c(this, { type: l, string: String(d), index: 0 }) }, function () { var f = u(this), h = f.string, p = f.index, m; return p >= h.length ? { value: void 0, done: !0 } : (m = a(h, p, !0), f.index += m.length, { value: m, done: !1 }) }) }, "./node_modules/webpack/buildin/global.js": function (t, r) { var i; i = function () { return this }(); try { i = i || Function("return this")() || (0, eval)("this") } catch { typeof window == "object" && (i = window) } t.exports = i }, "./src/default-attrs.json": function (t) { t.exports = { xmlns: "http://www.w3.org/2000/svg", width: 24, height: 24, viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", "stroke-width": 2, "stroke-linecap": "round", "stroke-linejoin": "round" } }, "./src/icon.js": function (t, r, i) { Object.defineProperty(r, "__esModule", { value: !0 }); var a = Object.assign || function (m) { for (var g = 1; g < arguments.length; g++) { var y = arguments[g]; for (var b in y) Object.prototype.hasOwnProperty.call(y, b) && (m[b] = y[b]) } return m }, o = function () { function m(g, y) { for (var b = 0; b < y.length; b++) { var w = y[b]; w.enumerable = w.enumerable || !1, w.configurable = !0, "value" in w && (w.writable = !0), Object.defineProperty(g, w.key, w) } } return function (g, y, b) { return y && m(g.prototype, y), b && m(g, b), g } }(), s = i("./node_modules/classnames/dedupe.js"), l = d(s), c = i("./src/default-attrs.json"), u = d(c); function d(m) { return m && m.__esModule ? m : { default: m } } function f(m, g) { if (!(m instanceof g)) throw new TypeError("Cannot call a class as a function") } var h = function () { function m(g, y) { var b = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : []; f(this, m), this.name = g, this.contents = y, this.tags = b, this.attrs = a({}, u.default, { class: "feather feather-" + g }) } return o(m, [{ key: "toSvg", value: function () { var y = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, b = a({}, this.attrs, y, { class: (0, l.default)(this.attrs.class, y.class) }); return "<svg " + p(b) + ">" + this.contents + "</svg>" } }, { key: "toString", value: function () { return this.contents } }]), m }(); function p(m) { return Object.keys(m).map(function (g) { return g + '="' + m[g] + '"' }).join(" ") } r.default = h }, "./src/icons.js": function (t, r, i) { Object.defineProperty(r, "__esModule", { value: !0 }); var a = i("./src/icon.js"), o = d(a), s = i("./dist/icons.json"), l = d(s), c = i("./src/tags.json"), u = d(c); function d(f) { return f && f.__esModule ? f : { default: f } } r.default = Object.keys(l.default).map(function (f) { return new o.default(f, l.default[f], u.default[f]) }).reduce(function (f, h) { return f[h.name] = h, f }, {}) }, "./src/index.js": function (t, r, i) { var a = i("./src/icons.js"), o = d(a), s = i("./src/to-svg.js"), l = d(s), c = i("./src/replace.js"), u = d(c); function d(f) { return f && f.__esModule ? f : { default: f } } t.exports = { icons: o.default, toSvg: l.default, replace: u.default } }, "./src/replace.js": function (t, r, i) { Object.defineProperty(r, "__esModule", { value: !0 }); var a = Object.assign || function (p) { for (var m = 1; m < arguments.length; m++) { var g = arguments[m]; for (var y in g) Object.prototype.hasOwnProperty.call(g, y) && (p[y] = g[y]) } return p }, o = i("./node_modules/classnames/dedupe.js"), s = u(o), l = i("./src/icons.js"), c = u(l); function u(p) { return p && p.__esModule ? p : { default: p } } function d() { var p = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}; if (typeof document > "u") throw new Error("`feather.replace()` only works in a browser environment."); var m = document.querySelectorAll("[data-feather]"); Array.from(m).forEach(function (g) { return f(g, p) }) } function f(p) { var m = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, g = h(p), y = g["data-feather"]; if (delete g["data-feather"], c.default[y] === void 0) { console.warn("feather: '" + y + "' is not a valid icon"); return } var b = c.default[y].toSvg(a({}, m, g, { class: (0, s.default)(m.class, g.class) })), w = new DOMParser().parseFromString(b, "image/svg+xml"), v = w.querySelector("svg"); p.parentNode.replaceChild(v, p) } function h(p) { return Array.from(p.attributes).reduce(function (m, g) { return m[g.name] = g.value, m }, {}) } r.default = d }, "./src/tags.json": function (t) { t.exports = { activity: ["pulse", "health", "action", "motion"], airplay: ["stream", "cast", "mirroring"], "alert-circle": ["warning", "alert", "danger"], "alert-octagon": ["warning", "alert", "danger"], "alert-triangle": ["warning", "alert", "danger"], "align-center": ["text alignment", "center"], "align-justify": ["text alignment", "justified"], "align-left": ["text alignment", "left"], "align-right": ["text alignment", "right"], anchor: [], archive: ["index", "box"], "at-sign": ["mention", "at", "email", "message"], award: ["achievement", "badge"], aperture: ["camera", "photo"], "bar-chart": ["statistics", "diagram", "graph"], "bar-chart-2": ["statistics", "diagram", "graph"], battery: ["power", "electricity"], "battery-charging": ["power", "electricity"], bell: ["alarm", "notification", "sound"], "bell-off": ["alarm", "notification", "silent"], bluetooth: ["wireless"], "book-open": ["read", "library"], book: ["read", "dictionary", "booklet", "magazine", "library"], bookmark: ["read", "clip", "marker", "tag"], box: ["cube"], briefcase: ["work", "bag", "baggage", "folder"], calendar: ["date"], camera: ["photo"], cast: ["chromecast", "airplay"], "chevron-down": ["expand"], "chevron-up": ["collapse"], circle: ["off", "zero", "record"], clipboard: ["copy"], clock: ["time", "watch", "alarm"], "cloud-drizzle": ["weather", "shower"], "cloud-lightning": ["weather", "bolt"], "cloud-rain": ["weather"], "cloud-snow": ["weather", "blizzard"], cloud: ["weather"], codepen: ["logo"], codesandbox: ["logo"], code: ["source", "programming"], coffee: ["drink", "cup", "mug", "tea", "cafe", "hot", "beverage"], columns: ["layout"], command: ["keyboard", "cmd", "terminal", "prompt"], compass: ["navigation", "safari", "travel", "direction"], copy: ["clone", "duplicate"], "corner-down-left": ["arrow", "return"], "corner-down-right": ["arrow"], "corner-left-down": ["arrow"], "corner-left-up": ["arrow"], "corner-right-down": ["arrow"], "corner-right-up": ["arrow"], "corner-up-left": ["arrow"], "corner-up-right": ["arrow"], cpu: ["processor", "technology"], "credit-card": ["purchase", "payment", "cc"], crop: ["photo", "image"], crosshair: ["aim", "target"], database: ["storage", "memory"], delete: ["remove"], disc: ["album", "cd", "dvd", "music"], "dollar-sign": ["currency", "money", "payment"], droplet: ["water"], edit: ["pencil", "change"], "edit-2": ["pencil", "change"], "edit-3": ["pencil", "change"], eye: ["view", "watch"], "eye-off": ["view", "watch", "hide", "hidden"], "external-link": ["outbound"], facebook: ["logo", "social"], "fast-forward": ["music"], figma: ["logo", "design", "tool"], "file-minus": ["delete", "remove", "erase"], "file-plus": ["add", "create", "new"], "file-text": ["data", "txt", "pdf"], film: ["movie", "video"], filter: ["funnel", "hopper"], flag: ["report"], "folder-minus": ["directory"], "folder-plus": ["directory"], folder: ["directory"], framer: ["logo", "design", "tool"], frown: ["emoji", "face", "bad", "sad", "emotion"], gift: ["present", "box", "birthday", "party"], "git-branch": ["code", "version control"], "git-commit": ["code", "version control"], "git-merge": ["code", "version control"], "git-pull-request": ["code", "version control"], github: ["logo", "version control"], gitlab: ["logo", "version control"], globe: ["world", "browser", "language", "translate"], "hard-drive": ["computer", "server", "memory", "data"], hash: ["hashtag", "number", "pound"], headphones: ["music", "audio", "sound"], heart: ["like", "love", "emotion"], "help-circle": ["question mark"], hexagon: ["shape", "node.js", "logo"], home: ["house", "living"], image: ["picture"], inbox: ["email"], instagram: ["logo", "camera"], key: ["password", "login", "authentication", "secure"], layers: ["stack"], layout: ["window", "webpage"], "life-buoy": ["help", "life ring", "support"], link: ["chain", "url"], "link-2": ["chain", "url"], linkedin: ["logo", "social media"], list: ["options"], lock: ["security", "password", "secure"], "log-in": ["sign in", "arrow", "enter"], "log-out": ["sign out", "arrow", "exit"], mail: ["email", "message"], "map-pin": ["location", "navigation", "travel", "marker"], map: ["location", "navigation", "travel"], maximize: ["fullscreen"], "maximize-2": ["fullscreen", "arrows", "expand"], meh: ["emoji", "face", "neutral", "emotion"], menu: ["bars", "navigation", "hamburger"], "message-circle": ["comment", "chat"], "message-square": ["comment", "chat"], "mic-off": ["record", "sound", "mute"], mic: ["record", "sound", "listen"], minimize: ["exit fullscreen", "close"], "minimize-2": ["exit fullscreen", "arrows", "close"], minus: ["subtract"], monitor: ["tv", "screen", "display"], moon: ["dark", "night"], "more-horizontal": ["ellipsis"], "more-vertical": ["ellipsis"], "mouse-pointer": ["arrow", "cursor"], move: ["arrows"], music: ["note"], navigation: ["location", "travel"], "navigation-2": ["location", "travel"], octagon: ["stop"], package: ["box", "container"], paperclip: ["attachment"], pause: ["music", "stop"], "pause-circle": ["music", "audio", "stop"], "pen-tool": ["vector", "drawing"], percent: ["discount"], "phone-call": ["ring"], "phone-forwarded": ["call"], "phone-incoming": ["call"], "phone-missed": ["call"], "phone-off": ["call", "mute"], "phone-outgoing": ["call"], phone: ["call"], play: ["music", "start"], "pie-chart": ["statistics", "diagram"], "play-circle": ["music", "start"], plus: ["add", "new"], "plus-circle": ["add", "new"], "plus-square": ["add", "new"], pocket: ["logo", "save"], power: ["on", "off"], printer: ["fax", "office", "device"], radio: ["signal"], "refresh-cw": ["synchronise", "arrows"], "refresh-ccw": ["arrows"], repeat: ["loop", "arrows"], rewind: ["music"], "rotate-ccw": ["arrow"], "rotate-cw": ["arrow"], rss: ["feed", "subscribe"], save: ["floppy disk"], scissors: ["cut"], search: ["find", "magnifier", "magnifying glass"], send: ["message", "mail", "email", "paper airplane", "paper aeroplane"], settings: ["cog", "edit", "gear", "preferences"], "share-2": ["network", "connections"], shield: ["security", "secure"], "shield-off": ["security", "insecure"], "shopping-bag": ["ecommerce", "cart", "purchase", "store"], "shopping-cart": ["ecommerce", "cart", "purchase", "store"], shuffle: ["music"], "skip-back": ["music"], "skip-forward": ["music"], slack: ["logo"], slash: ["ban", "no"], sliders: ["settings", "controls"], smartphone: ["cellphone", "device"], smile: ["emoji", "face", "happy", "good", "emotion"], speaker: ["audio", "music"], star: ["bookmark", "favorite", "like"], "stop-circle": ["media", "music"], sun: ["brightness", "weather", "light"], sunrise: ["weather", "time", "morning", "day"], sunset: ["weather", "time", "evening", "night"], tablet: ["device"], tag: ["label"], target: ["logo", "bullseye"], terminal: ["code", "command line", "prompt"], thermometer: ["temperature", "celsius", "fahrenheit", "weather"], "thumbs-down": ["dislike", "bad", "emotion"], "thumbs-up": ["like", "good", "emotion"], "toggle-left": ["on", "off", "switch"], "toggle-right": ["on", "off", "switch"], tool: ["settings", "spanner"], trash: ["garbage", "delete", "remove", "bin"], "trash-2": ["garbage", "delete", "remove", "bin"], triangle: ["delta"], truck: ["delivery", "van", "shipping", "transport", "lorry"], tv: ["television", "stream"], twitch: ["logo"], twitter: ["logo", "social"], type: ["text"], umbrella: ["rain", "weather"], unlock: ["security"], "user-check": ["followed", "subscribed"], "user-minus": ["delete", "remove", "unfollow", "unsubscribe"], "user-plus": ["new", "add", "create", "follow", "subscribe"], "user-x": ["delete", "remove", "unfollow", "unsubscribe", "unavailable"], user: ["person", "account"], users: ["group"], "video-off": ["camera", "movie", "film"], video: ["camera", "movie", "film"], voicemail: ["phone"], volume: ["music", "sound", "mute"], "volume-1": ["music", "sound"], "volume-2": ["music", "sound"], "volume-x": ["music", "sound", "mute"], watch: ["clock", "time"], "wifi-off": ["disabled"], wifi: ["connection", "signal", "wireless"], wind: ["weather", "air"], "x-circle": ["cancel", "close", "delete", "remove", "times", "clear"], "x-octagon": ["delete", "stop", "alert", "warning", "times", "clear"], "x-square": ["cancel", "close", "delete", "remove", "times", "clear"], x: ["cancel", "close", "delete", "remove", "times", "clear"], youtube: ["logo", "video", "play"], "zap-off": ["flash", "camera", "lightning"], zap: ["flash", "camera", "lightning"], "zoom-in": ["magnifying glass"], "zoom-out": ["magnifying glass"] } }, "./src/to-svg.js": function (t, r, i) { Object.defineProperty(r, "__esModule", { value: !0 }); var a = i("./src/icons.js"), o = s(a); function s(c) { return c && c.__esModule ? c : { default: c } } function l(c) { var u = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}; if (console.warn("feather.toSvg() is deprecated. Please use feather.icons[name].toSvg() instead."), !c) throw new Error("The required `key` (icon name) parameter is missing."); if (!o.default[c]) throw new Error("No icon matching '" + c + "'. See the complete list of icons at https://feathericons.com"); return o.default[c].toSvg(u) } r.default = l }, 0: function (t, r, i) { i("./node_modules/core-js/es/array/from.js"), t.exports = i("./src/index.js") }
    })
  })
})(gY); var obe = gY.exports; const dj = ck(obe), y$ = Object.keys(dj.icons), vc = { props: { name: { type: String, required: !0, validator(n) { const e = y$.includes(n); return e || (console.groupCollapsed("[frappe-ui] name property for feather-icon must be one of "), console.dir(y$), console.groupEnd()), e } }, color: { type: String, default: null }, strokeWidth: { type: Number, default: 1.5 } }, render() { let n = dj.icons[this.name]; return n || (n = dj.icons.circle), Gt("svg", Sn(n.attrs, { fill: "none", stroke: "currentColor", color: this.color, "stroke-linecap": "round", "stroke-linejoin": "round", "stroke-width": this.strokeWidth, width: null, height: null, class: [n.attrs.class, "shrink-0"], innerHTML: n.contents }, this.$attrs)) } }, uk = We({ __name: "LoadingIndicator", props: { scale: { required: !1, default: 100 } }, setup(n) { return (e, t) => (Z(), ye("svg", { class: "max-w-xs animate-spin", xmlns: "http://www.w3.org/2000/svg", fill: "none", style: aa(`scale: ${n.scale}%;`), viewBox: "0 0 24 24" }, t[0] || (t[0] = [re("circle", { class: "opacity-25", cx: "12", cy: "12", r: "10", stroke: "currentColor", "stroke-width": "4" }, null, -1), re("path", { class: "opacity-75", fill: "currentColor", d: "M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z" }, null, -1)]), 4)) } });/*!
  * vue-router v4.4.5
  * (c) 2024 Eduardo San Martin Morote
  * @license MIT
  */const fm = typeof document < "u"; function vY(n) { return typeof n == "object" || "displayName" in n || "props" in n || "__vccOpts" in n } function sbe(n) { return n.__esModule || n[Symbol.toStringTag] === "Module" || n.default && vY(n.default) } const Pn = Object.assign; function hE(n, e) { const t = {}; for (const r in e) { const i = e[r]; t[r] = Ss(i) ? i.map(n) : n(i) } return t } const Zy = () => { }, Ss = Array.isArray, yY = /#/g, lbe = /&/g, cbe = /\//g, ube = /=/g, dbe = /\?/g, _Y = /\+/g, fbe = /%5B/g, hbe = /%5D/g, bY = /%5E/g, pbe = /%60/g, wY = /%7B/g, mbe = /%7C/g, xY = /%7D/g, gbe = /%20/g; function rR(n) { return encodeURI("" + n).replace(mbe, "|").replace(fbe, "[").replace(hbe, "]") } function vbe(n) { return rR(n).replace(wY, "{").replace(xY, "}").replace(bY, "^") } function fj(n) { return rR(n).replace(_Y, "%2B").replace(gbe, "+").replace(yY, "%23").replace(lbe, "%26").replace(pbe, "`").replace(wY, "{").replace(xY, "}").replace(bY, "^") } function ybe(n) { return fj(n).replace(ube, "%3D") } function _be(n) { return rR(n).replace(yY, "%23").replace(dbe, "%3F") } function bbe(n) { return n == null ? "" : _be(n).replace(cbe, "%2F") } function F0(n) { try { return decodeURIComponent("" + n) } catch { } return "" + n } const wbe = /\/$/, xbe = n => n.replace(wbe, ""); function pE(n, e, t = "/") { let r, i = {}, a = "", o = ""; const s = e.indexOf("#"); let l = e.indexOf("?"); return s < l && s >= 0 && (l = -1), l > -1 && (r = e.slice(0, l), a = e.slice(l + 1, s > -1 ? s : e.length), i = n(a)), s > -1 && (r = r || e.slice(0, s), o = e.slice(s, e.length)), r = Cbe(r ?? e, t), { fullPath: r + (a && "?") + a + o, path: r, query: i, hash: F0(o) } } function Sbe(n, e) { const t = e.query ? n(e.query) : ""; return e.path + (t && "?") + t + (e.hash || "") } function _$(n, e) { return !e || !n.toLowerCase().startsWith(e.toLowerCase()) ? n : n.slice(e.length) || "/" } function Tbe(n, e, t) { const r = e.matched.length - 1, i = t.matched.length - 1; return r > -1 && r === i && dg(e.matched[r], t.matched[i]) && SY(e.params, t.params) && n(e.query) === n(t.query) && e.hash === t.hash } function dg(n, e) { return (n.aliasOf || n) === (e.aliasOf || e) } function SY(n, e) { if (Object.keys(n).length !== Object.keys(e).length) return !1; for (const t in n) if (!kbe(n[t], e[t])) return !1; return !0 } function kbe(n, e) { return Ss(n) ? b$(n, e) : Ss(e) ? b$(e, n) : n === e } function b$(n, e) { return Ss(e) ? n.length === e.length && n.every((t, r) => t === e[r]) : n.length === 1 && n[0] === e } function Cbe(n, e) { if (n.startsWith("/")) return n; if (!n) return e; const t = e.split("/"), r = n.split("/"), i = r[r.length - 1]; (i === ".." || i === ".") && r.push(""); let a = t.length - 1, o, s; for (o = 0; o < r.length; o++)if (s = r[o], s !== ".") if (s === "..") a > 1 && a--; else break; return t.slice(0, a).join("/") + "/" + r.slice(o).join("/") } const nu = { path: "/", name: void 0, params: {}, query: {}, hash: "", fullPath: "/", matched: [], meta: {}, redirectedFrom: void 0 }; var z0; (function (n) { n.pop = "pop", n.push = "push" })(z0 || (z0 = {})); var Xy; (function (n) { n.back = "back", n.forward = "forward", n.unknown = "" })(Xy || (Xy = {})); function Abe(n) { if (!n) if (fm) { const e = document.querySelector("base"); n = e && e.getAttribute("href") || "/", n = n.replace(/^\w+:\/\/[^\/]+/, "") } else n = "/"; return n[0] !== "/" && n[0] !== "#" && (n = "/" + n), xbe(n) } const Ebe = /^[^#]+#/; function Mbe(n, e) { return n.replace(Ebe, "#") + e } function Obe(n, e) { const t = document.documentElement.getBoundingClientRect(), r = n.getBoundingClientRect(); return { behavior: e.behavior, left: r.left - t.left - (e.left || 0), top: r.top - t.top - (e.top || 0) } } const dk = () => ({ left: window.scrollX, top: window.scrollY }); function Dbe(n) { let e; if ("el" in n) { const t = n.el, r = typeof t == "string" && t.startsWith("#"), i = typeof t == "string" ? r ? document.getElementById(t.slice(1)) : document.querySelector(t) : t; if (!i) return; e = Obe(i, n) } else e = n; "scrollBehavior" in document.documentElement.style ? window.scrollTo(e) : window.scrollTo(e.left != null ? e.left : window.scrollX, e.top != null ? e.top : window.scrollY) } function w$(n, e) { return (history.state ? history.state.position - e : -1) + n } const hj = new Map; function jbe(n, e) { hj.set(n, e) } function Pbe(n) { const e = hj.get(n); return hj.delete(n), e } let Ibe = () => location.protocol + "//" + location.host; function TY(n, e) { const { pathname: t, search: r, hash: i } = e, a = n.indexOf("#"); if (a > -1) { let s = i.includes(n.slice(a)) ? n.slice(a).length : 1, l = i.slice(s); return l[0] !== "/" && (l = "/" + l), _$(l, "") } return _$(t, n) + r + i } function Lbe(n, e, t, r) { let i = [], a = [], o = null; const s = ({ state: f }) => { const h = TY(n, location), p = t.value, m = e.value; let g = 0; if (f) { if (t.value = h, e.value = f, o && o === p) { o = null; return } g = m ? f.position - m.position : 0 } else r(h); i.forEach(y => { y(t.value, p, { delta: g, type: z0.pop, direction: g ? g > 0 ? Xy.forward : Xy.back : Xy.unknown }) }) }; function l() { o = t.value } function c(f) { i.push(f); const h = () => { const p = i.indexOf(f); p > -1 && i.splice(p, 1) }; return a.push(h), h } function u() { const { history: f } = window; f.state && f.replaceState(Pn({}, f.state, { scroll: dk() }), "") } function d() { for (const f of a) f(); a = [], window.removeEventListener("popstate", s), window.removeEventListener("beforeunload", u) } return window.addEventListener("popstate", s), window.addEventListener("beforeunload", u, { passive: !0 }), { pauseListeners: l, listen: c, destroy: d } } function x$(n, e, t, r = !1, i = !1) { return { back: n, current: e, forward: t, replaced: r, position: window.history.length, scroll: i ? dk() : null } } function Rbe(n) { const { history: e, location: t } = window, r = { value: TY(n, t) }, i = { value: e.state }; i.value || a(r.value, { back: null, current: r.value, forward: null, position: e.length - 1, replaced: !0, scroll: null }, !0); function a(l, c, u) { const d = n.indexOf("#"), f = d > -1 ? (t.host && document.querySelector("base") ? n : n.slice(d)) + l : Ibe() + n + l; try { e[u ? "replaceState" : "pushState"](c, "", f), i.value = c } catch (h) { console.error(h), t[u ? "replace" : "assign"](f) } } function o(l, c) { const u = Pn({}, e.state, x$(i.value.back, l, i.value.forward, !0), c, { position: i.value.position }); a(l, u, !0), r.value = l } function s(l, c) { const u = Pn({}, i.value, e.state, { forward: l, scroll: dk() }); a(u.current, u, !0); const d = Pn({}, x$(r.value, l, null), { position: u.position + 1 }, c); a(l, d, !1), r.value = l } return { location: r, state: i, push: s, replace: o } } function Nbe(n) { n = Abe(n); const e = Rbe(n), t = Lbe(n, e.state, e.location, e.replace); function r(a, o = !0) { o || t.pauseListeners(), history.go(a) } const i = Pn({ location: "", base: n, go: r, createHref: Mbe.bind(null, n) }, e, t); return Object.defineProperty(i, "location", { enumerable: !0, get: () => e.location.value }), Object.defineProperty(i, "state", { enumerable: !0, get: () => e.state.value }), i } function Bbe(n) { return typeof n == "string" || n && typeof n == "object" } function kY(n) { return typeof n == "string" || typeof n == "symbol" } const CY = Symbol(""); var S$; (function (n) { n[n.aborted = 4] = "aborted", n[n.cancelled = 8] = "cancelled", n[n.duplicated = 16] = "duplicated" })(S$ || (S$ = {})); function fg(n, e) { return Pn(new Error, { type: n, [CY]: !0 }, e) } function ql(n, e) { return n instanceof Error && CY in n && (e == null || !!(n.type & e)) } const T$ = "[^/]+?", $be = { sensitive: !1, strict: !1, start: !0, end: !0 }, Fbe = /[.+*?^${}()[\]/\\]/g; function zbe(n, e) { const t = Pn({}, $be, e), r = []; let i = t.start ? "^" : ""; const a = []; for (const c of n) { const u = c.length ? [] : [90]; t.strict && !c.length && (i += "/"); for (let d = 0; d < c.length; d++) { const f = c[d]; let h = 40 + (t.sensitive ? .25 : 0); if (f.type === 0) d || (i += "/"), i += f.value.replace(Fbe, "\\$&"), h += 40; else if (f.type === 1) { const { value: p, repeatable: m, optional: g, regexp: y } = f; a.push({ name: p, repeatable: m, optional: g }); const b = y || T$; if (b !== T$) { h += 10; try { new RegExp(`(${b})`) } catch (v) { throw new Error(`Invalid custom RegExp for param "${p}" (${b}): ` + v.message) } } let w = m ? `((?:${b})(?:/(?:${b}))*)` : `(${b})`; d || (w = g && c.length < 2 ? `(?:/${w})` : "/" + w), g && (w += "?"), i += w, h += 20, g && (h += -8), m && (h += -20), b === ".*" && (h += -50) } u.push(h) } r.push(u) } if (t.strict && t.end) { const c = r.length - 1; r[c][r[c].length - 1] += .7000000000000001 } t.strict || (i += "/?"), t.end ? i += "$" : t.strict && (i += "(?:/|$)"); const o = new RegExp(i, t.sensitive ? "" : "i"); function s(c) { const u = c.match(o), d = {}; if (!u) return null; for (let f = 1; f < u.length; f++) { const h = u[f] || "", p = a[f - 1]; d[p.name] = h && p.repeatable ? h.split("/") : h } return d } function l(c) { let u = "", d = !1; for (const f of n) { (!d || !u.endsWith("/")) && (u += "/"), d = !1; for (const h of f) if (h.type === 0) u += h.value; else if (h.type === 1) { const { value: p, repeatable: m, optional: g } = h, y = p in c ? c[p] : ""; if (Ss(y) && !m) throw new Error(`Provided param "${p}" is an array but it is not repeatable (* or + modifiers)`); const b = Ss(y) ? y.join("/") : y; if (!b) if (g) f.length < 2 && (u.endsWith("/") ? u = u.slice(0, -1) : d = !0); else throw new Error(`Missing required param "${p}"`); u += b } } return u || "/" } return { re: o, score: r, keys: a, parse: s, stringify: l } } function Vbe(n, e) { let t = 0; for (; t < n.length && t < e.length;) { const r = e[t] - n[t]; if (r) return r; t++ } return n.length < e.length ? n.length === 1 && n[0] === 40 + 40 ? -1 : 1 : n.length > e.length ? e.length === 1 && e[0] === 40 + 40 ? 1 : -1 : 0 } function AY(n, e) { let t = 0; const r = n.score, i = e.score; for (; t < r.length && t < i.length;) { const a = Vbe(r[t], i[t]); if (a) return a; t++ } if (Math.abs(i.length - r.length) === 1) { if (k$(r)) return 1; if (k$(i)) return -1 } return i.length - r.length } function k$(n) { const e = n[n.length - 1]; return n.length > 0 && e[e.length - 1] < 0 } const Hbe = { type: 0, value: "" }, Ube = /[a-zA-Z0-9_]/; function Gbe(n) { if (!n) return [[]]; if (n === "/") return [[Hbe]]; if (!n.startsWith("/")) throw new Error(`Invalid path "${n}"`); function e(h) { throw new Error(`ERR (${t})/"${c}": ${h}`) } let t = 0, r = t; const i = []; let a; function o() { a && i.push(a), a = [] } let s = 0, l, c = "", u = ""; function d() { c && (t === 0 ? a.push({ type: 0, value: c }) : t === 1 || t === 2 || t === 3 ? (a.length > 1 && (l === "*" || l === "+") && e(`A repeatable param (${c}) must be alone in its segment. eg: '/:ids+.`), a.push({ type: 1, value: c, regexp: u, repeatable: l === "*" || l === "+", optional: l === "*" || l === "?" })) : e("Invalid state to consume buffer"), c = "") } function f() { c += l } for (; s < n.length;) { if (l = n[s++], l === "\\" && t !== 2) { r = t, t = 4; continue } switch (t) { case 0: l === "/" ? (c && d(), o()) : l === ":" ? (d(), t = 1) : f(); break; case 4: f(), t = r; break; case 1: l === "(" ? t = 2 : Ube.test(l) ? f() : (d(), t = 0, l !== "*" && l !== "?" && l !== "+" && s--); break; case 2: l === ")" ? u[u.length - 1] == "\\" ? u = u.slice(0, -1) + l : t = 3 : u += l; break; case 3: d(), t = 0, l !== "*" && l !== "?" && l !== "+" && s--, u = ""; break; default: e("Unknown state"); break } } return t === 2 && e(`Unfinished custom RegExp for param "${c}"`), d(), o(), i } function Wbe(n, e, t) { const r = zbe(Gbe(n.path), t), i = Pn(r, { record: n, parent: e, children: [], alias: [] }); return e && !i.record.aliasOf == !e.record.aliasOf && e.children.push(i), i } function Kbe(n, e) { const t = [], r = new Map; e = M$({ strict: !1, end: !0, sensitive: !1 }, e); function i(d) { return r.get(d) } function a(d, f, h) { const p = !h, m = A$(d); m.aliasOf = h && h.record; const g = M$(e, d), y = [m]; if ("alias" in d) { const v = typeof d.alias == "string" ? [d.alias] : d.alias; for (const S of v) y.push(A$(Pn({}, m, { components: h ? h.record.components : m.components, path: S, aliasOf: h ? h.record : m }))) } let b, w; for (const v of y) { const { path: S } = v; if (f && S[0] !== "/") { const x = f.record.path, k = x[x.length - 1] === "/" ? "" : "/"; v.path = f.record.path + (S && k + S) } if (b = Wbe(v, f, g), h ? h.alias.push(b) : (w = w || b, w !== b && w.alias.push(b), p && d.name && !E$(b) && o(d.name)), EY(b) && l(b), m.children) { const x = m.children; for (let k = 0; k < x.length; k++)a(x[k], b, h && h.children[k]) } h = h || b } return w ? () => { o(w) } : Zy } function o(d) { if (kY(d)) { const f = r.get(d); f && (r.delete(d), t.splice(t.indexOf(f), 1), f.children.forEach(o), f.alias.forEach(o)) } else { const f = t.indexOf(d); f > -1 && (t.splice(f, 1), d.record.name && r.delete(d.record.name), d.children.forEach(o), d.alias.forEach(o)) } } function s() { return t } function l(d) { const f = Zbe(d, t); t.splice(f, 0, d), d.record.name && !E$(d) && r.set(d.record.name, d) } function c(d, f) { let h, p = {}, m, g; if ("name" in d && d.name) { if (h = r.get(d.name), !h) throw fg(1, { location: d }); g = h.record.name, p = Pn(C$(f.params, h.keys.filter(w => !w.optional).concat(h.parent ? h.parent.keys.filter(w => w.optional) : []).map(w => w.name)), d.params && C$(d.params, h.keys.map(w => w.name))), m = h.stringify(p) } else if (d.path != null) m = d.path, h = t.find(w => w.re.test(m)), h && (p = h.parse(m), g = h.record.name); else { if (h = f.name ? r.get(f.name) : t.find(w => w.re.test(f.path)), !h) throw fg(1, { location: d, currentLocation: f }); g = h.record.name, p = Pn({}, f.params, d.params), m = h.stringify(p) } const y = []; let b = h; for (; b;)y.unshift(b.record), b = b.parent; return { name: g, path: m, params: p, matched: y, meta: Ybe(y) } } n.forEach(d => a(d)); function u() { t.length = 0, r.clear() } return { addRoute: a, resolve: c, removeRoute: o, clearRoutes: u, getRoutes: s, getRecordMatcher: i } } function C$(n, e) { const t = {}; for (const r of e) r in n && (t[r] = n[r]); return t } function A$(n) { const e = { path: n.path, redirect: n.redirect, name: n.name, meta: n.meta || {}, aliasOf: n.aliasOf, beforeEnter: n.beforeEnter, props: qbe(n), children: n.children || [], instances: {}, leaveGuards: new Set, updateGuards: new Set, enterCallbacks: {}, components: "components" in n ? n.components || null : n.component && { default: n.component } }; return Object.defineProperty(e, "mods", { value: {} }), e } function qbe(n) { const e = {}, t = n.props || !1; if ("component" in n) e.default = t; else for (const r in n.components) e[r] = typeof t == "object" ? t[r] : t; return e } function E$(n) { for (; n;) { if (n.record.aliasOf) return !0; n = n.parent } return !1 } function Ybe(n) { return n.reduce((e, t) => Pn(e, t.meta), {}) } function M$(n, e) { const t = {}; for (const r in n) t[r] = r in e ? e[r] : n[r]; return t } function Zbe(n, e) { let t = 0, r = e.length; for (; t !== r;) { const a = t + r >> 1; AY(n, e[a]) < 0 ? r = a : t = a + 1 } const i = Xbe(n); return i && (r = e.lastIndexOf(i, r - 1)), r } function Xbe(n) { let e = n; for (; e = e.parent;)if (EY(e) && AY(n, e) === 0) return e } function EY({ record: n }) { return !!(n.name || n.components && Object.keys(n.components).length || n.redirect) } function Jbe(n) { const e = {}; if (n === "" || n === "?") return e; const r = (n[0] === "?" ? n.slice(1) : n).split("&"); for (let i = 0; i < r.length; ++i) { const a = r[i].replace(_Y, " "), o = a.indexOf("="), s = F0(o < 0 ? a : a.slice(0, o)), l = o < 0 ? null : F0(a.slice(o + 1)); if (s in e) { let c = e[s]; Ss(c) || (c = e[s] = [c]), c.push(l) } else e[s] = l } return e } function O$(n) { let e = ""; for (let t in n) { const r = n[t]; if (t = ybe(t), r == null) { r !== void 0 && (e += (e.length ? "&" : "") + t); continue } (Ss(r) ? r.map(a => a && fj(a)) : [r && fj(r)]).forEach(a => { a !== void 0 && (e += (e.length ? "&" : "") + t, a != null && (e += "=" + a)) }) } return e } function Qbe(n) { const e = {}; for (const t in n) { const r = n[t]; r !== void 0 && (e[t] = Ss(r) ? r.map(i => i == null ? null : "" + i) : r == null ? r : "" + r) } return e } const e1e = Symbol(""), D$ = Symbol(""), fk = Symbol(""), iR = Symbol(""), pj = Symbol(""); function Lv() { let n = []; function e(r) { return n.push(r), () => { const i = n.indexOf(r); i > -1 && n.splice(i, 1) } } function t() { n = [] } return { add: e, list: () => n.slice(), reset: t } } function Su(n, e, t, r, i, a = o => o()) { const o = r && (r.enterCallbacks[i] = r.enterCallbacks[i] || []); return () => new Promise((s, l) => { const c = f => { f === !1 ? l(fg(4, { from: t, to: e })) : f instanceof Error ? l(f) : Bbe(f) ? l(fg(2, { from: e, to: f })) : (o && r.enterCallbacks[i] === o && typeof f == "function" && o.push(f), s()) }, u = a(() => n.call(r && r.instances[i], e, t, c)); let d = Promise.resolve(u); n.length < 3 && (d = d.then(c)), d.catch(f => l(f)) }) } function mE(n, e, t, r, i = a => a()) { const a = []; for (const o of n) for (const s in o.components) { let l = o.components[s]; if (!(e !== "beforeRouteEnter" && !o.instances[s])) if (vY(l)) { const u = (l.__vccOpts || l)[e]; u && a.push(Su(u, t, r, o, s, i)) } else { let c = l(); a.push(() => c.then(u => { if (!u) throw new Error(`Couldn't resolve component "${s}" at "${o.path}"`); const d = sbe(u) ? u.default : u; o.mods[s] = u, o.components[s] = d; const h = (d.__vccOpts || d)[e]; return h && Su(h, t, r, o, s, i)() })) } } return a } function j$(n) { const e = zn(fk), t = zn(iR), r = ne(() => { const l = X(n.to); return e.resolve(l) }), i = ne(() => { const { matched: l } = r.value, { length: c } = l, u = l[c - 1], d = t.matched; if (!u || !d.length) return -1; const f = d.findIndex(dg.bind(null, u)); if (f > -1) return f; const h = P$(l[c - 2]); return c > 1 && P$(u) === h && d[d.length - 1].path !== h ? d.findIndex(dg.bind(null, l[c - 2])) : f }), a = ne(() => i.value > -1 && i1e(t.params, r.value.params)), o = ne(() => i.value > -1 && i.value === t.matched.length - 1 && SY(t.params, r.value.params)); function s(l = {}) { return r1e(l) ? e[X(n.replace) ? "replace" : "push"](X(n.to)).catch(Zy) : Promise.resolve() } return { route: r, href: ne(() => r.value.href), isActive: a, isExactActive: o, navigate: s } } const t1e = We({ name: "RouterLink", compatConfig: { MODE: 3 }, props: { to: { type: [String, Object], required: !0 }, replace: Boolean, activeClass: String, exactActiveClass: String, custom: Boolean, ariaCurrentValue: { type: String, default: "page" } }, useLink: j$, setup(n, { slots: e }) { const t = vr(j$(n)), { options: r } = zn(fk), i = ne(() => ({ [I$(n.activeClass, r.linkActiveClass, "router-link-active")]: t.isActive, [I$(n.exactActiveClass, r.linkExactActiveClass, "router-link-exact-active")]: t.isExactActive })); return () => { const a = e.default && e.default(t); return n.custom ? a : Gt("a", { "aria-current": t.isExactActive ? n.ariaCurrentValue : null, href: t.href, onClick: t.navigate, class: i.value }, a) } } }), n1e = t1e; function r1e(n) { if (!(n.metaKey || n.altKey || n.ctrlKey || n.shiftKey) && !n.defaultPrevented && !(n.button !== void 0 && n.button !== 0)) { if (n.currentTarget && n.currentTarget.getAttribute) { const e = n.currentTarget.getAttribute("target"); if (/\b_blank\b/i.test(e)) return } return n.preventDefault && n.preventDefault(), !0 } } function i1e(n, e) { for (const t in e) { const r = e[t], i = n[t]; if (typeof r == "string") { if (r !== i) return !1 } else if (!Ss(i) || i.length !== r.length || r.some((a, o) => a !== i[o])) return !1 } return !0 } function P$(n) { return n ? n.aliasOf ? n.aliasOf.path : n.path : "" } const I$ = (n, e, t) => n ?? e ?? t, a1e = We({ name: "RouterView", inheritAttrs: !1, props: { name: { type: String, default: "default" }, route: Object }, compatConfig: { MODE: 3 }, setup(n, { attrs: e, slots: t }) { const r = zn(pj), i = ne(() => n.route || r.value), a = zn(D$, 0), o = ne(() => { let c = X(a); const { matched: u } = i.value; let d; for (; (d = u[c]) && !d.components;)c++; return c }), s = ne(() => i.value.matched[o.value]); Or(D$, ne(() => o.value + 1)), Or(e1e, s), Or(pj, i); const l = he(); return Ct(() => [l.value, s.value, n.name], ([c, u, d], [f, h, p]) => { u && (u.instances[d] = c, h && h !== u && c && c === f && (u.leaveGuards.size || (u.leaveGuards = h.leaveGuards), u.updateGuards.size || (u.updateGuards = h.updateGuards))), c && u && (!h || !dg(u, h) || !f) && (u.enterCallbacks[d] || []).forEach(m => m(c)) }, { flush: "post" }), () => { const c = i.value, u = n.name, d = s.value, f = d && d.components[u]; if (!f) return L$(t.default, { Component: f, route: c }); const h = d.props[u], p = h ? h === !0 ? c.params : typeof h == "function" ? h(c) : h : null, g = Gt(f, Pn({}, p, e, { onVnodeUnmounted: y => { y.component.isUnmounted && (d.instances[u] = null) }, ref: l })); return L$(t.default, { Component: g, route: c }) || g } } }); function L$(n, e) { if (!n) return null; const t = n(e); return t.length === 1 ? t[0] : t } const o1e = a1e; function s1e(n) { const e = Kbe(n.routes, n), t = n.parseQuery || Jbe, r = n.stringifyQuery || O$, i = n.history, a = Lv(), o = Lv(), s = Lv(), l = Fa(nu); let c = nu; fm && n.scrollBehavior && "scrollRestoration" in history && (history.scrollRestoration = "manual"); const u = hE.bind(null, ae => "" + ae), d = hE.bind(null, bbe), f = hE.bind(null, F0); function h(ae, pe) { let se, ge; return kY(ae) ? (se = e.getRecordMatcher(ae), ge = pe) : ge = ae, e.addRoute(ge, se) } function p(ae) { const pe = e.getRecordMatcher(ae); pe && e.removeRoute(pe) } function m() { return e.getRoutes().map(ae => ae.record) } function g(ae) { return !!e.getRecordMatcher(ae) } function y(ae, pe) { if (pe = Pn({}, pe || l.value), typeof ae == "string") { const q = pE(t, ae, pe.path), ee = e.resolve({ path: q.path }, pe), de = i.createHref(q.fullPath); return Pn(q, ee, { params: f(ee.params), hash: F0(q.hash), redirectedFrom: void 0, href: de }) } let se; if (ae.path != null) se = Pn({}, ae, { path: pE(t, ae.path, pe.path).path }); else { const q = Pn({}, ae.params); for (const ee in q) q[ee] == null && delete q[ee]; se = Pn({}, ae, { params: d(q) }), pe.params = d(pe.params) } const ge = e.resolve(se, pe), _e = ae.hash || ""; ge.params = u(f(ge.params)); const je = Sbe(r, Pn({}, ae, { hash: vbe(_e), path: ge.path })), U = i.createHref(je); return Pn({ fullPath: je, hash: _e, query: r === O$ ? Qbe(ae.query) : ae.query || {} }, ge, { redirectedFrom: void 0, href: U }) } function b(ae) { return typeof ae == "string" ? pE(t, ae, l.value.path) : Pn({}, ae) } function w(ae, pe) { if (c !== ae) return fg(8, { from: pe, to: ae }) } function v(ae) { return k(ae) } function S(ae) { return v(Pn(b(ae), { replace: !0 })) } function x(ae) { const pe = ae.matched[ae.matched.length - 1]; if (pe && pe.redirect) { const { redirect: se } = pe; let ge = typeof se == "function" ? se(ae) : se; return typeof ge == "string" && (ge = ge.includes("?") || ge.includes("#") ? ge = b(ge) : { path: ge }, ge.params = {}), Pn({ query: ae.query, hash: ae.hash, params: ge.path != null ? {} : ae.params }, ge) } } function k(ae, pe) { const se = c = y(ae), ge = l.value, _e = ae.state, je = ae.force, U = ae.replace === !0, q = x(se); if (q) return k(Pn(b(q), { state: typeof q == "object" ? Pn({}, _e, q.state) : _e, force: je, replace: U }), pe || se); const ee = se; ee.redirectedFrom = pe; let de; return !je && Tbe(r, ge, se) && (de = fg(16, { to: ee, from: ge }), V(ge, ge, !0, !1)), (de ? Promise.resolve(de) : E(ee, ge)).catch(me => ql(me) ? ql(me, 2) ? me : K(me) : B(me, ee, ge)).then(me => { if (me) { if (ql(me, 2)) return k(Pn({ replace: U }, b(me.to), { state: typeof me.to == "object" ? Pn({}, _e, me.to.state) : _e, force: je }), pe || ee) } else me = j(ee, ge, !0, U, _e); return O(ee, ge, me), me }) } function A(ae, pe) { const se = w(ae, pe); return se ? Promise.reject(se) : Promise.resolve() } function C(ae) { const pe = ie.values().next().value; return pe && typeof pe.runWithContext == "function" ? pe.runWithContext(ae) : ae() } function E(ae, pe) { let se; const [ge, _e, je] = l1e(ae, pe); se = mE(ge.reverse(), "beforeRouteLeave", ae, pe); for (const q of ge) q.leaveGuards.forEach(ee => { se.push(Su(ee, ae, pe)) }); const U = A.bind(null, ae, pe); return se.push(U), De(se).then(() => { se = []; for (const q of a.list()) se.push(Su(q, ae, pe)); return se.push(U), De(se) }).then(() => { se = mE(_e, "beforeRouteUpdate", ae, pe); for (const q of _e) q.updateGuards.forEach(ee => { se.push(Su(ee, ae, pe)) }); return se.push(U), De(se) }).then(() => { se = []; for (const q of je) if (q.beforeEnter) if (Ss(q.beforeEnter)) for (const ee of q.beforeEnter) se.push(Su(ee, ae, pe)); else se.push(Su(q.beforeEnter, ae, pe)); return se.push(U), De(se) }).then(() => (ae.matched.forEach(q => q.enterCallbacks = {}), se = mE(je, "beforeRouteEnter", ae, pe, C), se.push(U), De(se))).then(() => { se = []; for (const q of o.list()) se.push(Su(q, ae, pe)); return se.push(U), De(se) }).catch(q => ql(q, 8) ? q : Promise.reject(q)) } function O(ae, pe, se) { s.list().forEach(ge => C(() => ge(ae, pe, se))) } function j(ae, pe, se, ge, _e) { const je = w(ae, pe); if (je) return je; const U = pe === nu, q = fm ? history.state : {}; se && (ge || U ? i.replace(ae.fullPath, Pn({ scroll: U && q && q.scroll }, _e)) : i.push(ae.fullPath, _e)), l.value = ae, V(ae, pe, se, U), K() } let I; function L() { I || (I = i.listen((ae, pe, se) => { if (!le.listening) return; const ge = y(ae), _e = x(ge); if (_e) { k(Pn(_e, { replace: !0 }), ge).catch(Zy); return } c = ge; const je = l.value; fm && jbe(w$(je.fullPath, se.delta), dk()), E(ge, je).catch(U => ql(U, 12) ? U : ql(U, 2) ? (k(U.to, ge).then(q => { ql(q, 20) && !se.delta && se.type === z0.pop && i.go(-1, !1) }).catch(Zy), Promise.reject()) : (se.delta && i.go(-se.delta, !1), B(U, ge, je))).then(U => { U = U || j(ge, je, !1), U && (se.delta && !ql(U, 8) ? i.go(-se.delta, !1) : se.type === z0.pop && ql(U, 20) && i.go(-1, !1)), O(ge, je, U) }).catch(Zy) })) } let R = Lv(), D = Lv(), P; function B(ae, pe, se) { K(ae); const ge = D.list(); return ge.length ? ge.forEach(_e => _e(ae, pe, se)) : console.error(ae), Promise.reject(ae) } function F() { return P && l.value !== nu ? Promise.resolve() : new Promise((ae, pe) => { R.add([ae, pe]) }) } function K(ae) { return P || (P = !ae, L(), R.list().forEach(([pe, se]) => ae ? se(ae) : pe()), R.reset()), ae } function V(ae, pe, se, ge) { const { scrollBehavior: _e } = n; if (!fm || !_e) return Promise.resolve(); const je = !se && Pbe(w$(ae.fullPath, 0)) || (ge || !se) && history.state && history.state.scroll || null; return Pr().then(() => _e(ae, pe, je)).then(U => U && Dbe(U)).catch(U => B(U, ae, pe)) } const W = ae => i.go(ae); let J; const ie = new Set, le = { currentRoute: l, listening: !0, addRoute: h, removeRoute: p, clearRoutes: e.clearRoutes, hasRoute: g, getRoutes: m, resolve: y, options: n, push: v, replace: S, go: W, back: () => W(-1), forward: () => W(1), beforeEach: a.add, beforeResolve: o.add, afterEach: s.add, onError: D.add, isReady: F, install(ae) { const pe = this; ae.component("RouterLink", n1e), ae.component("RouterView", o1e), ae.config.globalProperties.$router = pe, Object.defineProperty(ae.config.globalProperties, "$route", { enumerable: !0, get: () => X(l) }), fm && !J && l.value === nu && (J = !0, v(i.location).catch(_e => { })); const se = {}; for (const _e in nu) Object.defineProperty(se, _e, { get: () => l.value[_e], enumerable: !0 }); ae.provide(fk, pe), ae.provide(iR, dK(se)), ae.provide(pj, l); const ge = ae.unmount; ie.add(ae), ae.unmount = function () { ie.delete(ae), ie.size < 1 && (c = nu, I && I(), I = null, l.value = nu, J = !1, P = !1), ge() } } }; function De(ae) { return ae.reduce((pe, se) => pe.then(() => C(se)), Promise.resolve()) } return le } function l1e(n, e) { const t = [], r = [], i = [], a = Math.max(e.matched.length, n.matched.length); for (let o = 0; o < a; o++) { const s = e.matched[o]; s && (n.matched.find(c => dg(c, s)) ? r.push(s) : t.push(s)); const l = n.matched[o]; l && (e.matched.find(c => dg(c, l)) || i.push(l)) } return [t, r, i] } function c1e() { return zn(fk) } function Ldt(n) { return zn(iR) } const u1e = ["disabled", "ariaLabel"], ed = We({ __name: "Button", props: { theme: { default: "gray" }, size: { default: "sm" }, variant: { default: "subtle" }, label: {}, icon: {}, iconLeft: {}, iconRight: {}, loading: { type: Boolean, default: !1 }, loadingText: {}, disabled: { type: Boolean, default: !1 }, route: {}, link: {} }, setup(n) { const e = n, t = ek(), r = c1e(), i = ne(() => { let u = { gray: "text-ink-white bg-surface-gray-7 hover:bg-surface-gray-6 active:bg-surface-gray-5", blue: "text-ink-white bg-blue-500 hover:bg-surface-blue-3 active:bg-blue-700", green: "text-ink-white bg-surface-green-3 hover:bg-green-700 active:bg-green-800", red: "text-ink-white bg-surface-red-5 hover:bg-surface-red-6 active:bg-surface-red-7" }[e.theme], d = { gray: "text-ink-gray-8 bg-surface-gray-2 hover:bg-surface-gray-3 active:bg-surface-gray-4", blue: "text-ink-blue-3 bg-surface-blue-2 hover:bg-blue-200 active:bg-blue-300", green: "text-green-800 bg-surface-green-2 hover:bg-green-200 active:bg-green-300", red: "text-red-700 bg-surface-red-2 hover:bg-surface-red-3 active:bg-surface-red-4" }[e.theme], f = { gray: "text-ink-gray-8 bg-surface-white bg-surface-white border border-outline-gray-2 hover:border-outline-gray-3 active:border-outline-gray-3 active:bg-surface-gray-4", blue: "text-ink-blue-3 bg-surface-white border border-outline-blue-1 hover:border-blue-400 active:border-blue-400 active:bg-blue-300", green: "text-green-800 bg-surface-white border border-outline-green-2 hover:border-green-500 active:border-green-500 active:bg-green-300", red: "text-red-700 bg-surface-white border border-outline-red-1 hover:border-outline-red-2 active:border-outline-red-2 active:bg-surface-red-3" }[e.theme], h = { gray: "text-ink-gray-8 bg-transparent hover:bg-surface-gray-3 active:bg-surface-gray-4", blue: "text-ink-blue-3 bg-transparent hover:bg-blue-200 active:bg-blue-300", green: "text-green-800 bg-transparent hover:bg-green-200 active:bg-green-300", red: "text-red-700 bg-transparent hover:bg-surface-red-3 active:bg-surface-red-4" }[e.theme], p = { gray: "focus-visible:ring focus-visible:ring-outline-gray-3", blue: "focus-visible:ring focus-visible:ring-blue-400", green: "focus-visible:ring focus-visible:ring-outline-green-2", red: "focus-visible:ring focus-visible:ring-outline-red-2" }[e.theme], m = { subtle: d, solid: u, outline: f, ghost: h }[e.variant], g = `${e.theme}-${e.variant}`, b = { "gray-solid": "bg-surface-gray-2 text-ink-gray-4", "gray-subtle": "bg-surface-gray-2 text-ink-gray-4", "gray-outline": "bg-surface-gray-2 text-ink-gray-4 border border-outline-gray-2", "gray-ghost": "text-ink-gray-4", "blue-solid": "bg-blue-300 text-ink-white", "blue-subtle": "bg-surface-blue-2 text-ink-blue-link", "blue-outline": "bg-surface-blue-2 text-ink-blue-link border border-outline-blue-1", "blue-ghost": "text-ink-blue-link", "green-solid": "bg-surface-green-2 text-ink-green-2", "green-subtle": "bg-surface-green-2 text-ink-green-2", "green-outline": "bg-surface-green-2 text-ink-green-2 border border-outline-green-2", "green-ghost": "text-ink-green-2", "red-solid": "bg-surface-red-2 text-ink-red-2", "red-subtle": "bg-surface-red-2 text-ink-red-2", "red-outline": "bg-surface-red-2 text-ink-red-2 border border-outline-red-1", "red-ghost": "text-ink-red-2" }[g], w = { sm: "h-7 text-base px-2 rounded", md: "h-8 text-base font-medium px-2.5 rounded", lg: "h-10 text-lg font-medium px-3 rounded-md", xl: "h-11.5 text-xl font-medium px-3.5 rounded-lg", "2xl": "h-13 text-2xl font-medium px-3.5 rounded-xl" }[e.size]; return l.value && (w = { sm: "h-7 w-7 rounded", md: "h-8 w-8 rounded", lg: "h-10 w-10 rounded-md", xl: "h-11.5 w-11.5 rounded-lg", "2xl": "h-13 w-13 rounded-xl" }[e.size]), ["inline-flex items-center justify-center gap-2 transition-colors focus:outline-none", o.value ? b : m, p, w] }), a = ne(() => ({ sm: "h-4", md: "h-4.5", lg: "h-5", xl: "h-6", "2xl": "h-6" })[e.size]), o = ne(() => e.disabled || e.loading), s = ne(() => l.value ? e.label : null), l = ne(() => e.icon || t.icon), c = () => { if (e.route) return r.push(e.route); if (e.link) return window.open(e.link, "_blank") }; return (u, d) => (Z(), ye("button", Sn(u.$attrs, { class: i.value, onClick: c, disabled: o.value, ariaLabel: s.value }), [u.loading ? (Z(), Ye(uk, { key: 0, class: Tt({ "h-3 w-3": u.size == "sm", "h-[13.5px] w-[13.5px]": u.size == "md", "h-[15px] w-[15px]": u.size == "lg", "h-4.5 w-4.5": u.size == "xl" || u.size == "2xl" }) }, null, 8, ["class"])) : u.$slots.prefix || u.iconLeft ? ut(u.$slots, "prefix", { key: 1 }, () => [u.iconLeft && typeof u.iconLeft == "string" ? (Z(), Ye(vc, { key: 0, name: u.iconLeft, class: Tt(a.value), "aria-hidden": "true" }, null, 8, ["name", "class"])) : u.iconLeft ? (Z(), Ye(dl(u.iconLeft), { key: 1, class: Tt(a.value) }, null, 8, ["class"])) : mt("", !0)]) : mt("", !0), u.loading && u.loadingText ? (Z(), ye(Qt, { key: 2 }, [Fo(Ht(u.loadingText), 1)], 64)) : l.value && !u.loading ? (Z(), ye(Qt, { key: 3 }, [u.icon && typeof u.icon == "string" ? (Z(), Ye(vc, { key: 0, name: u.icon, class: Tt(a.value), "aria-label": u.label }, null, 8, ["name", "class", "aria-label"])) : u.icon ? (Z(), Ye(dl(u.icon), { key: 1, class: Tt(a.value) }, null, 8, ["class"])) : u.$slots.icon ? ut(u.$slots, "icon", { key: 2 }) : mt("", !0)], 64)) : (Z(), ye("span", { key: 4, class: Tt([{ "sr-only": l.value }, "truncate"]) }, [ut(u.$slots, "default", {}, () => [Fo(Ht(u.label), 1)])], 2)), ut(u.$slots, "suffix", {}, () => [u.iconRight && typeof u.iconRight == "string" ? (Z(), Ye(vc, { key: 0, name: u.iconRight, class: Tt(a.value), "aria-hidden": "true" }, null, 8, ["name", "class"])) : u.iconRight ? (Z(), Ye(dl(u.iconRight), { key: 1, class: Tt(a.value) }, null, 8, ["class"])) : mt("", !0)])], 16, u1e)) } }), d1e = { class: "w-full space-y-1.5" }, f1e = { key: 0, class: "block text-xs text-ink-gray-5" }, h1e = ["onClick"], p1e = { class: "flex items-center overflow-hidden" }, m1e = { key: 0, class: "truncate text-base leading-5 text-ink-gray-8" }, g1e = { key: 1, class: "text-base leading-5 text-ink-gray-4" }, v1e = { key: 0, class: "sticky top-0 z-10 flex items-stretch space-x-1.5 bg-surface-modal py-1.5" }, y1e = { class: "relative w-full" }, _1e = { class: "absolute right-0 inline-flex h-7 w-7 items-center justify-center" }, b1e = { key: 0, class: "sticky top-10 truncate bg-surface-modal px-2.5 py-1.5 text-sm font-medium text-ink-gray-5" }, w1e = { class: "flex flex-1 gap-2 overflow-hidden items-center" }, x1e = { key: 0, class: "flex flex-shrink-0" }, S1e = { key: 1, class: "h-4 w-4" }, T1e = { class: "flex-1 truncate text-ink-gray-7" }, k1e = { key: 0, class: "ml-2 flex-shrink-0" }, C1e = { key: 0, class: "text-sm text-ink-gray-5" }, A1e = { key: 1, class: "rounded-md px-2.5 py-1.5 text-base text-ink-gray-5" }, E1e = { key: 0, class: "border-t p-1" }, M1e = { key: 0, class: "flex items-center justify-end" }, O1e = { key: 1, class: "flex items-center justify-end" }, D1e = We({ __name: "Autocomplete", props: { label: {}, options: {}, hideSearch: { type: Boolean, default: !1 }, placeholder: {}, bodyClasses: {}, loading: { type: Boolean }, placement: {}, showFooter: { type: Boolean }, multiple: { type: Boolean, default: !1 }, modelValue: { type: [Array, null, String, Number, Boolean, Object] } }, emits: ["update:modelValue", "update:query", "change"], setup(n, { expose: e, emit: t }) { const r = n, i = t, a = he(), o = he(!1), s = he(""), l = ne(() => { var E; if (!((E = r.options) != null && E.length)) return []; let C; return x(r.options[0]) ? C = r.options : C = [{ group: "", items: u(r.options), hideLabel: !1 }], C.map((O, j) => ({ key: j, group: O.group, hideLabel: O.hideLabel, items: d(u(O.items || [])) })).filter(O => O.items.length > 0) }), c = ne(() => l.value.flatMap(C => C.items)), u = C => C ? C.map(E => S(E) ? E : { label: E.toString(), value: E }) : [], d = C => s.value ? C.filter(E => E.label.toLowerCase().includes(s.value.trim().toLowerCase()) || E.value.toString().toLowerCase().includes(s.value.trim().toLowerCase())) : C, f = ne({ get() { if (!r.multiple) return h(r.modelValue) || p(r.modelValue); const C = r.modelValue || []; return S(C[0]) ? C : C.map(E => h(E) || p(E)) }, set(C) { if (s.value = "", C && !r.multiple && (o.value = !1), !r.multiple) { i("update:modelValue", C); return } i("update:modelValue", C) } }), h = C => { if (!C) return C; const E = S(C) ? C.value : C; return c.value.find(O => O.value === E) }, p = C => S(C) ? C : { label: C, value: C }, m = C => S(C) ? (C == null ? void 0 : C.label) || (C == null ? void 0 : C.value) : C, g = ne(() => f.value ? r.multiple ? f.value.map(C => m(C)).join(", ") : m(f.value) : ""), y = C => { if (!f.value) return !1; const E = S(C) ? C.value : C; return r.multiple ? f.value.find(O => S(O) ? O.value === E : O === E) : f.value === E }, b = ne(() => { var C; return r.multiple ? c.value.length === ((C = f.value) == null ? void 0 : C.length) : !1 }), w = () => { f.value = c.value }, v = () => { f.value = r.multiple ? [] : void 0 }, S = C => typeof C == "object", x = C => typeof C == "object" && "items" in C && "group" in C; Ct(() => s.value, () => { i("update:query", s.value) }), Ct(() => o.value, () => { o.value && Pr(() => { var C; return (C = a.value) == null ? void 0 : C.$el.focus() }) }); const k = he(); return e({ rootRef: k, togglePopover: () => { o.value = !o.value } }), (C, E) => (Z(), Ye(X(p0e), { modelValue: f.value, "onUpdate:modelValue": E[2] || (E[2] = O => f.value = O), multiple: C.multiple, nullable: "" }, { default: Ue(({ open: O }) => [$e(X(mY), { class: "w-full", show: o.value, "onUpdate:show": E[1] || (E[1] = j => o.value = j), ref_key: "rootRef", ref: k, placement: C.placement }, { target: Ue(({ open: j, togglePopover: I, close: L }) => [ut(C.$slots, "target", Eo(Mo({ open: j, close: L, togglePopover: I, isOpen: O })), () => [re("div", d1e, [r.label ? (Z(), ye("label", f1e, Ht(r.label), 1)) : mt("", !0), re("button", { class: Tt(["flex h-7 w-full items-center justify-between gap-2 rounded bg-surface-gray-2 px-2 py-1 transition-colors hover:bg-surface-gray-3 border border-transparent focus:border-outline-gray-4 focus:outline-none focus:ring-2 focus:ring-outline-gray-3", { "bg-surface-gray-3": O }]), onClick: () => I() }, [re("div", p1e, [ut(C.$slots, "prefix"), g.value ? (Z(), ye("span", m1e, Ht(g.value), 1)) : (Z(), ye("span", g1e, Ht(C.placeholder || ""), 1)), ut(C.$slots, "suffix")]), $e(vc, { name: "chevron-down", class: "h-4 w-4 text-ink-gray-5", "aria-hidden": "true" })], 10, h1e)])])]), body: Ue(({ isOpen: j, togglePopover: I }) => [Dh(re("div", null, [re("div", { class: Tt(["relative mt-1 rounded-lg bg-surface-modal text-base shadow-2xl", C.bodyClasses]) }, [$e(X(g0e), { class: Tt(["max-h-[15rem] overflow-y-auto px-1.5 pb-1.5", { "pt-1.5": C.hideSearch }]), static: "" }, { default: Ue(() => [C.hideSearch ? mt("", !0) : (Z(), ye("div", v1e, [re("div", y1e, [$e(X(m0e), { ref_key: "searchInput", ref: a, class: "form-input w-full focus:bg-surface-gray-3 hover:bg-surface-gray-4 text-ink-gray-8", type: "text", value: s.value, onChange: E[0] || (E[0] = L => s.value = L.target.value), autocomplete: "off", placeholder: "Search" }, null, 8, ["value"]), re("div", _1e, [r.loading ? (Z(), Ye(uk, { key: 0, class: "h-4 w-4 text-ink-gray-5" })) : (Z(), ye("button", { key: 1, onClick: v }, [$e(vc, { name: "x", class: "w-4 text-ink-gray-8" })]))])])])), (Z(!0), ye(Qt, null, Wa(l.value, L => Dh((Z(), ye("div", { key: L.key }, [L.group && !L.hideLabel ? (Z(), ye("div", b1e, Ht(L.group), 1)) : mt("", !0), (Z(!0), ye(Qt, null, Wa(L.items.slice(0, 50), (R, D) => (Z(), Ye(X(v0e), { as: "template", key: D, value: R, disabled: R.disabled }, { default: Ue(({ active: P, selected: B }) => [re("li", { class: Tt(["flex cursor-pointer items-center justify-between rounded px-2.5 py-1.5 text-base", { "bg-surface-gray-3": P, "opacity-50": R.disabled }]) }, [re("div", w1e, [C.$slots["item-prefix"] || r.multiple ? (Z(), ye("div", x1e, [ut(C.$slots, "item-prefix", Sn({ ref_for: !0 }, { active: P, selected: B, option: R }), () => [y(R) ? (Z(), Ye(vc, { key: 0, name: "check", class: "h-4 w-4 text-ink-gray-7" })) : (Z(), ye("div", S1e))])])) : mt("", !0), re("span", T1e, Ht(m(R)), 1)]), C.$slots["item-suffix"] || R != null && R.description ? (Z(), ye("div", k1e, [ut(C.$slots, "item-suffix", Sn({ ref_for: !0 }, { active: P, selected: B, option: R }), () => [R != null && R.description ? (Z(), ye("div", C1e, Ht(R.description), 1)) : mt("", !0)])])) : mt("", !0)], 2)]), _: 2 }, 1032, ["value", "disabled"]))), 128))])), [[ag, L.items.length > 0]])), 128)), l.value.length == 0 ? (Z(), ye("li", A1e, " No results found ")) : mt("", !0)]), _: 3 }, 8, ["class"]), C.$slots.footer || r.showFooter || C.multiple ? (Z(), ye("div", E1e, [ut(C.$slots, "footer", Eo(Mo({ togglePopover: I })), () => [C.multiple ? (Z(), ye("div", M1e, [b.value ? mt("", !0) : (Z(), Ye(X(ed), { key: 0, label: "Select All", onClick: ar(w, ["stop"]) })), b.value ? (Z(), Ye(X(ed), { key: 1, label: "Clear All", onClick: ar(v, ["stop"]) })) : mt("", !0)])) : (Z(), ye("div", O1e, [$e(X(ed), { label: "Clear", onClick: ar(v, ["stop"]) })]))])])) : mt("", !0)], 2)], 512), [[ag, j]])]), _: 2 }, 1032, ["show", "placement"])]), _: 3 }, 8, ["modelValue", "multiple"])) } }), MY = We({ __name: "Badge", props: { theme: { default: "gray" }, size: { default: "md" }, variant: { default: "subtle" }, label: {} }, setup(n) { const e = n, t = ne(() => { let r = { gray: "text-ink-white bg-surface-gray-7", blue: "text-ink-blue-1 bg-surface-blue-2", green: "text-ink-green-1 bg-surface-green-3", orange: "text-ink-amber-1 bg-surface-amber-2", red: "text-ink-red-1 bg-surface-red-4" }[e.theme], i = { gray: "text-ink-gray-6 bg-surface-gray-2", blue: "text-ink-blue-2 bg-surface-blue-1", green: "text-ink-green-3 bg-surface-green-2", orange: "text-ink-amber-3 bg-surface-amber-1", red: "text-ink-red-4 bg-surface-red-1" }[e.theme], a = { gray: "text-ink-gray-6 bg-transparent border border-outline-gray-1", blue: "text-ink-blue-2 bg-transparent border border-outline-blue-1", green: "text-ink-green-3 bg-transparent border border-outline-green-2", orange: "text-ink-amber-3 bg-transparent border border-outline-amber-2", red: "text-ink-red-4 bg-transparent border border-outline-red-2" }[e.theme], o = { gray: "text-ink-gray-6 bg-transparent", blue: "text-ink-blue-2 bg-transparent", green: "text-ink-green-3 bg-transparent", orange: "text-ink-amber-3 bg-transparent", red: "text-ink-red-4 bg-transparent" }[e.theme], s = { subtle: i, solid: r, outline: a, ghost: o }[e.variant], l = { sm: "h-4 text-xs px-1.5", md: "h-5 text-xs px-1.5", lg: "h-6 text-sm px-2" }[e.size]; return [s, l] }); return (r, i) => (Z(), ye("div", { class: Tt(["inline-flex select-none items-center gap-1 rounded-full", t.value]) }, [r.$slots.prefix ? (Z(), ye("div", { key: 0, class: Tt([e.size == "lg" ? "max-h-6" : "max-h-4"]) }, [ut(r.$slots, "prefix")], 2)) : mt("", !0), ut(r.$slots, "default", {}, () => { var a; return [Fo(Ht((a = e.label) == null ? void 0 : a.toString()), 1)] }), r.$slots.suffix ? (Z(), ye("div", { key: 1, class: Tt([e.size == "lg" ? "max-h-6" : "max-h-4"]) }, [ut(r.$slots, "suffix")], 2)) : mt("", !0)], 2)) } }); var j1e = !1; function yd(n) { return Q_() ? (eb(n), !0) : !1 } function gE() { const n = new Set, e = i => { n.delete(i) }; return { on: i => { n.add(i); const a = () => e(i); return yd(a), { off: a } }, off: e, trigger: (...i) => Promise.all(Array.from(n).map(a => a(...i))) } } function tr(n) { return typeof n == "function" ? n() : X(n) } const V0 = typeof window < "u" && typeof document < "u"; typeof WorkerGlobalScope < "u" && globalThis instanceof WorkerGlobalScope; const P1e = n => n != null, I1e = Object.prototype.toString, L1e = n => I1e.call(n) === "[object Object]", ys = () => { }, R1e = N1e(); function N1e() { var n, e; return V0 && ((n = window == null ? void 0 : window.navigator) == null ? void 0 : n.userAgent) && (/iP(?:ad|hone|od)/.test(window.navigator.userAgent) || ((e = window == null ? void 0 : window.navigator) == null ? void 0 : e.maxTouchPoints) > 2 && /iPad|Macintosh/.test(window == null ? void 0 : window.navigator.userAgent)) } function OY(n, e) { function t(...r) { return new Promise((i, a) => { Promise.resolve(n(() => e.apply(this, r), { fn: e, thisArg: this, args: r })).then(i).catch(a) }) } return t } const DY = n => n(); function jY(n, e = {}) { let t, r, i = ys; const a = s => { clearTimeout(s), i(), i = ys }; return s => { const l = tr(n), c = tr(e.maxWait); return t && a(t), l <= 0 || c !== void 0 && c <= 0 ? (r && (a(r), r = null), Promise.resolve(s())) : new Promise((u, d) => { i = e.rejectOnCancel ? d : u, c && !r && (r = setTimeout(() => { t && a(t), r = null, u(s()) }, c)), t = setTimeout(() => { r && a(r), r = null, u(s()) }, l) }) } } function B1e(n = DY) { const e = he(!0); function t() { e.value = !1 } function r() { e.value = !0 } const i = (...a) => { e.value && n(...a) }; return { isActive: ba(e), pause: t, resume: r, eventFilter: i } } function R$(n, e = !1, t = "Timeout") { return new Promise((r, i) => { setTimeout(e ? () => i(t) : r, n) }) } function $1e(n, ...e) { return e.some(t => t in n) } function F1e(n) { return n || kr() } function vE(...n) { if (n.length !== 1) return M0(...n); const e = n[0]; return typeof e == "function" ? ba(XT(() => ({ get: e, set: ys }))) : he(e) } function Rdt(n, e = 200, t = {}) { return OY(jY(e, t), n) } function PY(n, e, t = {}) { const { eventFilter: r = DY, ...i } = t; return Ct(n, OY(r, e), i) } function z1e(n, e, t = {}) { const { eventFilter: r, ...i } = t, { eventFilter: a, pause: o, resume: s, isActive: l } = B1e(r); return { stop: PY(n, e, { ...i, eventFilter: a }), pause: o, resume: s, isActive: l } } function IY(n, e = !0, t) { F1e() ? un(n, t) : e ? n() : Pr(n) } function mj(n, e = !1) { function t(d, { flush: f = "sync", deep: h = !1, timeout: p, throwOnTimeout: m } = {}) { let g = null; const b = [new Promise(w => { g = Ct(n, v => { d(v) !== e && (g == null || g(), w(v)) }, { flush: f, deep: h, immediate: !0 }) })]; return p != null && b.push(R$(p, m).then(() => tr(n)).finally(() => g == null ? void 0 : g())), Promise.race(b) } function r(d, f) { if (!Kn(d)) return t(v => v === d, f); const { flush: h = "sync", deep: p = !1, timeout: m, throwOnTimeout: g } = f ?? {}; let y = null; const w = [new Promise(v => { y = Ct([n, d], ([S, x]) => { e !== (S === x) && (y == null || y(), v(S)) }, { flush: h, deep: p, immediate: !0 }) })]; return m != null && w.push(R$(m, g).then(() => tr(n)).finally(() => (y == null || y(), tr(n)))), Promise.race(w) } function i(d) { return t(f => !!f, d) } function a(d) { return r(null, d) } function o(d) { return r(void 0, d) } function s(d) { return t(Number.isNaN, d) } function l(d, f) { return t(h => { const p = Array.from(h); return p.includes(d) || p.includes(tr(d)) }, f) } function c(d) { return u(1, d) } function u(d = 1, f) { let h = -1; return t(() => (h += 1, h >= d), f) } return Array.isArray(tr(n)) ? { toMatch: t, toContains: l, changed: c, changedTimes: u, get not() { return mj(n, !e) } } : { toMatch: t, toBe: r, toBeTruthy: i, toBeNull: a, toBeNaN: s, toBeUndefined: o, changed: c, changedTimes: u, get not() { return mj(n, !e) } } } function V1e(n) { return mj(n) } const H1e = /^(\d{4})[-/]?(\d{1,2})?[-/]?(\d{0,2})[T\s]*(\d{1,2})?:?(\d{1,2})?:?(\d{1,2})?[.:]?(\d+)?$/i, U1e = /[YMDHhms]o|\[([^\]]+)\]|Y{1,4}|M{1,4}|D{1,2}|d{1,4}|H{1,2}|h{1,2}|a{1,2}|A{1,2}|m{1,2}|s{1,2}|Z{1,2}|SSS/g; function G1e(n, e, t, r) { let i = n < 12 ? "AM" : "PM"; return r && (i = i.split("").reduce((a, o) => a += `${o}.`, "")), t ? i.toLowerCase() : i } function sf(n) { const e = ["th", "st", "nd", "rd"], t = n % 100; return n + (e[(t - 20) % 10] || e[t] || e[0]) } function W1e(n, e, t = {}) { var r; const i = n.getFullYear(), a = n.getMonth(), o = n.getDate(), s = n.getHours(), l = n.getMinutes(), c = n.getSeconds(), u = n.getMilliseconds(), d = n.getDay(), f = (r = t.customMeridiem) != null ? r : G1e, h = { Yo: () => sf(i), YY: () => String(i).slice(-2), YYYY: () => i, M: () => a + 1, Mo: () => sf(a + 1), MM: () => `${a + 1}`.padStart(2, "0"), MMM: () => n.toLocaleDateString(t.locales, { month: "short" }), MMMM: () => n.toLocaleDateString(t.locales, { month: "long" }), D: () => String(o), Do: () => sf(o), DD: () => `${o}`.padStart(2, "0"), H: () => String(s), Ho: () => sf(s), HH: () => `${s}`.padStart(2, "0"), h: () => `${s % 12 || 12}`.padStart(1, "0"), ho: () => sf(s % 12 || 12), hh: () => `${s % 12 || 12}`.padStart(2, "0"), m: () => String(l), mo: () => sf(l), mm: () => `${l}`.padStart(2, "0"), s: () => String(c), so: () => sf(c), ss: () => `${c}`.padStart(2, "0"), SSS: () => `${u}`.padStart(3, "0"), d: () => d, dd: () => n.toLocaleDateString(t.locales, { weekday: "narrow" }), ddd: () => n.toLocaleDateString(t.locales, { weekday: "short" }), dddd: () => n.toLocaleDateString(t.locales, { weekday: "long" }), A: () => f(s, l), AA: () => f(s, l, !1, !0), a: () => f(s, l, !0), aa: () => f(s, l, !0, !0) }; return e.replace(U1e, (p, m) => { var g, y; return (y = m ?? ((g = h[p]) == null ? void 0 : g.call(h))) != null ? y : p }) } function K1e(n) { if (n === null) return new Date(Number.NaN); if (n === void 0) return new Date; if (n instanceof Date) return new Date(n); if (typeof n == "string" && !/Z$/i.test(n)) { const e = n.match(H1e); if (e) { const t = e[2] - 1 || 0, r = (e[7] || "0").substring(0, 3); return new Date(e[1], t, e[3] || 1, e[4] || 0, e[5] || 0, e[6] || 0, r) } } return new Date(n) } function q1e(n, e = "HH:mm:ss", t = {}) { return ne(() => W1e(K1e(tr(n)), tr(e), t)) } function Y1e(n, e = 1e3, t = {}) { const { immediate: r = !0, immediateCallback: i = !1 } = t; let a = null; const o = he(!1); function s() { a && (clearInterval(a), a = null) } function l() { o.value = !1, s() } function c() { const u = tr(e); u <= 0 || (o.value = !0, i && n(), s(), a = setInterval(n, u)) } if (r && V0 && c(), Kn(e) || typeof e == "function") { const u = Ct(e, () => { o.value && V0 && c() }); yd(u) } return yd(l), { isActive: o, pause: l, resume: c } } function Z1e(n, e, t = {}) { const { immediate: r = !0 } = t, i = he(!1); let a = null; function o() { a && (clearTimeout(a), a = null) } function s() { i.value = !1, o() } function l(...c) { o(), i.value = !0, a = setTimeout(() => { i.value = !1, a = null, n(...c) }, tr(e)) } return r && (i.value = !0, V0 && l()), yd(s), { isPending: ba(i), start: l, stop: s } } function Ndt(n, e, t = {}) { const { debounce: r = 0, maxWait: i = void 0, ...a } = t; return PY(n, e, { ...a, eventFilter: jY(r, { maxWait: i }) }) } function Bdt(n, e, t) { const r = Ct(n, (...i) => (Pr(() => r()), e(...i)), t); return r } function Nu(n) { var e; const t = tr(n); return (e = t == null ? void 0 : t.$el) != null ? e : t } const Ts = V0 ? window : void 0; function rl(...n) { let e, t, r, i; if (typeof n[0] == "string" || Array.isArray(n[0]) ? ([t, r, i] = n, e = Ts) : [e, t, r, i] = n, !e) return ys; Array.isArray(t) || (t = [t]), Array.isArray(r) || (r = [r]); const a = [], o = () => { a.forEach(u => u()), a.length = 0 }, s = (u, d, f, h) => (u.addEventListener(d, f, h), () => u.removeEventListener(d, f, h)), l = Ct(() => [Nu(e), tr(i)], ([u, d]) => { if (o(), !u) return; const f = L1e(d) ? { ...d } : d; a.push(...t.flatMap(h => r.map(p => s(u, h, p, f)))) }, { immediate: !0, flush: "post" }), c = () => { l(), o() }; return yd(c), c } let N$ = !1; function $dt(n, e, t = {}) { const { window: r = Ts, ignore: i = [], capture: a = !0, detectIframe: o = !1 } = t; if (!r) return ys; R1e && !N$ && (N$ = !0, Array.from(r.document.body.children).forEach(f => f.addEventListener("click", ys)), r.document.documentElement.addEventListener("click", ys)); let s = !0; const l = f => i.some(h => { if (typeof h == "string") return Array.from(r.document.querySelectorAll(h)).some(p => p === f.target || f.composedPath().includes(p)); { const p = Nu(h); return p && (f.target === p || f.composedPath().includes(p)) } }), u = [rl(r, "click", f => { const h = Nu(n); if (!(!h || h === f.target || f.composedPath().includes(h))) { if (f.detail === 0 && (s = !l(f)), !s) { s = !0; return } e(f) } }, { passive: !0, capture: a }), rl(r, "pointerdown", f => { const h = Nu(n); s = !l(f) && !!(h && !f.composedPath().includes(h)) }, { passive: !0 }), o && rl(r, "blur", f => { setTimeout(() => { var h; const p = Nu(n); ((h = r.document.activeElement) == null ? void 0 : h.tagName) === "IFRAME" && !(p != null && p.contains(r.document.activeElement)) && e(f) }, 0) })].filter(Boolean); return () => u.forEach(f => f()) } function X1e() { const n = he(!1), e = kr(); return e && un(() => { n.value = !0 }, e), n } function LY(n) { const e = X1e(); return ne(() => (e.value, !!n())) } function J1e(n, e = {}) { const { immediate: t = !0, fpsLimit: r = void 0, window: i = Ts } = e, a = he(!1), o = r ? 1e3 / r : null; let s = 0, l = null; function c(f) { if (!a.value || !i) return; s || (s = f); const h = f - s; if (o && h < o) { l = i.requestAnimationFrame(c); return } s = f, n({ delta: h, timestamp: f }), l = i.requestAnimationFrame(c) } function u() { !a.value && i && (a.value = !0, s = 0, l = i.requestAnimationFrame(c)) } function d() { a.value = !1, l != null && i && (i.cancelAnimationFrame(l), l = null) } return t && u(), yd(d), { isActive: ba(a), pause: d, resume: u } } function Q1e(n, e = {}) { const { window: t = Ts } = e, r = LY(() => t && "matchMedia" in t && typeof t.matchMedia == "function"); let i; const a = he(!1), o = c => { a.value = c.matches }, s = () => { i && ("removeEventListener" in i ? i.removeEventListener("change", o) : i.removeListener(o)) }, l = Bn(() => { r.value && (s(), i = t.matchMedia(tr(n)), "addEventListener" in i ? i.addEventListener("change", o) : i.addListener(o), a.value = i.matches) }); return yd(() => { l(), s(), i = void 0 }), a } const U1 = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {}, G1 = "__vueuse_ssr_handlers__", ewe = twe(); function twe() { return G1 in U1 || (U1[G1] = U1[G1] || {}), U1[G1] } function nwe(n, e) { return ewe[n] || e } function rwe(n) { return n == null ? "any" : n instanceof Set ? "set" : n instanceof Map ? "map" : n instanceof Date ? "date" : typeof n == "boolean" ? "boolean" : typeof n == "string" ? "string" : typeof n == "object" ? "object" : Number.isNaN(n) ? "any" : "number" } const iwe = { boolean: { read: n => n === "true", write: n => String(n) }, object: { read: n => JSON.parse(n), write: n => JSON.stringify(n) }, number: { read: n => Number.parseFloat(n), write: n => String(n) }, any: { read: n => n, write: n => String(n) }, string: { read: n => n, write: n => String(n) }, map: { read: n => new Map(JSON.parse(n)), write: n => JSON.stringify(Array.from(n.entries())) }, set: { read: n => new Set(JSON.parse(n)), write: n => JSON.stringify(Array.from(n)) }, date: { read: n => new Date(n), write: n => n.toISOString() } }, B$ = "vueuse-storage"; function Fdt(n, e, t, r = {}) { var i; const { flush: a = "pre", deep: o = !0, listenToStorageChanges: s = !0, writeDefaults: l = !0, mergeDefaults: c = !1, shallow: u, window: d = Ts, eventFilter: f, onError: h = E => { console.error(E) }, initOnMounted: p } = r, m = (u ? Fa : he)(typeof e == "function" ? e() : e); if (!t) try { t = nwe("getDefaultStorage", () => { var E; return (E = Ts) == null ? void 0 : E.localStorage })() } catch (E) { h(E) } if (!t) return m; const g = tr(e), y = rwe(g), b = (i = r.serializer) != null ? i : iwe[y], { pause: w, resume: v } = z1e(m, () => x(m.value), { flush: a, deep: o, eventFilter: f }); d && s && IY(() => { rl(d, "storage", A), rl(d, B$, C), p && A() }), p || A(); function S(E, O) { d && d.dispatchEvent(new CustomEvent(B$, { detail: { key: n, oldValue: E, newValue: O, storageArea: t } })) } function x(E) { try { const O = t.getItem(n); if (E == null) S(O, null), t.removeItem(n); else { const j = b.write(E); O !== j && (t.setItem(n, j), S(O, j)) } } catch (O) { h(O) } } function k(E) { const O = E ? E.newValue : t.getItem(n); if (O == null) return l && g != null && t.setItem(n, b.write(g)), g; if (!E && c) { const j = b.read(O); return typeof c == "function" ? c(j, g) : y === "object" && !Array.isArray(j) ? { ...g, ...j } : j } else return typeof O != "string" ? O : b.read(O) } function A(E) { if (!(E && E.storageArea !== t)) { if (E && E.key == null) { m.value = g; return } if (!(E && E.key !== n)) { w(); try { (E == null ? void 0 : E.newValue) !== b.write(m.value) && (m.value = k(E)) } catch (O) { h(O) } finally { E ? Pr(v) : v() } } } } function C(E) { A(E.detail) } return m } function awe(n, e, t = {}) { const { root: r, rootMargin: i = "0px", threshold: a = .1, window: o = Ts, immediate: s = !0 } = t, l = LY(() => o && "IntersectionObserver" in o), c = ne(() => { const p = tr(n); return (Array.isArray(p) ? p : [p]).map(Nu).filter(P1e) }); let u = ys; const d = he(s), f = l.value ? Ct(() => [c.value, Nu(r), d.value], ([p, m]) => { if (u(), !d.value || !p.length) return; const g = new IntersectionObserver(e, { root: Nu(m), rootMargin: i, threshold: a }); p.forEach(y => y && g.observe(y)), u = () => { g.disconnect(), u = ys } }, { immediate: s, flush: "post" }) : ys, h = () => { u(), f(), d.value = !1 }; return yd(h), { isSupported: l, isActive: d, pause() { u(), d.value = !1 }, resume() { d.value = !0 }, stop: h } } function zdt(n, e = {}) { const { window: t = Ts, scrollTarget: r, threshold: i = 0 } = e, a = he(!1); return awe(n, o => { let s = a.value, l = 0; for (const c of o) c.time >= l && (l = c.time, s = c.isIntersecting); a.value = s }, { root: r, window: t, threshold: i }), a } const owe = { json: "application/json", text: "text/plain" }; function RS(n) { return n && $1e(n, "immediate", "refetch", "initialData", "timeout", "beforeFetch", "afterFetch", "onFetchError", "fetch", "updateDataOnError") } const swe = /^(?:[a-z][a-z\d+\-.]*:)?\/\//i; function lwe(n) { return swe.test(n) } function Jy(n) { return typeof Headers < "u" && n instanceof Headers ? Object.fromEntries(n.entries()) : n } function Pp(n, ...e) { return n === "overwrite" ? async t => { const r = e[e.length - 1]; return r ? { ...t, ...await r(t) } : t } : async t => { for (const r of e) r && (t = { ...t, ...await r(t) }); return t } } function cwe(n = {}) { const e = n.combination || "chain", t = n.options || {}, r = n.fetchOptions || {}; function i(a, ...o) { const s = ne(() => { const u = tr(n.baseUrl), d = tr(a); return u && !lwe(d) ? dwe(u, d) : d }); let l = t, c = r; return o.length > 0 && (RS(o[0]) ? l = { ...l, ...o[0], beforeFetch: Pp(e, t.beforeFetch, o[0].beforeFetch), afterFetch: Pp(e, t.afterFetch, o[0].afterFetch), onFetchError: Pp(e, t.onFetchError, o[0].onFetchError) } : c = { ...c, ...o[0], headers: { ...Jy(c.headers) || {}, ...Jy(o[0].headers) || {} } }), o.length > 1 && RS(o[1]) && (l = { ...l, ...o[1], beforeFetch: Pp(e, t.beforeFetch, o[1].beforeFetch), afterFetch: Pp(e, t.afterFetch, o[1].afterFetch), onFetchError: Pp(e, t.onFetchError, o[1].onFetchError) }), uwe(s, c, l) } return i } function uwe(n, ...e) { var t; const r = typeof AbortController == "function"; let i = {}, a = { immediate: !0, refetch: !1, timeout: 0, updateDataOnError: !1 }; const o = { method: "GET", type: "text", payload: void 0 }; e.length > 0 && (RS(e[0]) ? a = { ...a, ...e[0] } : i = e[0]), e.length > 1 && RS(e[1]) && (a = { ...a, ...e[1] }); const { fetch: s = (t = Ts) == null ? void 0 : t.fetch, initialData: l, timeout: c } = a, u = gE(), d = gE(), f = gE(), h = he(!1), p = he(!1), m = he(!1), g = he(null), y = Fa(null), b = Fa(null), w = Fa(l || null), v = ne(() => r && p.value); let S, x; const k = () => { r && (S == null || S.abort(), S = new AbortController, S.signal.onabort = () => m.value = !0, i = { ...i, signal: S.signal }) }, A = D => { p.value = D, h.value = !D }; c && (x = Z1e(k, c, { immediate: !1 })); let C = 0; const E = async (D = !1) => { var P, B; k(), A(!0), b.value = null, g.value = null, m.value = !1, C += 1; const F = C, K = { method: o.method, headers: {} }; if (o.payload) { const ie = Jy(K.headers), le = tr(o.payload); !o.payloadType && le && Object.getPrototypeOf(le) === Object.prototype && !(le instanceof FormData) && (o.payloadType = "json"), o.payloadType && (ie["Content-Type"] = (P = owe[o.payloadType]) != null ? P : o.payloadType), K.body = o.payloadType === "json" ? JSON.stringify(le) : le } let V = !1; const W = { url: tr(n), options: { ...K, ...i }, cancel: () => { V = !0 } }; if (a.beforeFetch && Object.assign(W, await a.beforeFetch(W)), V || !s) return A(!1), Promise.resolve(null); let J = null; return x && x.start(), s(W.url, { ...K, ...W.options, headers: { ...Jy(K.headers), ...Jy((B = W.options) == null ? void 0 : B.headers) } }).then(async ie => { if (y.value = ie, g.value = ie.status, J = await ie.clone()[o.type](), !ie.ok) throw w.value = l || null, new Error(ie.statusText); return a.afterFetch && ({ data: J } = await a.afterFetch({ data: J, response: ie })), w.value = J, u.trigger(ie), ie }).catch(async ie => { let le = ie.message || ie.name; if (a.onFetchError && ({ error: le, data: J } = await a.onFetchError({ data: J, error: ie, response: y.value })), b.value = le, a.updateDataOnError && (w.value = J), d.trigger(ie), D) throw ie; return null }).finally(() => { F === C && A(!1), x && x.stop(), f.trigger(null) }) }, O = vE(a.refetch); Ct([O, vE(n)], ([D]) => D && E(), { deep: !0 }); const j = { isFinished: ba(h), isFetching: ba(p), statusCode: g, response: y, error: b, data: w, canAbort: v, aborted: m, abort: k, execute: E, onFetchResponse: u.on, onFetchError: d.on, onFetchFinally: f.on, get: I("GET"), put: I("PUT"), post: I("POST"), delete: I("DELETE"), patch: I("PATCH"), head: I("HEAD"), options: I("OPTIONS"), json: R("json"), text: R("text"), blob: R("blob"), arrayBuffer: R("arrayBuffer"), formData: R("formData") }; function I(D) { return (P, B) => { if (!p.value) return o.method = D, o.payload = P, o.payloadType = B, Kn(o.payload) && Ct([O, vE(o.payload)], ([F]) => F && E(), { deep: !0 }), { ...j, then(F, K) { return L().then(F, K) } } } } function L() { return new Promise((D, P) => { V1e(h).toBe(!0).then(() => D(j)).catch(B => P(B)) }) } function R(D) { return () => { if (!p.value) return o.type = D, { ...j, then(P, B) { return L().then(P, B) } } } } return a.immediate && Promise.resolve().then(() => E()), { ...j, then(D, P) { return L().then(D, P) } } } function dwe(n, e) { return !n.endsWith("/") && !e.startsWith("/") ? `${n}/${e}` : `${n}${e}` } const fwe = { ctrl: "control", command: "meta", cmd: "meta", option: "alt", up: "arrowup", down: "arrowdown", left: "arrowleft", right: "arrowright" }; function hwe(n = {}) { const { reactive: e = !1, target: t = Ts, aliasMap: r = fwe, passive: i = !0, onEventFired: a = ys } = n, o = vr(new Set), s = { toJSON() { return {} }, current: o }, l = e ? vr(s) : s, c = new Set, u = new Set; function d(m, g) { m in l && (e ? l[m] = g : l[m].value = g) } function f() { o.clear(); for (const m of u) d(m, !1) } function h(m, g) { var y, b; const w = (y = m.key) == null ? void 0 : y.toLowerCase(), S = [(b = m.code) == null ? void 0 : b.toLowerCase(), w].filter(Boolean); w && (g ? o.add(w) : o.delete(w)); for (const x of S) u.add(x), d(x, g); w === "meta" && !g ? (c.forEach(x => { o.delete(x), d(x, !1) }), c.clear()) : typeof m.getModifierState == "function" && m.getModifierState("Meta") && g && [...o, ...S].forEach(x => c.add(x)) } rl(t, "keydown", m => (h(m, !0), a(m)), { passive: i }), rl(t, "keyup", m => (h(m, !1), a(m)), { passive: i }), rl("blur", f, { passive: !0 }), rl("focus", f, { passive: !0 }); const p = new Proxy(l, { get(m, g, y) { if (typeof g != "string") return Reflect.get(m, g, y); if (g = g.toLowerCase(), g in r && (g = r[g]), !(g in l)) if (/[+_-]/.test(g)) { const w = g.split(/[+_-]/g).map(v => v.trim()); l[g] = ne(() => w.every(v => tr(p[v]))) } else l[g] = he(!1); const b = Reflect.get(m, g, y); return e ? tr(b) : b } }); return p } function pwe(n = {}) { const { controls: e = !1, interval: t = "requestAnimationFrame" } = n, r = he(new Date), i = () => r.value = new Date, a = t === "requestAnimationFrame" ? J1e(i, { immediate: !0 }) : Y1e(i, t, { immediate: !0 }); return e ? { now: r, ...a } : r } const mwe = [{ max: 6e4, value: 1e3, name: "second" }, { max: 276e4, value: 6e4, name: "minute" }, { max: 72e6, value: 36e5, name: "hour" }, { max: 5184e5, value: 864e5, name: "day" }, { max: 24192e5, value: 6048e5, name: "week" }, { max: 28512e6, value: 2592e6, name: "month" }, { max: Number.POSITIVE_INFINITY, value: 31536e6, name: "year" }], gwe = { justNow: "just now", past: n => n.match(/\d/) ? `${n} ago` : n, future: n => n.match(/\d/) ? `in ${n}` : n, month: (n, e) => n === 1 ? e ? "last month" : "next month" : `${n} month${n > 1 ? "s" : ""}`, year: (n, e) => n === 1 ? e ? "last year" : "next year" : `${n} year${n > 1 ? "s" : ""}`, day: (n, e) => n === 1 ? e ? "yesterday" : "tomorrow" : `${n} day${n > 1 ? "s" : ""}`, week: (n, e) => n === 1 ? e ? "last week" : "next week" : `${n} week${n > 1 ? "s" : ""}`, hour: n => `${n} hour${n > 1 ? "s" : ""}`, minute: n => `${n} minute${n > 1 ? "s" : ""}`, second: n => `${n} second${n > 1 ? "s" : ""}`, invalid: "" }; function vwe(n) { return n.toISOString().slice(0, 10) } function ywe(n, e = {}) { const { controls: t = !1, updateInterval: r = 3e4 } = e, { now: i, ...a } = pwe({ interval: r, controls: !0 }), o = ne(() => _we(new Date(tr(n)), e, tr(i))); return t ? { timeAgo: o, ...a } : o } function _we(n, e = {}, t = Date.now()) { var r; const { max: i, messages: a = gwe, fullDateFormatter: o = vwe, units: s = mwe, showSecond: l = !1, rounding: c = "round" } = e, u = typeof c == "number" ? g => +g.toFixed(c) : Math[c], d = +t - +n, f = Math.abs(d); function h(g, y) { return u(Math.abs(g) / y.value) } function p(g, y) { const b = h(g, y), w = g > 0, v = m(y.name, b, w); return m(w ? "past" : "future", v, w) } function m(g, y, b) { const w = a[g]; return typeof w == "function" ? w(y, b) : w.replace("{0}", y.toString()) } if (f < 6e4 && !l) return a.justNow; if (typeof i == "number" && f > i) return o(new Date(n)); if (typeof i == "string") { const g = (r = s.find(y => y.name === i)) == null ? void 0 : r.max; if (g && f > g) return o(new Date(n)) } for (const [g, y] of s.entries()) { if (h(d, y) <= 0 && s[g - 1]) return p(d, s[g - 1]); if (f < y.max) return p(d, y) } return a.invalid } function Vdt(n = {}) { const { window: e = Ts, initialWidth: t = Number.POSITIVE_INFINITY, initialHeight: r = Number.POSITIVE_INFINITY, listenOrientation: i = !0, includeScrollbar: a = !0 } = n, o = he(t), s = he(r), l = () => { e && (a ? (o.value = e.innerWidth, s.value = e.innerHeight) : (o.value = e.document.documentElement.clientWidth, s.value = e.document.documentElement.clientHeight)) }; if (l(), IY(l), rl("resize", l, { passive: !0 }), i) { const c = Q1e("(orientation: portrait)"); Ct(c, () => l()) } return { width: o, height: s } } const bwe = ["top", "right", "bottom", "left"], _d = Math.min, Ra = Math.max, NS = Math.round, W1 = Math.floor, bd = n => ({ x: n, y: n }), wwe = { left: "right", right: "left", bottom: "top", top: "bottom" }, xwe = { start: "end", end: "start" }; function gj(n, e, t) { return Ra(n, _d(e, t)) } function Ec(n, e) { return typeof n == "function" ? n(e) : n } function Mc(n) { return n.split("-")[0] } function Fg(n) { return n.split("-")[1] } function aR(n) { return n === "x" ? "y" : "x" } function oR(n) { return n === "y" ? "height" : "width" } function wd(n) { return ["top", "bottom"].includes(Mc(n)) ? "y" : "x" } function sR(n) { return aR(wd(n)) } function Swe(n, e, t) { t === void 0 && (t = !1); const r = Fg(n), i = sR(n), a = oR(i); let o = i === "x" ? r === (t ? "end" : "start") ? "right" : "left" : r === "start" ? "bottom" : "top"; return e.reference[a] > e.floating[a] && (o = BS(o)), [o, BS(o)] } function Twe(n) { const e = BS(n); return [vj(n), e, vj(e)] } function vj(n) { return n.replace(/start|end/g, e => xwe[e]) } function kwe(n, e, t) { const r = ["left", "right"], i = ["right", "left"], a = ["top", "bottom"], o = ["bottom", "top"]; switch (n) { case "top": case "bottom": return t ? e ? i : r : e ? r : i; case "left": case "right": return e ? a : o; default: return [] } } function Cwe(n, e, t, r) { const i = Fg(n); let a = kwe(Mc(n), t === "start", r); return i && (a = a.map(o => o + "-" + i), e && (a = a.concat(a.map(vj)))), a } function BS(n) { return n.replace(/left|right|bottom|top/g, e => wwe[e]) } function Awe(n) { return { top: 0, right: 0, bottom: 0, left: 0, ...n } } function RY(n) { return typeof n != "number" ? Awe(n) : { top: n, right: n, bottom: n, left: n } } function $S(n) { const { x: e, y: t, width: r, height: i } = n; return { width: r, height: i, top: t, left: e, right: e + r, bottom: t + i, x: e, y: t } } function $$(n, e, t) { let { reference: r, floating: i } = n; const a = wd(e), o = sR(e), s = oR(o), l = Mc(e), c = a === "y", u = r.x + r.width / 2 - i.width / 2, d = r.y + r.height / 2 - i.height / 2, f = r[s] / 2 - i[s] / 2; let h; switch (l) { case "top": h = { x: u, y: r.y - i.height }; break; case "bottom": h = { x: u, y: r.y + r.height }; break; case "right": h = { x: r.x + r.width, y: d }; break; case "left": h = { x: r.x - i.width, y: d }; break; default: h = { x: r.x, y: r.y } }switch (Fg(e)) { case "start": h[o] -= f * (t && c ? -1 : 1); break; case "end": h[o] += f * (t && c ? -1 : 1); break }return h } const Ewe = async (n, e, t) => { const { placement: r = "bottom", strategy: i = "absolute", middleware: a = [], platform: o } = t, s = a.filter(Boolean), l = await (o.isRTL == null ? void 0 : o.isRTL(e)); let c = await o.getElementRects({ reference: n, floating: e, strategy: i }), { x: u, y: d } = $$(c, r, l), f = r, h = {}, p = 0; for (let m = 0; m < s.length; m++) { const { name: g, fn: y } = s[m], { x: b, y: w, data: v, reset: S } = await y({ x: u, y: d, initialPlacement: r, placement: f, strategy: i, middlewareData: h, rects: c, platform: o, elements: { reference: n, floating: e } }); u = b ?? u, d = w ?? d, h = { ...h, [g]: { ...h[g], ...v } }, S && p <= 50 && (p++, typeof S == "object" && (S.placement && (f = S.placement), S.rects && (c = S.rects === !0 ? await o.getElementRects({ reference: n, floating: e, strategy: i }) : S.rects), { x: u, y: d } = $$(c, f, l)), m = -1) } return { x: u, y: d, placement: f, strategy: i, middlewareData: h } }; async function H0(n, e) { var t; e === void 0 && (e = {}); const { x: r, y: i, platform: a, rects: o, elements: s, strategy: l } = n, { boundary: c = "clippingAncestors", rootBoundary: u = "viewport", elementContext: d = "floating", altBoundary: f = !1, padding: h = 0 } = Ec(e, n), p = RY(h), g = s[f ? d === "floating" ? "reference" : "floating" : d], y = $S(await a.getClippingRect({ element: (t = await (a.isElement == null ? void 0 : a.isElement(g))) == null || t ? g : g.contextElement || await (a.getDocumentElement == null ? void 0 : a.getDocumentElement(s.floating)), boundary: c, rootBoundary: u, strategy: l })), b = d === "floating" ? { x: r, y: i, width: o.floating.width, height: o.floating.height } : o.reference, w = await (a.getOffsetParent == null ? void 0 : a.getOffsetParent(s.floating)), v = await (a.isElement == null ? void 0 : a.isElement(w)) ? await (a.getScale == null ? void 0 : a.getScale(w)) || { x: 1, y: 1 } : { x: 1, y: 1 }, S = $S(a.convertOffsetParentRelativeRectToViewportRelativeRect ? await a.convertOffsetParentRelativeRectToViewportRelativeRect({ elements: s, rect: b, offsetParent: w, strategy: l }) : b); return { top: (y.top - S.top + p.top) / v.y, bottom: (S.bottom - y.bottom + p.bottom) / v.y, left: (y.left - S.left + p.left) / v.x, right: (S.right - y.right + p.right) / v.x } } const Mwe = n => ({ name: "arrow", options: n, async fn(e) { const { x: t, y: r, placement: i, rects: a, platform: o, elements: s, middlewareData: l } = e, { element: c, padding: u = 0 } = Ec(n, e) || {}; if (c == null) return {}; const d = RY(u), f = { x: t, y: r }, h = sR(i), p = oR(h), m = await o.getDimensions(c), g = h === "y", y = g ? "top" : "left", b = g ? "bottom" : "right", w = g ? "clientHeight" : "clientWidth", v = a.reference[p] + a.reference[h] - f[h] - a.floating[p], S = f[h] - a.reference[h], x = await (o.getOffsetParent == null ? void 0 : o.getOffsetParent(c)); let k = x ? x[w] : 0; (!k || !await (o.isElement == null ? void 0 : o.isElement(x))) && (k = s.floating[w] || a.floating[p]); const A = v / 2 - S / 2, C = k / 2 - m[p] / 2 - 1, E = _d(d[y], C), O = _d(d[b], C), j = E, I = k - m[p] - O, L = k / 2 - m[p] / 2 + A, R = gj(j, L, I), D = !l.arrow && Fg(i) != null && L !== R && a.reference[p] / 2 - (L < j ? E : O) - m[p] / 2 < 0, P = D ? L < j ? L - j : L - I : 0; return { [h]: f[h] + P, data: { [h]: R, centerOffset: L - R - P, ...D && { alignmentOffset: P } }, reset: D } } }), Owe = function (n) { return n === void 0 && (n = {}), { name: "flip", options: n, async fn(e) { var t, r; const { placement: i, middlewareData: a, rects: o, initialPlacement: s, platform: l, elements: c } = e, { mainAxis: u = !0, crossAxis: d = !0, fallbackPlacements: f, fallbackStrategy: h = "bestFit", fallbackAxisSideDirection: p = "none", flipAlignment: m = !0, ...g } = Ec(n, e); if ((t = a.arrow) != null && t.alignmentOffset) return {}; const y = Mc(i), b = wd(s), w = Mc(s) === s, v = await (l.isRTL == null ? void 0 : l.isRTL(c.floating)), S = f || (w || !m ? [BS(s)] : Twe(s)), x = p !== "none"; !f && x && S.push(...Cwe(s, m, p, v)); const k = [s, ...S], A = await H0(e, g), C = []; let E = ((r = a.flip) == null ? void 0 : r.overflows) || []; if (u && C.push(A[y]), d) { const L = Swe(i, o, v); C.push(A[L[0]], A[L[1]]) } if (E = [...E, { placement: i, overflows: C }], !C.every(L => L <= 0)) { var O, j; const L = (((O = a.flip) == null ? void 0 : O.index) || 0) + 1, R = k[L]; if (R) return { data: { index: L, overflows: E }, reset: { placement: R } }; let D = (j = E.filter(P => P.overflows[0] <= 0).sort((P, B) => P.overflows[1] - B.overflows[1])[0]) == null ? void 0 : j.placement; if (!D) switch (h) { case "bestFit": { var I; const P = (I = E.filter(B => { if (x) { const F = wd(B.placement); return F === b || F === "y" } return !0 }).map(B => [B.placement, B.overflows.filter(F => F > 0).reduce((F, K) => F + K, 0)]).sort((B, F) => B[1] - F[1])[0]) == null ? void 0 : I[0]; P && (D = P); break } case "initialPlacement": D = s; break }if (i !== D) return { reset: { placement: D } } } return {} } } }; function F$(n, e) { return { top: n.top - e.height, right: n.right - e.width, bottom: n.bottom - e.height, left: n.left - e.width } } function z$(n) { return bwe.some(e => n[e] >= 0) } const Dwe = function (n) { return n === void 0 && (n = {}), { name: "hide", options: n, async fn(e) { const { rects: t } = e, { strategy: r = "referenceHidden", ...i } = Ec(n, e); switch (r) { case "referenceHidden": { const a = await H0(e, { ...i, elementContext: "reference" }), o = F$(a, t.reference); return { data: { referenceHiddenOffsets: o, referenceHidden: z$(o) } } } case "escaped": { const a = await H0(e, { ...i, altBoundary: !0 }), o = F$(a, t.floating); return { data: { escapedOffsets: o, escaped: z$(o) } } } default: return {} } } } }; async function jwe(n, e) { const { placement: t, platform: r, elements: i } = n, a = await (r.isRTL == null ? void 0 : r.isRTL(i.floating)), o = Mc(t), s = Fg(t), l = wd(t) === "y", c = ["left", "top"].includes(o) ? -1 : 1, u = a && l ? -1 : 1, d = Ec(e, n); let { mainAxis: f, crossAxis: h, alignmentAxis: p } = typeof d == "number" ? { mainAxis: d, crossAxis: 0, alignmentAxis: null } : { mainAxis: d.mainAxis || 0, crossAxis: d.crossAxis || 0, alignmentAxis: d.alignmentAxis }; return s && typeof p == "number" && (h = s === "end" ? p * -1 : p), l ? { x: h * u, y: f * c } : { x: f * c, y: h * u } } const Pwe = function (n) { return n === void 0 && (n = 0), { name: "offset", options: n, async fn(e) { var t, r; const { x: i, y: a, placement: o, middlewareData: s } = e, l = await jwe(e, n); return o === ((t = s.offset) == null ? void 0 : t.placement) && (r = s.arrow) != null && r.alignmentOffset ? {} : { x: i + l.x, y: a + l.y, data: { ...l, placement: o } } } } }, Iwe = function (n) { return n === void 0 && (n = {}), { name: "shift", options: n, async fn(e) { const { x: t, y: r, placement: i } = e, { mainAxis: a = !0, crossAxis: o = !1, limiter: s = { fn: g => { let { x: y, y: b } = g; return { x: y, y: b } } }, ...l } = Ec(n, e), c = { x: t, y: r }, u = await H0(e, l), d = wd(Mc(i)), f = aR(d); let h = c[f], p = c[d]; if (a) { const g = f === "y" ? "top" : "left", y = f === "y" ? "bottom" : "right", b = h + u[g], w = h - u[y]; h = gj(b, h, w) } if (o) { const g = d === "y" ? "top" : "left", y = d === "y" ? "bottom" : "right", b = p + u[g], w = p - u[y]; p = gj(b, p, w) } const m = s.fn({ ...e, [f]: h, [d]: p }); return { ...m, data: { x: m.x - t, y: m.y - r, enabled: { [f]: a, [d]: o } } } } } }, Lwe = function (n) { return n === void 0 && (n = {}), { options: n, fn(e) { const { x: t, y: r, placement: i, rects: a, middlewareData: o } = e, { offset: s = 0, mainAxis: l = !0, crossAxis: c = !0 } = Ec(n, e), u = { x: t, y: r }, d = wd(i), f = aR(d); let h = u[f], p = u[d]; const m = Ec(s, e), g = typeof m == "number" ? { mainAxis: m, crossAxis: 0 } : { mainAxis: 0, crossAxis: 0, ...m }; if (l) { const w = f === "y" ? "height" : "width", v = a.reference[f] - a.floating[w] + g.mainAxis, S = a.reference[f] + a.reference[w] - g.mainAxis; h < v ? h = v : h > S && (h = S) } if (c) { var y, b; const w = f === "y" ? "width" : "height", v = ["top", "left"].includes(Mc(i)), S = a.reference[d] - a.floating[w] + (v && ((y = o.offset) == null ? void 0 : y[d]) || 0) + (v ? 0 : g.crossAxis), x = a.reference[d] + a.reference[w] + (v ? 0 : ((b = o.offset) == null ? void 0 : b[d]) || 0) - (v ? g.crossAxis : 0); p < S ? p = S : p > x && (p = x) } return { [f]: h, [d]: p } } } }, Rwe = function (n) { return n === void 0 && (n = {}), { name: "size", options: n, async fn(e) { var t, r; const { placement: i, rects: a, platform: o, elements: s } = e, { apply: l = () => { }, ...c } = Ec(n, e), u = await H0(e, c), d = Mc(i), f = Fg(i), h = wd(i) === "y", { width: p, height: m } = a.floating; let g, y; d === "top" || d === "bottom" ? (g = d, y = f === (await (o.isRTL == null ? void 0 : o.isRTL(s.floating)) ? "start" : "end") ? "left" : "right") : (y = d, g = f === "end" ? "top" : "bottom"); const b = m - u.top - u.bottom, w = p - u.left - u.right, v = _d(m - u[g], b), S = _d(p - u[y], w), x = !e.middlewareData.shift; let k = v, A = S; if ((t = e.middlewareData.shift) != null && t.enabled.x && (A = w), (r = e.middlewareData.shift) != null && r.enabled.y && (k = b), x && !f) { const E = Ra(u.left, 0), O = Ra(u.right, 0), j = Ra(u.top, 0), I = Ra(u.bottom, 0); h ? A = p - 2 * (E !== 0 || O !== 0 ? E + O : Ra(u.left, u.right)) : k = m - 2 * (j !== 0 || I !== 0 ? j + I : Ra(u.top, u.bottom)) } await l({ ...e, availableWidth: A, availableHeight: k }); const C = await o.getDimensions(s.floating); return p !== C.width || m !== C.height ? { reset: { rects: !0 } } : {} } } }; function hk() { return typeof window < "u" } function zg(n) { return NY(n) ? (n.nodeName || "").toLowerCase() : "#document" } function za(n) { var e; return (n == null || (e = n.ownerDocument) == null ? void 0 : e.defaultView) || window } function Ol(n) { var e; return (e = (NY(n) ? n.ownerDocument : n.document) || window.document) == null ? void 0 : e.documentElement } function NY(n) { return hk() ? n instanceof Node || n instanceof za(n).Node : !1 } function ks(n) { return hk() ? n instanceof Element || n instanceof za(n).Element : !1 } function _l(n) { return hk() ? n instanceof HTMLElement || n instanceof za(n).HTMLElement : !1 } function V$(n) { return !hk() || typeof ShadowRoot > "u" ? !1 : n instanceof ShadowRoot || n instanceof za(n).ShadowRoot } function pb(n) { const { overflow: e, overflowX: t, overflowY: r, display: i } = Cs(n); return /auto|scroll|overlay|hidden|clip/.test(e + r + t) && !["inline", "contents"].includes(i) } function Nwe(n) { return ["table", "td", "th"].includes(zg(n)) } function pk(n) { return [":popover-open", ":modal"].some(e => { try { return n.matches(e) } catch { return !1 } }) } function lR(n) { const e = cR(), t = ks(n) ? Cs(n) : n; return t.transform !== "none" || t.perspective !== "none" || (t.containerType ? t.containerType !== "normal" : !1) || !e && (t.backdropFilter ? t.backdropFilter !== "none" : !1) || !e && (t.filter ? t.filter !== "none" : !1) || ["transform", "perspective", "filter"].some(r => (t.willChange || "").includes(r)) || ["paint", "layout", "strict", "content"].some(r => (t.contain || "").includes(r)) } function Bwe(n) { let e = xd(n); for (; _l(e) && !hg(e);) { if (lR(e)) return e; if (pk(e)) return null; e = xd(e) } return null } function cR() { return typeof CSS > "u" || !CSS.supports ? !1 : CSS.supports("-webkit-backdrop-filter", "none") } function hg(n) { return ["html", "body", "#document"].includes(zg(n)) } function Cs(n) { return za(n).getComputedStyle(n) } function mk(n) { return ks(n) ? { scrollLeft: n.scrollLeft, scrollTop: n.scrollTop } : { scrollLeft: n.scrollX, scrollTop: n.scrollY } } function xd(n) { if (zg(n) === "html") return n; const e = n.assignedSlot || n.parentNode || V$(n) && n.host || Ol(n); return V$(e) ? e.host : e } function BY(n) { const e = xd(n); return hg(e) ? n.ownerDocument ? n.ownerDocument.body : n.body : _l(e) && pb(e) ? e : BY(e) } function U0(n, e, t) { var r; e === void 0 && (e = []), t === void 0 && (t = !0); const i = BY(n), a = i === ((r = n.ownerDocument) == null ? void 0 : r.body), o = za(i); if (a) { const s = yj(o); return e.concat(o, o.visualViewport || [], pb(i) ? i : [], s && t ? U0(s) : []) } return e.concat(i, U0(i, [], t)) } function yj(n) { return n.parent && Object.getPrototypeOf(n.parent) ? n.frameElement : null } function $Y(n) { const e = Cs(n); let t = parseFloat(e.width) || 0, r = parseFloat(e.height) || 0; const i = _l(n), a = i ? n.offsetWidth : t, o = i ? n.offsetHeight : r, s = NS(t) !== a || NS(r) !== o; return s && (t = a, r = o), { width: t, height: r, $: s } } function uR(n) { return ks(n) ? n : n.contextElement } function Hm(n) { const e = uR(n); if (!_l(e)) return bd(1); const t = e.getBoundingClientRect(), { width: r, height: i, $: a } = $Y(e); let o = (a ? NS(t.width) : t.width) / r, s = (a ? NS(t.height) : t.height) / i; return (!o || !Number.isFinite(o)) && (o = 1), (!s || !Number.isFinite(s)) && (s = 1), { x: o, y: s } } const $we = bd(0); function FY(n) { const e = za(n); return !cR() || !e.visualViewport ? $we : { x: e.visualViewport.offsetLeft, y: e.visualViewport.offsetTop } } function Fwe(n, e, t) { return e === void 0 && (e = !1), !t || e && t !== za(n) ? !1 : e } function Rh(n, e, t, r) { e === void 0 && (e = !1), t === void 0 && (t = !1); const i = n.getBoundingClientRect(), a = uR(n); let o = bd(1); e && (r ? ks(r) && (o = Hm(r)) : o = Hm(n)); const s = Fwe(a, t, r) ? FY(a) : bd(0); let l = (i.left + s.x) / o.x, c = (i.top + s.y) / o.y, u = i.width / o.x, d = i.height / o.y; if (a) { const f = za(a), h = r && ks(r) ? za(r) : r; let p = f, m = yj(p); for (; m && r && h !== p;) { const g = Hm(m), y = m.getBoundingClientRect(), b = Cs(m), w = y.left + (m.clientLeft + parseFloat(b.paddingLeft)) * g.x, v = y.top + (m.clientTop + parseFloat(b.paddingTop)) * g.y; l *= g.x, c *= g.y, u *= g.x, d *= g.y, l += w, c += v, p = za(m), m = yj(p) } } return $S({ width: u, height: d, x: l, y: c }) } function zwe(n) { let { elements: e, rect: t, offsetParent: r, strategy: i } = n; const a = i === "fixed", o = Ol(r), s = e ? pk(e.floating) : !1; if (r === o || s && a) return t; let l = { scrollLeft: 0, scrollTop: 0 }, c = bd(1); const u = bd(0), d = _l(r); if ((d || !d && !a) && ((zg(r) !== "body" || pb(o)) && (l = mk(r)), _l(r))) { const f = Rh(r); c = Hm(r), u.x = f.x + r.clientLeft, u.y = f.y + r.clientTop } return { width: t.width * c.x, height: t.height * c.y, x: t.x * c.x - l.scrollLeft * c.x + u.x, y: t.y * c.y - l.scrollTop * c.y + u.y } } function Vwe(n) { return Array.from(n.getClientRects()) } function _j(n, e) { const t = mk(n).scrollLeft; return e ? e.left + t : Rh(Ol(n)).left + t } function Hwe(n) { const e = Ol(n), t = mk(n), r = n.ownerDocument.body, i = Ra(e.scrollWidth, e.clientWidth, r.scrollWidth, r.clientWidth), a = Ra(e.scrollHeight, e.clientHeight, r.scrollHeight, r.clientHeight); let o = -t.scrollLeft + _j(n); const s = -t.scrollTop; return Cs(r).direction === "rtl" && (o += Ra(e.clientWidth, r.clientWidth) - i), { width: i, height: a, x: o, y: s } } function Uwe(n, e) { const t = za(n), r = Ol(n), i = t.visualViewport; let a = r.clientWidth, o = r.clientHeight, s = 0, l = 0; if (i) { a = i.width, o = i.height; const c = cR(); (!c || c && e === "fixed") && (s = i.offsetLeft, l = i.offsetTop) } return { width: a, height: o, x: s, y: l } } function Gwe(n, e) { const t = Rh(n, !0, e === "fixed"), r = t.top + n.clientTop, i = t.left + n.clientLeft, a = _l(n) ? Hm(n) : bd(1), o = n.clientWidth * a.x, s = n.clientHeight * a.y, l = i * a.x, c = r * a.y; return { width: o, height: s, x: l, y: c } } function H$(n, e, t) { let r; if (e === "viewport") r = Uwe(n, t); else if (e === "document") r = Hwe(Ol(n)); else if (ks(e)) r = Gwe(e, t); else { const i = FY(n); r = { ...e, x: e.x - i.x, y: e.y - i.y } } return $S(r) } function zY(n, e) { const t = xd(n); return t === e || !ks(t) || hg(t) ? !1 : Cs(t).position === "fixed" || zY(t, e) } function Wwe(n, e) { const t = e.get(n); if (t) return t; let r = U0(n, [], !1).filter(s => ks(s) && zg(s) !== "body"), i = null; const a = Cs(n).position === "fixed"; let o = a ? xd(n) : n; for (; ks(o) && !hg(o);) { const s = Cs(o), l = lR(o); !l && s.position === "fixed" && (i = null), (a ? !l && !i : !l && s.position === "static" && !!i && ["absolute", "fixed"].includes(i.position) || pb(o) && !l && zY(n, o)) ? r = r.filter(u => u !== o) : i = s, o = xd(o) } return e.set(n, r), r } function Kwe(n) { let { element: e, boundary: t, rootBoundary: r, strategy: i } = n; const o = [...t === "clippingAncestors" ? pk(e) ? [] : Wwe(e, this._c) : [].concat(t), r], s = o[0], l = o.reduce((c, u) => { const d = H$(e, u, i); return c.top = Ra(d.top, c.top), c.right = _d(d.right, c.right), c.bottom = _d(d.bottom, c.bottom), c.left = Ra(d.left, c.left), c }, H$(e, s, i)); return { width: l.right - l.left, height: l.bottom - l.top, x: l.left, y: l.top } } function qwe(n) { const { width: e, height: t } = $Y(n); return { width: e, height: t } } function Ywe(n, e, t) { const r = _l(e), i = Ol(e), a = t === "fixed", o = Rh(n, !0, a, e); let s = { scrollLeft: 0, scrollTop: 0 }; const l = bd(0); if (r || !r && !a) if ((zg(e) !== "body" || pb(i)) && (s = mk(e)), r) { const h = Rh(e, !0, a, e); l.x = h.x + e.clientLeft, l.y = h.y + e.clientTop } else i && (l.x = _j(i)); let c = 0, u = 0; if (i && !r && !a) { const h = i.getBoundingClientRect(); u = h.top + s.scrollTop, c = h.left + s.scrollLeft - _j(i, h) } const d = o.left + s.scrollLeft - l.x - c, f = o.top + s.scrollTop - l.y - u; return { x: d, y: f, width: o.width, height: o.height } } function yE(n) { return Cs(n).position === "static" } function U$(n, e) { if (!_l(n) || Cs(n).position === "fixed") return null; if (e) return e(n); let t = n.offsetParent; return Ol(n) === t && (t = t.ownerDocument.body), t } function VY(n, e) { const t = za(n); if (pk(n)) return t; if (!_l(n)) { let i = xd(n); for (; i && !hg(i);) { if (ks(i) && !yE(i)) return i; i = xd(i) } return t } let r = U$(n, e); for (; r && Nwe(r) && yE(r);)r = U$(r, e); return r && hg(r) && yE(r) && !lR(r) ? t : r || Bwe(n) || t } const Zwe = async function (n) { const e = this.getOffsetParent || VY, t = this.getDimensions, r = await t(n.floating); return { reference: Ywe(n.reference, await e(n.floating), n.strategy), floating: { x: 0, y: 0, width: r.width, height: r.height } } }; function Xwe(n) { return Cs(n).direction === "rtl" } const Jwe = { convertOffsetParentRelativeRectToViewportRelativeRect: zwe, getDocumentElement: Ol, getClippingRect: Kwe, getOffsetParent: VY, getElementRects: Zwe, getClientRects: Vwe, getDimensions: qwe, getScale: Hm, isElement: ks, isRTL: Xwe }; function Qwe(n, e) { let t = null, r; const i = Ol(n); function a() { var s; clearTimeout(r), (s = t) == null || s.disconnect(), t = null } function o(s, l) { s === void 0 && (s = !1), l === void 0 && (l = 1), a(); const { left: c, top: u, width: d, height: f } = n.getBoundingClientRect(); if (s || e(), !d || !f) return; const h = W1(u), p = W1(i.clientWidth - (c + d)), m = W1(i.clientHeight - (u + f)), g = W1(c), b = { rootMargin: -h + "px " + -p + "px " + -m + "px " + -g + "px", threshold: Ra(0, _d(1, l)) || 1 }; let w = !0; function v(S) { const x = S[0].intersectionRatio; if (x !== l) { if (!w) return o(); x ? o(!1, x) : r = setTimeout(() => { o(!1, 1e-7) }, 1e3) } w = !1 } try { t = new IntersectionObserver(v, { ...b, root: i.ownerDocument }) } catch { t = new IntersectionObserver(v, b) } t.observe(n) } return o(!0), a } function exe(n, e, t, r) { r === void 0 && (r = {}); const { ancestorScroll: i = !0, ancestorResize: a = !0, elementResize: o = typeof ResizeObserver == "function", layoutShift: s = typeof IntersectionObserver == "function", animationFrame: l = !1 } = r, c = uR(n), u = i || a ? [...c ? U0(c) : [], ...U0(e)] : []; u.forEach(y => { i && y.addEventListener("scroll", t, { passive: !0 }), a && y.addEventListener("resize", t) }); const d = c && s ? Qwe(c, t) : null; let f = -1, h = null; o && (h = new ResizeObserver(y => { let [b] = y; b && b.target === c && h && (h.unobserve(e), cancelAnimationFrame(f), f = requestAnimationFrame(() => { var w; (w = h) == null || w.observe(e) })), t() }), c && !l && h.observe(c), h.observe(e)); let p, m = l ? Rh(n) : null; l && g(); function g() { const y = Rh(n); m && (y.x !== m.x || y.y !== m.y || y.width !== m.width || y.height !== m.height) && t(), m = y, p = requestAnimationFrame(g) } return t(), () => { var y; u.forEach(b => { i && b.removeEventListener("scroll", t), a && b.removeEventListener("resize", t) }), d == null || d(), (y = h) == null || y.disconnect(), h = null, l && cancelAnimationFrame(p) } } const txe = Pwe, nxe = Iwe, G$ = Owe, rxe = Rwe, ixe = Dwe, axe = Mwe, oxe = Lwe, sxe = (n, e, t) => { const r = new Map, i = { platform: Jwe, ...t }, a = { ...i.platform, _c: r }; return Ewe(n, e, { ...i, platform: a }) }; function lxe() { return typeof window < "u" } function cxe(n) { return HY(n) ? (n.nodeName || "").toLowerCase() : "#document" } function uxe(n) { var e; return (n == null || (e = n.ownerDocument) == null ? void 0 : e.defaultView) || window } function HY(n) { return lxe() ? n instanceof Node || n instanceof uxe(n).Node : !1 } function dxe(n) { return n != null && typeof n == "object" && "$el" in n } function bj(n) { if (dxe(n)) { const e = n.$el; return HY(e) && cxe(e) === "#comment" ? null : e } return n } function hm(n) { return typeof n == "function" ? n() : X(n) } function fxe(n) { return { name: "arrow", options: n, fn(e) { const t = bj(hm(n.element)); return t == null ? {} : axe({ element: t, padding: n.padding }).fn(e) } } } function UY(n) { return typeof window > "u" ? 1 : (n.ownerDocument.defaultView || window).devicePixelRatio || 1 } function W$(n, e) { const t = UY(n); return Math.round(e * t) / t } function hxe(n, e, t) { t === void 0 && (t = {}); const r = t.whileElementsMounted, i = ne(() => { var k; return (k = hm(t.open)) != null ? k : !0 }), a = ne(() => hm(t.middleware)), o = ne(() => { var k; return (k = hm(t.placement)) != null ? k : "bottom" }), s = ne(() => { var k; return (k = hm(t.strategy)) != null ? k : "absolute" }), l = ne(() => { var k; return (k = hm(t.transform)) != null ? k : !0 }), c = ne(() => bj(n.value)), u = ne(() => bj(e.value)), d = he(0), f = he(0), h = he(s.value), p = he(o.value), m = Fa({}), g = he(!1), y = ne(() => { const k = { position: h.value, left: "0", top: "0" }; if (!u.value) return k; const A = W$(u.value, d.value), C = W$(u.value, f.value); return l.value ? { ...k, transform: "translate(" + A + "px, " + C + "px)", ...UY(u.value) >= 1.5 && { willChange: "transform" } } : { position: h.value, left: A + "px", top: C + "px" } }); let b; function w() { if (c.value == null || u.value == null) return; const k = i.value; sxe(c.value, u.value, { middleware: a.value, placement: o.value, strategy: s.value }).then(A => { d.value = A.x, f.value = A.y, h.value = A.strategy, p.value = A.placement, m.value = A.middlewareData, g.value = k !== !1 }) } function v() { typeof b == "function" && (b(), b = void 0) } function S() { if (v(), r === void 0) { w(); return } if (c.value != null && u.value != null) { b = r(c.value, u.value, w); return } } function x() { i.value || (g.value = !1) } return Ct([a, o, s, i], w, { flush: "sync" }), Ct([c, u], S, { flush: "sync" }), Ct(i, x, { flush: "sync" }), Q_() && eb(v), { x: Op(d), y: Op(f), strategy: Op(h), placement: Op(p), middlewareData: Op(m), isPositioned: Op(g), floatingStyles: y, update: w } } function dR(n) { return n ? n.flatMap(e => e.type === Qt ? dR(e.children) : [e]) : [] } const wj = We({ name: "PrimitiveSlot", inheritAttrs: !1, setup(n, { attrs: e, slots: t }) { return () => { var l, c; if (!t.default) return null; const r = dR(t.default()), i = r.findIndex(u => u.type !== mr); if (i === -1) return r; const a = r[i]; (l = a.props) == null || delete l.ref; const o = a.props ? Sn(e, a.props) : e; e.class && ((c = a.props) != null && c.class) && delete a.props.class; const s = $o(a, o); for (const u in o) u.startsWith("on") && (s.props || (s.props = {}), s.props[u] = o[u]); return r.length === 1 ? s : (r[i] = s, r) } } }), Uo = We({ name: "Primitive", inheritAttrs: !1, props: { asChild: { type: Boolean, default: !1 }, as: { type: [String, Object], default: "div" } }, setup(n, { attrs: e, slots: t }) { const r = n.asChild ? "template" : n.as; return typeof r == "string" && ["area", "img", "input"].includes(r) ? () => Gt(r, e) : r !== "template" ? () => Gt(n.as, e, { default: t.default }) : () => Gt(wj, e, { default: t.default }) } }), fR = We({ __name: "VisuallyHidden", props: { feature: { default: "focusable" }, asChild: { type: Boolean }, as: { default: "span" } }, setup(n) { return (e, t) => (Z(), Ye(X(Uo), { as: e.as, "as-child": e.asChild, "aria-hidden": e.feature === "focusable" ? "true" : void 0, "data-hidden": e.feature === "fully-hidden" ? "" : void 0, tabindex: e.feature === "fully-hidden" ? "-1" : void 0, style: { position: "absolute", border: 0, width: "1px", height: "1px", padding: 0, margin: "-1px", overflow: "hidden", clip: "rect(0, 0, 0, 0)", clipPath: "inset(50%)", whiteSpace: "nowrap", wordWrap: "normal" } }, { default: Ue(() => [ut(e.$slots, "default")]), _: 3 }, 8, ["as", "as-child", "aria-hidden", "data-hidden", "tabindex"])) } }); function pxe(n, e) { var t; const r = Fa(); return Bn(() => { r.value = n() }, { ...e, flush: (t = e == null ? void 0 : e.flush) != null ? t : "sync" }), ba(r) } function mb(n) { return Q_() ? (eb(n), !0) : !1 } function mxe() { const n = new Set, e = a => { n.delete(a) }; return { on: a => { n.add(a); const o = () => e(a); return mb(o), { off: o } }, off: e, trigger: (...a) => Promise.all(Array.from(n).map(o => o(...a))), clear: () => { n.clear() } } } const Vg = typeof window < "u" && typeof document < "u"; typeof WorkerGlobalScope < "u" && globalThis instanceof WorkerGlobalScope; const gxe = n => typeof n < "u", vxe = Object.prototype.toString, yxe = n => vxe.call(n) === "[object Object]", _xe = () => { }; function _E(n) { return Array.isArray(n) ? n : [n] } function bxe(n, e = 1e4) { return XT((t, r) => { let i = Po(n), a; const o = () => setTimeout(() => { i = Po(n), r() }, Po(e)); return mb(() => { clearTimeout(a) }), { get() { return t(), i }, set(s) { i = s, r(), clearTimeout(a), a = o() } } }) } function hR(n, e, t = {}) { const { immediate: r = !0, immediateCallback: i = !1 } = t, a = Fa(!1); let o = null; function s() { o && (clearTimeout(o), o = null) } function l() { a.value = !1, s() } function c(...u) { i && n(), s(), a.value = !0, o = setTimeout(() => { a.value = !1, o = null, n(...u) }, Po(e)) } return r && (a.value = !0, Vg && c()), mb(l), { isPending: ba(a), start: c, stop: l } } function wxe(n = 1e3, e = {}) { const { controls: t = !1, callback: r } = e, i = hR(r ?? _xe, n, e), a = ne(() => !i.isPending.value); return t ? { ready: a, ...i } : a } function xxe(n, e, t) { return Ct(n, e, { ...t, immediate: !0 }) } const gk = Vg ? window : void 0; function Nh(n) { var e; const t = Po(n); return (e = t == null ? void 0 : t.$el) != null ? e : t } function xj(...n) { const e = [], t = () => { e.forEach(s => s()), e.length = 0 }, r = (s, l, c, u) => (s.addEventListener(l, c, u), () => s.removeEventListener(l, c, u)), i = ne(() => { const s = _E(Po(n[0])).filter(l => l != null); return s.every(l => typeof l != "string") ? s : void 0 }), a = xxe(() => { var s, l; return [(l = (s = i.value) == null ? void 0 : s.map(c => Nh(c))) != null ? l : [gk].filter(c => c != null), _E(Po(i.value ? n[1] : n[0])), _E(X(i.value ? n[2] : n[1])), Po(i.value ? n[3] : n[2])] }, ([s, l, c, u]) => { if (t(), !(s != null && s.length) || !(l != null && l.length) || !(c != null && c.length)) return; const d = yxe(u) ? { ...u } : u; e.push(...s.flatMap(f => l.flatMap(h => c.map(p => r(f, h, p, d))))) }, { flush: "post" }), o = () => { a(), t() }; return mb(t), o } function Sxe() { const n = Fa(!1), e = kr(); return e && un(() => { n.value = !0 }, e), n } function Txe(n) { return typeof n == "function" ? n : typeof n == "string" ? e => e.key === n : Array.isArray(n) ? e => n.includes(e.key) : () => !0 } function pR(...n) { let e, t, r = {}; n.length === 3 ? (e = n[0], t = n[1], r = n[2]) : n.length === 2 ? typeof n[1] == "object" ? (e = !0, t = n[0], r = n[1]) : (e = n[0], t = n[1]) : (e = !0, t = n[0]); const { target: i = gk, eventName: a = "keydown", passive: o = !1, dedupe: s = !1 } = r, l = Txe(e); return xj(i, a, u => { u.repeat && Po(s) || l(u) && t(u) }, o) } function GY(n, e = {}) { const { immediate: t = !0, fpsLimit: r = void 0, window: i = gk, once: a = !1 } = e, o = Fa(!1), s = ne(() => r ? 1e3 / Po(r) : null); let l = 0, c = null; function u(h) { if (!o.value || !i) return; l || (l = h); const p = h - l; if (s.value && p < s.value) { c = i.requestAnimationFrame(u); return } if (l = h, n({ delta: p, timestamp: h }), a) { o.value = !1, c = null; return } c = i.requestAnimationFrame(u) } function d() { !o.value && i && (o.value = !0, l = 0, c = i.requestAnimationFrame(u)) } function f() { o.value = !1, c != null && i && (i.cancelAnimationFrame(c), c = null) } return t && d(), mb(f), { isActive: ba(o), pause: f, resume: d } } function kxe(n) { return JSON.parse(JSON.stringify(n)) } function WY(n, e, t, r = {}) { var i, a, o; const { clone: s = !1, passive: l = !1, eventName: c, deep: u = !1, defaultValue: d, shouldEmit: f } = r, h = kr(), p = t || (h == null ? void 0 : h.emit) || ((i = h == null ? void 0 : h.$emit) == null ? void 0 : i.bind(h)) || ((o = (a = h == null ? void 0 : h.proxy) == null ? void 0 : a.$emit) == null ? void 0 : o.bind(h == null ? void 0 : h.proxy)); let m = c; e || (e = "modelValue"), m = m || `update:${e.toString()}`; const g = w => s ? typeof s == "function" ? s(w) : kxe(w) : w, y = () => gxe(n[e]) ? g(n[e]) : d, b = w => { f ? f(w) && p(m, w) : p(m, w) }; if (l) { const w = y(), v = he(w); let S = !1; return Ct(() => n[e], x => { S || (S = !0, v.value = g(x), Pr(() => S = !1)) }), Ct(v, x => { !S && (x !== n[e] || u) && b(x) }, { deep: u }), v } else return ne({ get() { return y() }, set(w) { b(w) } }) } function Xh(n, e) { const t = typeof n == "string" && !e ? `${n}Context` : e, r = Symbol(t); return [o => { const s = zn(r, o); if (s || s === null) return s; throw new Error(`Injection \`${r.toString()}\` not found. Component must be used within ${Array.isArray(n) ? `one of the following components: ${n.join(", ")}` : `\`${n}\``}`) }, o => (Or(r, o), o)] } const [Cxe, Hdt] = Xh("ConfigProvider"); function Wr() { const n = kr(), e = he(), t = ne(() => { var o, s; return ["#text", "#comment"].includes((o = e.value) == null ? void 0 : o.$el.nodeName) ? (s = e.value) == null ? void 0 : s.$el.nextElementSibling : Nh(e) }), r = Object.assign({}, n.exposed), i = {}; for (const o in n.props) Object.defineProperty(i, o, { enumerable: !0, configurable: !0, get: () => n.props[o] }); if (Object.keys(r).length > 0) for (const o in r) Object.defineProperty(i, o, { enumerable: !0, configurable: !0, get: () => r[o] }); Object.defineProperty(i, "$el", { enumerable: !0, configurable: !0, get: () => n.vnode.el }), n.exposed = i; function a(o) { e.value = o, o && (Object.defineProperty(i, "$el", { enumerable: !0, configurable: !0, get: () => o instanceof Element ? o : o.$el }), n.exposed = i) } return { forwardRef: a, currentRef: e, currentElement: t } } let Axe = 0; function Exe(n, e = "reka") { if (n) return n; const t = Cxe({ useId: void 0 }); return RD ? `${e}-${RD()}` : t.useId ? `${e}-${t.useId()}` : `${e}-${++Axe}` } function Mxe(n, e) { const t = he(n); function r(a) { return e[t.value][a] ?? t.value } return { state: t, dispatch: a => { t.value = r(a) } } } function Oxe(n, e) { var g; const t = he({}), r = he("none"), i = he(n), a = n.value ? "mounted" : "unmounted"; let o; const s = ((g = e.value) == null ? void 0 : g.ownerDocument.defaultView) ?? gk, { state: l, dispatch: c } = Mxe(a, { mounted: { UNMOUNT: "unmounted", ANIMATION_OUT: "unmountSuspended" }, unmountSuspended: { MOUNT: "mounted", ANIMATION_END: "unmounted" }, unmounted: { MOUNT: "mounted" } }), u = y => { var b; if (Vg) { const w = new CustomEvent(y, { bubbles: !1, cancelable: !1 }); (b = e.value) == null || b.dispatchEvent(w) } }; Ct(n, async (y, b) => { var v; const w = b !== y; if (await Pr(), w) { const S = r.value, x = K1(e.value); y ? (c("MOUNT"), u("enter"), x === "none" && u("after-enter")) : x === "none" || ((v = t.value) == null ? void 0 : v.display) === "none" ? (c("UNMOUNT"), u("leave"), u("after-leave")) : b && S !== x ? (c("ANIMATION_OUT"), u("leave")) : (c("UNMOUNT"), u("after-leave")) } }, { immediate: !0 }); const d = y => { const b = K1(e.value), w = b.includes(y.animationName), v = l.value === "mounted" ? "enter" : "leave"; if (y.target === e.value && w && (u(`after-${v}`), c("ANIMATION_END"), !i.value)) { const S = e.value.style.animationFillMode; e.value.style.animationFillMode = "forwards", o = s == null ? void 0 : s.setTimeout(() => { var x; ((x = e.value) == null ? void 0 : x.style.animationFillMode) === "forwards" && (e.value.style.animationFillMode = S) }) } y.target === e.value && b === "none" && c("ANIMATION_END") }, f = y => { y.target === e.value && (r.value = K1(e.value)) }, h = Ct(e, (y, b) => { y ? (t.value = getComputedStyle(y), y.addEventListener("animationstart", f), y.addEventListener("animationcancel", d), y.addEventListener("animationend", d)) : (c("ANIMATION_END"), o !== void 0 && (s == null || s.clearTimeout(o)), b == null || b.removeEventListener("animationstart", f), b == null || b.removeEventListener("animationcancel", d), b == null || b.removeEventListener("animationend", d)) }, { immediate: !0 }), p = Ct(l, () => { const y = K1(e.value); r.value = l.value === "mounted" ? y : "none" }); return cr(() => { h(), p() }), { isPresent: ne(() => ["mounted", "unmountSuspended"].includes(l.value)) } } function K1(n) { return n && getComputedStyle(n).animationName || "none" } const KY = We({
  name: "Presence", props: { present: { type: Boolean, required: !0 }, forceMount: { type: Boolean } }, slots: {}, setup(n, { slots: e, expose: t }) {
    var c; const { present: r, forceMount: i } = tb(n), a = he(), { isPresent: o } = Oxe(r, a); t({ present: o }); let s = e.default({ present: o.value }); s = dR(s || []); const l = kr(); if (s && (s == null ? void 0 : s.length) > 1) {
      const u = (c = l == null ? void 0 : l.parent) != null && c.type.name ? `<${l.parent.type.name} />` : "component"; throw new Error([`Detected an invalid children for \`${u}\` for  \`Presence\` component.`, "", "Note: Presence works similarly to `v-if` directly, but it waits for animation/transition to finished before unmounting. So it expect only one direct child of valid VNode type.", "You can apply a few solutions:", ["Provide a single child element so that `presence` directive attach correctly.", "Ensure the first child is an actual element instead of a raw text node or comment node."].map(d => `  - ${d}`).join(`
`)].join(`
`))
    } return () => i.value || r.value || o.value ? Gt(e.default({ present: o.value })[0], { ref: u => { const d = Nh(u); return typeof (d == null ? void 0 : d.hasAttribute) > "u" || (d != null && d.hasAttribute("data-reka-popper-content-wrapper") ? a.value = d.firstElementChild : a.value = d), d } }) : null
  }
}); function Dxe(n) { const e = kr(), t = e == null ? void 0 : e.type.emits, r = {}; return t != null && t.length || console.warn(`No emitted event found. Please check component: ${e == null ? void 0 : e.type.__name}`), t == null || t.forEach(i => { r[$y(Ta(i))] = (...a) => n(i, ...a) }), r } function qY(n) { const e = kr(), t = Object.keys((e == null ? void 0 : e.type.props) ?? {}).reduce((i, a) => { const o = (e == null ? void 0 : e.type.props[a]).default; return o !== void 0 && (i[a] = o), i }, {}), r = M0(n); return ne(() => { const i = {}, a = (e == null ? void 0 : e.vnode.props) ?? {}; return Object.keys(a).forEach(o => { i[Ta(o)] = a[o] }), Object.keys({ ...t, ...i }).reduce((o, s) => (r.value[s] !== void 0 && (o[s] = r.value[s]), o), {}) }) } function jxe(n, e) { const t = qY(n), r = e ? Dxe(e) : {}; return ne(() => ({ ...t.value, ...r })) } const Pxe = We({ __name: "Teleport", props: { to: { default: "body" }, disabled: { type: Boolean }, defer: { type: Boolean }, forceMount: { type: Boolean } }, setup(n) { const e = Sxe(); return (t, r) => X(e) || t.forceMount ? (Z(), Ye(rb, { key: 0, to: t.to, disabled: t.disabled, defer: t.defer }, [ut(t.$slots, "default")], 8, ["to", "disabled", "defer"])) : mt("", !0) } }); function YY(n, e, t) { const r = t.originalEvent.target, i = new CustomEvent(n, { bubbles: !1, cancelable: !0, detail: t }); e && r.addEventListener(n, e, { once: !0 }), r.dispatchEvent(i) } const Ixe = "dismissableLayer.pointerDownOutside", Lxe = "dismissableLayer.focusOutside"; function ZY(n, e) { const t = e.closest("[data-dismissable-layer]"), r = n.dataset.dismissableLayer === "" ? n : n.querySelector("[data-dismissable-layer]"), i = Array.from(n.ownerDocument.querySelectorAll("[data-dismissable-layer]")); return !!(t && r === t || i.indexOf(r) < i.indexOf(t)) } function Rxe(n, e) { var a; const t = ((a = e == null ? void 0 : e.value) == null ? void 0 : a.ownerDocument) ?? (globalThis == null ? void 0 : globalThis.document), r = he(!1), i = he(() => { }); return Bn(o => { if (!Vg) return; const s = async c => { const u = c.target; if (e != null && e.value) { if (ZY(e.value, u)) { r.value = !1; return } if (c.target && !r.value) { let d = function () { YY(Ixe, n, f) }; const f = { originalEvent: c }; c.pointerType === "touch" ? (t.removeEventListener("click", i.value), i.value = d, t.addEventListener("click", i.value, { once: !0 })) : d() } else t.removeEventListener("click", i.value); r.value = !1 } }, l = window.setTimeout(() => { t.addEventListener("pointerdown", s) }, 0); o(() => { window.clearTimeout(l), t.removeEventListener("pointerdown", s), t.removeEventListener("click", i.value) }) }), { onPointerDownCapture: () => r.value = !0 } } function Nxe(n, e) { var i; const t = ((i = e == null ? void 0 : e.value) == null ? void 0 : i.ownerDocument) ?? (globalThis == null ? void 0 : globalThis.document), r = he(!1); return Bn(a => { if (!Vg) return; const o = async s => { e != null && e.value && (await Pr(), !(!e.value || ZY(e.value, s.target)) && s.target && !r.value && YY(Lxe, n, { originalEvent: s })) }; t.addEventListener("focusin", o), a(() => t.removeEventListener("focusin", o)) }), { onFocusCapture: () => r.value = !0, onBlurCapture: () => r.value = !1 } } const ns = vr({ layersRoot: new Set, layersWithOutsidePointerEventsDisabled: new Set, branches: new Set }), Bxe = We({ __name: "DismissableLayer", props: { disableOutsidePointerEvents: { type: Boolean, default: !1 }, asChild: { type: Boolean }, as: {} }, emits: ["escapeKeyDown", "pointerDownOutside", "focusOutside", "interactOutside", "dismiss"], setup(n, { emit: e }) { const t = n, r = e, { forwardRef: i, currentElement: a } = Wr(), o = ne(() => { var p; return ((p = a.value) == null ? void 0 : p.ownerDocument) ?? globalThis.document }), s = ne(() => ns.layersRoot), l = ne(() => a.value ? Array.from(s.value).indexOf(a.value) : -1), c = ne(() => ns.layersWithOutsidePointerEventsDisabled.size > 0), u = ne(() => { const p = Array.from(s.value), [m] = [...ns.layersWithOutsidePointerEventsDisabled].slice(-1), g = p.indexOf(m); return l.value >= g }), d = Rxe(async p => { const m = [...ns.branches].some(g => g == null ? void 0 : g.contains(p.target)); !u.value || m || (r("pointerDownOutside", p), r("interactOutside", p), await Pr(), p.defaultPrevented || r("dismiss")) }, a), f = Nxe(p => { [...ns.branches].some(g => g == null ? void 0 : g.contains(p.target)) || (r("focusOutside", p), r("interactOutside", p), p.defaultPrevented || r("dismiss")) }, a); pR("Escape", p => { l.value === s.value.size - 1 && (r("escapeKeyDown", p), p.defaultPrevented || r("dismiss")) }); let h; return Bn(p => { a.value && (t.disableOutsidePointerEvents && (ns.layersWithOutsidePointerEventsDisabled.size === 0 && (h = o.value.body.style.pointerEvents, o.value.body.style.pointerEvents = "none"), ns.layersWithOutsidePointerEventsDisabled.add(a.value)), s.value.add(a.value), p(() => { t.disableOutsidePointerEvents && ns.layersWithOutsidePointerEventsDisabled.size === 1 && (o.value.body.style.pointerEvents = h) })) }), Bn(p => { p(() => { a.value && (s.value.delete(a.value), ns.layersWithOutsidePointerEventsDisabled.delete(a.value)) }) }), (p, m) => (Z(), Ye(X(Uo), { ref: X(i), "as-child": p.asChild, as: p.as, "data-dismissable-layer": "", style: aa({ pointerEvents: c.value ? u.value ? "auto" : "none" : void 0 }), onFocusCapture: X(f).onFocusCapture, onBlurCapture: X(f).onBlurCapture, onPointerdownCapture: X(d).onPointerDownCapture }, { default: Ue(() => [ut(p.$slots, "default")]), _: 3 }, 8, ["as-child", "as", "style", "onFocusCapture", "onBlurCapture", "onPointerdownCapture"])) } }); function pg() { let n = document.activeElement; if (n == null) return null; for (; n != null && n.shadowRoot != null && n.shadowRoot.activeElement != null;)n = n.shadowRoot.activeElement; return n } function bE(n, { select: e = !1 } = {}) { const t = pg(); for (const r of n) if (zxe(r, { select: e }), pg() !== t) return !0 } function $xe(n) { const e = [], t = document.createTreeWalker(n, NodeFilter.SHOW_ELEMENT, { acceptNode: r => { const i = r.tagName === "INPUT" && r.type === "hidden"; return r.disabled || r.hidden || i ? NodeFilter.FILTER_SKIP : r.tabIndex >= 0 ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP } }); for (; t.nextNode();)e.push(t.currentNode); return e } function Fxe(n) { return n instanceof HTMLInputElement && "select" in n } function zxe(n, { select: e = !1 } = {}) { if (n && n.focus) { const t = pg(); n.focus({ preventScroll: !0 }), n !== t && Fxe(n) && e && n.select() } } function K$() { const n = he(), e = ne(() => { var t, r; return ["#text", "#comment"].includes((t = n.value) == null ? void 0 : t.$el.nodeName) ? (r = n.value) == null ? void 0 : r.$el.nextElementSibling : Nh(n) }); return { primitiveElement: n, currentElement: e } } const q$ = "data-reka-collection-item"; function mR(n = {}) { const { key: e = "", isProvider: t = !1 } = n, r = `${e}CollectionProvider`; let i; if (t) { const u = he(new Map); i = { collectionRef: he(), itemMap: u }, Or(r, i) } else i = zn(r); const a = (u = !1) => { const d = i.collectionRef.value; if (!d) return []; const f = Array.from(d.querySelectorAll(`[${q$}]`)), p = Array.from(i.itemMap.value.values()).sort((m, g) => f.indexOf(m.ref) - f.indexOf(g.ref)); return u ? p : p.filter(m => m.ref.dataset.disabled !== "") }, o = We({ name: "CollectionSlot", setup(u, { slots: d }) { const { primitiveElement: f, currentElement: h } = K$(); return Ct(h, () => { i.collectionRef.value = h.value }), () => Gt(wj, { ref: f }, d) } }), s = We({ name: "CollectionItem", inheritAttrs: !1, props: { value: { validator: () => !0 } }, setup(u, { slots: d, attrs: f }) { const { primitiveElement: h, currentElement: p } = K$(); return Bn(m => { if (p.value) { const g = dn(p.value); i.itemMap.value.set(g, { ref: p.value, value: u.value }), m(() => i.itemMap.value.delete(g)) } }), () => Gt(wj, { ...f, [q$]: "", ref: h }, d) } }), l = ne(() => Array.from(i.itemMap.value.values())), c = ne(() => i.itemMap.value.size); return { getItems: a, reactiveItems: l, itemMapSize: c, CollectionSlot: o, CollectionItem: s } } const [XY, Vxe] = Xh("PopperRoot"), Hxe = We({ inheritAttrs: !1, __name: "PopperRoot", setup(n) { const e = he(); return Vxe({ anchor: e, onAnchorChange: t => e.value = t }), (t, r) => ut(t.$slots, "default") } }), Uxe = We({ __name: "PopperAnchor", props: { reference: {}, asChild: { type: Boolean }, as: {} }, setup(n) { const e = n, { forwardRef: t, currentElement: r } = Wr(), i = XY(); return GK(() => { i.onAnchorChange(e.reference ?? r.value) }), (a, o) => (Z(), Ye(X(Uo), { ref: X(t), as: a.as, "as-child": a.asChild }, { default: Ue(() => [ut(a.$slots, "default")]), _: 3 }, 8, ["as", "as-child"])) } }); function Gxe(n) { return n !== null } function Wxe(n) { return { name: "transformOrigin", options: n, fn(e) { var g, y, b; const { placement: t, rects: r, middlewareData: i } = e, o = ((g = i.arrow) == null ? void 0 : g.centerOffset) !== 0, s = o ? 0 : n.arrowWidth, l = o ? 0 : n.arrowHeight, [c, u] = Sj(t), d = { start: "0%", center: "50%", end: "100%" }[u], f = (((y = i.arrow) == null ? void 0 : y.x) ?? 0) + s / 2, h = (((b = i.arrow) == null ? void 0 : b.y) ?? 0) + l / 2; let p = "", m = ""; return c === "bottom" ? (p = o ? d : `${f}px`, m = `${-l}px`) : c === "top" ? (p = o ? d : `${f}px`, m = `${r.floating.height + l}px`) : c === "right" ? (p = `${-l}px`, m = o ? d : `${h}px`) : c === "left" && (p = `${r.floating.width + l}px`, m = o ? d : `${h}px`), { data: { x: p, y: m } } } } } function Sj(n) { const [e, t = "center"] = n.split("-"); return [e, t] } function Kxe(n) { const e = he(), t = ne(() => { var i; return ((i = e.value) == null ? void 0 : i.width) ?? 0 }), r = ne(() => { var i; return ((i = e.value) == null ? void 0 : i.height) ?? 0 }); return un(() => { const i = Nh(n); if (i) { e.value = { width: i.offsetWidth, height: i.offsetHeight }; const a = new ResizeObserver(o => { if (!Array.isArray(o) || !o.length) return; const s = o[0]; let l, c; if ("borderBoxSize" in s) { const u = s.borderBoxSize, d = Array.isArray(u) ? u[0] : u; l = d.inlineSize, c = d.blockSize } else l = i.offsetWidth, c = i.offsetHeight; e.value = { width: l, height: c } }); return a.observe(i, { box: "border-box" }), () => a.unobserve(i) } else e.value = void 0 }), { width: t, height: r } } const qxe = { side: "bottom", sideOffset: 0, align: "center", alignOffset: 0, arrowPadding: 0, avoidCollisions: !0, collisionBoundary: () => [], collisionPadding: 0, sticky: "partial", hideWhenDetached: !1, positionStrategy: "fixed", updatePositionStrategy: "optimized", prioritizePosition: !1 }, [Yxe, Zxe] = Xh("PopperContent"), Xxe = We({ inheritAttrs: !1, __name: "PopperContent", props: Wge({ side: {}, sideOffset: {}, align: {}, alignOffset: {}, avoidCollisions: { type: Boolean }, collisionBoundary: {}, collisionPadding: {}, arrowPadding: {}, sticky: {}, hideWhenDetached: { type: Boolean }, positionStrategy: {}, updatePositionStrategy: {}, disableUpdateOnLayoutShift: { type: Boolean }, prioritizePosition: { type: Boolean }, reference: {}, asChild: { type: Boolean }, as: {} }, { ...qxe }), emits: ["placed"], setup(n, { emit: e }) { const t = n, r = e, i = XY(), { forwardRef: a, currentElement: o } = Wr(), s = he(), l = he(), { width: c, height: u } = Kxe(l), d = ne(() => t.side + (t.align !== "center" ? `-${t.align}` : "")), f = ne(() => typeof t.collisionPadding == "number" ? t.collisionPadding : { top: 0, right: 0, bottom: 0, left: 0, ...t.collisionPadding }), h = ne(() => Array.isArray(t.collisionBoundary) ? t.collisionBoundary : [t.collisionBoundary]), p = ne(() => ({ padding: f.value, boundary: h.value.filter(Gxe), altBoundary: h.value.length > 0 })), m = pxe(() => [txe({ mainAxis: t.sideOffset + u.value, alignmentAxis: t.alignOffset }), t.prioritizePosition && t.avoidCollisions && G$({ ...p.value }), t.avoidCollisions && nxe({ mainAxis: !0, crossAxis: !!t.prioritizePosition, limiter: t.sticky === "partial" ? oxe() : void 0, ...p.value }), !t.prioritizePosition && t.avoidCollisions && G$({ ...p.value }), rxe({ ...p.value, apply: ({ elements: j, rects: I, availableWidth: L, availableHeight: R }) => { const { width: D, height: P } = I.reference, B = j.floating.style; B.setProperty("--reka-popper-available-width", `${L}px`), B.setProperty("--reka-popper-available-height", `${R}px`), B.setProperty("--reka-popper-anchor-width", `${D}px`), B.setProperty("--reka-popper-anchor-height", `${P}px`) } }), l.value && fxe({ element: l.value, padding: t.arrowPadding }), Wxe({ arrowWidth: c.value, arrowHeight: u.value }), t.hideWhenDetached && ixe({ strategy: "referenceHidden", ...p.value })]), g = ne(() => t.reference ?? i.anchor.value), { floatingStyles: y, placement: b, isPositioned: w, middlewareData: v, update: S } = hxe(g, s, { strategy: t.positionStrategy, placement: d, whileElementsMounted: (...j) => exe(...j, { layoutShift: !t.disableUpdateOnLayoutShift, animationFrame: t.updatePositionStrategy === "always" }), middleware: m }), x = ne(() => Sj(b.value)[0]), k = ne(() => Sj(b.value)[1]); GK(() => { w.value && r("placed") }); const A = ne(() => { var j; return ((j = v.value.arrow) == null ? void 0 : j.centerOffset) !== 0 }), C = he(""); Bn(() => { o.value && (C.value = window.getComputedStyle(o.value).zIndex) }); const E = ne(() => { var j; return ((j = v.value.arrow) == null ? void 0 : j.x) ?? 0 }), O = ne(() => { var j; return ((j = v.value.arrow) == null ? void 0 : j.y) ?? 0 }); return Zxe({ placedSide: x, onArrowChange: j => l.value = j, arrowX: E, arrowY: O, shouldHideArrow: A }), (j, I) => { var L, R, D; return Z(), ye("div", { ref_key: "floatingRef", ref: s, "data-reka-popper-content-wrapper": "", style: aa({ ...X(y), transform: X(w) ? X(y).transform : "translate(0, -200%)", minWidth: "max-content", zIndex: C.value, "--reka-popper-transform-origin": [(L = X(v).transformOrigin) == null ? void 0 : L.x, (R = X(v).transformOrigin) == null ? void 0 : R.y].join(" "), ...((D = X(v).hide) == null ? void 0 : D.referenceHidden) && { visibility: "hidden", pointerEvents: "none" } }) }, [$e(X(Uo), Sn({ ref: X(a) }, j.$attrs, { "as-child": t.asChild, as: j.as, "data-side": x.value, "data-align": k.value, style: { animation: X(w) ? void 0 : "none" } }), { default: Ue(() => [ut(j.$slots, "default")]), _: 3 }, 16, ["as-child", "as", "data-side", "data-align", "style"])], 4) } } }), Jxe = { key: 0, d: "M0 0L6 6L12 0" }, Qxe = { key: 1, d: "M0 0L4.58579 4.58579C5.36683 5.36683 6.63316 5.36684 7.41421 4.58579L12 0" }, eSe = We({ __name: "Arrow", props: { width: { default: 10 }, height: { default: 5 }, rounded: { type: Boolean }, asChild: { type: Boolean }, as: { default: "svg" } }, setup(n) { const e = n; return Wr(), (t, r) => (Z(), Ye(X(Uo), Sn(e, { width: t.width, height: t.height, viewBox: t.asChild ? void 0 : "0 0 12 6", preserveAspectRatio: t.asChild ? void 0 : "none" }), { default: Ue(() => [ut(t.$slots, "default", {}, () => [t.rounded ? (Z(), ye("path", Qxe)) : (Z(), ye("path", Jxe))])]), _: 3 }, 16, ["width", "height", "viewBox", "preserveAspectRatio"])) } }), tSe = { top: "bottom", right: "left", bottom: "top", left: "right" }, nSe = We({ inheritAttrs: !1, __name: "PopperArrow", props: { width: {}, height: {}, rounded: { type: Boolean }, asChild: { type: Boolean }, as: { default: "svg" } }, setup(n) { const { forwardRef: e } = Wr(), t = Yxe(), r = ne(() => tSe[t.placedSide.value]); return (i, a) => { var o, s, l, c; return Z(), ye("span", { ref: u => { X(t).onArrowChange(u) }, style: aa({ position: "absolute", left: (o = X(t).arrowX) != null && o.value ? `${(s = X(t).arrowX) == null ? void 0 : s.value}px` : void 0, top: (l = X(t).arrowY) != null && l.value ? `${(c = X(t).arrowY) == null ? void 0 : c.value}px` : void 0, [r.value]: 0, transformOrigin: { top: "", right: "0 0", bottom: "center 0", left: "100% 0" }[X(t).placedSide.value], transform: { top: "translateY(100%)", right: "translateY(50%) rotate(90deg) translateX(-50%)", bottom: "rotate(180deg)", left: "translateY(50%) rotate(-90deg) translateX(50%)" }[X(t).placedSide.value], visibility: X(t).shouldHideArrow.value ? "hidden" : void 0 }) }, [$e(eSe, Sn(i.$attrs, { ref: X(e), style: { display: "block" }, as: i.as, "as-child": i.asChild, rounded: i.rounded, width: i.width, height: i.height }), { default: Ue(() => [ut(i.$slots, "default")]), _: 3 }, 16, ["as", "as-child", "rounded", "width", "height"])], 4) } } }); function rSe(n, e) { const t = bxe(!1, 300), r = he(null), i = mxe(); function a() { r.value = null, t.value = !1 } function o(s, l) { const c = s.currentTarget, u = { x: s.clientX, y: s.clientY }, d = iSe(u, c.getBoundingClientRect()), f = aSe(u, d), h = oSe(l.getBoundingClientRect()), p = lSe([...f, ...h]); r.value = p, t.value = !0 } return Bn(s => { if (n.value && e.value) { const l = u => o(u, e.value), c = u => o(u, n.value); n.value.addEventListener("pointerleave", l), e.value.addEventListener("pointerleave", c), s(() => { var u, d; (u = n.value) == null || u.removeEventListener("pointerleave", l), (d = e.value) == null || d.removeEventListener("pointerleave", c) }) } }), Bn(s => { var l; if (r.value) { const c = u => { var g, y; if (!r.value) return; const d = u.target, f = { x: u.clientX, y: u.clientY }, h = ((g = n.value) == null ? void 0 : g.contains(d)) || ((y = e.value) == null ? void 0 : y.contains(d)), p = !sSe(f, r.value), m = !!d.closest("[data-grace-area-trigger]"); h ? a() : (p || m) && (a(), i.trigger()) }; (l = n.value) == null || l.ownerDocument.addEventListener("pointermove", c), s(() => { var u; return (u = n.value) == null ? void 0 : u.ownerDocument.removeEventListener("pointermove", c) }) } }), { isPointerInTransit: t, onPointerExit: i.on } } function iSe(n, e) { const t = Math.abs(e.top - n.y), r = Math.abs(e.bottom - n.y), i = Math.abs(e.right - n.x), a = Math.abs(e.left - n.x); switch (Math.min(t, r, i, a)) { case a: return "left"; case i: return "right"; case t: return "top"; case r: return "bottom"; default: throw new Error("unreachable") } } function aSe(n, e, t = 5) { const r = []; switch (e) { case "top": r.push({ x: n.x - t, y: n.y + t }, { x: n.x + t, y: n.y + t }); break; case "bottom": r.push({ x: n.x - t, y: n.y - t }, { x: n.x + t, y: n.y - t }); break; case "left": r.push({ x: n.x + t, y: n.y - t }, { x: n.x + t, y: n.y + t }); break; case "right": r.push({ x: n.x - t, y: n.y - t }, { x: n.x - t, y: n.y + t }); break }return r } function oSe(n) { const { top: e, right: t, bottom: r, left: i } = n; return [{ x: i, y: e }, { x: t, y: e }, { x: t, y: r }, { x: i, y: r }] } function sSe(n, e) { const { x: t, y: r } = n; let i = !1; for (let a = 0, o = e.length - 1; a < e.length; o = a++) { const s = e[a].x, l = e[a].y, c = e[o].x, u = e[o].y; l > r != u > r && t < (c - s) * (r - l) / (u - l) + s && (i = !i) } return i } function lSe(n) { const e = n.slice(); return e.sort((t, r) => t.x < r.x ? -1 : t.x > r.x ? 1 : t.y < r.y ? -1 : t.y > r.y ? 1 : 0), cSe(e) } function cSe(n) { if (n.length <= 1) return n.slice(); const e = []; for (let r = 0; r < n.length; r++) { const i = n[r]; for (; e.length >= 2;) { const a = e[e.length - 1], o = e[e.length - 2]; if ((a.x - o.x) * (i.y - o.y) >= (a.y - o.y) * (i.x - o.x)) e.pop(); else break } e.push(i) } e.pop(); const t = []; for (let r = n.length - 1; r >= 0; r--) { const i = n[r]; for (; t.length >= 2;) { const a = t[t.length - 1], o = t[t.length - 2]; if ((a.x - o.x) * (i.y - o.y) >= (a.y - o.y) * (i.x - o.x)) t.pop(); else break } t.push(i) } return t.pop(), e.length === 1 && t.length === 1 && e[0].x === t[0].x && e[0].y === t[0].y ? e : e.concat(t) } const [vk, uSe] = Xh("ToastProvider"), dSe = We({ inheritAttrs: !1, __name: "ToastProvider", props: { label: { default: "Notification" }, duration: { default: 5e3 }, swipeDirection: { default: "right" }, swipeThreshold: { default: 50 } }, setup(n) { const e = n, { label: t, duration: r, swipeDirection: i, swipeThreshold: a } = tb(e); mR({ isProvider: !0 }); const o = he(), s = he(0), l = he(!1), c = he(!1); if (e.label && typeof e.label == "string" && !e.label.trim()) { const u = "Invalid prop `label` supplied to `ToastProvider`. Expected non-empty `string`."; throw new Error(u) } return uSe({ label: t, duration: r, swipeDirection: i, swipeThreshold: a, toastCount: s, viewport: o, onViewportChange(u) { o.value = u }, onToastAdd() { s.value++ }, onToastRemove() { s.value-- }, isFocusedToastEscapeKeyDownRef: l, isClosePausedRef: c }), (u, d) => ut(u.$slots, "default") } }), fSe = "toast.swipeStart", hSe = "toast.swipeMove", pSe = "toast.swipeCancel", mSe = "toast.swipeEnd", Tj = "toast.viewportPause", kj = "toast.viewportResume"; function q1(n, e, t) { const r = t.originalEvent.currentTarget, i = new CustomEvent(n, { bubbles: !1, cancelable: !0, detail: t }); e && r.addEventListener(n, e, { once: !0 }), r.dispatchEvent(i) } function Y$(n, e, t = 0) { const r = Math.abs(n.x), i = Math.abs(n.y), a = r > i; return e === "left" || e === "right" ? a && r > t : !a && i > t } function gSe(n) { return n.nodeType === n.ELEMENT_NODE } function JY(n) { const e = []; return Array.from(n.childNodes).forEach(r => { if (r.nodeType === r.TEXT_NODE && r.textContent && e.push(r.textContent), gSe(r)) { const i = r.ariaHidden || r.hidden || r.style.display === "none", a = r.dataset.rekaToastAnnounceExclude === ""; if (!i) if (a) { const o = r.dataset.rekaToastAnnounceAlt; o && e.push(o) } else e.push(...JY(r)) } }), e } const vSe = We({ __name: "ToastAnnounce", setup(n) { const e = vk(), t = wxe(1e3), r = he(!1); return GY(() => { r.value = !0 }), (i, a) => X(t) || r.value ? (Z(), Ye(X(fR), { key: 0 }, { default: Ue(() => [Fo(Ht(X(e).label.value) + " ", 1), ut(i.$slots, "default")]), _: 3 })) : mt("", !0) } }), [ySe, _Se] = Xh("ToastRoot"), bSe = We({ inheritAttrs: !1, __name: "ToastRootImpl", props: { type: {}, open: { type: Boolean, default: !1 }, duration: {}, asChild: { type: Boolean }, as: { default: "li" } }, emits: ["close", "escapeKeyDown", "pause", "resume", "swipeStart", "swipeMove", "swipeCancel", "swipeEnd"], setup(n, { emit: e }) { const t = n, r = e, { forwardRef: i, currentElement: a } = Wr(), { CollectionItem: o } = mR(), s = vk(), l = he(null), c = he(null), u = ne(() => typeof t.duration == "number" ? t.duration : s.duration.value), d = he(0), f = he(u.value), h = he(0), p = he(u.value), m = GY(() => { const w = new Date().getTime() - d.value; p.value = Math.max(f.value - w, 0) }, { fpsLimit: 60 }); function g(w) { w <= 0 || w === Number.POSITIVE_INFINITY || Vg && (window.clearTimeout(h.value), d.value = new Date().getTime(), h.value = window.setTimeout(y, w)) } function y(w) { var x, k; const v = (w == null ? void 0 : w.pointerType) === ""; ((x = a.value) == null ? void 0 : x.contains(pg())) && v && ((k = s.viewport.value) == null || k.focus()), v && (s.isClosePausedRef.value = !1), r("close") } const b = ne(() => a.value ? JY(a.value) : null); if (t.type && !["foreground", "background"].includes(t.type)) { const w = "Invalid prop `type` supplied to `Toast`. Expected `foreground | background`."; throw new Error(w) } return Bn(w => { const v = s.viewport.value; if (v) { const S = () => { g(f.value), m.resume(), r("resume") }, x = () => { const k = new Date().getTime() - d.value; f.value = f.value - k, window.clearTimeout(h.value), m.pause(), r("pause") }; return v.addEventListener(Tj, x), v.addEventListener(kj, S), () => { v.removeEventListener(Tj, x), v.removeEventListener(kj, S) } } }), Ct(() => [t.open, u.value], () => { f.value = u.value, t.open && !s.isClosePausedRef.value && g(u.value) }, { immediate: !0 }), pR("Escape", w => { r("escapeKeyDown", w), w.defaultPrevented || (s.isFocusedToastEscapeKeyDownRef.value = !0, y()) }), un(() => { s.onToastAdd() }), cr(() => { s.onToastRemove() }), _Se({ onClose: y }), (w, v) => (Z(), ye(Qt, null, [b.value ? (Z(), Ye(vSe, { key: 0, role: "alert", "aria-live": w.type === "foreground" ? "assertive" : "polite", "aria-atomic": "true" }, { default: Ue(() => [Fo(Ht(b.value), 1)]), _: 1 }, 8, ["aria-live"])) : mt("", !0), X(s).viewport.value ? (Z(), Ye(rb, { key: 1, to: X(s).viewport.value }, [$e(X(o), null, { default: Ue(() => [$e(X(Uo), Sn({ ref: X(i), role: "alert", "aria-live": "off", "aria-atomic": "true", tabindex: "0" }, w.$attrs, { as: w.as, "as-child": w.asChild, "data-state": w.open ? "open" : "closed", "data-swipe-direction": X(s).swipeDirection.value, style: { userSelect: "none", touchAction: "none" }, onPointerdown: v[0] || (v[0] = ar(S => { l.value = { x: S.clientX, y: S.clientY } }, ["left"])), onPointermove: v[1] || (v[1] = S => { if (!l.value) return; const x = S.clientX - l.value.x, k = S.clientY - l.value.y, A = !!c.value, C = ["left", "right"].includes(X(s).swipeDirection.value), E = ["left", "up"].includes(X(s).swipeDirection.value) ? Math.min : Math.max, O = C ? E(0, x) : 0, j = C ? 0 : E(0, k), I = S.pointerType === "touch" ? 10 : 2, L = { x: O, y: j }, R = { originalEvent: S, delta: L }; A ? (c.value = L, X(q1)(X(hSe), D => r("swipeMove", D), R)) : X(Y$)(L, X(s).swipeDirection.value, I) ? (c.value = L, X(q1)(X(fSe), D => r("swipeStart", D), R), S.target.setPointerCapture(S.pointerId)) : (Math.abs(x) > I || Math.abs(k) > I) && (l.value = null) }), onPointerup: v[2] || (v[2] = S => { const x = c.value, k = S.target; if (k.hasPointerCapture(S.pointerId) && k.releasePointerCapture(S.pointerId), c.value = null, l.value = null, x) { const A = S.currentTarget, C = { originalEvent: S, delta: x }; X(Y$)(x, X(s).swipeDirection.value, X(s).swipeThreshold.value) ? X(q1)(X(mSe), E => r("swipeEnd", E), C) : X(q1)(X(pSe), E => r("swipeCancel", E), C), A == null || A.addEventListener("click", E => E.preventDefault(), { once: !0 }) } }) }), { default: Ue(() => [ut(w.$slots, "default", { remaining: p.value, duration: u.value })]), _: 3 }, 16, ["as", "as-child", "data-state", "data-swipe-direction"])]), _: 3 })], 8, ["to"])) : mt("", !0)], 64)) } }), wSe = We({ __name: "ToastRoot", props: { defaultOpen: { type: Boolean, default: !0 }, forceMount: { type: Boolean }, type: { default: "foreground" }, open: { type: Boolean, default: void 0 }, duration: {}, asChild: { type: Boolean }, as: { default: "li" } }, emits: ["escapeKeyDown", "pause", "resume", "swipeStart", "swipeMove", "swipeCancel", "swipeEnd", "update:open"], setup(n, { emit: e }) { const t = n, r = e, { forwardRef: i } = Wr(), a = WY(t, "open", r, { defaultValue: t.defaultOpen, passive: t.open === void 0 }); return (o, s) => (Z(), Ye(X(KY), { present: o.forceMount || X(a) }, { default: Ue(() => [$e(bSe, Sn({ ref: X(i), open: X(a), type: o.type, as: o.as, "as-child": o.asChild, duration: o.duration }, o.$attrs, { onClose: s[0] || (s[0] = l => a.value = !1), onPause: s[1] || (s[1] = l => r("pause")), onResume: s[2] || (s[2] = l => r("resume")), onEscapeKeyDown: s[3] || (s[3] = l => r("escapeKeyDown", l)), onSwipeStart: s[4] || (s[4] = l => { r("swipeStart", l), l.currentTarget.setAttribute("data-swipe", "start") }), onSwipeMove: s[5] || (s[5] = l => { r("swipeMove", l); const { x: c, y: u } = l.detail.delta, d = l.currentTarget; d.setAttribute("data-swipe", "move"), d.style.setProperty("--reka-toast-swipe-move-x", `${c}px`), d.style.setProperty("--reka-toast-swipe-move-y", `${u}px`) }), onSwipeCancel: s[6] || (s[6] = l => { r("swipeCancel", l); const c = l.currentTarget; c.setAttribute("data-swipe", "cancel"), c.style.removeProperty("--reka-toast-swipe-move-x"), c.style.removeProperty("--reka-toast-swipe-move-y"), c.style.removeProperty("--reka-toast-swipe-end-x"), c.style.removeProperty("--reka-toast-swipe-end-y") }), onSwipeEnd: s[7] || (s[7] = l => { r("swipeEnd", l); const { x: c, y: u } = l.detail.delta, d = l.currentTarget; d.setAttribute("data-swipe", "end"), d.style.removeProperty("--reka-toast-swipe-move-x"), d.style.removeProperty("--reka-toast-swipe-move-y"), d.style.setProperty("--reka-toast-swipe-end-x", `${c}px`), d.style.setProperty("--reka-toast-swipe-end-y", `${u}px`), a.value = !1 }) }), { default: Ue(({ remaining: l, duration: c }) => [ut(o.$slots, "default", { remaining: l, duration: c, open: X(a) })]), _: 3 }, 16, ["open", "type", "as", "as-child", "duration"])]), _: 3 }, 8, ["present"])) } }), QY = We({ __name: "ToastAnnounceExclude", props: { altText: {}, asChild: { type: Boolean }, as: {} }, setup(n) { return (e, t) => (Z(), Ye(X(Uo), { as: e.as, "as-child": e.asChild, "data-reka-toast-announce-exclude": "", "data-reka-toast-announce-alt": e.altText || void 0 }, { default: Ue(() => [ut(e.$slots, "default")]), _: 3 }, 8, ["as", "as-child", "data-reka-toast-announce-alt"])) } }), eZ = We({ __name: "ToastClose", props: { asChild: { type: Boolean }, as: { default: "button" } }, setup(n) { const e = n, t = ySe(), { forwardRef: r } = Wr(); return (i, a) => (Z(), Ye(QY, { "as-child": "" }, { default: Ue(() => [$e(X(Uo), Sn(e, { ref: X(r), type: i.as === "button" ? "button" : void 0, onClick: X(t).onClose }), { default: Ue(() => [ut(i.$slots, "default")]), _: 3 }, 16, ["type", "onClick"])]), _: 3 })) } }), xSe = We({ __name: "ToastAction", props: { altText: {}, asChild: { type: Boolean }, as: {} }, setup(n) { if (!n.altText) throw new Error("Missing prop `altText` expected on `ToastAction`"); const { forwardRef: t } = Wr(); return (r, i) => r.altText ? (Z(), Ye(QY, { key: 0, "alt-text": r.altText, "as-child": "" }, { default: Ue(() => [$e(eZ, { ref: X(t), as: r.as, "as-child": r.asChild }, { default: Ue(() => [ut(r.$slots, "default")]), _: 3 }, 8, ["as", "as-child"])]), _: 3 }, 8, ["alt-text"])) : mt("", !0) } }), Z$ = We({ __name: "FocusProxy", emits: ["focusFromOutsideViewport"], setup(n, { emit: e }) { const t = e, r = vk(); return (i, a) => (Z(), Ye(X(fR), { "aria-hidden": "true", tabindex: "0", style: { position: "fixed" }, onFocus: a[0] || (a[0] = o => { var c; const s = o.relatedTarget; !((c = X(r).viewport.value) != null && c.contains(s)) && t("focusFromOutsideViewport") }) }, { default: Ue(() => [ut(i.$slots, "default")]), _: 3 })) } }), SSe = We({ __name: "DismissableLayerBranch", props: { asChild: { type: Boolean }, as: {} }, setup(n) { const e = n, { forwardRef: t, currentElement: r } = Wr(); return un(() => { ns.branches.add(r.value) }), cr(() => { ns.branches.delete(r.value) }), (i, a) => (Z(), Ye(X(Uo), Sn({ ref: X(t) }, e), { default: Ue(() => [ut(i.$slots, "default")]), _: 3 }, 16)) } }), TSe = We({ inheritAttrs: !1, __name: "ToastViewport", props: { hotkey: { default: () => ["F8"] }, label: { type: [String, Function], default: "Notifications ({hotkey})" }, asChild: { type: Boolean }, as: { default: "ol" } }, setup(n) { const e = n, { hotkey: t, label: r } = tb(e), { forwardRef: i, currentElement: a } = Wr(), { CollectionSlot: o, getItems: s } = mR(), l = vk(), c = ne(() => l.toastCount.value > 0), u = he(), d = he(), f = ne(() => t.value.join("+").replace(/Key/g, "").replace(/Digit/g, "")); pR(t.value, () => { a.value.focus() }), un(() => { l.onViewportChange(a.value) }), Bn(p => { const m = a.value; if (c.value && m) { const g = () => { if (!l.isClosePausedRef.value) { const S = new CustomEvent(Tj); m.dispatchEvent(S), l.isClosePausedRef.value = !0 } }, y = () => { if (l.isClosePausedRef.value) { const S = new CustomEvent(kj); m.dispatchEvent(S), l.isClosePausedRef.value = !1 } }, b = S => { !m.contains(S.relatedTarget) && y() }, w = () => { m.contains(pg()) || y() }, v = S => { var A, C, E; const x = S.altKey || S.ctrlKey || S.metaKey; if (S.key === "Tab" && !x) { const O = pg(), j = S.shiftKey; if (S.target === m && j) { (A = u.value) == null || A.focus(); return } const R = h({ tabbingDirection: j ? "backwards" : "forwards" }), D = R.findIndex(P => P === O); bE(R.slice(D + 1)) ? S.preventDefault() : j ? (C = u.value) == null || C.focus() : (E = d.value) == null || E.focus() } }; m.addEventListener("focusin", g), m.addEventListener("focusout", b), m.addEventListener("pointermove", g), m.addEventListener("pointerleave", w), m.addEventListener("keydown", v), window.addEventListener("blur", g), window.addEventListener("focus", y), p(() => { m.removeEventListener("focusin", g), m.removeEventListener("focusout", b), m.removeEventListener("pointermove", g), m.removeEventListener("pointerleave", w), m.removeEventListener("keydown", v), window.removeEventListener("blur", g), window.removeEventListener("focus", y) }) } }); function h({ tabbingDirection: p }) { const g = s().map(y => y.ref).map(y => { const b = [y, ...$xe(y)]; return p === "forwards" ? b : b.reverse() }); return (p === "forwards" ? g.reverse() : g).flat() } return (p, m) => (Z(), Ye(X(SSe), { role: "region", "aria-label": typeof X(r) == "string" ? X(r).replace("{hotkey}", f.value) : X(r)(f.value), tabindex: "-1", style: aa({ pointerEvents: c.value ? void 0 : "none" }) }, { default: Ue(() => [c.value ? (Z(), Ye(Z$, { key: 0, ref: g => { u.value = X(Nh)(g) }, onFocusFromOutsideViewport: m[0] || (m[0] = () => { const g = h({ tabbingDirection: "forwards" }); X(bE)(g) }) }, null, 512)) : mt("", !0), $e(X(o), null, { default: Ue(() => [$e(X(Uo), Sn({ ref: X(i), tabindex: "-1", as: p.as, "as-child": p.asChild }, p.$attrs), { default: Ue(() => [ut(p.$slots, "default")]), _: 3 }, 16, ["as", "as-child"])]), _: 3 }), c.value ? (Z(), Ye(Z$, { key: 1, ref: g => { d.value = X(Nh)(g) }, onFocusFromOutsideViewport: m[1] || (m[1] = () => { const g = h({ tabbingDirection: "backwards" }); X(bE)(g) }) }, null, 512)) : mt("", !0)]), _: 3 }, 8, ["aria-label", "style"])) } }), kSe = We({ __name: "ToastDescription", props: { asChild: { type: Boolean }, as: {} }, setup(n) { const e = n; return Wr(), (t, r) => (Z(), Ye(X(Uo), Eo(Mo(e)), { default: Ue(() => [ut(t.$slots, "default")]), _: 3 }, 16)) } }), tZ = "tooltip.open", [gR, CSe] = Xh("TooltipProvider"), ASe = We({ inheritAttrs: !1, __name: "TooltipProvider", props: { delayDuration: { default: 700 }, skipDelayDuration: { default: 300 }, disableHoverableContent: { type: Boolean, default: !1 }, disableClosingTrigger: { type: Boolean }, disabled: { type: Boolean }, ignoreNonKeyboardFocus: { type: Boolean, default: !1 } }, setup(n) { const e = n, { delayDuration: t, skipDelayDuration: r, disableHoverableContent: i, disableClosingTrigger: a, ignoreNonKeyboardFocus: o, disabled: s } = tb(e); Wr(); const l = he(!0), c = he(!1), { start: u, stop: d } = hR(() => { l.value = !0 }, r, { immediate: !1 }); return CSe({ isOpenDelayed: l, delayDuration: t, onOpen() { d(), l.value = !1 }, onClose() { u() }, isPointerInTransitRef: c, disableHoverableContent: i, disableClosingTrigger: a, disabled: s, ignoreNonKeyboardFocus: o }), (f, h) => ut(f.$slots, "default") } }), [yk, ESe] = Xh("TooltipRoot"), MSe = We({ __name: "TooltipRoot", props: { defaultOpen: { type: Boolean, default: !1 }, open: { type: Boolean, default: void 0 }, delayDuration: { default: void 0 }, disableHoverableContent: { type: Boolean, default: void 0 }, disableClosingTrigger: { type: Boolean, default: void 0 }, disabled: { type: Boolean, default: void 0 }, ignoreNonKeyboardFocus: { type: Boolean, default: void 0 } }, emits: ["update:open"], setup(n, { emit: e }) { const t = n, r = e; Wr(); const i = gR(), a = ne(() => t.disableHoverableContent ?? i.disableHoverableContent.value), o = ne(() => t.disableClosingTrigger ?? i.disableClosingTrigger.value), s = ne(() => t.disabled ?? i.disabled.value), l = ne(() => t.delayDuration ?? i.delayDuration.value), c = ne(() => t.ignoreNonKeyboardFocus ?? i.ignoreNonKeyboardFocus.value), u = WY(t, "open", r, { defaultValue: t.defaultOpen, passive: t.open === void 0 }); Ct(u, w => { i.onClose && (w ? (i.onOpen(), document.dispatchEvent(new CustomEvent(tZ))) : i.onClose()) }); const d = he(!1), f = he(), h = ne(() => u.value ? d.value ? "delayed-open" : "instant-open" : "closed"), { start: p, stop: m } = hR(() => { d.value = !0, u.value = !0 }, l, { immediate: !1 }); function g() { m(), d.value = !1, u.value = !0 } function y() { m(), u.value = !1 } function b() { p() } return ESe({ contentId: "", open: u, stateAttribute: h, trigger: f, onTriggerChange(w) { f.value = w }, onTriggerEnter() { i.isOpenDelayed.value ? b() : g() }, onTriggerLeave() { a.value ? y() : m() }, onOpen: g, onClose: y, disableHoverableContent: a, disableClosingTrigger: o, disabled: s, ignoreNonKeyboardFocus: c }), (w, v) => (Z(), Ye(X(Hxe), null, { default: Ue(() => [ut(w.$slots, "default", { open: X(u) })]), _: 3 })) } }), OSe = We({ __name: "TooltipTrigger", props: { reference: {}, asChild: { type: Boolean }, as: { default: "button" } }, setup(n) { const e = n, t = yk(), r = gR(); t.contentId || (t.contentId = Exe(void 0, "reka-tooltip-content")); const { forwardRef: i, currentElement: a } = Wr(), o = he(!1), s = he(!1), l = ne(() => t.disabled.value ? {} : { click: m, focus: h, pointermove: d, pointerleave: f, pointerdown: u, blur: p }); un(() => { t.onTriggerChange(a.value) }); function c() { setTimeout(() => { o.value = !1 }, 1) } function u() { o.value = !0, document.addEventListener("pointerup", c, { once: !0 }) } function d(g) { g.pointerType !== "touch" && !s.value && !r.isPointerInTransitRef.value && (t.onTriggerEnter(), s.value = !0) } function f() { t.onTriggerLeave(), s.value = !1 } function h(g) { var y, b; o.value || t.ignoreNonKeyboardFocus.value && !((b = (y = g.target).matches) != null && b.call(y, ":focus-visible")) || t.onOpen() } function p() { t.onClose() } function m() { t.disableClosingTrigger.value || t.onClose() } return (g, y) => (Z(), Ye(X(Uxe), { "as-child": "", reference: g.reference }, { default: Ue(() => [$e(X(Uo), Sn({ ref: X(i), "aria-describedby": X(t).open.value ? X(t).contentId : void 0, "data-state": X(t).stateAttribute.value, as: g.as, "as-child": e.asChild, "data-grace-area-trigger": "" }, Uge(l.value)), { default: Ue(() => [ut(g.$slots, "default")]), _: 3 }, 16, ["aria-describedby", "data-state", "as", "as-child"])]), _: 3 }, 8, ["reference"])) } }), nZ = We({ __name: "TooltipContentImpl", props: { ariaLabel: {}, asChild: { type: Boolean }, as: {}, side: { default: "top" }, sideOffset: { default: 0 }, align: { default: "center" }, alignOffset: {}, avoidCollisions: { type: Boolean, default: !0 }, collisionBoundary: { default: () => [] }, collisionPadding: { default: 0 }, arrowPadding: { default: 0 }, sticky: { default: "partial" }, hideWhenDetached: { type: Boolean, default: !1 }, positionStrategy: {}, updatePositionStrategy: {} }, emits: ["escapeKeyDown", "pointerDownOutside"], setup(n, { emit: e }) { const t = n, r = e, i = yk(), { forwardRef: a } = Wr(), o = ek(), s = ne(() => { var u; return (u = o.default) == null ? void 0 : u.call(o, {}) }), l = ne(() => { var f; if (t.ariaLabel) return t.ariaLabel; let u = ""; function d(h) { typeof h.children == "string" && h.type !== mr ? u += h.children : Array.isArray(h.children) && h.children.forEach(p => d(p)) } return (f = s.value) == null || f.forEach(h => d(h)), u }), c = ne(() => { const { ariaLabel: u, ...d } = t; return d }); return un(() => { xj(window, "scroll", u => { const d = u.target; d != null && d.contains(i.trigger.value) && i.onClose() }), xj(window, tZ, i.onClose) }), (u, d) => (Z(), Ye(X(Bxe), { "as-child": "", "disable-outside-pointer-events": !1, onEscapeKeyDown: d[0] || (d[0] = f => r("escapeKeyDown", f)), onPointerDownOutside: d[1] || (d[1] = f => { var h; X(i).disableClosingTrigger.value && ((h = X(i).trigger.value) != null && h.contains(f.target)) && f.preventDefault(), r("pointerDownOutside", f) }), onFocusOutside: d[2] || (d[2] = ar(() => { }, ["prevent"])), onDismiss: d[3] || (d[3] = f => X(i).onClose()) }, { default: Ue(() => [$e(X(Xxe), Sn({ ref: X(a), "data-state": X(i).stateAttribute.value }, { ...u.$attrs, ...c.value }, { style: { "--reka-tooltip-content-transform-origin": "var(--reka-popper-transform-origin)", "--reka-tooltip-content-available-width": "var(--reka-popper-available-width)", "--reka-tooltip-content-available-height": "var(--reka-popper-available-height)", "--reka-tooltip-trigger-width": "var(--reka-popper-anchor-width)", "--reka-tooltip-trigger-height": "var(--reka-popper-anchor-height)" } }), { default: Ue(() => [ut(u.$slots, "default"), $e(X(fR), { id: X(i).contentId, role: "tooltip" }, { default: Ue(() => [Fo(Ht(l.value), 1)]), _: 1 }, 8, ["id"])]), _: 3 }, 16, ["data-state"])]), _: 3 })) } }), DSe = We({ __name: "TooltipContentHoverable", props: { ariaLabel: {}, asChild: { type: Boolean }, as: {}, side: {}, sideOffset: {}, align: {}, alignOffset: {}, avoidCollisions: { type: Boolean }, collisionBoundary: {}, collisionPadding: {}, arrowPadding: {}, sticky: {}, hideWhenDetached: { type: Boolean }, positionStrategy: {}, updatePositionStrategy: {} }, setup(n) { const t = qY(n), { forwardRef: r, currentElement: i } = Wr(), { trigger: a, onClose: o } = yk(), s = gR(), { isPointerInTransit: l, onPointerExit: c } = rSe(a, i); return s.isPointerInTransitRef = l, c(() => { o() }), (u, d) => (Z(), Ye(nZ, Sn({ ref: X(r) }, X(t)), { default: Ue(() => [ut(u.$slots, "default")]), _: 3 }, 16)) } }), jSe = We({ __name: "TooltipContent", props: { forceMount: { type: Boolean }, ariaLabel: {}, asChild: { type: Boolean }, as: {}, side: { default: "top" }, sideOffset: {}, align: {}, alignOffset: {}, avoidCollisions: { type: Boolean }, collisionBoundary: {}, collisionPadding: {}, arrowPadding: {}, sticky: {}, hideWhenDetached: { type: Boolean }, positionStrategy: {}, updatePositionStrategy: {} }, emits: ["escapeKeyDown", "pointerDownOutside"], setup(n, { emit: e }) { const t = n, r = e, i = yk(), a = jxe(t, r), { forwardRef: o } = Wr(); return (s, l) => (Z(), Ye(X(KY), { present: s.forceMount || X(i).open.value }, { default: Ue(() => [(Z(), Ye(dl(X(i).disableHoverableContent.value ? nZ : DSe), Sn({ ref: X(o) }, X(a)), { default: Ue(() => [ut(s.$slots, "default")]), _: 3 }, 16))]), _: 3 }, 8, ["present"])) } }), PSe = We({ __name: "TooltipArrow", props: { width: { default: 10 }, height: { default: 5 }, asChild: { type: Boolean }, as: { default: "svg" } }, setup(n) { const e = n; return Wr(), (t, r) => (Z(), Ye(X(nSe), Eo(Mo(e)), { default: Ue(() => [ut(t.$slots, "default")]), _: 3 }, 16)) } }), ISe = We({ __name: "TooltipPortal", props: { to: {}, disabled: { type: Boolean }, defer: { type: Boolean }, forceMount: { type: Boolean } }, setup(n) { const e = n; return (t, r) => (Z(), Ye(X(Pxe), Eo(Mo(e)), { default: Ue(() => [ut(t.$slots, "default")]), _: 3 }, 16)) } }), LSe = { class: "lucide lucide-check", xmlns: "http://www.w3.org/2000/svg", width: "24", height: "24", viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", "stroke-width": "1.5", "stroke-linecap": "round", "stroke-linejoin": "round" }; function RSe(n, e) { return Z(), ye("svg", LSe, e[0] || (e[0] = [re("path", { d: "M20 6 9 17l-5-5" }, null, -1)])) } const NSe = dn({ name: "lucide-check", render: RSe }), BSe = { class: "lucide lucide-chevron-down", xmlns: "http://www.w3.org/2000/svg", width: "24", height: "24", viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", "stroke-width": "1.5", "stroke-linecap": "round", "stroke-linejoin": "round" }; function $Se(n, e) { return Z(), ye("svg", BSe, e[0] || (e[0] = [re("path", { d: "m6 9 6 6 6-6" }, null, -1)])) } dn({ name: "lucide-chevron-down", render: $Se }); let FSe = 0; function zSe() { return ++FSe } function rZ() { return "frappe-ui-" + zSe() } const VSe = ["disabled", "id", "checked"], HSe = ["for"], USe = We({ __name: "Checkbox", props: { size: { default: "sm" }, label: {}, checked: { type: Boolean }, disabled: { type: Boolean }, padding: { type: Boolean, default: !1 }, modelValue: { type: [Boolean, Number] }, id: {} }, setup(n) { const e = n, t = ab(), r = e.id ?? rZ(), i = ne(() => [{ sm: "text-base font-medium", md: "text-lg font-medium" }[e.size], e.disabled ? "text-ink-gray-4" : "text-ink-gray-8", "select-none"]), a = ne(() => { let o = e.disabled ? "border-outline-gray-2 bg-surface-menu-bar text-ink-gray-3" : "border-outline-gray-4 text-ink-gray-9 hover:border-gray-600 focus:ring-offset-0 focus:border-gray-900 active:border-gray-700 transition", s = e.disabled ? "" : e.padding ? "focus:ring-0" : "hover:shadow-sm focus:ring-0 focus-visible:ring-2 focus-visible:ring-outline-gray-3 active:bg-surface-gray-2", l = { sm: "w-3.5 h-3.5", md: "w-4 h-4" }[e.size]; return [o, s, l] }); return (o, s) => (Z(), ye("div", { class: Tt(["inline-flex items-center space-x-2 rounded transition", { "px-2.5 py-1.5": o.padding && o.size === "sm", "px-3 py-2": o.padding && o.size === "md", "focus-within:bg-surface-gray-2 focus-within:ring-2 focus-within:ring-outline-gray-3 hover:bg-surface-gray-3 active:bg-surface-gray-4": o.padding && !o.disabled }]) }, [re("input", Sn({ class: ["rounded-sm", a.value], type: "checkbox", disabled: o.disabled, id: X(r), checked: !!o.modelValue, onChange: s[0] || (s[0] = l => o.$emit("update:modelValue", l.target.checked)) }, X(t)), null, 16, VSe), o.label ? (Z(), ye("label", { key: 0, class: Tt(["block", i.value]), for: X(r) }, Ht(o.label), 11, HSe)) : mt("", !0)], 2)) } }); function _k(n, e, t) { var r; return function () { var i = this, a = arguments, o = function () { r = void 0, t || n.apply(i, a) }, s = t && !r; clearTimeout(r), r = window.setTimeout(o, e), s && n.apply(i, a) } } const GSe = ["type", "placeholder", "disabled", "id", "value", "required"], vR = We({ inheritAttrs: !1, __name: "TextInput", props: { type: { default: "text" }, size: { default: "sm" }, variant: { default: "subtle" }, placeholder: {}, disabled: { type: Boolean }, id: {}, modelValue: {}, debounce: {}, required: { type: Boolean } }, emits: ["update:modelValue"], setup(n, { expose: e, emit: t }) { const r = n, i = t, a = ek(), o = ab(), s = ne(() => Object.fromEntries(Object.entries(o).filter(([m]) => m !== "class" && m !== "style"))), l = he(null); e({ el: l }); const c = ne(() => r.disabled ? "text-ink-gray-5" : "text-ink-gray-8"), u = ne(() => { let m = { sm: "text-base rounded h-7", md: "text-base rounded h-8", lg: "text-lg rounded-md h-10", xl: "text-xl rounded-md h-10" }[r.size], g = { sm: ["py-1.5", a.prefix ? "pl-8" : "pl-2", a.suffix ? "pr-8" : "pr-2"], md: ["py-1.5", a.prefix ? "pl-9" : "pl-2.5", a.suffix ? "pr-9" : "pr-2.5"], lg: ["py-1.5", a.prefix ? "pl-10" : "pl-3", a.suffix ? "pr-10" : "pr-3"], xl: ["py-1.5", a.prefix ? "pl-10" : "pl-3", a.suffix ? "pr-10" : "pr-3"] }[r.size], y = r.disabled ? "disabled" : r.variant, b = { subtle: "border border-[--surface-gray-2] bg-surface-gray-2 placeholder-ink-gray-4 hover:border-outline-gray-modals hover:bg-surface-gray-3 focus:bg-surface-white focus:border-outline-gray-4 focus:shadow-sm focus:ring-0 focus-visible:ring-2 focus-visible:ring-outline-gray-3", outline: "border border-outline-gray-2 bg-surface-white placeholder-ink-gray-4 hover:border-outline-gray-3 hover:shadow-sm focus:bg-surface-white focus:border-outline-gray-4 focus:shadow-sm focus:ring-0 focus-visible:ring-2 focus-visible:ring-outline-gray-3", disabled: ["border bg-surface-gray-1 placeholder-ink-gray-3", r.variant === "outline" ? "border-outline-gray-2" : "border-transparent"] }[y]; return [m, g, b, c.value, "transition-colors w-full dark:[color-scheme:dark]"] }); let d = ne(() => ({ sm: "pl-2", md: "pl-2.5", lg: "pl-3", xl: "pl-3" })[r.size]), f = ne(() => ({ sm: "pr-2", md: "pr-2.5", lg: "pr-3", xl: "pr-3" })[r.size]), h = m => { i("update:modelValue", m) }; r.debounce && (h = _k(h, r.debounce)); let p = m => { h(m.target.value) }; return (m, g) => (Z(), ye("div", { class: Tt(["relative flex items-center", X(o).class]), style: aa(X(o).style) }, [m.$slots.prefix ? (Z(), ye("div", { key: 0, class: Tt(["absolute inset-y-0 left-0 flex items-center", c.value, X(d)]) }, [ut(m.$slots, "prefix")], 2)) : mt("", !0), re("input", Sn({ ref_key: "inputRef", ref: l, type: m.type, placeholder: m.placeholder, class: u.value, disabled: m.disabled, id: m.id, value: m.modelValue, required: m.required, onInput: g[0] || (g[0] = (...y) => X(p) && X(p)(...y)), onChange: g[1] || (g[1] = (...y) => X(p) && X(p)(...y)) }, s.value), null, 16, GSe), m.$slots.suffix ? (Z(), ye("div", { key: 1, class: Tt(["absolute inset-y-0 right-0 flex items-center", c.value, X(f)]) }, [ut(m.$slots, "suffix")], 2)) : mt("", !0)], 6)) } }); var iZ = 60, aZ = iZ * 60, oZ = aZ * 24, WSe = oZ * 7, Oc = 1e3, dh = iZ * Oc, G0 = aZ * Oc, W0 = oZ * Oc, sZ = WSe * Oc, bk = "millisecond", Kf = "second", il = "minute", qf = "hour", oc = "day", Lx = "week", yo = "month", lZ = "quarter", sc = "year", Mm = "date", yR = "YYYY-MM-DDTHH:mm:ssZ", X$ = "Invalid Date", KSe = /^(\d{4})[-/]?(\d{1,2})?[-/]?(\d{0,2})[Tt\s]*(\d{1,2})?:?(\d{1,2})?:?(\d{1,2})?[.:]?(\d+)?$/, cZ = /\[([^\]]+)]|Y{1,4}|M{1,4}|D{1,2}|d{1,4}|H{1,2}|h{1,2}|a|A|m{1,2}|s{1,2}|Z{1,2}|SSS/g; const qSe = { name: "en", weekdays: "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"), months: "January_February_March_April_May_June_July_August_September_October_November_December".split("_"), ordinal: function (e) { var t = ["th", "st", "nd", "rd"], r = e % 100; return "[" + e + (t[(r - 20) % 10] || t[r] || t[0]) + "]" } }; var Cj = function (e, t, r) { var i = String(e); return !i || i.length >= t ? e : "" + Array(t + 1 - i.length).join(r) + e }, YSe = function (e) { var t = -e.utcOffset(), r = Math.abs(t), i = Math.floor(r / 60), a = r % 60; return (t <= 0 ? "+" : "-") + Cj(i, 2, "0") + ":" + Cj(a, 2, "0") }, ZSe = function n(e, t) { if (e.date() < t.date()) return -n(t, e); var r = (t.year() - e.year()) * 12 + (t.month() - e.month()), i = e.clone().add(r, yo), a = t - i < 0, o = e.clone().add(r + (a ? -1 : 1), yo); return +(-(r + (t - i) / (a ? i - o : o - i)) || 0) }, XSe = function (e) { return e < 0 ? Math.ceil(e) || 0 : Math.floor(e) }, JSe = function (e) { var t = { M: yo, y: sc, w: Lx, d: oc, D: Mm, h: qf, m: il, s: Kf, ms: bk, Q: lZ }; return t[e] || String(e || "").toLowerCase().replace(/s$/, "") }, QSe = function (e) { return e === void 0 }; const e2e = { s: Cj, z: YSe, m: ZSe, a: XSe, p: JSe, u: QSe }; var Qy = "en", fh = {}; fh[Qy] = qSe; var uZ = "$isDayjsObject", _R = function (e) { return e instanceof wk || !!(e && e[uZ]) }, FS = function n(e, t, r) { var i; if (!e) return Qy; if (typeof e == "string") { var a = e.toLowerCase(); fh[a] && (i = a), t && (fh[a] = t, i = a); var o = e.split("-"); if (!i && o.length > 1) return n(o[0]) } else { var s = e.name; fh[s] = e, i = s } return !r && i && (Qy = i), i || !r && Qy }, kn = function (e, t) { if (_R(e)) return e.clone(); var r = typeof t == "object" ? t : {}; return r.date = e, r.args = arguments, new wk(r) }, t2e = function (e, t) { return kn(e, { locale: t.$L, utc: t.$u, x: t.$x, $offset: t.$offset }) }, $n = e2e; $n.l = FS; $n.i = _R; $n.w = t2e; var n2e = function (e) { var t = e.date, r = e.utc; if (t === null) return new Date(NaN); if ($n.u(t)) return new Date; if (t instanceof Date) return new Date(t); if (typeof t == "string" && !/Z$/i.test(t)) { var i = t.match(KSe); if (i) { var a = i[2] - 1 || 0, o = (i[7] || "0").substring(0, 3); return r ? new Date(Date.UTC(i[1], a, i[3] || 1, i[4] || 0, i[5] || 0, i[6] || 0, o)) : new Date(i[1], a, i[3] || 1, i[4] || 0, i[5] || 0, i[6] || 0, o) } } return new Date(t) }, wk = function () { function n(t) { this.$L = FS(t.locale, null, !0), this.parse(t), this.$x = this.$x || t.x || {}, this[uZ] = !0 } var e = n.prototype; return e.parse = function (r) { this.$d = n2e(r), this.init() }, e.init = function () { var r = this.$d; this.$y = r.getFullYear(), this.$M = r.getMonth(), this.$D = r.getDate(), this.$W = r.getDay(), this.$H = r.getHours(), this.$m = r.getMinutes(), this.$s = r.getSeconds(), this.$ms = r.getMilliseconds() }, e.$utils = function () { return $n }, e.isValid = function () { return this.$d.toString() !== X$ }, e.isSame = function (r, i) { var a = kn(r); return this.startOf(i) <= a && a <= this.endOf(i) }, e.isAfter = function (r, i) { return kn(r) < this.startOf(i) }, e.isBefore = function (r, i) { return this.endOf(i) < kn(r) }, e.$g = function (r, i, a) { return $n.u(r) ? this[i] : this.set(a, r) }, e.unix = function () { return Math.floor(this.valueOf() / 1e3) }, e.valueOf = function () { return this.$d.getTime() }, e.startOf = function (r, i) { var a = this, o = $n.u(i) ? !0 : i, s = $n.p(r), l = function (y, b) { var w = $n.w(a.$u ? Date.UTC(a.$y, b, y) : new Date(a.$y, b, y), a); return o ? w : w.endOf(oc) }, c = function (y, b) { var w = [0, 0, 0, 0], v = [23, 59, 59, 999]; return $n.w(a.toDate()[y].apply(a.toDate("s"), (o ? w : v).slice(b)), a) }, u = this.$W, d = this.$M, f = this.$D, h = "set" + (this.$u ? "UTC" : ""); switch (s) { case sc: return o ? l(1, 0) : l(31, 11); case yo: return o ? l(1, d) : l(0, d + 1); case Lx: { var p = this.$locale().weekStart || 0, m = (u < p ? u + 7 : u) - p; return l(o ? f - m : f + (6 - m), d) } case oc: case Mm: return c(h + "Hours", 0); case qf: return c(h + "Minutes", 1); case il: return c(h + "Seconds", 2); case Kf: return c(h + "Milliseconds", 3); default: return this.clone() } }, e.endOf = function (r) { return this.startOf(r, !1) }, e.$set = function (r, i) { var a, o = $n.p(r), s = "set" + (this.$u ? "UTC" : ""), l = (a = {}, a[oc] = s + "Date", a[Mm] = s + "Date", a[yo] = s + "Month", a[sc] = s + "FullYear", a[qf] = s + "Hours", a[il] = s + "Minutes", a[Kf] = s + "Seconds", a[bk] = s + "Milliseconds", a)[o], c = o === oc ? this.$D + (i - this.$W) : i; if (o === yo || o === sc) { var u = this.clone().set(Mm, 1); u.$d[l](c), u.init(), this.$d = u.set(Mm, Math.min(this.$D, u.daysInMonth())).$d } else l && this.$d[l](c); return this.init(), this }, e.set = function (r, i) { return this.clone().$set(r, i) }, e.get = function (r) { return this[$n.p(r)]() }, e.add = function (r, i) { var a = this, o; r = Number(r); var s = $n.p(i), l = function (f) { var h = kn(a); return $n.w(h.date(h.date() + Math.round(f * r)), a) }; if (s === yo) return this.set(yo, this.$M + r); if (s === sc) return this.set(sc, this.$y + r); if (s === oc) return l(1); if (s === Lx) return l(7); var c = (o = {}, o[il] = dh, o[qf] = G0, o[Kf] = Oc, o)[s] || 1, u = this.$d.getTime() + r * c; return $n.w(u, this) }, e.subtract = function (r, i) { return this.add(r * -1, i) }, e.format = function (r) { var i = this, a = this.$locale(); if (!this.isValid()) return a.invalidDate || X$; var o = r || yR, s = $n.z(this), l = this.$H, c = this.$m, u = this.$M, d = a.weekdays, f = a.months, h = a.meridiem, p = function (w, v, S, x) { return w && (w[v] || w(i, o)) || S[v].slice(0, x) }, m = function (w) { return $n.s(l % 12 || 12, w, "0") }, g = h || function (b, w, v) { var S = b < 12 ? "AM" : "PM"; return v ? S.toLowerCase() : S }, y = function (w) { switch (w) { case "YY": return String(i.$y).slice(-2); case "YYYY": return $n.s(i.$y, 4, "0"); case "M": return u + 1; case "MM": return $n.s(u + 1, 2, "0"); case "MMM": return p(a.monthsShort, u, f, 3); case "MMMM": return p(f, u); case "D": return i.$D; case "DD": return $n.s(i.$D, 2, "0"); case "d": return String(i.$W); case "dd": return p(a.weekdaysMin, i.$W, d, 2); case "ddd": return p(a.weekdaysShort, i.$W, d, 3); case "dddd": return d[i.$W]; case "H": return String(l); case "HH": return $n.s(l, 2, "0"); case "h": return m(1); case "hh": return m(2); case "a": return g(l, c, !0); case "A": return g(l, c, !1); case "m": return String(c); case "mm": return $n.s(c, 2, "0"); case "s": return String(i.$s); case "ss": return $n.s(i.$s, 2, "0"); case "SSS": return $n.s(i.$ms, 3, "0"); case "Z": return s }return null }; return o.replace(cZ, function (b, w) { return w || y(b) || s.replace(":", "") }) }, e.utcOffset = function () { return -Math.round(this.$d.getTimezoneOffset() / 15) * 15 }, e.diff = function (r, i, a) { var o = this, s = $n.p(i), l = kn(r), c = (l.utcOffset() - this.utcOffset()) * dh, u = this - l, d = function () { return $n.m(o, l) }, f; switch (s) { case sc: f = d() / 12; break; case yo: f = d(); break; case lZ: f = d() / 3; break; case Lx: f = (u - c) / sZ; break; case oc: f = (u - c) / W0; break; case qf: f = u / G0; break; case il: f = u / dh; break; case Kf: f = u / Oc; break; default: f = u; break }return a ? f : $n.a(f) }, e.daysInMonth = function () { return this.endOf(yo).$D }, e.$locale = function () { return fh[this.$L] }, e.locale = function (r, i) { if (!r) return this.$L; var a = this.clone(), o = FS(r, i, !0); return o && (a.$L = o), a }, e.clone = function () { return $n.w(this.$d, this) }, e.toDate = function () { return new Date(this.valueOf()) }, e.toJSON = function () { return this.isValid() ? this.toISOString() : null }, e.toISOString = function () { return this.$d.toISOString() }, e.toString = function () { return this.$d.toUTCString() }, n }(), dZ = wk.prototype; kn.prototype = dZ;[["$ms", bk], ["$s", Kf], ["$m", il], ["$H", qf], ["$W", oc], ["$M", yo], ["$y", sc], ["$D", Mm]].forEach(function (n) { dZ[n[1]] = function (e) { return this.$g(e, n[0], n[1]) } }); kn.extend = function (n, e) { return n.$i || (n(e, wk, kn), n.$i = !0), kn }; kn.locale = FS; kn.isDayjs = _R; kn.unix = function (n) { return kn(n * 1e3) }; kn.en = fh[Qy]; kn.Ls = fh; kn.p = {}; const r2e = function (n, e, t) { n = n || {}; var r = e.prototype, i = { future: "in %s", past: "%s ago", s: "a few seconds", m: "a minute", mm: "%d minutes", h: "an hour", hh: "%d hours", d: "a day", dd: "%d days", M: "a month", MM: "%d months", y: "a year", yy: "%d years" }; t.en.relativeTime = i, r.fromToBase = function (s, l, c, u, d) { for (var f = c.$locale().relativeTime || i, h = n.thresholds || [{ l: "s", r: 44, d: Kf }, { l: "m", r: 89 }, { l: "mm", r: 44, d: il }, { l: "h", r: 89 }, { l: "hh", r: 21, d: qf }, { l: "d", r: 35 }, { l: "dd", r: 25, d: oc }, { l: "M", r: 45 }, { l: "MM", r: 10, d: yo }, { l: "y", r: 17 }, { l: "yy", d: sc }], p = h.length, m, g, y, b = 0; b < p; b += 1) { var w = h[b]; w.d && (m = u ? t(s).diff(c, w.d, !0) : c.diff(s, w.d, !0)); var v = (n.rounding || Math.round)(Math.abs(m)); if (y = m > 0, v <= w.r || !w.r) { v <= 1 && b > 0 && (w = h[b - 1]); var S = f[w.l]; d && (v = d("" + v)), typeof S == "string" ? g = S.replace("%d", v) : g = S(v, l, w.l, y); break } } if (l) return g; var x = y ? f.future : f.past; return typeof x == "function" ? x(g) : x.replace("%s", g) }; function a(s, l, c, u) { return r.fromToBase(s, l, c, u) } r.to = function (s, l) { return a(s, l, this, !0) }, r.from = function (s, l) { return a(s, l, this) }; var o = function (l) { return l.$u ? t.utc() : t() }; r.toNow = function (s) { return this.to(o(this), s) }, r.fromNow = function (s) { return this.from(o(this), s) } }; var i2e = function (e) { return e.replace(/(\[[^\]]+])|(MMMM|MM|DD|dddd)/g, function (t, r, i) { return r || i.slice(1) }) }, fZ = { LTS: "h:mm:ss A", LT: "h:mm A", L: "MM/DD/YYYY", LL: "MMMM D, YYYY", LLL: "MMMM D, YYYY h:mm A", LLLL: "dddd, MMMM D, YYYY h:mm A" }, a2e = function (e, t) { return e.replace(/(\[[^\]]+])|(LTS?|l{1,4}|L{1,4})/g, function (r, i, a) { var o = a && a.toUpperCase(); return i || t[a] || fZ[a] || i2e(t[o]) }) }; const o2e = function (n, e, t) { var r = e.prototype, i = r.format; t.en.formats = fZ, r.format = function (a) { a === void 0 && (a = yR); var o = this.$locale(), s = o.formats, l = s === void 0 ? {} : s, c = a2e(a, l); return i.call(this, c) } }, s2e = function (n, e, t) { t.updateLocale = function (r, i) { var a = t.Ls, o = a[r]; if (o) { var s = i ? Object.keys(i) : []; return s.forEach(function (l) { o[l] = i[l] }), o } } }, l2e = function (n, e, t) { var r = e.prototype; r.isToday = function () { var i = "YYYY-MM-DD", a = t(); return this.format(i) === a.format(i) } }; var zS = W0 * 365, Aj = zS / 12, c2e = /^(-|\+)?P(?:([-+]?[0-9,.]*)Y)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)W)?(?:([-+]?[0-9,.]*)D)?(?:T(?:([-+]?[0-9,.]*)H)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)S)?)?$/, Rv = { years: zS, months: Aj, days: W0, hours: G0, minutes: dh, seconds: Oc, milliseconds: 1, weeks: sZ }, Rx = function (e) { return e instanceof mZ }, hZ, Ks, _y = function (e, t, r) { return new mZ(e, r, t.$l) }, Nv = function (e) { return Ks.p(e) + "s" }, pZ = function (e) { return e < 0 }, lf = function (e) { return pZ(e) ? Math.ceil(e) : Math.floor(e) }, u2e = function (e) { return Math.abs(e) }, Ip = function (e, t) { return e ? pZ(e) ? { negative: !0, format: "" + u2e(e) + t } : { negative: !1, format: "" + e + t } : { negative: !1, format: "" } }, mZ = function () { function n(t, r, i) { var a = this; if (this.$d = {}, this.$l = i, t === void 0 && (this.$ms = 0, this.parseFromMilliseconds()), r) return _y(t * Rv[Nv(r)], this); if (typeof t == "number") return this.$ms = t, this.parseFromMilliseconds(), this; if (typeof t == "object") return Object.keys(t).forEach(function (c) { a.$d[Nv(c)] = t[c] }), this.calMilliseconds(), this; if (typeof t == "string") { var o = t.match(c2e); if (o) { var s = o.slice(2), l = s.map(function (c) { return c != null ? Number(c) : 0 }); return this.$d.years = l[0], this.$d.months = l[1], this.$d.weeks = l[2], this.$d.days = l[3], this.$d.hours = l[4], this.$d.minutes = l[5], this.$d.seconds = l[6], this.calMilliseconds(), this } } return this } var e = n.prototype; return e.calMilliseconds = function () { var r = this; this.$ms = Object.keys(this.$d).reduce(function (i, a) { return i + (r.$d[a] || 0) * Rv[a] }, 0) }, e.parseFromMilliseconds = function () { var r = this.$ms; this.$d.years = lf(r / zS), r %= zS, this.$d.months = lf(r / Aj), r %= Aj, this.$d.days = lf(r / W0), r %= W0, this.$d.hours = lf(r / G0), r %= G0, this.$d.minutes = lf(r / dh), r %= dh, this.$d.seconds = lf(r / Oc), r %= Oc, this.$d.milliseconds = r }, e.toISOString = function () { var r = Ip(this.$d.years, "Y"), i = Ip(this.$d.months, "M"), a = +this.$d.days || 0; this.$d.weeks && (a += this.$d.weeks * 7); var o = Ip(a, "D"), s = Ip(this.$d.hours, "H"), l = Ip(this.$d.minutes, "M"), c = this.$d.seconds || 0; this.$d.milliseconds && (c += this.$d.milliseconds / 1e3, c = Math.round(c * 1e3) / 1e3); var u = Ip(c, "S"), d = r.negative || i.negative || o.negative || s.negative || l.negative || u.negative, f = s.format || l.format || u.format ? "T" : "", h = d ? "-" : "", p = h + "P" + r.format + i.format + o.format + f + s.format + l.format + u.format; return p === "P" || p === "-P" ? "P0D" : p }, e.toJSON = function () { return this.toISOString() }, e.format = function (r) { var i = r || "YYYY-MM-DDTHH:mm:ss", a = { Y: this.$d.years, YY: Ks.s(this.$d.years, 2, "0"), YYYY: Ks.s(this.$d.years, 4, "0"), M: this.$d.months, MM: Ks.s(this.$d.months, 2, "0"), D: this.$d.days, DD: Ks.s(this.$d.days, 2, "0"), H: this.$d.hours, HH: Ks.s(this.$d.hours, 2, "0"), m: this.$d.minutes, mm: Ks.s(this.$d.minutes, 2, "0"), s: this.$d.seconds, ss: Ks.s(this.$d.seconds, 2, "0"), SSS: Ks.s(this.$d.milliseconds, 3, "0") }; return i.replace(cZ, function (o, s) { return s || String(a[o]) }) }, e.as = function (r) { return this.$ms / Rv[Nv(r)] }, e.get = function (r) { var i = this.$ms, a = Nv(r); return a === "milliseconds" ? i %= 1e3 : a === "weeks" ? i = lf(i / Rv[a]) : i = this.$d[a], i || 0 }, e.add = function (r, i, a) { var o; return i ? o = r * Rv[Nv(i)] : Rx(r) ? o = r.$ms : o = _y(r, this).$ms, _y(this.$ms + o * (a ? -1 : 1), this) }, e.subtract = function (r, i) { return this.add(r, i, !0) }, e.locale = function (r) { var i = this.clone(); return i.$l = r, i }, e.clone = function () { return _y(this.$ms, this) }, e.humanize = function (r) { return hZ().add(this.$ms, "ms").locale(this.$l).fromNow(!r) }, e.valueOf = function () { return this.asMilliseconds() }, e.milliseconds = function () { return this.get("milliseconds") }, e.asMilliseconds = function () { return this.as("milliseconds") }, e.seconds = function () { return this.get("seconds") }, e.asSeconds = function () { return this.as("seconds") }, e.minutes = function () { return this.get("minutes") }, e.asMinutes = function () { return this.as("minutes") }, e.hours = function () { return this.get("hours") }, e.asHours = function () { return this.as("hours") }, e.days = function () { return this.get("days") }, e.asDays = function () { return this.as("days") }, e.weeks = function () { return this.get("weeks") }, e.asWeeks = function () { return this.as("weeks") }, e.months = function () { return this.get("months") }, e.asMonths = function () { return this.as("months") }, e.years = function () { return this.get("years") }, e.asYears = function () { return this.as("years") }, n }(), J$ = function (e, t, r) { return e.add(t.years() * r, "y").add(t.months() * r, "M").add(t.days() * r, "d").add(t.hours() * r, "h").add(t.minutes() * r, "m").add(t.seconds() * r, "s").add(t.milliseconds() * r, "ms") }; const d2e = function (n, e, t) { hZ = t, Ks = t().$utils(), t.duration = function (a, o) { var s = t.locale(); return _y(a, { $l: s }, o) }, t.isDuration = Rx; var r = e.prototype.add, i = e.prototype.subtract; e.prototype.add = function (a, o) { return Rx(a) ? J$(this, a, 1) : r.bind(this)(a, o) }, e.prototype.subtract = function (a, o) { return Rx(a) ? J$(this, a, -1) : i.bind(this)(a, o) } }; var f2e = /[+-]\d\d(?::?\d\d)?/g, h2e = /([+-]|\d\d)/g; function p2e(n) { n === void 0 && (n = ""); var e = n.match(f2e); if (!e) return null; var t = ("" + e[0]).match(h2e) || ["-", 0, 0], r = t[0], i = t[1], a = t[2], o = +i * 60 + +a; return o === 0 ? 0 : r === "+" ? o : -o } const m2e = function (n, e, t) { var r = e.prototype; t.utc = function (d) { var f = { date: d, utc: !0, args: arguments }; return new e(f) }, r.utc = function (d) { var f = t(this.toDate(), { locale: this.$L, utc: !0 }); return d ? f.add(this.utcOffset(), il) : f }, r.local = function () { return t(this.toDate(), { locale: this.$L, utc: !1 }) }; var i = r.parse; r.parse = function (d) { d.utc && (this.$u = !0), this.$utils().u(d.$offset) || (this.$offset = d.$offset), i.call(this, d) }; var a = r.init; r.init = function () { if (this.$u) { var d = this.$d; this.$y = d.getUTCFullYear(), this.$M = d.getUTCMonth(), this.$D = d.getUTCDate(), this.$W = d.getUTCDay(), this.$H = d.getUTCHours(), this.$m = d.getUTCMinutes(), this.$s = d.getUTCSeconds(), this.$ms = d.getUTCMilliseconds() } else a.call(this) }; var o = r.utcOffset; r.utcOffset = function (d, f) { var h = this.$utils(), p = h.u; if (p(d)) return this.$u ? 0 : p(this.$offset) ? o.call(this) : this.$offset; if (typeof d == "string" && (d = p2e(d), d === null)) return this; var m = Math.abs(d) <= 16 ? d * 60 : d, g = this; if (f) return g.$offset = m, g.$u = d === 0, g; if (d !== 0) { var y = this.$u ? this.toDate().getTimezoneOffset() : -1 * this.utcOffset(); g = this.local().add(m + y, il), g.$offset = m, g.$x.$localOffset = y } else g = this.utc(); return g }; var s = r.format, l = "YYYY-MM-DDTHH:mm:ss[Z]"; r.format = function (d) { var f = d || (this.$u ? l : ""); return s.call(this, f) }, r.valueOf = function () { var d = this.$utils().u(this.$offset) ? 0 : this.$offset + (this.$x.$localOffset || this.$d.getTimezoneOffset()); return this.$d.valueOf() - d * dh }, r.isUTC = function () { return !!this.$u }, r.toISOString = function () { return this.toDate().toISOString() }, r.toString = function () { return this.toDate().toUTCString() }; var c = r.toDate; r.toDate = function (d) { return d === "s" && this.$offset ? t(this.format("YYYY-MM-DD HH:mm:ss:SSS")).toDate() : c.call(this) }; var u = r.diff; r.diff = function (d, f, h) { if (d && this.$u === d.$u) return u.call(this, d, f, h); var p = this.local(), m = t(d).local(); return u.call(p, m, f, h) } }; var g2e = { year: 0, month: 1, day: 2, hour: 3, minute: 4, second: 5 }, Q$ = {}, v2e = function (e, t) { t === void 0 && (t = {}); var r = t.timeZoneName || "short", i = e + "|" + r, a = Q$[i]; return a || (a = new Intl.DateTimeFormat("en-US", { hour12: !1, timeZone: e, year: "numeric", month: "2-digit", day: "2-digit", hour: "2-digit", minute: "2-digit", second: "2-digit", timeZoneName: r }), Q$[i] = a), a }; const y2e = function (n, e, t) { var r, i = function (u, d, f) { f === void 0 && (f = {}); var h = new Date(u), p = v2e(d, f); return p.formatToParts(h) }, a = function (u, d) { for (var f = i(u, d), h = [], p = 0; p < f.length; p += 1) { var m = f[p], g = m.type, y = m.value, b = g2e[g]; b >= 0 && (h[b] = parseInt(y, 10)) } var w = h[3], v = w === 24 ? 0 : w, S = h[0] + "-" + h[1] + "-" + h[2] + " " + v + ":" + h[4] + ":" + h[5] + ":000", x = t.utc(S).valueOf(), k = +u, A = k % 1e3; return k -= A, (x - k) / 6e4 }, o = function (u, d, f) { var h = u - d * 60 * 1e3, p = a(h, f); if (d === p) return [h, d]; h -= (p - d) * 60 * 1e3; var m = a(h, f); return p === m ? [h, p] : [u - Math.min(p, m) * 60 * 1e3, Math.max(p, m)] }, s = e.prototype; s.tz = function (c, u) { c === void 0 && (c = r); var d = this.utcOffset(), f = this.toDate(), h = f.toLocaleString("en-US", { timeZone: c }), p = Math.round((f - new Date(h)) / 1e3 / 60), m = -Math.round(f.getTimezoneOffset() / 15) * 15 - p, g = !Number(m), y; if (g) y = this.utcOffset(0, u); else if (y = t(h, { locale: this.$L }).$set(bk, this.$ms).utcOffset(m, !0), u) { var b = y.utcOffset(); y = y.add(d - b, il) } return y.$x.$timezone = c, y }, s.offsetName = function (c) { var u = this.$x.$timezone || t.tz.guess(), d = i(this.valueOf(), u, { timeZoneName: c }).find(function (f) { return f.type.toLowerCase() === "timezonename" }); return d && d.value }; var l = s.startOf; s.startOf = function (c, u) { if (!this.$x || !this.$x.$timezone) return l.call(this, c, u); var d = t(this.format("YYYY-MM-DD HH:mm:ss:SSS"), { locale: this.$L }), f = l.call(d, c, u); return f.tz(this.$x.$timezone, !0) }, t.tz = function (c, u, d) { var f = d && u, h = d || u || r, p = a(+t(), h); if (typeof c != "string") return t(c).tz(h); var m = t.utc(c, f).valueOf(), g = o(m, p, h), y = g[0], b = g[1], w = t(y).utcOffset(b); return w.$x.$timezone = h, w }, t.tz.guess = function () { return Intl.DateTimeFormat().resolvedOptions().timeZone }, t.tz.setDefault = function (c) { r = c } }, _2e = function (n, e) { var t = e.prototype, r = t.format; t.format = function (i) { var a = this, o = this.$locale(); if (!this.isValid()) return r.bind(this)(i); var s = this.$utils(), l = i || yR, c = l.replace(/\[([^\]]+)]|Q|wo|ww|w|WW|W|zzz|z|gggg|GGGG|Do|X|x|k{1,2}|S/g, function (u) { switch (u) { case "Q": return Math.ceil((a.$M + 1) / 3); case "Do": return o.ordinal(a.$D); case "gggg": return a.weekYear(); case "GGGG": return a.isoWeekYear(); case "wo": return o.ordinal(a.week(), "W"); case "w": case "ww": return s.s(a.week(), u === "w" ? 1 : 2, "0"); case "W": case "WW": return s.s(a.isoWeek(), u === "W" ? 1 : 2, "0"); case "k": case "kk": return s.s(String(a.$H === 0 ? 24 : a.$H), u === "k" ? 1 : 2, "0"); case "X": return Math.floor(a.$d.getTime() / 1e3); case "x": return a.$d.getTime(); case "z": return "[" + a.offsetName() + "]"; case "zzz": return "[" + a.offsetName("long") + "]"; default: return u } }); return r.bind(this)(c) } }; let gZ = {}; function vZ(n, e) { gZ[n] = e } function Xi(n) { return gZ[n] || null } kn.extend(s2e); kn.extend(r2e); kn.extend(o2e); kn.extend(l2e); kn.extend(d2e); kn.extend(m2e); kn.extend(y2e); kn.extend(_2e); function yZ() { return Intl.DateTimeFormat().resolvedOptions().timeZone } function Udt(n) { let e = Xi("systemTimezone"), t = Xi("localTimezone") || yZ(); return e ? n ? kn.tz(n, e).tz(t) : kn().tz(t) : kn(n) } function Gdt(n) { let e = Xi("systemTimezone"), t = Xi("localTimezone") || yZ(); return e ? n ? kn.tz(n, t).tz(e) : kn().tz(e) : kn(n) } let Wdt = kn; const b2e = ["data-dialog"], w2e = { class: "bg-surface-modal px-4 pb-6 pt-5 sm:px-6" }, x2e = { class: "flex" }, S2e = { class: "w-full flex-1" }, T2e = { class: "mb-6 flex items-center justify-between" }, k2e = { class: "flex items-center space-x-2" }, C2e = { class: "text-2xl font-semibold leading-6 text-ink-gray-9" }, A2e = { key: 0, class: "text-p-base text-ink-gray-7" }, E2e = { key: 0, class: "px-4 pb-7 pt-4 sm:px-6" }, M2e = { class: "space-y-2" }, _Z = We({ __name: "Dialog", props: { modelValue: { type: Boolean }, options: { default: () => ({}) }, disableOutsideClickToClose: { type: Boolean, default: !1 } }, emits: ["update:modelValue", "close", "after-leave"], setup(n, { emit: e }) { const t = n, r = e, i = ne(() => { let d = t.options.actions; return d != null && d.length ? d.map(f => { let h = vr({ ...f, loading: !1, onClick: f.onClick ? async () => { h.loading = !0; try { if (f.onClick) { let p = function () { console.warn("Value passed to onClick is a context object. Please use context.close() instead of context() to close the dialog."), o() }; p.close = o, await f.onClick(p) } } finally { h.loading = !1 } } : o }); return h }) : [] }), a = ne({ get() { return t.modelValue }, set(d) { r("update:modelValue", d), d || r("close") } }); function o() { a.value = !1 } const s = ne(() => { var f; if (!((f = t.options) != null && f.icon)) return null; let d = t.options.icon; return typeof d == "string" && (d = { name: d }), d }), l = ne(() => { var f; const d = ((f = t.options) == null ? void 0 : f.position) || "center"; return { center: "justify-center", top: "pt-[20vh]" }[d] }), c = ne(() => { var f; const d = (f = s.value) == null ? void 0 : f.appearance; return d ? { warning: "bg-surface-amber-2", info: "bg-surface-blue-2", danger: "bg-surface-red-2", success: "bg-surface-green-2" }[d] : "bg-surface-gray-2" }), u = ne(() => { var f; const d = (f = s.value) == null ? void 0 : f.appearance; return d ? { warning: "text-ink-amber-3", info: "text-ink-blue-3", danger: "text-ink-red-4", success: "text-ink-green-3" }[d] : "text-ink-gray-5" }); return (d, f) => (Z(), Ye(X(rY), { as: "template", show: a.value, onAfterLeave: f[1] || (f[1] = h => d.$emit("after-leave")) }, { default: Ue(() => [$e(X(V0e), { as: "div", class: "fixed inset-0 z-10 overflow-y-auto", onClose: f[0] || (f[0] = h => !d.disableOutsideClickToClose && o()) }, { default: Ue(() => [re("div", { class: Tt(["flex min-h-screen flex-col items-center px-4 py-4 text-center", l.value]) }, [$e(X(lj), { as: "template", enter: "ease-out duration-150", "enter-from": "opacity-0", "enter-to": "opacity-100", leave: "ease-in duration-150", "leave-from": "opacity-100", "leave-to": "opacity-0" }, { default: Ue(() => [re("div", { class: "fixed inset-0 bg-black-overlay-200 transition-opacity dark:backdrop-filter dark:backdrop-blur-[1px]", "data-dialog": d.options.title }, null, 8, b2e)]), _: 1 }), $e(X(lj), { as: "template", enter: "ease-out duration-150", "enter-from": "opacity-50 translate-y-2 scale-95", "enter-to": "opacity-100 translate-y-0 scale-100", leave: "ease-in duration-150", "leave-from": "opacity-100 translate-y-0 scale-100", "leave-to": "opacity-50 translate-y-4 translate-y-4 scale-95" }, { default: Ue(() => [$e(X(H0e), { class: Tt(["my-8 inline-block w-full transform overflow-hidden rounded-xl bg-surface-modal text-left align-middle shadow-xl transition-all", { "max-w-7xl": d.options.size === "7xl", "max-w-6xl": d.options.size === "6xl", "max-w-5xl": d.options.size === "5xl", "max-w-4xl": d.options.size === "4xl", "max-w-3xl": d.options.size === "3xl", "max-w-2xl": d.options.size === "2xl", "max-w-xl": d.options.size === "xl", "max-w-lg": d.options.size === "lg" || !d.options.size, "max-w-md": d.options.size === "md", "max-w-sm": d.options.size === "sm", "max-w-xs": d.options.size === "xs" }]) }, { default: Ue(() => [ut(d.$slots, "body", {}, () => [ut(d.$slots, "body-main", {}, () => [re("div", w2e, [re("div", x2e, [re("div", S2e, [ut(d.$slots, "body-header", {}, () => [re("div", T2e, [re("div", k2e, [s.value ? (Z(), ye("div", { key: 0, class: Tt(["flex h-7 w-7 flex-shrink-0 items-center justify-center rounded-full", c.value]) }, [$e(vc, { name: s.value.name, class: Tt(["h-4 w-4", u.value]), "aria-hidden": "true" }, null, 8, ["name", "class"])], 2)) : mt("", !0), $e(X(U0e), { as: "header" }, { default: Ue(() => [ut(d.$slots, "body-title", {}, () => [re("h3", C2e, Ht(d.options.title || "Untitled"), 1)])]), _: 3 })]), $e(X(ed), { variant: "ghost", onClick: o }, { icon: Ue(() => f[2] || (f[2] = [re("svg", { width: "16", height: "16", viewBox: "0 0 16 16", fill: "none", xmlns: "http://www.w3.org/2000/svg", class: "text-ink-gray-9" }, [re("path", { "fill-rule": "evenodd", "clip-rule": "evenodd", d: "M12.8567 3.85355C13.052 3.65829 13.052 3.34171 12.8567 3.14645C12.6615 2.95118 12.3449 2.95118 12.1496 3.14645L8.00201 7.29405L3.85441 3.14645C3.65914 2.95118 3.34256 2.95118 3.1473 3.14645C2.95204 3.34171 2.95204 3.65829 3.1473 3.85355L7.29491 8.00116L3.14645 12.1496C2.95118 12.3449 2.95118 12.6615 3.14645 12.8567C3.34171 13.052 3.65829 13.052 3.85355 12.8567L8.00201 8.70827L12.1505 12.8567C12.3457 13.052 12.6623 13.052 12.8576 12.8567C13.0528 12.6615 13.0528 12.3449 12.8576 12.1496L8.70912 8.00116L12.8567 3.85355Z", fill: "currentColor" })], -1)])), _: 1 })])]), ut(d.$slots, "body-content", {}, () => [d.options.message ? (Z(), ye("p", A2e, Ht(d.options.message), 1)) : mt("", !0)])])])])]), i.value.length || d.$slots.actions ? (Z(), ye("div", E2e, [ut(d.$slots, "actions", Eo(Mo({ close: o })), () => [re("div", M2e, [(Z(!0), ye(Qt, null, Wa(i.value, h => (Z(), Ye(X(ed), Sn({ class: "w-full", key: h.label, disabled: h.disabled }, { ref_for: !0 }, h), { default: Ue(() => [Fo(Ht(h.label), 1)]), _: 2 }, 1040, ["disabled"]))), 128))])])])) : mt("", !0)])]), _: 3 }, 8, ["class"])]), _: 3 })], 2)]), _: 3 })]), _: 3 }, 8, ["show"])) } }); he([]); const O2e = ["innerHTML"], bR = We({ __name: "ErrorMessage", props: { message: {} }, setup(n) { const e = n, t = ne(() => e.message ? e.message instanceof Error ? e.message.messages || e.message.message : e.message : ""); return (r, i) => r.message ? (Z(), ye("div", { key: 0, class: "whitespace-pre-line text-sm text-ink-red-4", role: "alert", innerHTML: t.value }, null, 8, O2e)) : mt("", !0) } }), D2e = { class: "relative flex items-center" }, j2e = ["disabled", "id", "value"], P2e = ["value", "disabled", "selected"], I2e = We({ inheritAttrs: !1, __name: "Select", props: { size: { default: "sm" }, variant: { default: "subtle" }, placeholder: {}, disabled: { type: Boolean }, id: {}, modelValue: {}, options: {} }, emits: ["update:modelValue"], setup(n, { emit: e }) { const t = n, r = e; ek(); const i = ab(); function a(f) { r("update:modelValue", f.target.value) } const o = ne(() => { var f; return ((f = t.options) == null ? void 0 : f.map(h => typeof h == "string" ? { label: h, value: h } : h).filter(Boolean)) || [] }), s = ne(() => t.disabled ? "text-ink-gray-4" : "text-ink-gray-8"), l = ne(() => ({ sm: "text-base", md: "text-base", lg: "text-lg", xl: "text-xl" })[t.size]), c = ne(() => ({ sm: "pl-2 pr-5", md: "pl-2.5 pr-5.5", lg: "pl-3 pr-6", xl: "pl-3 pr-6" })[t.size]), u = ne(() => { let f = { sm: "rounded h-7", md: "rounded h-8", lg: "rounded-md h-10", xl: "rounded-md h-10" }[t.size], h = t.disabled ? "disabled" : t.variant, p = { subtle: "border border-[--surface-gray-2] bg-surface-gray-2 hover:border-outline-gray-modals hover:bg-surface-gray-3 focus:border-outline-gray-4 focus:ring-0 focus-visible:ring-2 focus-visible:ring-outline-gray-3", outline: "border border-outline-gray-2 bg-surface-white hover:border-outline-gray-3 focus:border-outline-gray-4 focus:ring-0 focus-visible:ring-2 focus-visible:ring-outline-gray-3", ghost: "bg-transparent border-transparent hover:bg-surface-gray-3 focus:bg-surface-gray-3 focus:border-outline-gray-4 focus:ring-0 focus-visible:ring-2 focus-visible:ring-outline-gray-3", disabled: ["border", t.variant !== "ghost" ? "bg-surface-gray-1" : "", t.variant === "outline" ? "border-outline-gray-2" : "border-transparent"] }[h]; return [f, l.value, c.value, p, s.value, "transition-colors w-full py-0 truncate"] }); let d = ne(() => ({ sm: "pl-2", md: "pl-2.5", lg: "pl-3", xl: "pl-3" })[t.size]); return (f, h) => (Z(), ye("div", D2e, [f.$slots.prefix ? (Z(), ye("div", { key: 0, class: Tt(["absolute inset-y-0 left-0 flex items-center", s.value, X(d)]) }, [ut(f.$slots, "prefix")], 2)) : mt("", !0), f.placeholder ? Dh((Z(), ye("div", { key: 1, class: Tt(["pointer-events-none absolute text-ink-gray-4 truncate w-full", [l.value, c.value]]) }, Ht(f.placeholder), 3)), [[ag, !f.modelValue]]) : mt("", !0), re("select", Sn({ class: u.value, disabled: f.disabled, id: f.id, value: f.modelValue, onChange: a }, X(i)), [(Z(!0), ye(Qt, null, Wa(o.value, p => (Z(), ye("option", { key: p.value, value: p.value, disabled: p.disabled || !1, selected: f.modelValue === p.value }, Ht(p.label), 9, P2e))), 128))], 16, j2e)])) } }), L2e = { class: "space-y-1.5" }, R2e = ["for"], N2e = ["placeholder", "disabled", "id", "value", "rows"], B2e = We({ __name: "Textarea", props: { size: { default: "sm" }, variant: { default: "subtle" }, placeholder: {}, disabled: { type: Boolean }, id: {}, modelValue: {}, debounce: {}, rows: { default: 3 }, label: {} }, emits: ["update:modelValue"], setup(n, { expose: e, emit: t }) { const r = n, i = t, a = ab(), o = he(null), s = ne(() => { let d = { sm: "text-base rounded", md: "text-base rounded", lg: "text-lg rounded-md", xl: "text-xl rounded-md" }[r.size], f = { sm: ["py-1.5 px-2"], md: ["py-1.5 px-2.5"], lg: ["py-1.5 px-3"], xl: ["py-1.5 px-3"] }[r.size], h = r.disabled ? "disabled" : r.variant, p = { subtle: "border border-[--surface-gray-2] bg-surface-gray-2 placeholder-ink-gray-4 hover:border-outline-gray-modals hover:bg-surface-gray-3 focus:bg-surface-white focus:border-outline-gray-4 focus:shadow-sm focus:ring-0 focus-visible:ring-2 focus-visible:ring-outline-gray-3", outline: "border border-outline-gray-2 bg-surface-white placeholder-ink-gray-4 hover:border-outline-gray-3 hover:shadow-sm focus:bg-surface-white focus:border-outline-gray-4 focus:shadow-sm focus:ring-0 focus-visible:ring-2 focus-visible:ring-outline-gray-3", disabled: ["border bg-surface-gray-1 placeholder-ink-gray-3", r.variant === "outline" ? "border-outline-gray-2" : "border-transparent"] }[h]; return [d, f, p, r.disabled ? "text-ink-gray-5" : "text-ink-gray-8", "transition-colors w-full block"] }), l = ne(() => [{ sm: "text-xs", md: "text-base", lg: "text-lg", xl: "text-xl" }[r.size], "text-ink-gray-5"]); let c = d => { i("update:modelValue", d) }; r.debounce && (c = _k(c, r.debounce)); let u = d => { c(d.target.value) }; return e({ el: o }), (d, f) => (Z(), ye("div", L2e, [d.label ? (Z(), ye("label", { key: 0, class: Tt(["block", l.value]), for: d.id }, Ht(d.label), 11, R2e)) : mt("", !0), re("textarea", Sn({ ref_key: "textareaRef", ref: o, placeholder: d.placeholder, class: s.value, disabled: d.disabled, id: d.id, value: d.modelValue, rows: d.rows, onInput: f[0] || (f[0] = (...h) => X(u) && X(u)(...h)), onChange: f[1] || (f[1] = (...h) => X(u) && X(u)(...h)) }, X(a)), null, 16, N2e)])) } }), $2e = ["for"], F2e = We({ __name: "FormLabel", props: { label: {}, size: { default: "sm" }, id: {}, required: { type: Boolean } }, setup(n) { const e = n, t = ne(() => [{ sm: "text-xs", md: "text-base" }[e.size], "text-ink-gray-5"]); return (r, i) => (Z(), ye("label", { class: Tt(["block", t.value]), for: r.id }, [Fo(Ht(r.label) + " ", 1), r.required ? (Z(), ye(Qt, { key: 0 }, [i[0] || (i[0] = re("span", { class: "text-ink-red-3 select-none", "aria-hidden": "true" }, "*", -1)), i[1] || (i[1] = re("span", { class: "sr-only" }, "(required)", -1))], 64)) : mt("", !0)], 10, $2e)) } }), z2e = { inheritAttrs: !1 }, V2e = We({ ...z2e, __name: "FormControl", props: { label: {}, description: {}, type: { default: "text" }, size: { default: "sm" }, variant: { default: "subtle" }, required: { type: Boolean } }, setup(n) { const e = rZ(), t = n, r = ab(), i = ne(() => { let o = {}; for (let s in r) s !== "class" && s !== "style" && (o[s] = r[s]); return o }), a = ne(() => [{ sm: "text-xs", md: "text-base" }[t.size], "text-ink-gray-5"]); return (o, s) => o.type != "checkbox" ? (Z(), ye("div", { key: 0, class: Tt(["space-y-1.5", X(r).class]), style: aa(X(r).style) }, [o.label ? (Z(), Ye(F2e, { key: 0, label: o.label, size: o.size, id: X(e), required: o.required }, null, 8, ["label", "size", "id", "required"])) : mt("", !0), o.type === "select" ? (Z(), Ye(X(I2e), Sn({ key: 1, id: X(e) }, { ...i.value, size: o.size, variant: o.variant }), nE({ _: 2 }, [o.$slots.prefix ? { name: "prefix", fn: Ue(() => [ut(o.$slots, "prefix")]), key: "0" } : void 0]), 1040, ["id"])) : o.type === "autocomplete" ? (Z(), Ye(X(D1e), Eo(Sn({ key: 2 }, { ...i.value })), nE({ _: 2 }, [o.$slots.prefix ? { name: "prefix", fn: Ue(() => [ut(o.$slots, "prefix")]), key: "0" } : void 0, o.$slots["item-prefix"] ? { name: "item-prefix", fn: Ue(l => [ut(o.$slots, "item-prefix", Eo(Mo(l)))]), key: "1" } : void 0]), 1040)) : o.type === "textarea" ? (Z(), Ye(X(B2e), Sn({ key: 3, id: X(e) }, { ...i.value, size: o.size, variant: o.variant }), null, 16, ["id"])) : (Z(), Ye(X(vR), Sn({ key: 4, id: X(e) }, { ...i.value, type: o.type, size: o.size, variant: o.variant, required: o.required }), nE({ _: 2 }, [o.$slots.prefix ? { name: "prefix", fn: Ue(() => [ut(o.$slots, "prefix")]), key: "0" } : void 0, o.$slots.suffix ? { name: "suffix", fn: Ue(() => [ut(o.$slots, "suffix")]), key: "1" } : void 0]), 1040, ["id"])), ut(o.$slots, "description", {}, () => [o.description ? (Z(), ye("p", { key: 0, class: Tt(a.value) }, Ht(o.description), 3)) : mt("", !0)])], 6)) : (Z(), Ye(X(USe), Sn({ key: 1, id: X(e) }, { ...i.value, label: o.label, size: o.size, class: X(r).class }), null, 16, ["id"])) } }); const H2e = { name: "Input", inheritAttrs: !1, expose: ["getInputValue"], components: { FeatherIcon: vc }, props: { label: { type: String }, type: { type: String, default: "text", validator(n) { let e = ["text", "number", "checkbox", "textarea", "select", "email", "password", "date"].includes(n); return e || console.warn(`Invalid value "${n}" for "type" prop for Input`), e } }, modelValue: { type: [String, Number, Boolean, Object, Array] }, inputClass: { type: [String, Array, Object] }, debounce: { type: Number }, options: { type: Array }, disabled: { type: Boolean }, rows: { type: Number, default: 3 }, placeholder: { type: String }, iconLeft: { type: String } }, emits: ["input", "change", "update:modelValue"], methods: { focus() { this.$refs.input.focus() }, blur() { this.$refs.input.blur() }, getInputValue(n) { let e = n ? n.target : this.$refs.input, t = e.value; return this.type == "checkbox" && (t = e.checked), t } }, computed: { passedInputValue() { return "value" in this.$attrs ? this.$attrs.value : this.modelValue || null }, inputAttributes() { let n = {}, e = t => { this.$emit("input", this.getInputValue(t)) }; return this.debounce && (e = _k(e, this.debounce)), this.type == "checkbox" && (n.checked = this.passedInputValue), Object.assign(n, this.$attrs, { onInput: e, onChange: t => { this.$emit("change", this.getInputValue(t)), this.$emit("update:modelValue", this.getInputValue(t)) } }) }, selectOptions() { return this.options.map(n => typeof n == "string" ? { label: n, value: n } : n).filter(Boolean) }, isNormalInput() { return ["text", "number", "checkbox", "email", "password", "date"].includes(this.type) } } }, U2e = { key: 0, class: "mb-2 block text-sm leading-4 text-gray-700" }, G2e = ["type", "disabled", "placeholder", "value"], W2e = ["placeholder", "value", "disabled", "rows"], K2e = ["disabled"], q2e = ["value", "disabled", "selected"], Y2e = { key: 1, class: "ml-2 inline-block text-base leading-4" }; function Z2e(n, e, t, r, i, a) { const o = Cc("FeatherIcon"); return Z(), ye("label", { class: Tt([t.type == "checkbox" ? "flex" : "block", n.$attrs.class]), style: aa(n.$attrs.style) }, [t.label && t.type != "checkbox" ? (Z(), ye("span", U2e, Ht(t.label), 1)) : mt("", !0), re("div", { class: Tt(["relative flex", { "items-center": a.isNormalInput || t.type == "select" }]) }, [t.iconLeft && t.type != "checkbox" ? (Z(), Ye(o, { key: 0, name: t.iconLeft, class: Tt(["absolute mx-2 h-4 w-4 text-gray-600", { "mt-2": t.type == "textarea" }]) }, null, 8, ["name", "class"])) : mt("", !0), a.isNormalInput ? (Z(), ye("input", Sn({ key: 1 }, a.inputAttributes, { class: ["border-gray-400 placeholder-gray-500", [{ "form-input block w-full": t.type != "checkbox", "form-checkbox": t.type == "checkbox", "pl-8": t.iconLeft && t.type != "checkbox" }, t.inputClass]], ref: "input", type: t.type || "text", disabled: t.disabled, placeholder: t.placeholder, value: a.passedInputValue }), null, 16, G2e)) : mt("", !0), t.type === "textarea" ? (Z(), ye("textarea", Sn({ key: 2 }, a.inputAttributes, { placeholder: t.placeholder, class: ["placeholder-gray-500", ["form-textarea block w-full resize-none", t.inputClass, { "pl-8": t.iconLeft }]], ref: "input", value: a.passedInputValue, disabled: t.disabled, rows: t.rows }), null, 16, W2e)) : mt("", !0), t.type === "select" ? (Z(), ye("select", Sn({ key: 3 }, a.inputAttributes, { class: ["form-select block w-full", { "pl-8": t.iconLeft }], ref: "input", disabled: t.disabled }), [(Z(!0), ye(Qt, null, Wa(a.selectOptions, s => (Z(), ye("option", { key: s.value, value: s.value, disabled: s.disabled || !1, selected: a.passedInputValue === s.value }, Ht(s.label), 9, q2e))), 128))], 16, K2e)) : mt("", !0)], 2), t.label && t.type == "checkbox" ? (Z(), ye("span", Y2e, Ht(t.label), 1)) : mt("", !0)], 6) } const X2e = yn(H2e, [["render", Z2e]]); function ai(n) { this.content = n } ai.prototype = { constructor: ai, find: function (n) { for (var e = 0; e < this.content.length; e += 2)if (this.content[e] === n) return e; return -1 }, get: function (n) { var e = this.find(n); return e == -1 ? void 0 : this.content[e + 1] }, update: function (n, e, t) { var r = t && t != n ? this.remove(t) : this, i = r.find(n), a = r.content.slice(); return i == -1 ? a.push(t || n, e) : (a[i + 1] = e, t && (a[i] = t)), new ai(a) }, remove: function (n) { var e = this.find(n); if (e == -1) return this; var t = this.content.slice(); return t.splice(e, 2), new ai(t) }, addToStart: function (n, e) { return new ai([n, e].concat(this.remove(n).content)) }, addToEnd: function (n, e) { var t = this.remove(n).content.slice(); return t.push(n, e), new ai(t) }, addBefore: function (n, e, t) { var r = this.remove(e), i = r.content.slice(), a = r.find(n); return i.splice(a == -1 ? i.length : a, 0, e, t), new ai(i) }, forEach: function (n) { for (var e = 0; e < this.content.length; e += 2)n(this.content[e], this.content[e + 1]) }, prepend: function (n) { return n = ai.from(n), n.size ? new ai(n.content.concat(this.subtract(n).content)) : this }, append: function (n) { return n = ai.from(n), n.size ? new ai(this.subtract(n).content.concat(n.content)) : this }, subtract: function (n) { var e = this; n = ai.from(n); for (var t = 0; t < n.content.length; t += 2)e = e.remove(n.content[t]); return e }, toObject: function () { var n = {}; return this.forEach(function (e, t) { n[e] = t }), n }, get size() { return this.content.length >> 1 } }; ai.from = function (n) { if (n instanceof ai) return n; var e = []; if (n) for (var t in n) e.push(t, n[t]); return new ai(e) }; function bZ(n, e, t) { for (let r = 0; ; r++) { if (r == n.childCount || r == e.childCount) return n.childCount == e.childCount ? null : t; let i = n.child(r), a = e.child(r); if (i == a) { t += i.nodeSize; continue } if (!i.sameMarkup(a)) return t; if (i.isText && i.text != a.text) { for (let o = 0; i.text[o] == a.text[o]; o++)t++; return t } if (i.content.size || a.content.size) { let o = bZ(i.content, a.content, t + 1); if (o != null) return o } t += i.nodeSize } } function wZ(n, e, t, r) { for (let i = n.childCount, a = e.childCount; ;) { if (i == 0 || a == 0) return i == a ? null : { a: t, b: r }; let o = n.child(--i), s = e.child(--a), l = o.nodeSize; if (o == s) { t -= l, r -= l; continue } if (!o.sameMarkup(s)) return { a: t, b: r }; if (o.isText && o.text != s.text) { let c = 0, u = Math.min(o.text.length, s.text.length); for (; c < u && o.text[o.text.length - c - 1] == s.text[s.text.length - c - 1];)c++, t--, r--; return { a: t, b: r } } if (o.content.size || s.content.size) { let c = wZ(o.content, s.content, t - 1, r - 1); if (c) return c } t -= l, r -= l } } let Be = class Ui { constructor(e, t) { if (this.content = e, this.size = t || 0, t == null) for (let r = 0; r < e.length; r++)this.size += e[r].nodeSize } nodesBetween(e, t, r, i = 0, a) { for (let o = 0, s = 0; s < t; o++) { let l = this.content[o], c = s + l.nodeSize; if (c > e && r(l, i + s, a || null, o) !== !1 && l.content.size) { let u = s + 1; l.nodesBetween(Math.max(0, e - u), Math.min(l.content.size, t - u), r, i + u) } s = c } } descendants(e) { this.nodesBetween(0, this.size, e) } textBetween(e, t, r, i) { let a = "", o = !0; return this.nodesBetween(e, t, (s, l) => { let c = s.isText ? s.text.slice(Math.max(e, l) - l, t - l) : s.isLeaf ? i ? typeof i == "function" ? i(s) : i : s.type.spec.leafText ? s.type.spec.leafText(s) : "" : ""; s.isBlock && (s.isLeaf && c || s.isTextblock) && r && (o ? o = !1 : a += r), a += c }, 0), a } append(e) { if (!e.size) return this; if (!this.size) return e; let t = this.lastChild, r = e.firstChild, i = this.content.slice(), a = 0; for (t.isText && t.sameMarkup(r) && (i[i.length - 1] = t.withText(t.text + r.text), a = 1); a < e.content.length; a++)i.push(e.content[a]); return new Ui(i, this.size + e.size) } cut(e, t = this.size) { if (e == 0 && t == this.size) return this; let r = [], i = 0; if (t > e) for (let a = 0, o = 0; o < t; a++) { let s = this.content[a], l = o + s.nodeSize; l > e && ((o < e || l > t) && (s.isText ? s = s.cut(Math.max(0, e - o), Math.min(s.text.length, t - o)) : s = s.cut(Math.max(0, e - o - 1), Math.min(s.content.size, t - o - 1))), r.push(s), i += s.nodeSize), o = l } return new Ui(r, i) } cutByIndex(e, t) { return e == t ? Ui.empty : e == 0 && t == this.content.length ? this : new Ui(this.content.slice(e, t)) } replaceChild(e, t) { let r = this.content[e]; if (r == t) return this; let i = this.content.slice(), a = this.size + t.nodeSize - r.nodeSize; return i[e] = t, new Ui(i, a) } addToStart(e) { return new Ui([e].concat(this.content), this.size + e.nodeSize) } addToEnd(e) { return new Ui(this.content.concat(e), this.size + e.nodeSize) } eq(e) { if (this.content.length != e.content.length) return !1; for (let t = 0; t < this.content.length; t++)if (!this.content[t].eq(e.content[t])) return !1; return !0 } get firstChild() { return this.content.length ? this.content[0] : null } get lastChild() { return this.content.length ? this.content[this.content.length - 1] : null } get childCount() { return this.content.length } child(e) { let t = this.content[e]; if (!t) throw new RangeError("Index " + e + " out of range for " + this); return t } maybeChild(e) { return this.content[e] || null } forEach(e) { for (let t = 0, r = 0; t < this.content.length; t++) { let i = this.content[t]; e(i, r, t), r += i.nodeSize } } findDiffStart(e, t = 0) { return bZ(this, e, t) } findDiffEnd(e, t = this.size, r = e.size) { return wZ(this, e, t, r) } findIndex(e, t = -1) { if (e == 0) return Y1(0, e); if (e == this.size) return Y1(this.content.length, e); if (e > this.size || e < 0) throw new RangeError(`Position ${e} outside of fragment (${this})`); for (let r = 0, i = 0; ; r++) { let a = this.child(r), o = i + a.nodeSize; if (o >= e) return o == e || t > 0 ? Y1(r + 1, o) : Y1(r, i); i = o } } toString() { return "<" + this.toStringInner() + ">" } toStringInner() { return this.content.join(", ") } toJSON() { return this.content.length ? this.content.map(e => e.toJSON()) : null } static fromJSON(e, t) { if (!t) return Ui.empty; if (!Array.isArray(t)) throw new RangeError("Invalid input for Fragment.fromJSON"); return new Ui(t.map(e.nodeFromJSON)) } static fromArray(e) { if (!e.length) return Ui.empty; let t, r = 0; for (let i = 0; i < e.length; i++) { let a = e[i]; r += a.nodeSize, i && a.isText && e[i - 1].sameMarkup(a) ? (t || (t = e.slice(0, i)), t[t.length - 1] = a.withText(t[t.length - 1].text + a.text)) : t && t.push(a) } return new Ui(t || e, r) } static from(e) { if (!e) return Ui.empty; if (e instanceof Ui) return e; if (Array.isArray(e)) return this.fromArray(e); if (e.attrs) return new Ui([e], e.nodeSize); throw new RangeError("Can not convert " + e + " to a Fragment" + (e.nodesBetween ? " (looks like multiple versions of prosemirror-model were loaded)" : "")) } }; Be.empty = new Be([], 0); const wE = { index: 0, offset: 0 }; function Y1(n, e) { return wE.index = n, wE.offset = e, wE } function VS(n, e) { if (n === e) return !0; if (!(n && typeof n == "object") || !(e && typeof e == "object")) return !1; let t = Array.isArray(n); if (Array.isArray(e) != t) return !1; if (t) { if (n.length != e.length) return !1; for (let r = 0; r < n.length; r++)if (!VS(n[r], e[r])) return !1 } else { for (let r in n) if (!(r in e) || !VS(n[r], e[r])) return !1; for (let r in e) if (!(r in n)) return !1 } return !0 } let Hn = class Ej { constructor(e, t) { this.type = e, this.attrs = t } addToSet(e) { let t, r = !1; for (let i = 0; i < e.length; i++) { let a = e[i]; if (this.eq(a)) return e; if (this.type.excludes(a.type)) t || (t = e.slice(0, i)); else { if (a.type.excludes(this.type)) return e; !r && a.type.rank > this.type.rank && (t || (t = e.slice(0, i)), t.push(this), r = !0), t && t.push(a) } } return t || (t = e.slice()), r || t.push(this), t } removeFromSet(e) { for (let t = 0; t < e.length; t++)if (this.eq(e[t])) return e.slice(0, t).concat(e.slice(t + 1)); return e } isInSet(e) { for (let t = 0; t < e.length; t++)if (this.eq(e[t])) return !0; return !1 } eq(e) { return this == e || this.type == e.type && VS(this.attrs, e.attrs) } toJSON() { let e = { type: this.type.name }; for (let t in this.attrs) { e.attrs = this.attrs; break } return e } static fromJSON(e, t) { if (!t) throw new RangeError("Invalid input for Mark.fromJSON"); let r = e.marks[t.type]; if (!r) throw new RangeError(`There is no mark type ${t.type} in this schema`); let i = r.create(t.attrs); return r.checkAttrs(i.attrs), i } static sameSet(e, t) { if (e == t) return !0; if (e.length != t.length) return !1; for (let r = 0; r < e.length; r++)if (!e[r].eq(t[r])) return !1; return !0 } static setFrom(e) { if (!e || Array.isArray(e) && e.length == 0) return Ej.none; if (e instanceof Ej) return [e]; let t = e.slice(); return t.sort((r, i) => r.type.rank - i.type.rank), t } }; Hn.none = []; class HS extends Error { } let Qe = class pm { constructor(e, t, r) { this.content = e, this.openStart = t, this.openEnd = r } get size() { return this.content.size - this.openStart - this.openEnd } insertAt(e, t) { let r = SZ(this.content, e + this.openStart, t); return r && new pm(r, this.openStart, this.openEnd) } removeBetween(e, t) { return new pm(xZ(this.content, e + this.openStart, t + this.openStart), this.openStart, this.openEnd) } eq(e) { return this.content.eq(e.content) && this.openStart == e.openStart && this.openEnd == e.openEnd } toString() { return this.content + "(" + this.openStart + "," + this.openEnd + ")" } toJSON() { if (!this.content.size) return null; let e = { content: this.content.toJSON() }; return this.openStart > 0 && (e.openStart = this.openStart), this.openEnd > 0 && (e.openEnd = this.openEnd), e } static fromJSON(e, t) { if (!t) return pm.empty; let r = t.openStart || 0, i = t.openEnd || 0; if (typeof r != "number" || typeof i != "number") throw new RangeError("Invalid input for Slice.fromJSON"); return new pm(Be.fromJSON(e, t.content), r, i) } static maxOpen(e, t = !0) { let r = 0, i = 0; for (let a = e.firstChild; a && !a.isLeaf && (t || !a.type.spec.isolating); a = a.firstChild)r++; for (let a = e.lastChild; a && !a.isLeaf && (t || !a.type.spec.isolating); a = a.lastChild)i++; return new pm(e, r, i) } }; Qe.empty = new Qe(Be.empty, 0, 0); function xZ(n, e, t) { let { index: r, offset: i } = n.findIndex(e), a = n.maybeChild(r), { index: o, offset: s } = n.findIndex(t); if (i == e || a.isText) { if (s != t && !n.child(o).isText) throw new RangeError("Removing non-flat range"); return n.cut(0, e).append(n.cut(t)) } if (r != o) throw new RangeError("Removing non-flat range"); return n.replaceChild(r, a.copy(xZ(a.content, e - i - 1, t - i - 1))) } function SZ(n, e, t, r) { let { index: i, offset: a } = n.findIndex(e), o = n.maybeChild(i); if (a == e || o.isText) return r && !r.canReplace(i, i, t) ? null : n.cut(0, e).append(t).append(n.cut(e)); let s = SZ(o.content, e - a - 1, t); return s && n.replaceChild(i, o.copy(s)) } function J2e(n, e, t) { if (t.openStart > n.depth) throw new HS("Inserted content deeper than insertion position"); if (n.depth - t.openStart != e.depth - t.openEnd) throw new HS("Inconsistent open depths"); return TZ(n, e, t, 0) } function TZ(n, e, t, r) { let i = n.index(r), a = n.node(r); if (i == e.index(r) && r < n.depth - t.openStart) { let o = TZ(n, e, t, r + 1); return a.copy(a.content.replaceChild(i, o)) } else if (t.content.size) if (!t.openStart && !t.openEnd && n.depth == r && e.depth == r) { let o = n.parent, s = o.content; return ph(o, s.cut(0, n.parentOffset).append(t.content).append(s.cut(e.parentOffset))) } else { let { start: o, end: s } = Q2e(t, n); return ph(a, CZ(n, o, s, e, r)) } else return ph(a, US(n, e, r)) } function kZ(n, e) { if (!e.type.compatibleContent(n.type)) throw new HS("Cannot join " + e.type.name + " onto " + n.type.name) } function Mj(n, e, t) { let r = n.node(t); return kZ(r, e.node(t)), r } function hh(n, e) { let t = e.length - 1; t >= 0 && n.isText && n.sameMarkup(e[t]) ? e[t] = n.withText(e[t].text + n.text) : e.push(n) } function e0(n, e, t, r) { let i = (e || n).node(t), a = 0, o = e ? e.index(t) : i.childCount; n && (a = n.index(t), n.depth > t ? a++ : n.textOffset && (hh(n.nodeAfter, r), a++)); for (let s = a; s < o; s++)hh(i.child(s), r); e && e.depth == t && e.textOffset && hh(e.nodeBefore, r) } function ph(n, e) { return n.type.checkContent(e), n.copy(e) } function CZ(n, e, t, r, i) { let a = n.depth > i && Mj(n, e, i + 1), o = r.depth > i && Mj(t, r, i + 1), s = []; return e0(null, n, i, s), a && o && e.index(i) == t.index(i) ? (kZ(a, o), hh(ph(a, CZ(n, e, t, r, i + 1)), s)) : (a && hh(ph(a, US(n, e, i + 1)), s), e0(e, t, i, s), o && hh(ph(o, US(t, r, i + 1)), s)), e0(r, null, i, s), new Be(s) } function US(n, e, t) { let r = []; if (e0(null, n, t, r), n.depth > t) { let i = Mj(n, e, t + 1); hh(ph(i, US(n, e, t + 1)), r) } return e0(e, null, t, r), new Be(r) } function Q2e(n, e) { let t = e.depth - n.openStart, i = e.node(t).copy(n.content); for (let a = t - 1; a >= 0; a--)i = e.node(a).copy(Be.from(i)); return { start: i.resolveNoCache(n.openStart + t), end: i.resolveNoCache(i.content.size - n.openEnd - t) } } class K0 { constructor(e, t, r) { this.pos = e, this.path = t, this.parentOffset = r, this.depth = t.length / 3 - 1 } resolveDepth(e) { return e == null ? this.depth : e < 0 ? this.depth + e : e } get parent() { return this.node(this.depth) } get doc() { return this.node(0) } node(e) { return this.path[this.resolveDepth(e) * 3] } index(e) { return this.path[this.resolveDepth(e) * 3 + 1] } indexAfter(e) { return e = this.resolveDepth(e), this.index(e) + (e == this.depth && !this.textOffset ? 0 : 1) } start(e) { return e = this.resolveDepth(e), e == 0 ? 0 : this.path[e * 3 - 1] + 1 } end(e) { return e = this.resolveDepth(e), this.start(e) + this.node(e).content.size } before(e) { if (e = this.resolveDepth(e), !e) throw new RangeError("There is no position before the top-level node"); return e == this.depth + 1 ? this.pos : this.path[e * 3 - 1] } after(e) { if (e = this.resolveDepth(e), !e) throw new RangeError("There is no position after the top-level node"); return e == this.depth + 1 ? this.pos : this.path[e * 3 - 1] + this.path[e * 3].nodeSize } get textOffset() { return this.pos - this.path[this.path.length - 1] } get nodeAfter() { let e = this.parent, t = this.index(this.depth); if (t == e.childCount) return null; let r = this.pos - this.path[this.path.length - 1], i = e.child(t); return r ? e.child(t).cut(r) : i } get nodeBefore() { let e = this.index(this.depth), t = this.pos - this.path[this.path.length - 1]; return t ? this.parent.child(e).cut(0, t) : e == 0 ? null : this.parent.child(e - 1) } posAtIndex(e, t) { t = this.resolveDepth(t); let r = this.path[t * 3], i = t == 0 ? 0 : this.path[t * 3 - 1] + 1; for (let a = 0; a < e; a++)i += r.child(a).nodeSize; return i } marks() { let e = this.parent, t = this.index(); if (e.content.size == 0) return Hn.none; if (this.textOffset) return e.child(t).marks; let r = e.maybeChild(t - 1), i = e.maybeChild(t); if (!r) { let s = r; r = i, i = s } let a = r.marks; for (var o = 0; o < a.length; o++)a[o].type.spec.inclusive === !1 && (!i || !a[o].isInSet(i.marks)) && (a = a[o--].removeFromSet(a)); return a } marksAcross(e) { let t = this.parent.maybeChild(this.index()); if (!t || !t.isInline) return null; let r = t.marks, i = e.parent.maybeChild(e.index()); for (var a = 0; a < r.length; a++)r[a].type.spec.inclusive === !1 && (!i || !r[a].isInSet(i.marks)) && (r = r[a--].removeFromSet(r)); return r } sharedDepth(e) { for (let t = this.depth; t > 0; t--)if (this.start(t) <= e && this.end(t) >= e) return t; return 0 } blockRange(e = this, t) { if (e.pos < this.pos) return e.blockRange(this); for (let r = this.depth - (this.parent.inlineContent || this.pos == e.pos ? 1 : 0); r >= 0; r--)if (e.pos <= this.end(r) && (!t || t(this.node(r)))) return new GS(this, e, r); return null } sameParent(e) { return this.pos - this.parentOffset == e.pos - e.parentOffset } max(e) { return e.pos > this.pos ? e : this } min(e) { return e.pos < this.pos ? e : this } toString() { let e = ""; for (let t = 1; t <= this.depth; t++)e += (e ? "/" : "") + this.node(t).type.name + "_" + this.index(t - 1); return e + ":" + this.parentOffset } static resolve(e, t) { if (!(t >= 0 && t <= e.content.size)) throw new RangeError("Position " + t + " out of range"); let r = [], i = 0, a = t; for (let o = e; ;) { let { index: s, offset: l } = o.content.findIndex(a), c = a - l; if (r.push(o, s, i + l), !c || (o = o.child(s), o.isText)) break; a = c - 1, i += l + 1 } return new K0(t, r, a) } static resolveCached(e, t) { let r = eF.get(e); if (r) for (let a = 0; a < r.elts.length; a++) { let o = r.elts[a]; if (o.pos == t) return o } else eF.set(e, r = new eTe); let i = r.elts[r.i] = K0.resolve(e, t); return r.i = (r.i + 1) % tTe, i } } class eTe { constructor() { this.elts = [], this.i = 0 } } const tTe = 12, eF = new WeakMap; class GS { constructor(e, t, r) { this.$from = e, this.$to = t, this.depth = r } get start() { return this.$from.before(this.depth + 1) } get end() { return this.$to.after(this.depth + 1) } get parent() { return this.$from.node(this.depth) } get startIndex() { return this.$from.index(this.depth) } get endIndex() { return this.$to.indexAfter(this.depth) } } const nTe = Object.create(null); let td = class Oj { constructor(e, t, r, i = Hn.none) { this.type = e, this.attrs = t, this.marks = i, this.content = r || Be.empty } get nodeSize() { return this.isLeaf ? 1 : 2 + this.content.size } get childCount() { return this.content.childCount } child(e) { return this.content.child(e) } maybeChild(e) { return this.content.maybeChild(e) } forEach(e) { this.content.forEach(e) } nodesBetween(e, t, r, i = 0) { this.content.nodesBetween(e, t, r, i, this) } descendants(e) { this.nodesBetween(0, this.content.size, e) } get textContent() { return this.isLeaf && this.type.spec.leafText ? this.type.spec.leafText(this) : this.textBetween(0, this.content.size, "") } textBetween(e, t, r, i) { return this.content.textBetween(e, t, r, i) } get firstChild() { return this.content.firstChild } get lastChild() { return this.content.lastChild } eq(e) { return this == e || this.sameMarkup(e) && this.content.eq(e.content) } sameMarkup(e) { return this.hasMarkup(e.type, e.attrs, e.marks) } hasMarkup(e, t, r) { return this.type == e && VS(this.attrs, t || e.defaultAttrs || nTe) && Hn.sameSet(this.marks, r || Hn.none) } copy(e = null) { return e == this.content ? this : new Oj(this.type, this.attrs, e, this.marks) } mark(e) { return e == this.marks ? this : new Oj(this.type, this.attrs, this.content, e) } cut(e, t = this.content.size) { return e == 0 && t == this.content.size ? this : this.copy(this.content.cut(e, t)) } slice(e, t = this.content.size, r = !1) { if (e == t) return Qe.empty; let i = this.resolve(e), a = this.resolve(t), o = r ? 0 : i.sharedDepth(t), s = i.start(o), c = i.node(o).content.cut(i.pos - s, a.pos - s); return new Qe(c, i.depth - o, a.depth - o) } replace(e, t, r) { return J2e(this.resolve(e), this.resolve(t), r) } nodeAt(e) { for (let t = this; ;) { let { index: r, offset: i } = t.content.findIndex(e); if (t = t.maybeChild(r), !t) return null; if (i == e || t.isText) return t; e -= i + 1 } } childAfter(e) { let { index: t, offset: r } = this.content.findIndex(e); return { node: this.content.maybeChild(t), index: t, offset: r } } childBefore(e) { if (e == 0) return { node: null, index: 0, offset: 0 }; let { index: t, offset: r } = this.content.findIndex(e); if (r < e) return { node: this.content.child(t), index: t, offset: r }; let i = this.content.child(t - 1); return { node: i, index: t - 1, offset: r - i.nodeSize } } resolve(e) { return K0.resolveCached(this, e) } resolveNoCache(e) { return K0.resolve(this, e) } rangeHasMark(e, t, r) { let i = !1; return t > e && this.nodesBetween(e, t, a => (r.isInSet(a.marks) && (i = !0), !i)), i } get isBlock() { return this.type.isBlock } get isTextblock() { return this.type.isTextblock } get inlineContent() { return this.type.inlineContent } get isInline() { return this.type.isInline } get isText() { return this.type.isText } get isLeaf() { return this.type.isLeaf } get isAtom() { return this.type.isAtom } toString() { if (this.type.spec.toDebugString) return this.type.spec.toDebugString(this); let e = this.type.name; return this.content.size && (e += "(" + this.content.toStringInner() + ")"), AZ(this.marks, e) } contentMatchAt(e) { let t = this.type.contentMatch.matchFragment(this.content, 0, e); if (!t) throw new Error("Called contentMatchAt on a node with invalid content"); return t } canReplace(e, t, r = Be.empty, i = 0, a = r.childCount) { let o = this.contentMatchAt(e).matchFragment(r, i, a), s = o && o.matchFragment(this.content, t); if (!s || !s.validEnd) return !1; for (let l = i; l < a; l++)if (!this.type.allowsMarks(r.child(l).marks)) return !1; return !0 } canReplaceWith(e, t, r, i) { if (i && !this.type.allowsMarks(i)) return !1; let a = this.contentMatchAt(e).matchType(r), o = a && a.matchFragment(this.content, t); return o ? o.validEnd : !1 } canAppend(e) { return e.content.size ? this.canReplace(this.childCount, this.childCount, e.content) : this.type.compatibleContent(e.type) } check() { this.type.checkContent(this.content), this.type.checkAttrs(this.attrs); let e = Hn.none; for (let t = 0; t < this.marks.length; t++) { let r = this.marks[t]; r.type.checkAttrs(r.attrs), e = r.addToSet(e) } if (!Hn.sameSet(e, this.marks)) throw new RangeError(`Invalid collection of marks for node ${this.type.name}: ${this.marks.map(t => t.type.name)}`); this.content.forEach(t => t.check()) } toJSON() { let e = { type: this.type.name }; for (let t in this.attrs) { e.attrs = this.attrs; break } return this.content.size && (e.content = this.content.toJSON()), this.marks.length && (e.marks = this.marks.map(t => t.toJSON())), e } static fromJSON(e, t) { if (!t) throw new RangeError("Invalid input for Node.fromJSON"); let r; if (t.marks) { if (!Array.isArray(t.marks)) throw new RangeError("Invalid mark data for Node.fromJSON"); r = t.marks.map(e.markFromJSON) } if (t.type == "text") { if (typeof t.text != "string") throw new RangeError("Invalid text node in JSON"); return e.text(t.text, r) } let i = Be.fromJSON(e, t.content), a = e.nodeType(t.type).create(t.attrs, i, r); return a.type.checkAttrs(a.attrs), a } }; td.prototype.text = void 0; class WS extends td { constructor(e, t, r, i) { if (super(e, t, null, i), !r) throw new RangeError("Empty text nodes are not allowed"); this.text = r } toString() { return this.type.spec.toDebugString ? this.type.spec.toDebugString(this) : AZ(this.marks, JSON.stringify(this.text)) } get textContent() { return this.text } textBetween(e, t) { return this.text.slice(e, t) } get nodeSize() { return this.text.length } mark(e) { return e == this.marks ? this : new WS(this.type, this.attrs, this.text, e) } withText(e) { return e == this.text ? this : new WS(this.type, this.attrs, e, this.marks) } cut(e = 0, t = this.text.length) { return e == 0 && t == this.text.length ? this : this.withText(this.text.slice(e, t)) } eq(e) { return this.sameMarkup(e) && this.text == e.text } toJSON() { let e = super.toJSON(); return e.text = this.text, e } } function AZ(n, e) { for (let t = n.length - 1; t >= 0; t--)e = n[t].type.name + "(" + e + ")"; return e } class Bh {
  constructor(e) { this.validEnd = e, this.next = [], this.wrapCache = [] } static parse(e, t) { let r = new rTe(e, t); if (r.next == null) return Bh.empty; let i = EZ(r); r.next && r.err("Unexpected trailing text"); let a = uTe(cTe(i)); return dTe(a, r), a } matchType(e) { for (let t = 0; t < this.next.length; t++)if (this.next[t].type == e) return this.next[t].next; return null } matchFragment(e, t = 0, r = e.childCount) { let i = this; for (let a = t; i && a < r; a++)i = i.matchType(e.child(a).type); return i } get inlineContent() { return this.next.length != 0 && this.next[0].type.isInline } get defaultType() { for (let e = 0; e < this.next.length; e++) { let { type: t } = this.next[e]; if (!(t.isText || t.hasRequiredAttrs())) return t } return null } compatible(e) { for (let t = 0; t < this.next.length; t++)for (let r = 0; r < e.next.length; r++)if (this.next[t].type == e.next[r].type) return !0; return !1 } fillBefore(e, t = !1, r = 0) { let i = [this]; function a(o, s) { let l = o.matchFragment(e, r); if (l && (!t || l.validEnd)) return Be.from(s.map(c => c.createAndFill())); for (let c = 0; c < o.next.length; c++) { let { type: u, next: d } = o.next[c]; if (!(u.isText || u.hasRequiredAttrs()) && i.indexOf(d) == -1) { i.push(d); let f = a(d, s.concat(u)); if (f) return f } } return null } return a(this, []) } findWrapping(e) { for (let r = 0; r < this.wrapCache.length; r += 2)if (this.wrapCache[r] == e) return this.wrapCache[r + 1]; let t = this.computeWrapping(e); return this.wrapCache.push(e, t), t } computeWrapping(e) { let t = Object.create(null), r = [{ match: this, type: null, via: null }]; for (; r.length;) { let i = r.shift(), a = i.match; if (a.matchType(e)) { let o = []; for (let s = i; s.type; s = s.via)o.push(s.type); return o.reverse() } for (let o = 0; o < a.next.length; o++) { let { type: s, next: l } = a.next[o]; !s.isLeaf && !s.hasRequiredAttrs() && !(s.name in t) && (!i.type || l.validEnd) && (r.push({ match: s.contentMatch, type: s, via: i }), t[s.name] = !0) } } return null } get edgeCount() { return this.next.length } edge(e) { if (e >= this.next.length) throw new RangeError(`There's no ${e}th edge in this content match`); return this.next[e] } toString() {
    let e = []; function t(r) { e.push(r); for (let i = 0; i < r.next.length; i++)e.indexOf(r.next[i].next) == -1 && t(r.next[i].next) } return t(this), e.map((r, i) => { let a = i + (r.validEnd ? "*" : " ") + " "; for (let o = 0; o < r.next.length; o++)a += (o ? ", " : "") + r.next[o].type.name + "->" + e.indexOf(r.next[o].next); return a }).join(`
`)
  }
} Bh.empty = new Bh(!0); class rTe { constructor(e, t) { this.string = e, this.nodeTypes = t, this.inline = null, this.pos = 0, this.tokens = e.split(/\s*(?=\b|\W|$)/), this.tokens[this.tokens.length - 1] == "" && this.tokens.pop(), this.tokens[0] == "" && this.tokens.shift() } get next() { return this.tokens[this.pos] } eat(e) { return this.next == e && (this.pos++ || !0) } err(e) { throw new SyntaxError(e + " (in content expression '" + this.string + "')") } } function EZ(n) { let e = []; do e.push(iTe(n)); while (n.eat("|")); return e.length == 1 ? e[0] : { type: "choice", exprs: e } } function iTe(n) { let e = []; do e.push(aTe(n)); while (n.next && n.next != ")" && n.next != "|"); return e.length == 1 ? e[0] : { type: "seq", exprs: e } } function aTe(n) { let e = lTe(n); for (; ;)if (n.eat("+")) e = { type: "plus", expr: e }; else if (n.eat("*")) e = { type: "star", expr: e }; else if (n.eat("?")) e = { type: "opt", expr: e }; else if (n.eat("{")) e = oTe(n, e); else break; return e } function tF(n) { /\D/.test(n.next) && n.err("Expected number, got '" + n.next + "'"); let e = Number(n.next); return n.pos++, e } function oTe(n, e) { let t = tF(n), r = t; return n.eat(",") && (n.next != "}" ? r = tF(n) : r = -1), n.eat("}") || n.err("Unclosed braced range"), { type: "range", min: t, max: r, expr: e } } function sTe(n, e) { let t = n.nodeTypes, r = t[e]; if (r) return [r]; let i = []; for (let a in t) { let o = t[a]; o.groups.indexOf(e) > -1 && i.push(o) } return i.length == 0 && n.err("No node type or group '" + e + "' found"), i } function lTe(n) { if (n.eat("(")) { let e = EZ(n); return n.eat(")") || n.err("Missing closing paren"), e } else if (/\W/.test(n.next)) n.err("Unexpected token '" + n.next + "'"); else { let e = sTe(n, n.next).map(t => (n.inline == null ? n.inline = t.isInline : n.inline != t.isInline && n.err("Mixing inline and block content"), { type: "name", value: t })); return n.pos++, e.length == 1 ? e[0] : { type: "choice", exprs: e } } } function cTe(n) { let e = [[]]; return i(a(n, 0), t()), e; function t() { return e.push([]) - 1 } function r(o, s, l) { let c = { term: l, to: s }; return e[o].push(c), c } function i(o, s) { o.forEach(l => l.to = s) } function a(o, s) { if (o.type == "choice") return o.exprs.reduce((l, c) => l.concat(a(c, s)), []); if (o.type == "seq") for (let l = 0; ; l++) { let c = a(o.exprs[l], s); if (l == o.exprs.length - 1) return c; i(c, s = t()) } else if (o.type == "star") { let l = t(); return r(s, l), i(a(o.expr, l), l), [r(l)] } else if (o.type == "plus") { let l = t(); return i(a(o.expr, s), l), i(a(o.expr, l), l), [r(l)] } else { if (o.type == "opt") return [r(s)].concat(a(o.expr, s)); if (o.type == "range") { let l = s; for (let c = 0; c < o.min; c++) { let u = t(); i(a(o.expr, l), u), l = u } if (o.max == -1) i(a(o.expr, l), l); else for (let c = o.min; c < o.max; c++) { let u = t(); r(l, u), i(a(o.expr, l), u), l = u } return [r(l)] } else { if (o.type == "name") return [r(s, void 0, o.value)]; throw new Error("Unknown expr type") } } } } function MZ(n, e) { return e - n } function nF(n, e) { let t = []; return r(e), t.sort(MZ); function r(i) { let a = n[i]; if (a.length == 1 && !a[0].term) return r(a[0].to); t.push(i); for (let o = 0; o < a.length; o++) { let { term: s, to: l } = a[o]; !s && t.indexOf(l) == -1 && r(l) } } } function uTe(n) { let e = Object.create(null); return t(nF(n, 0)); function t(r) { let i = []; r.forEach(o => { n[o].forEach(({ term: s, to: l }) => { if (!s) return; let c; for (let u = 0; u < i.length; u++)i[u][0] == s && (c = i[u][1]); nF(n, l).forEach(u => { c || i.push([s, c = []]), c.indexOf(u) == -1 && c.push(u) }) }) }); let a = e[r.join(",")] = new Bh(r.indexOf(n.length - 1) > -1); for (let o = 0; o < i.length; o++) { let s = i[o][1].sort(MZ); a.next.push({ type: i[o][0], next: e[s.join(",")] || t(s) }) } return a } } function dTe(n, e) { for (let t = 0, r = [n]; t < r.length; t++) { let i = r[t], a = !i.validEnd, o = []; for (let s = 0; s < i.next.length; s++) { let { type: l, next: c } = i.next[s]; o.push(l.name), a && !(l.isText || l.hasRequiredAttrs()) && (a = !1), r.indexOf(c) == -1 && r.push(c) } a && e.err("Only non-generatable nodes (" + o.join(", ") + ") in a required position (see https://prosemirror.net/docs/guide/#generatable)") } } function OZ(n) { let e = Object.create(null); for (let t in n) { let r = n[t]; if (!r.hasDefault) return null; e[t] = r.default } return e } function DZ(n, e) { let t = Object.create(null); for (let r in n) { let i = e && e[r]; if (i === void 0) { let a = n[r]; if (a.hasDefault) i = a.default; else throw new RangeError("No value supplied for attribute " + r) } t[r] = i } return t } function jZ(n, e, t, r) { for (let i in e) if (!(i in n)) throw new RangeError(`Unsupported attribute ${i} for ${t} of type ${i}`); for (let i in n) { let a = n[i]; a.validate && a.validate(e[i]) } } function PZ(n, e) { let t = Object.create(null); if (e) for (let r in e) t[r] = new hTe(n, r, e[r]); return t } let rF = class IZ { constructor(e, t, r) { this.name = e, this.schema = t, this.spec = r, this.markSet = null, this.groups = r.group ? r.group.split(" ") : [], this.attrs = PZ(e, r.attrs), this.defaultAttrs = OZ(this.attrs), this.contentMatch = null, this.inlineContent = null, this.isBlock = !(r.inline || e == "text"), this.isText = e == "text" } get isInline() { return !this.isBlock } get isTextblock() { return this.isBlock && this.inlineContent } get isLeaf() { return this.contentMatch == Bh.empty } get isAtom() { return this.isLeaf || !!this.spec.atom } get whitespace() { return this.spec.whitespace || (this.spec.code ? "pre" : "normal") } hasRequiredAttrs() { for (let e in this.attrs) if (this.attrs[e].isRequired) return !0; return !1 } compatibleContent(e) { return this == e || this.contentMatch.compatible(e.contentMatch) } computeAttrs(e) { return !e && this.defaultAttrs ? this.defaultAttrs : DZ(this.attrs, e) } create(e = null, t, r) { if (this.isText) throw new Error("NodeType.create can't construct text nodes"); return new td(this, this.computeAttrs(e), Be.from(t), Hn.setFrom(r)) } createChecked(e = null, t, r) { return t = Be.from(t), this.checkContent(t), new td(this, this.computeAttrs(e), t, Hn.setFrom(r)) } createAndFill(e = null, t, r) { if (e = this.computeAttrs(e), t = Be.from(t), t.size) { let o = this.contentMatch.fillBefore(t); if (!o) return null; t = o.append(t) } let i = this.contentMatch.matchFragment(t), a = i && i.fillBefore(Be.empty, !0); return a ? new td(this, e, t.append(a), Hn.setFrom(r)) : null } validContent(e) { let t = this.contentMatch.matchFragment(e); if (!t || !t.validEnd) return !1; for (let r = 0; r < e.childCount; r++)if (!this.allowsMarks(e.child(r).marks)) return !1; return !0 } checkContent(e) { if (!this.validContent(e)) throw new RangeError(`Invalid content for node ${this.name}: ${e.toString().slice(0, 50)}`) } checkAttrs(e) { jZ(this.attrs, e, "node", this.name) } allowsMarkType(e) { return this.markSet == null || this.markSet.indexOf(e) > -1 } allowsMarks(e) { if (this.markSet == null) return !0; for (let t = 0; t < e.length; t++)if (!this.allowsMarkType(e[t].type)) return !1; return !0 } allowedMarks(e) { if (this.markSet == null) return e; let t; for (let r = 0; r < e.length; r++)this.allowsMarkType(e[r].type) ? t && t.push(e[r]) : t || (t = e.slice(0, r)); return t ? t.length ? t : Hn.none : e } static compile(e, t) { let r = Object.create(null); e.forEach((a, o) => r[a] = new IZ(a, t, o)); let i = t.spec.topNode || "doc"; if (!r[i]) throw new RangeError("Schema is missing its top node type ('" + i + "')"); if (!r.text) throw new RangeError("Every schema needs a 'text' type"); for (let a in r.text.attrs) throw new RangeError("The text node type should not have attributes"); return r } }; function fTe(n, e, t) { let r = t.split("|"); return i => { let a = i === null ? "null" : typeof i; if (r.indexOf(a) < 0) throw new RangeError(`Expected value of type ${r} for attribute ${e} on type ${n}, got ${a}`) } } class hTe { constructor(e, t, r) { this.hasDefault = Object.prototype.hasOwnProperty.call(r, "default"), this.default = r.default, this.validate = typeof r.validate == "string" ? fTe(e, t, r.validate) : r.validate } get isRequired() { return !this.hasDefault } } class xk { constructor(e, t, r, i) { this.name = e, this.rank = t, this.schema = r, this.spec = i, this.attrs = PZ(e, i.attrs), this.excluded = null; let a = OZ(this.attrs); this.instance = a ? new Hn(this, a) : null } create(e = null) { return !e && this.instance ? this.instance : new Hn(this, DZ(this.attrs, e)) } static compile(e, t) { let r = Object.create(null), i = 0; return e.forEach((a, o) => r[a] = new xk(a, i++, t, o)), r } removeFromSet(e) { for (var t = 0; t < e.length; t++)e[t].type == this && (e = e.slice(0, t).concat(e.slice(t + 1)), t--); return e } isInSet(e) { for (let t = 0; t < e.length; t++)if (e[t].type == this) return e[t] } checkAttrs(e) { jZ(this.attrs, e, "mark", this.name) } excludes(e) { return this.excluded.indexOf(e) > -1 } } class wR { constructor(e) { this.linebreakReplacement = null, this.cached = Object.create(null); let t = this.spec = {}; for (let i in e) t[i] = e[i]; t.nodes = ai.from(e.nodes), t.marks = ai.from(e.marks || {}), this.nodes = rF.compile(this.spec.nodes, this), this.marks = xk.compile(this.spec.marks, this); let r = Object.create(null); for (let i in this.nodes) { if (i in this.marks) throw new RangeError(i + " can not be both a node and a mark"); let a = this.nodes[i], o = a.spec.content || "", s = a.spec.marks; if (a.contentMatch = r[o] || (r[o] = Bh.parse(o, this.nodes)), a.inlineContent = a.contentMatch.inlineContent, a.spec.linebreakReplacement) { if (this.linebreakReplacement) throw new RangeError("Multiple linebreak nodes defined"); if (!a.isInline || !a.isLeaf) throw new RangeError("Linebreak replacement nodes must be inline leaf nodes"); this.linebreakReplacement = a } a.markSet = s == "_" ? null : s ? iF(this, s.split(" ")) : s == "" || !a.inlineContent ? [] : null } for (let i in this.marks) { let a = this.marks[i], o = a.spec.excludes; a.excluded = o == null ? [a] : o == "" ? [] : iF(this, o.split(" ")) } this.nodeFromJSON = this.nodeFromJSON.bind(this), this.markFromJSON = this.markFromJSON.bind(this), this.topNodeType = this.nodes[this.spec.topNode || "doc"], this.cached.wrappings = Object.create(null) } node(e, t = null, r, i) { if (typeof e == "string") e = this.nodeType(e); else if (e instanceof rF) { if (e.schema != this) throw new RangeError("Node type from different schema used (" + e.name + ")") } else throw new RangeError("Invalid node type: " + e); return e.createChecked(t, r, i) } text(e, t) { let r = this.nodes.text; return new WS(r, r.defaultAttrs, e, Hn.setFrom(t)) } mark(e, t) { return typeof e == "string" && (e = this.marks[e]), e.create(t) } nodeFromJSON(e) { return td.fromJSON(this, e) } markFromJSON(e) { return Hn.fromJSON(this, e) } nodeType(e) { let t = this.nodes[e]; if (!t) throw new RangeError("Unknown node type: " + e); return t } } function iF(n, e) { let t = []; for (let r = 0; r < e.length; r++) { let i = e[r], a = n.marks[i], o = a; if (a) t.push(a); else for (let s in n.marks) { let l = n.marks[s]; (i == "_" || l.spec.group && l.spec.group.split(" ").indexOf(i) > -1) && t.push(o = l) } if (!o) throw new SyntaxError("Unknown mark type: '" + e[r] + "'") } return t } function pTe(n) { return n.tag != null } function mTe(n) { return n.style != null } let nd = class Dj { constructor(e, t) { this.schema = e, this.rules = t, this.tags = [], this.styles = []; let r = this.matchedStyles = []; t.forEach(i => { if (pTe(i)) this.tags.push(i); else if (mTe(i)) { let a = /[^=]*/.exec(i.style)[0]; r.indexOf(a) < 0 && r.push(a), this.styles.push(i) } }), this.normalizeLists = !this.tags.some(i => { if (!/^(ul|ol)\b/.test(i.tag) || !i.node) return !1; let a = e.nodes[i.node]; return a.contentMatch.matchType(a) }) } parse(e, t = {}) { let r = new oF(this, t, !1); return r.addAll(e, Hn.none, t.from, t.to), r.finish() } parseSlice(e, t = {}) { let r = new oF(this, t, !0); return r.addAll(e, Hn.none, t.from, t.to), Qe.maxOpen(r.finish()) } matchTag(e, t, r) { for (let i = r ? this.tags.indexOf(r) + 1 : 0; i < this.tags.length; i++) { let a = this.tags[i]; if (yTe(e, a.tag) && (a.namespace === void 0 || e.namespaceURI == a.namespace) && (!a.context || t.matchesContext(a.context))) { if (a.getAttrs) { let o = a.getAttrs(e); if (o === !1) continue; a.attrs = o || void 0 } return a } } } matchStyle(e, t, r, i) { for (let a = i ? this.styles.indexOf(i) + 1 : 0; a < this.styles.length; a++) { let o = this.styles[a], s = o.style; if (!(s.indexOf(e) != 0 || o.context && !r.matchesContext(o.context) || s.length > e.length && (s.charCodeAt(e.length) != 61 || s.slice(e.length + 1) != t))) { if (o.getAttrs) { let l = o.getAttrs(t); if (l === !1) continue; o.attrs = l || void 0 } return o } } } static schemaRules(e) { let t = []; function r(i) { let a = i.priority == null ? 50 : i.priority, o = 0; for (; o < t.length; o++) { let s = t[o]; if ((s.priority == null ? 50 : s.priority) < a) break } t.splice(o, 0, i) } for (let i in e.marks) { let a = e.marks[i].spec.parseDOM; a && a.forEach(o => { r(o = sF(o)), o.mark || o.ignore || o.clearMark || (o.mark = i) }) } for (let i in e.nodes) { let a = e.nodes[i].spec.parseDOM; a && a.forEach(o => { r(o = sF(o)), o.node || o.ignore || o.mark || (o.node = i) }) } return t } static fromSchema(e) { return e.cached.domParser || (e.cached.domParser = new Dj(e, Dj.schemaRules(e))) } }; const LZ = { address: !0, article: !0, aside: !0, blockquote: !0, canvas: !0, dd: !0, div: !0, dl: !0, fieldset: !0, figcaption: !0, figure: !0, footer: !0, form: !0, h1: !0, h2: !0, h3: !0, h4: !0, h5: !0, h6: !0, header: !0, hgroup: !0, hr: !0, li: !0, noscript: !0, ol: !0, output: !0, p: !0, pre: !0, section: !0, table: !0, tfoot: !0, ul: !0 }, gTe = { head: !0, noscript: !0, object: !0, script: !0, style: !0, title: !0 }, RZ = { ol: !0, ul: !0 }, KS = 1, qS = 2, t0 = 4; function aF(n, e, t) { return e != null ? (e ? KS : 0) | (e === "full" ? qS : 0) : n && n.whitespace == "pre" ? KS | qS : t & ~t0 } let Z1 = class { constructor(e, t, r, i, a, o) { this.type = e, this.attrs = t, this.marks = r, this.solid = i, this.options = o, this.content = [], this.activeMarks = Hn.none, this.match = a || (o & t0 ? null : e.contentMatch) } findWrapping(e) { if (!this.match) { if (!this.type) return []; let t = this.type.contentMatch.fillBefore(Be.from(e)); if (t) this.match = this.type.contentMatch.matchFragment(t); else { let r = this.type.contentMatch, i; return (i = r.findWrapping(e.type)) ? (this.match = r, i) : null } } return this.match.findWrapping(e.type) } finish(e) { if (!(this.options & KS)) { let r = this.content[this.content.length - 1], i; if (r && r.isText && (i = /[ \t\r\n\u000c]+$/.exec(r.text))) { let a = r; r.text.length == i[0].length ? this.content.pop() : this.content[this.content.length - 1] = a.withText(a.text.slice(0, a.text.length - i[0].length)) } } let t = Be.from(this.content); return !e && this.match && (t = t.append(this.match.fillBefore(Be.empty, !0))), this.type ? this.type.create(this.attrs, t, this.marks) : t } inlineContext(e) { return this.type ? this.type.inlineContent : this.content.length ? this.content[0].isInline : e.parentNode && !LZ.hasOwnProperty(e.parentNode.nodeName.toLowerCase()) } }, oF = class {
  constructor(e, t, r) { this.parser = e, this.options = t, this.isOpen = r, this.open = 0; let i = t.topNode, a, o = aF(null, t.preserveWhitespace, 0) | (r ? t0 : 0); i ? a = new Z1(i.type, i.attrs, Hn.none, !0, t.topMatch || i.type.contentMatch, o) : r ? a = new Z1(null, null, Hn.none, !0, null, o) : a = new Z1(e.schema.topNodeType, null, Hn.none, !0, null, o), this.nodes = [a], this.find = t.findPositions, this.needsBlock = !1 } get top() { return this.nodes[this.open] } addDOM(e, t) { e.nodeType == 3 ? this.addTextNode(e, t) : e.nodeType == 1 && this.addElement(e, t) } addTextNode(e, t) {
    let r = e.nodeValue, i = this.top; if (i.options & qS || i.inlineContext(e) || /[^ \t\r\n\u000c]/.test(r)) {
      if (i.options & KS) i.options & qS ? r = r.replace(/\r\n?/g, `
`) : r = r.replace(/\r?\n|\r/g, " "); else if (r = r.replace(/[ \t\r\n\u000c]+/g, " "), /^[ \t\r\n\u000c]/.test(r) && this.open == this.nodes.length - 1) { let a = i.content[i.content.length - 1], o = e.previousSibling; (!a || o && o.nodeName == "BR" || a.isText && /[ \t\r\n\u000c]$/.test(a.text)) && (r = r.slice(1)) } r && this.insertNode(this.parser.schema.text(r), t), this.findInText(e)
    } else this.findInside(e)
  } addElement(e, t, r) { let i = e.nodeName.toLowerCase(), a; RZ.hasOwnProperty(i) && this.parser.normalizeLists && vTe(e); let o = this.options.ruleFromNode && this.options.ruleFromNode(e) || (a = this.parser.matchTag(e, this, r)); if (o ? o.ignore : gTe.hasOwnProperty(i)) this.findInside(e), this.ignoreFallback(e, t); else if (!o || o.skip || o.closeParent) { o && o.closeParent ? this.open = Math.max(0, this.open - 1) : o && o.skip.nodeType && (e = o.skip); let s, l = this.top, c = this.needsBlock; if (LZ.hasOwnProperty(i)) l.content.length && l.content[0].isInline && this.open && (this.open--, l = this.top), s = !0, l.type || (this.needsBlock = !0); else if (!e.firstChild) { this.leafFallback(e, t); return } let u = o && o.skip ? t : this.readStyles(e, t); u && this.addAll(e, u), s && this.sync(l), this.needsBlock = c } else { let s = this.readStyles(e, t); s && this.addElementByRule(e, o, s, o.consuming === !1 ? a : void 0) } } leafFallback(e, t) {
    e.nodeName == "BR" && this.top.type && this.top.type.inlineContent && this.addTextNode(e.ownerDocument.createTextNode(`
`), t)
  } ignoreFallback(e, t) { e.nodeName == "BR" && (!this.top.type || !this.top.type.inlineContent) && this.findPlace(this.parser.schema.text("-"), t) } readStyles(e, t) { let r = e.style; if (r && r.length) for (let i = 0; i < this.parser.matchedStyles.length; i++) { let a = this.parser.matchedStyles[i], o = r.getPropertyValue(a); if (o) for (let s = void 0; ;) { let l = this.parser.matchStyle(a, o, this, s); if (!l) break; if (l.ignore) return null; if (l.clearMark ? t = t.filter(c => !l.clearMark(c)) : t = t.concat(this.parser.schema.marks[l.mark].create(l.attrs)), l.consuming === !1) s = l; else break } } return t } addElementByRule(e, t, r, i) { let a, o; if (t.node) if (o = this.parser.schema.nodes[t.node], o.isLeaf) this.insertNode(o.create(t.attrs), r) || this.leafFallback(e, r); else { let l = this.enter(o, t.attrs || null, r, t.preserveWhitespace); l && (a = !0, r = l) } else { let l = this.parser.schema.marks[t.mark]; r = r.concat(l.create(t.attrs)) } let s = this.top; if (o && o.isLeaf) this.findInside(e); else if (i) this.addElement(e, r, i); else if (t.getContent) this.findInside(e), t.getContent(e, this.parser.schema).forEach(l => this.insertNode(l, r)); else { let l = e; typeof t.contentElement == "string" ? l = e.querySelector(t.contentElement) : typeof t.contentElement == "function" ? l = t.contentElement(e) : t.contentElement && (l = t.contentElement), this.findAround(e, l, !0), this.addAll(l, r) } a && this.sync(s) && this.open-- } addAll(e, t, r, i) { let a = r || 0; for (let o = r ? e.childNodes[r] : e.firstChild, s = i == null ? null : e.childNodes[i]; o != s; o = o.nextSibling, ++a)this.findAtPoint(e, a), this.addDOM(o, t); this.findAtPoint(e, a) } findPlace(e, t) { let r, i; for (let a = this.open; a >= 0; a--) { let o = this.nodes[a], s = o.findWrapping(e); if (s && (!r || r.length > s.length) && (r = s, i = o, !s.length) || o.solid) break } if (!r) return null; this.sync(i); for (let a = 0; a < r.length; a++)t = this.enterInner(r[a], null, t, !1); return t } insertNode(e, t) { if (e.isInline && this.needsBlock && !this.top.type) { let i = this.textblockFromContext(); i && (t = this.enterInner(i, null, t)) } let r = this.findPlace(e, t); if (r) { this.closeExtra(); let i = this.top; i.match && (i.match = i.match.matchType(e.type)); let a = Hn.none; for (let o of r.concat(e.marks)) (i.type ? i.type.allowsMarkType(o.type) : lF(o.type, e.type)) && (a = o.addToSet(a)); return i.content.push(e.mark(a)), !0 } return !1 } enter(e, t, r, i) { let a = this.findPlace(e.create(t), r); return a && (a = this.enterInner(e, t, r, !0, i)), a } enterInner(e, t, r, i = !1, a) { this.closeExtra(); let o = this.top; o.match = o.match && o.match.matchType(e); let s = aF(e, a, o.options); o.options & t0 && o.content.length == 0 && (s |= t0); let l = Hn.none; return r = r.filter(c => (o.type ? o.type.allowsMarkType(c.type) : lF(c.type, e)) ? (l = c.addToSet(l), !1) : !0), this.nodes.push(new Z1(e, t, l, i, null, s)), this.open++, r } closeExtra(e = !1) { let t = this.nodes.length - 1; if (t > this.open) { for (; t > this.open; t--)this.nodes[t - 1].content.push(this.nodes[t].finish(e)); this.nodes.length = this.open + 1 } } finish() { return this.open = 0, this.closeExtra(this.isOpen), this.nodes[0].finish(this.isOpen || this.options.topOpen) } sync(e) { for (let t = this.open; t >= 0; t--)if (this.nodes[t] == e) return this.open = t, !0; return !1 } get currentPos() { this.closeExtra(); let e = 0; for (let t = this.open; t >= 0; t--) { let r = this.nodes[t].content; for (let i = r.length - 1; i >= 0; i--)e += r[i].nodeSize; t && e++ } return e } findAtPoint(e, t) { if (this.find) for (let r = 0; r < this.find.length; r++)this.find[r].node == e && this.find[r].offset == t && (this.find[r].pos = this.currentPos) } findInside(e) { if (this.find) for (let t = 0; t < this.find.length; t++)this.find[t].pos == null && e.nodeType == 1 && e.contains(this.find[t].node) && (this.find[t].pos = this.currentPos) } findAround(e, t, r) { if (e != t && this.find) for (let i = 0; i < this.find.length; i++)this.find[i].pos == null && e.nodeType == 1 && e.contains(this.find[i].node) && t.compareDocumentPosition(this.find[i].node) & (r ? 2 : 4) && (this.find[i].pos = this.currentPos) } findInText(e) { if (this.find) for (let t = 0; t < this.find.length; t++)this.find[t].node == e && (this.find[t].pos = this.currentPos - (e.nodeValue.length - this.find[t].offset)) } matchesContext(e) { if (e.indexOf("|") > -1) return e.split(/\s*\|\s*/).some(this.matchesContext, this); let t = e.split("/"), r = this.options.context, i = !this.isOpen && (!r || r.parent.type == this.nodes[0].type), a = -(r ? r.depth + 1 : 0) + (i ? 0 : 1), o = (s, l) => { for (; s >= 0; s--) { let c = t[s]; if (c == "") { if (s == t.length - 1 || s == 0) continue; for (; l >= a; l--)if (o(s - 1, l)) return !0; return !1 } else { let u = l > 0 || l == 0 && i ? this.nodes[l].type : r && l >= a ? r.node(l - a).type : null; if (!u || u.name != c && u.groups.indexOf(c) == -1) return !1; l-- } } return !0 }; return o(t.length - 1, this.open) } textblockFromContext() { let e = this.options.context; if (e) for (let t = e.depth; t >= 0; t--) { let r = e.node(t).contentMatchAt(e.indexAfter(t)).defaultType; if (r && r.isTextblock && r.defaultAttrs) return r } for (let t in this.parser.schema.nodes) { let r = this.parser.schema.nodes[t]; if (r.isTextblock && r.defaultAttrs) return r } }
}; function vTe(n) { for (let e = n.firstChild, t = null; e; e = e.nextSibling) { let r = e.nodeType == 1 ? e.nodeName.toLowerCase() : null; r && RZ.hasOwnProperty(r) && t ? (t.appendChild(e), e = t) : r == "li" ? t = e : r && (t = null) } } function yTe(n, e) { return (n.matches || n.msMatchesSelector || n.webkitMatchesSelector || n.mozMatchesSelector).call(n, e) } function sF(n) { let e = {}; for (let t in n) e[t] = n[t]; return e } function lF(n, e) { let t = e.schema.nodes; for (let r in t) { let i = t[r]; if (!i.allowsMarkType(n)) continue; let a = [], o = s => { a.push(s); for (let l = 0; l < s.edgeCount; l++) { let { type: c, next: u } = s.edge(l); if (c == e || a.indexOf(u) < 0 && o(u)) return !0 } }; if (o(i.contentMatch)) return !0 } } class Jh { constructor(e, t) { this.nodes = e, this.marks = t } serializeFragment(e, t = {}, r) { r || (r = xE(t).createDocumentFragment()); let i = r, a = []; return e.forEach(o => { if (a.length || o.marks.length) { let s = 0, l = 0; for (; s < a.length && l < o.marks.length;) { let c = o.marks[l]; if (!this.marks[c.type.name]) { l++; continue } if (!c.eq(a[s][0]) || c.type.spec.spanning === !1) break; s++, l++ } for (; s < a.length;)i = a.pop()[1]; for (; l < o.marks.length;) { let c = o.marks[l++], u = this.serializeMark(c, o.isInline, t); u && (a.push([c, i]), i.appendChild(u.dom), i = u.contentDOM || u.dom) } } i.appendChild(this.serializeNodeInner(o, t)) }), r } serializeNodeInner(e, t) { let { dom: r, contentDOM: i } = Nx(xE(t), this.nodes[e.type.name](e), null, e.attrs); if (i) { if (e.isLeaf) throw new RangeError("Content hole not allowed in a leaf node spec"); this.serializeFragment(e.content, t, i) } return r } serializeNode(e, t = {}) { let r = this.serializeNodeInner(e, t); for (let i = e.marks.length - 1; i >= 0; i--) { let a = this.serializeMark(e.marks[i], e.isInline, t); a && ((a.contentDOM || a.dom).appendChild(r), r = a.dom) } return r } serializeMark(e, t, r = {}) { let i = this.marks[e.type.name]; return i && Nx(xE(r), i(e, t), null, e.attrs) } static renderSpec(e, t, r = null, i) { return Nx(e, t, r, i) } static fromSchema(e) { return e.cached.domSerializer || (e.cached.domSerializer = new Jh(this.nodesFromSchema(e), this.marksFromSchema(e))) } static nodesFromSchema(e) { let t = cF(e.nodes); return t.text || (t.text = r => r.text), t } static marksFromSchema(e) { return cF(e.marks) } } function cF(n) { let e = {}; for (let t in n) { let r = n[t].spec.toDOM; r && (e[t] = r) } return e } function xE(n) { return n.document || window.document } const uF = new WeakMap; function _Te(n) { let e = uF.get(n); return e === void 0 && uF.set(n, e = bTe(n)), e } function bTe(n) { let e = null; function t(r) { if (r && typeof r == "object") if (Array.isArray(r)) if (typeof r[0] == "string") e || (e = []), e.push(r); else for (let i = 0; i < r.length; i++)t(r[i]); else for (let i in r) t(r[i]) } return t(n), e } function Nx(n, e, t, r) { if (typeof e == "string") return { dom: n.createTextNode(e) }; if (e.nodeType != null) return { dom: e }; if (e.dom && e.dom.nodeType != null) return e; let i = e[0], a; if (typeof i != "string") throw new RangeError("Invalid array passed to renderSpec"); if (r && (a = _Te(r)) && a.indexOf(e) > -1) throw new RangeError("Using an array from an attribute object as a DOM spec. This may be an attempted cross site scripting attack."); let o = i.indexOf(" "); o > 0 && (t = i.slice(0, o), i = i.slice(o + 1)); let s, l = t ? n.createElementNS(t, i) : n.createElement(i), c = e[1], u = 1; if (c && typeof c == "object" && c.nodeType == null && !Array.isArray(c)) { u = 2; for (let d in c) if (c[d] != null) { let f = d.indexOf(" "); f > 0 ? l.setAttributeNS(d.slice(0, f), d.slice(f + 1), c[d]) : l.setAttribute(d, c[d]) } } for (let d = u; d < e.length; d++) { let f = e[d]; if (f === 0) { if (d < e.length - 1 || d > u) throw new RangeError("Content hole must be the only child of its parent node"); return { dom: l, contentDOM: l } } else { let { dom: h, contentDOM: p } = Nx(n, f, t, r); if (l.appendChild(h), p) { if (s) throw new RangeError("Multiple content holes"); s = p } } } return { dom: l, contentDOM: s } } const NZ = 65535, BZ = Math.pow(2, 16); function wTe(n, e) { return n + e * BZ } function dF(n) { return n & NZ } function xTe(n) { return (n - (n & NZ)) / BZ } const $Z = 1, FZ = 2, Bx = 4, zZ = 8; class jj { constructor(e, t, r) { this.pos = e, this.delInfo = t, this.recover = r } get deleted() { return (this.delInfo & zZ) > 0 } get deletedBefore() { return (this.delInfo & ($Z | Bx)) > 0 } get deletedAfter() { return (this.delInfo & (FZ | Bx)) > 0 } get deletedAcross() { return (this.delInfo & Bx) > 0 } } class Na { constructor(e, t = !1) { if (this.ranges = e, this.inverted = t, !e.length && Na.empty) return Na.empty } recover(e) { let t = 0, r = dF(e); if (!this.inverted) for (let i = 0; i < r; i++)t += this.ranges[i * 3 + 2] - this.ranges[i * 3 + 1]; return this.ranges[r * 3] + t + xTe(e) } mapResult(e, t = 1) { return this._map(e, t, !1) } map(e, t = 1) { return this._map(e, t, !0) } _map(e, t, r) { let i = 0, a = this.inverted ? 2 : 1, o = this.inverted ? 1 : 2; for (let s = 0; s < this.ranges.length; s += 3) { let l = this.ranges[s] - (this.inverted ? i : 0); if (l > e) break; let c = this.ranges[s + a], u = this.ranges[s + o], d = l + c; if (e <= d) { let f = c ? e == l ? -1 : e == d ? 1 : t : t, h = l + i + (f < 0 ? 0 : u); if (r) return h; let p = e == (t < 0 ? l : d) ? null : wTe(s / 3, e - l), m = e == l ? FZ : e == d ? $Z : Bx; return (t < 0 ? e != l : e != d) && (m |= zZ), new jj(h, m, p) } i += u - c } return r ? e + i : new jj(e + i, 0, null) } touches(e, t) { let r = 0, i = dF(t), a = this.inverted ? 2 : 1, o = this.inverted ? 1 : 2; for (let s = 0; s < this.ranges.length; s += 3) { let l = this.ranges[s] - (this.inverted ? r : 0); if (l > e) break; let c = this.ranges[s + a], u = l + c; if (e <= u && s == i * 3) return !0; r += this.ranges[s + o] - c } return !1 } forEach(e) { let t = this.inverted ? 2 : 1, r = this.inverted ? 1 : 2; for (let i = 0, a = 0; i < this.ranges.length; i += 3) { let o = this.ranges[i], s = o - (this.inverted ? a : 0), l = o + (this.inverted ? 0 : a), c = this.ranges[i + t], u = this.ranges[i + r]; e(s, s + c, l, l + u), a += u - c } } invert() { return new Na(this.ranges, !this.inverted) } toString() { return (this.inverted ? "-" : "") + JSON.stringify(this.ranges) } static offset(e) { return e == 0 ? Na.empty : new Na(e < 0 ? [0, -e, 0] : [0, 0, e]) } } Na.empty = new Na([]); class Um { constructor(e = [], t, r = 0, i = e.length) { this.maps = e, this.mirror = t, this.from = r, this.to = i } slice(e = 0, t = this.maps.length) { return new Um(this.maps, this.mirror, e, t) } copy() { return new Um(this.maps.slice(), this.mirror && this.mirror.slice(), this.from, this.to) } appendMap(e, t) { this.to = this.maps.push(e), t != null && this.setMirror(this.maps.length - 1, t) } appendMapping(e) { for (let t = 0, r = this.maps.length; t < e.maps.length; t++) { let i = e.getMirror(t); this.appendMap(e.maps[t], i != null && i < t ? r + i : void 0) } } getMirror(e) { if (this.mirror) { for (let t = 0; t < this.mirror.length; t++)if (this.mirror[t] == e) return this.mirror[t + (t % 2 ? -1 : 1)] } } setMirror(e, t) { this.mirror || (this.mirror = []), this.mirror.push(e, t) } appendMappingInverted(e) { for (let t = e.maps.length - 1, r = this.maps.length + e.maps.length; t >= 0; t--) { let i = e.getMirror(t); this.appendMap(e.maps[t].invert(), i != null && i > t ? r - i - 1 : void 0) } } invert() { let e = new Um; return e.appendMappingInverted(this), e } map(e, t = 1) { if (this.mirror) return this._map(e, t, !0); for (let r = this.from; r < this.to; r++)e = this.maps[r].map(e, t); return e } mapResult(e, t = 1) { return this._map(e, t, !1) } _map(e, t, r) { let i = 0; for (let a = this.from; a < this.to; a++) { let o = this.maps[a], s = o.mapResult(e, t); if (s.recover != null) { let l = this.getMirror(a); if (l != null && l > a && l < this.to) { a = l, e = this.maps[l].recover(s.recover); continue } } i |= s.delInfo, e = s.pos } return r ? e : new jj(e, i, null) } } const SE = Object.create(null); class Ni { getMap() { return Na.empty } merge(e) { return null } static fromJSON(e, t) { if (!t || !t.stepType) throw new RangeError("Invalid input for Step.fromJSON"); let r = SE[t.stepType]; if (!r) throw new RangeError(`No step type ${t.stepType} defined`); return r.fromJSON(e, t) } static jsonID(e, t) { if (e in SE) throw new RangeError("Duplicate use of step JSON ID " + e); return SE[e] = t, t.prototype.jsonID = e, t } } class Ar { constructor(e, t) { this.doc = e, this.failed = t } static ok(e) { return new Ar(e, null) } static fail(e) { return new Ar(null, e) } static fromReplace(e, t, r, i) { try { return Ar.ok(e.replace(t, r, i)) } catch (a) { if (a instanceof HS) return Ar.fail(a.message); throw a } } } function xR(n, e, t) { let r = []; for (let i = 0; i < n.childCount; i++) { let a = n.child(i); a.content.size && (a = a.copy(xR(a.content, e, a))), a.isInline && (a = e(a, t, i)), r.push(a) } return Be.fromArray(r) } class Bu extends Ni { constructor(e, t, r) { super(), this.from = e, this.to = t, this.mark = r } apply(e) { let t = e.slice(this.from, this.to), r = e.resolve(this.from), i = r.node(r.sharedDepth(this.to)), a = new Qe(xR(t.content, (o, s) => !o.isAtom || !s.type.allowsMarkType(this.mark.type) ? o : o.mark(this.mark.addToSet(o.marks)), i), t.openStart, t.openEnd); return Ar.fromReplace(e, this.from, this.to, a) } invert() { return new al(this.from, this.to, this.mark) } map(e) { let t = e.mapResult(this.from, 1), r = e.mapResult(this.to, -1); return t.deleted && r.deleted || t.pos >= r.pos ? null : new Bu(t.pos, r.pos, this.mark) } merge(e) { return e instanceof Bu && e.mark.eq(this.mark) && this.from <= e.to && this.to >= e.from ? new Bu(Math.min(this.from, e.from), Math.max(this.to, e.to), this.mark) : null } toJSON() { return { stepType: "addMark", mark: this.mark.toJSON(), from: this.from, to: this.to } } static fromJSON(e, t) { if (typeof t.from != "number" || typeof t.to != "number") throw new RangeError("Invalid input for AddMarkStep.fromJSON"); return new Bu(t.from, t.to, e.markFromJSON(t.mark)) } } Ni.jsonID("addMark", Bu); class al extends Ni { constructor(e, t, r) { super(), this.from = e, this.to = t, this.mark = r } apply(e) { let t = e.slice(this.from, this.to), r = new Qe(xR(t.content, i => i.mark(this.mark.removeFromSet(i.marks)), e), t.openStart, t.openEnd); return Ar.fromReplace(e, this.from, this.to, r) } invert() { return new Bu(this.from, this.to, this.mark) } map(e) { let t = e.mapResult(this.from, 1), r = e.mapResult(this.to, -1); return t.deleted && r.deleted || t.pos >= r.pos ? null : new al(t.pos, r.pos, this.mark) } merge(e) { return e instanceof al && e.mark.eq(this.mark) && this.from <= e.to && this.to >= e.from ? new al(Math.min(this.from, e.from), Math.max(this.to, e.to), this.mark) : null } toJSON() { return { stepType: "removeMark", mark: this.mark.toJSON(), from: this.from, to: this.to } } static fromJSON(e, t) { if (typeof t.from != "number" || typeof t.to != "number") throw new RangeError("Invalid input for RemoveMarkStep.fromJSON"); return new al(t.from, t.to, e.markFromJSON(t.mark)) } } Ni.jsonID("removeMark", al); class $u extends Ni { constructor(e, t) { super(), this.pos = e, this.mark = t } apply(e) { let t = e.nodeAt(this.pos); if (!t) return Ar.fail("No node at mark step's position"); let r = t.type.create(t.attrs, null, this.mark.addToSet(t.marks)); return Ar.fromReplace(e, this.pos, this.pos + 1, new Qe(Be.from(r), 0, t.isLeaf ? 0 : 1)) } invert(e) { let t = e.nodeAt(this.pos); if (t) { let r = this.mark.addToSet(t.marks); if (r.length == t.marks.length) { for (let i = 0; i < t.marks.length; i++)if (!t.marks[i].isInSet(r)) return new $u(this.pos, t.marks[i]); return new $u(this.pos, this.mark) } } return new mg(this.pos, this.mark) } map(e) { let t = e.mapResult(this.pos, 1); return t.deletedAfter ? null : new $u(t.pos, this.mark) } toJSON() { return { stepType: "addNodeMark", pos: this.pos, mark: this.mark.toJSON() } } static fromJSON(e, t) { if (typeof t.pos != "number") throw new RangeError("Invalid input for AddNodeMarkStep.fromJSON"); return new $u(t.pos, e.markFromJSON(t.mark)) } } Ni.jsonID("addNodeMark", $u); class mg extends Ni { constructor(e, t) { super(), this.pos = e, this.mark = t } apply(e) { let t = e.nodeAt(this.pos); if (!t) return Ar.fail("No node at mark step's position"); let r = t.type.create(t.attrs, null, this.mark.removeFromSet(t.marks)); return Ar.fromReplace(e, this.pos, this.pos + 1, new Qe(Be.from(r), 0, t.isLeaf ? 0 : 1)) } invert(e) { let t = e.nodeAt(this.pos); return !t || !this.mark.isInSet(t.marks) ? this : new $u(this.pos, this.mark) } map(e) { let t = e.mapResult(this.pos, 1); return t.deletedAfter ? null : new mg(t.pos, this.mark) } toJSON() { return { stepType: "removeNodeMark", pos: this.pos, mark: this.mark.toJSON() } } static fromJSON(e, t) { if (typeof t.pos != "number") throw new RangeError("Invalid input for RemoveNodeMarkStep.fromJSON"); return new mg(t.pos, e.markFromJSON(t.mark)) } } Ni.jsonID("removeNodeMark", mg); class Br extends Ni { constructor(e, t, r, i = !1) { super(), this.from = e, this.to = t, this.slice = r, this.structure = i } apply(e) { return this.structure && Pj(e, this.from, this.to) ? Ar.fail("Structure replace would overwrite content") : Ar.fromReplace(e, this.from, this.to, this.slice) } getMap() { return new Na([this.from, this.to - this.from, this.slice.size]) } invert(e) { return new Br(this.from, this.from + this.slice.size, e.slice(this.from, this.to)) } map(e) { let t = e.mapResult(this.from, 1), r = e.mapResult(this.to, -1); return t.deletedAcross && r.deletedAcross ? null : new Br(t.pos, Math.max(t.pos, r.pos), this.slice) } merge(e) { if (!(e instanceof Br) || e.structure || this.structure) return null; if (this.from + this.slice.size == e.from && !this.slice.openEnd && !e.slice.openStart) { let t = this.slice.size + e.slice.size == 0 ? Qe.empty : new Qe(this.slice.content.append(e.slice.content), this.slice.openStart, e.slice.openEnd); return new Br(this.from, this.to + (e.to - e.from), t, this.structure) } else if (e.to == this.from && !this.slice.openStart && !e.slice.openEnd) { let t = this.slice.size + e.slice.size == 0 ? Qe.empty : new Qe(e.slice.content.append(this.slice.content), e.slice.openStart, this.slice.openEnd); return new Br(e.from, this.to, t, this.structure) } else return null } toJSON() { let e = { stepType: "replace", from: this.from, to: this.to }; return this.slice.size && (e.slice = this.slice.toJSON()), this.structure && (e.structure = !0), e } static fromJSON(e, t) { if (typeof t.from != "number" || typeof t.to != "number") throw new RangeError("Invalid input for ReplaceStep.fromJSON"); return new Br(t.from, t.to, Qe.fromJSON(e, t.slice), !!t.structure) } } Ni.jsonID("replace", Br); class Hr extends Ni { constructor(e, t, r, i, a, o, s = !1) { super(), this.from = e, this.to = t, this.gapFrom = r, this.gapTo = i, this.slice = a, this.insert = o, this.structure = s } apply(e) { if (this.structure && (Pj(e, this.from, this.gapFrom) || Pj(e, this.gapTo, this.to))) return Ar.fail("Structure gap-replace would overwrite content"); let t = e.slice(this.gapFrom, this.gapTo); if (t.openStart || t.openEnd) return Ar.fail("Gap is not a flat range"); let r = this.slice.insertAt(this.insert, t.content); return r ? Ar.fromReplace(e, this.from, this.to, r) : Ar.fail("Content does not fit in gap") } getMap() { return new Na([this.from, this.gapFrom - this.from, this.insert, this.gapTo, this.to - this.gapTo, this.slice.size - this.insert]) } invert(e) { let t = this.gapTo - this.gapFrom; return new Hr(this.from, this.from + this.slice.size + t, this.from + this.insert, this.from + this.insert + t, e.slice(this.from, this.to).removeBetween(this.gapFrom - this.from, this.gapTo - this.from), this.gapFrom - this.from, this.structure) } map(e) { let t = e.mapResult(this.from, 1), r = e.mapResult(this.to, -1), i = this.from == this.gapFrom ? t.pos : e.map(this.gapFrom, -1), a = this.to == this.gapTo ? r.pos : e.map(this.gapTo, 1); return t.deletedAcross && r.deletedAcross || i < t.pos || a > r.pos ? null : new Hr(t.pos, r.pos, i, a, this.slice, this.insert, this.structure) } toJSON() { let e = { stepType: "replaceAround", from: this.from, to: this.to, gapFrom: this.gapFrom, gapTo: this.gapTo, insert: this.insert }; return this.slice.size && (e.slice = this.slice.toJSON()), this.structure && (e.structure = !0), e } static fromJSON(e, t) { if (typeof t.from != "number" || typeof t.to != "number" || typeof t.gapFrom != "number" || typeof t.gapTo != "number" || typeof t.insert != "number") throw new RangeError("Invalid input for ReplaceAroundStep.fromJSON"); return new Hr(t.from, t.to, t.gapFrom, t.gapTo, Qe.fromJSON(e, t.slice), t.insert, !!t.structure) } } Ni.jsonID("replaceAround", Hr); function Pj(n, e, t) { let r = n.resolve(e), i = t - e, a = r.depth; for (; i > 0 && a > 0 && r.indexAfter(a) == r.node(a).childCount;)a--, i--; if (i > 0) { let o = r.node(a).maybeChild(r.indexAfter(a)); for (; i > 0;) { if (!o || o.isLeaf) return !0; o = o.firstChild, i-- } } return !1 } function STe(n, e, t, r) { let i = [], a = [], o, s; n.doc.nodesBetween(e, t, (l, c, u) => { if (!l.isInline) return; let d = l.marks; if (!r.isInSet(d) && u.type.allowsMarkType(r.type)) { let f = Math.max(c, e), h = Math.min(c + l.nodeSize, t), p = r.addToSet(d); for (let m = 0; m < d.length; m++)d[m].isInSet(p) || (o && o.to == f && o.mark.eq(d[m]) ? o.to = h : i.push(o = new al(f, h, d[m]))); s && s.to == f ? s.to = h : a.push(s = new Bu(f, h, r)) } }), i.forEach(l => n.step(l)), a.forEach(l => n.step(l)) } function TTe(n, e, t, r) { let i = [], a = 0; n.doc.nodesBetween(e, t, (o, s) => { if (!o.isInline) return; a++; let l = null; if (r instanceof xk) { let c = o.marks, u; for (; u = r.isInSet(c);)(l || (l = [])).push(u), c = u.removeFromSet(c) } else r ? r.isInSet(o.marks) && (l = [r]) : l = o.marks; if (l && l.length) { let c = Math.min(s + o.nodeSize, t); for (let u = 0; u < l.length; u++) { let d = l[u], f; for (let h = 0; h < i.length; h++) { let p = i[h]; p.step == a - 1 && d.eq(i[h].style) && (f = p) } f ? (f.to = c, f.step = a) : i.push({ style: d, from: Math.max(s, e), to: c, step: a }) } } }), i.forEach(o => n.step(new al(o.from, o.to, o.style))) } function VZ(n, e, t, r = t.contentMatch, i = !0) { let a = n.doc.nodeAt(e), o = [], s = e + 1; for (let l = 0; l < a.childCount; l++) { let c = a.child(l), u = s + c.nodeSize, d = r.matchType(c.type); if (!d) o.push(new Br(s, u, Qe.empty)); else { r = d; for (let f = 0; f < c.marks.length; f++)t.allowsMarkType(c.marks[f].type) || n.step(new al(s, u, c.marks[f])); if (i && c.isText && t.whitespace != "pre") { let f, h = /\r?\n|\r/g, p; for (; f = h.exec(c.text);)p || (p = new Qe(Be.from(t.schema.text(" ", t.allowedMarks(c.marks))), 0, 0)), o.push(new Br(s + f.index, s + f.index + f[0].length, p)) } } s = u } if (!r.validEnd) { let l = r.fillBefore(Be.empty, !0); n.replace(s, s, new Qe(l, 0, 0)) } for (let l = o.length - 1; l >= 0; l--)n.step(o[l]) } function kTe(n, e, t) { return (e == 0 || n.canReplace(e, n.childCount)) && (t == n.childCount || n.canReplace(0, t)) } function Qh(n) { let t = n.parent.content.cutByIndex(n.startIndex, n.endIndex); for (let r = n.depth; ; --r) { let i = n.$from.node(r), a = n.$from.index(r), o = n.$to.indexAfter(r); if (r < n.depth && i.canReplace(a, o, t)) return r; if (r == 0 || i.type.spec.isolating || !kTe(i, a, o)) break } return null } function CTe(n, e, t) { let { $from: r, $to: i, depth: a } = e, o = r.before(a + 1), s = i.after(a + 1), l = o, c = s, u = Be.empty, d = 0; for (let p = a, m = !1; p > t; p--)m || r.index(p) > 0 ? (m = !0, u = Be.from(r.node(p).copy(u)), d++) : l--; let f = Be.empty, h = 0; for (let p = a, m = !1; p > t; p--)m || i.after(p + 1) < i.end(p) ? (m = !0, f = Be.from(i.node(p).copy(f)), h++) : c++; n.step(new Hr(l, c, o, s, new Qe(u.append(f), d, h), u.size - d, !0)) } function SR(n, e, t = null, r = n) { let i = ATe(n, e), a = i && ETe(r, e); return a ? i.map(fF).concat({ type: e, attrs: t }).concat(a.map(fF)) : null } function fF(n) { return { type: n, attrs: null } } function ATe(n, e) { let { parent: t, startIndex: r, endIndex: i } = n, a = t.contentMatchAt(r).findWrapping(e); if (!a) return null; let o = a.length ? a[0] : e; return t.canReplaceWith(r, i, o) ? a : null } function ETe(n, e) { let { parent: t, startIndex: r, endIndex: i } = n, a = t.child(r), o = e.contentMatch.findWrapping(a.type); if (!o) return null; let l = (o.length ? o[o.length - 1] : e).contentMatch; for (let c = r; l && c < i; c++)l = l.matchType(t.child(c).type); return !l || !l.validEnd ? null : o } function MTe(n, e, t) { let r = Be.empty; for (let o = t.length - 1; o >= 0; o--) { if (r.size) { let s = t[o].type.contentMatch.matchFragment(r); if (!s || !s.validEnd) throw new RangeError("Wrapper type given to Transform.wrap does not form valid content of its parent wrapper") } r = Be.from(t[o].type.create(t[o].attrs, r)) } let i = e.start, a = e.end; n.step(new Hr(i, a, i, a, new Qe(r, 0, 0), t.length, !0)) } function OTe(n, e, t, r, i) { if (!r.isTextblock) throw new RangeError("Type given to setBlockType should be a textblock"); let a = n.steps.length; n.doc.nodesBetween(e, t, (o, s) => { let l = typeof i == "function" ? i(o) : i; if (o.isTextblock && !o.hasMarkup(r, l) && PTe(n.doc, n.mapping.slice(a).map(s), r)) { let c = null; if (r.schema.linebreakReplacement) { let h = r.whitespace == "pre", p = !!r.contentMatch.matchType(r.schema.linebreakReplacement); h && !p ? c = !1 : !h && p && (c = !0) } c === !1 && jTe(n, o, s, a), VZ(n, n.mapping.slice(a).map(s, 1), r, void 0, c === null); let u = n.mapping.slice(a), d = u.map(s, 1), f = u.map(s + o.nodeSize, 1); return n.step(new Hr(d, f, d + 1, f - 1, new Qe(Be.from(r.create(l, null, o.marks)), 0, 0), 1, !0)), c === !0 && DTe(n, o, s, a), !1 } }) } function DTe(n, e, t, r) { e.forEach((i, a) => { if (i.isText) { let o, s = /\r?\n|\r/g; for (; o = s.exec(i.text);) { let l = n.mapping.slice(r).map(t + 1 + a + o.index); n.replaceWith(l, l + 1, e.type.schema.linebreakReplacement.create()) } } }) } function jTe(n, e, t, r) {
  e.forEach((i, a) => {
    if (i.type == i.type.schema.linebreakReplacement) {
      let o = n.mapping.slice(r).map(t + 1 + a); n.replaceWith(o, o + 1, e.type.schema.text(`
`))
    }
  })
} function PTe(n, e, t) { let r = n.resolve(e), i = r.index(); return r.parent.canReplaceWith(i, i + 1, t) } function ITe(n, e, t, r, i) { let a = n.doc.nodeAt(e); if (!a) throw new RangeError("No node at given position"); t || (t = a.type); let o = t.create(r, null, i || a.marks); if (a.isLeaf) return n.replaceWith(e, e + a.nodeSize, o); if (!t.validContent(a.content)) throw new RangeError("Invalid content for node type " + t.name); n.step(new Hr(e, e + a.nodeSize, e + 1, e + a.nodeSize - 1, new Qe(Be.from(o), 0, 0), 1, !0)) } function hl(n, e, t = 1, r) { let i = n.resolve(e), a = i.depth - t, o = r && r[r.length - 1] || i.parent; if (a < 0 || i.parent.type.spec.isolating || !i.parent.canReplace(i.index(), i.parent.childCount) || !o.type.validContent(i.parent.content.cutByIndex(i.index(), i.parent.childCount))) return !1; for (let c = i.depth - 1, u = t - 2; c > a; c--, u--) { let d = i.node(c), f = i.index(c); if (d.type.spec.isolating) return !1; let h = d.content.cutByIndex(f, d.childCount), p = r && r[u + 1]; p && (h = h.replaceChild(0, p.type.create(p.attrs))); let m = r && r[u] || d; if (!d.canReplace(f + 1, d.childCount) || !m.type.validContent(h)) return !1 } let s = i.indexAfter(a), l = r && r[0]; return i.node(a).canReplaceWith(s, s, l ? l.type : i.node(a + 1).type) } function LTe(n, e, t = 1, r) { let i = n.doc.resolve(e), a = Be.empty, o = Be.empty; for (let s = i.depth, l = i.depth - t, c = t - 1; s > l; s--, c--) { a = Be.from(i.node(s).copy(a)); let u = r && r[c]; o = Be.from(u ? u.type.create(u.attrs, o) : i.node(s).copy(o)) } n.step(new Br(e, e, new Qe(a.append(o), t, t), !0)) } function Dl(n, e) { let t = n.resolve(e), r = t.index(); return HZ(t.nodeBefore, t.nodeAfter) && t.parent.canReplace(r, r + 1) } function HZ(n, e) { return !!(n && e && !n.isLeaf && n.canAppend(e)) } function Hg(n, e, t = -1) { let r = n.resolve(e); for (let i = r.depth; ; i--) { let a, o, s = r.index(i); if (i == r.depth ? (a = r.nodeBefore, o = r.nodeAfter) : t > 0 ? (a = r.node(i + 1), s++, o = r.node(i).maybeChild(s)) : (a = r.node(i).maybeChild(s - 1), o = r.node(i + 1)), a && !a.isTextblock && HZ(a, o) && r.node(i).canReplace(s, s + 1)) return e; if (i == 0) break; e = t < 0 ? r.before(i) : r.after(i) } } function RTe(n, e, t) { let r = new Br(e - t, e + t, Qe.empty, !0); n.step(r) } function NTe(n, e, t) { let r = n.resolve(e); if (r.parent.canReplaceWith(r.index(), r.index(), t)) return e; if (r.parentOffset == 0) for (let i = r.depth - 1; i >= 0; i--) { let a = r.index(i); if (r.node(i).canReplaceWith(a, a, t)) return r.before(i + 1); if (a > 0) return null } if (r.parentOffset == r.parent.content.size) for (let i = r.depth - 1; i >= 0; i--) { let a = r.indexAfter(i); if (r.node(i).canReplaceWith(a, a, t)) return r.after(i + 1); if (a < r.node(i).childCount) return null } return null } function UZ(n, e, t) { let r = n.resolve(e); if (!t.content.size) return e; let i = t.content; for (let a = 0; a < t.openStart; a++)i = i.firstChild.content; for (let a = 1; a <= (t.openStart == 0 && t.size ? 2 : 1); a++)for (let o = r.depth; o >= 0; o--) { let s = o == r.depth ? 0 : r.pos <= (r.start(o + 1) + r.end(o + 1)) / 2 ? -1 : 1, l = r.index(o) + (s > 0 ? 1 : 0), c = r.node(o), u = !1; if (a == 1) u = c.canReplace(l, l, i); else { let d = c.contentMatchAt(l).findWrapping(i.firstChild.type); u = d && c.canReplaceWith(l, l, d[0]) } if (u) return s == 0 ? r.pos : s < 0 ? r.before(o + 1) : r.after(o + 1) } return null } function Sk(n, e, t = e, r = Qe.empty) { if (e == t && !r.size) return null; let i = n.resolve(e), a = n.resolve(t); return GZ(i, a, r) ? new Br(e, t, r) : new BTe(i, a, r).fit() } function GZ(n, e, t) { return !t.openStart && !t.openEnd && n.start() == e.start() && n.parent.canReplace(n.index(), e.index(), t.content) } class BTe { constructor(e, t, r) { this.$from = e, this.$to = t, this.unplaced = r, this.frontier = [], this.placed = Be.empty; for (let i = 0; i <= e.depth; i++) { let a = e.node(i); this.frontier.push({ type: a.type, match: a.contentMatchAt(e.indexAfter(i)) }) } for (let i = e.depth; i > 0; i--)this.placed = Be.from(e.node(i).copy(this.placed)) } get depth() { return this.frontier.length - 1 } fit() { for (; this.unplaced.size;) { let c = this.findFittable(); c ? this.placeNodes(c) : this.openMore() || this.dropNode() } let e = this.mustMoveInline(), t = this.placed.size - this.depth - this.$from.depth, r = this.$from, i = this.close(e < 0 ? this.$to : r.doc.resolve(e)); if (!i) return null; let a = this.placed, o = r.depth, s = i.depth; for (; o && s && a.childCount == 1;)a = a.firstChild.content, o--, s--; let l = new Qe(a, o, s); return e > -1 ? new Hr(r.pos, e, this.$to.pos, this.$to.end(), l, t) : l.size || r.pos != this.$to.pos ? new Br(r.pos, i.pos, l) : null } findFittable() { let e = this.unplaced.openStart; for (let t = this.unplaced.content, r = 0, i = this.unplaced.openEnd; r < e; r++) { let a = t.firstChild; if (t.childCount > 1 && (i = 0), a.type.spec.isolating && i <= r) { e = r; break } t = a.content } for (let t = 1; t <= 2; t++)for (let r = t == 1 ? e : this.unplaced.openStart; r >= 0; r--) { let i, a = null; r ? (a = TE(this.unplaced.content, r - 1).firstChild, i = a.content) : i = this.unplaced.content; let o = i.firstChild; for (let s = this.depth; s >= 0; s--) { let { type: l, match: c } = this.frontier[s], u, d = null; if (t == 1 && (o ? c.matchType(o.type) || (d = c.fillBefore(Be.from(o), !1)) : a && l.compatibleContent(a.type))) return { sliceDepth: r, frontierDepth: s, parent: a, inject: d }; if (t == 2 && o && (u = c.findWrapping(o.type))) return { sliceDepth: r, frontierDepth: s, parent: a, wrap: u }; if (a && c.matchType(a.type)) break } } } openMore() { let { content: e, openStart: t, openEnd: r } = this.unplaced, i = TE(e, t); return !i.childCount || i.firstChild.isLeaf ? !1 : (this.unplaced = new Qe(e, t + 1, Math.max(r, i.size + t >= e.size - r ? t + 1 : 0)), !0) } dropNode() { let { content: e, openStart: t, openEnd: r } = this.unplaced, i = TE(e, t); if (i.childCount <= 1 && t > 0) { let a = e.size - t <= t + i.size; this.unplaced = new Qe(by(e, t - 1, 1), t - 1, a ? t - 1 : r) } else this.unplaced = new Qe(by(e, t, 1), t, r) } placeNodes({ sliceDepth: e, frontierDepth: t, parent: r, inject: i, wrap: a }) { for (; this.depth > t;)this.closeFrontierNode(); if (a) for (let m = 0; m < a.length; m++)this.openFrontierNode(a[m]); let o = this.unplaced, s = r ? r.content : o.content, l = o.openStart - e, c = 0, u = [], { match: d, type: f } = this.frontier[t]; if (i) { for (let m = 0; m < i.childCount; m++)u.push(i.child(m)); d = d.matchFragment(i) } let h = s.size + e - (o.content.size - o.openEnd); for (; c < s.childCount;) { let m = s.child(c), g = d.matchType(m.type); if (!g) break; c++, (c > 1 || l == 0 || m.content.size) && (d = g, u.push(WZ(m.mark(f.allowedMarks(m.marks)), c == 1 ? l : 0, c == s.childCount ? h : -1))) } let p = c == s.childCount; p || (h = -1), this.placed = wy(this.placed, t, Be.from(u)), this.frontier[t].match = d, p && h < 0 && r && r.type == this.frontier[this.depth].type && this.frontier.length > 1 && this.closeFrontierNode(); for (let m = 0, g = s; m < h; m++) { let y = g.lastChild; this.frontier.push({ type: y.type, match: y.contentMatchAt(y.childCount) }), g = y.content } this.unplaced = p ? e == 0 ? Qe.empty : new Qe(by(o.content, e - 1, 1), e - 1, h < 0 ? o.openEnd : e - 1) : new Qe(by(o.content, e, c), o.openStart, o.openEnd) } mustMoveInline() { if (!this.$to.parent.isTextblock) return -1; let e = this.frontier[this.depth], t; if (!e.type.isTextblock || !kE(this.$to, this.$to.depth, e.type, e.match, !1) || this.$to.depth == this.depth && (t = this.findCloseLevel(this.$to)) && t.depth == this.depth) return -1; let { depth: r } = this.$to, i = this.$to.after(r); for (; r > 1 && i == this.$to.end(--r);)++i; return i } findCloseLevel(e) { e: for (let t = Math.min(this.depth, e.depth); t >= 0; t--) { let { match: r, type: i } = this.frontier[t], a = t < e.depth && e.end(t + 1) == e.pos + (e.depth - (t + 1)), o = kE(e, t, i, r, a); if (o) { for (let s = t - 1; s >= 0; s--) { let { match: l, type: c } = this.frontier[s], u = kE(e, s, c, l, !0); if (!u || u.childCount) continue e } return { depth: t, fit: o, move: a ? e.doc.resolve(e.after(t + 1)) : e } } } } close(e) { let t = this.findCloseLevel(e); if (!t) return null; for (; this.depth > t.depth;)this.closeFrontierNode(); t.fit.childCount && (this.placed = wy(this.placed, t.depth, t.fit)), e = t.move; for (let r = t.depth + 1; r <= e.depth; r++) { let i = e.node(r), a = i.type.contentMatch.fillBefore(i.content, !0, e.index(r)); this.openFrontierNode(i.type, i.attrs, a) } return e } openFrontierNode(e, t = null, r) { let i = this.frontier[this.depth]; i.match = i.match.matchType(e), this.placed = wy(this.placed, this.depth, Be.from(e.create(t, r))), this.frontier.push({ type: e, match: e.contentMatch }) } closeFrontierNode() { let t = this.frontier.pop().match.fillBefore(Be.empty, !0); t.childCount && (this.placed = wy(this.placed, this.frontier.length, t)) } } function by(n, e, t) { return e == 0 ? n.cutByIndex(t, n.childCount) : n.replaceChild(0, n.firstChild.copy(by(n.firstChild.content, e - 1, t))) } function wy(n, e, t) { return e == 0 ? n.append(t) : n.replaceChild(n.childCount - 1, n.lastChild.copy(wy(n.lastChild.content, e - 1, t))) } function TE(n, e) { for (let t = 0; t < e; t++)n = n.firstChild.content; return n } function WZ(n, e, t) { if (e <= 0) return n; let r = n.content; return e > 1 && (r = r.replaceChild(0, WZ(r.firstChild, e - 1, r.childCount == 1 ? t - 1 : 0))), e > 0 && (r = n.type.contentMatch.fillBefore(r).append(r), t <= 0 && (r = r.append(n.type.contentMatch.matchFragment(r).fillBefore(Be.empty, !0)))), n.copy(r) } function kE(n, e, t, r, i) { let a = n.node(e), o = i ? n.indexAfter(e) : n.index(e); if (o == a.childCount && !t.compatibleContent(a.type)) return null; let s = r.fillBefore(a.content, !0, o); return s && !$Te(t, a.content, o) ? s : null } function $Te(n, e, t) { for (let r = t; r < e.childCount; r++)if (!n.allowsMarks(e.child(r).marks)) return !0; return !1 } function FTe(n) { return n.spec.defining || n.spec.definingForContent } function zTe(n, e, t, r) { if (!r.size) return n.deleteRange(e, t); let i = n.doc.resolve(e), a = n.doc.resolve(t); if (GZ(i, a, r)) return n.step(new Br(e, t, r)); let o = qZ(i, n.doc.resolve(t)); o[o.length - 1] == 0 && o.pop(); let s = -(i.depth + 1); o.unshift(s); for (let f = i.depth, h = i.pos - 1; f > 0; f--, h--) { let p = i.node(f).type.spec; if (p.defining || p.definingAsContext || p.isolating) break; o.indexOf(f) > -1 ? s = f : i.before(f) == h && o.splice(1, 0, -f) } let l = o.indexOf(s), c = [], u = r.openStart; for (let f = r.content, h = 0; ; h++) { let p = f.firstChild; if (c.push(p), h == r.openStart) break; f = p.content } for (let f = u - 1; f >= 0; f--) { let h = c[f], p = FTe(h.type); if (p && !h.sameMarkup(i.node(Math.abs(s) - 1))) u = f; else if (p || !h.type.isTextblock) break } for (let f = r.openStart; f >= 0; f--) { let h = (f + u + 1) % (r.openStart + 1), p = c[h]; if (p) for (let m = 0; m < o.length; m++) { let g = o[(m + l) % o.length], y = !0; g < 0 && (y = !1, g = -g); let b = i.node(g - 1), w = i.index(g - 1); if (b.canReplaceWith(w, w, p.type, p.marks)) return n.replace(i.before(g), y ? a.after(g) : t, new Qe(KZ(r.content, 0, r.openStart, h), h, r.openEnd)) } } let d = n.steps.length; for (let f = o.length - 1; f >= 0 && (n.replace(e, t, r), !(n.steps.length > d)); f--) { let h = o[f]; h < 0 || (e = i.before(h), t = a.after(h)) } } function KZ(n, e, t, r, i) { if (e < t) { let a = n.firstChild; n = n.replaceChild(0, a.copy(KZ(a.content, e + 1, t, r, a))) } if (e > r) { let a = i.contentMatchAt(0), o = a.fillBefore(n).append(n); n = o.append(a.matchFragment(o).fillBefore(Be.empty, !0)) } return n } function VTe(n, e, t, r) { if (!r.isInline && e == t && n.doc.resolve(e).parent.content.size) { let i = NTe(n.doc, e, r.type); i != null && (e = t = i) } n.replaceRange(e, t, new Qe(Be.from(r), 0, 0)) } function HTe(n, e, t) { let r = n.doc.resolve(e), i = n.doc.resolve(t), a = qZ(r, i); for (let o = 0; o < a.length; o++) { let s = a[o], l = o == a.length - 1; if (l && s == 0 || r.node(s).type.contentMatch.validEnd) return n.delete(r.start(s), i.end(s)); if (s > 0 && (l || r.node(s - 1).canReplace(r.index(s - 1), i.indexAfter(s - 1)))) return n.delete(r.before(s), i.after(s)) } for (let o = 1; o <= r.depth && o <= i.depth; o++)if (e - r.start(o) == r.depth - o && t > r.end(o) && i.end(o) - t != i.depth - o) return n.delete(r.before(o), t); n.delete(e, t) } function qZ(n, e) { let t = [], r = Math.min(n.depth, e.depth); for (let i = r; i >= 0; i--) { let a = n.start(i); if (a < n.pos - (n.depth - i) || e.end(i) > e.pos + (e.depth - i) || n.node(i).type.spec.isolating || e.node(i).type.spec.isolating) break; (a == e.start(i) || i == n.depth && i == e.depth && n.parent.inlineContent && e.parent.inlineContent && i && e.start(i - 1) == a - 1) && t.push(i) } return t } class Gm extends Ni { constructor(e, t, r) { super(), this.pos = e, this.attr = t, this.value = r } apply(e) { let t = e.nodeAt(this.pos); if (!t) return Ar.fail("No node at attribute step's position"); let r = Object.create(null); for (let a in t.attrs) r[a] = t.attrs[a]; r[this.attr] = this.value; let i = t.type.create(r, null, t.marks); return Ar.fromReplace(e, this.pos, this.pos + 1, new Qe(Be.from(i), 0, t.isLeaf ? 0 : 1)) } getMap() { return Na.empty } invert(e) { return new Gm(this.pos, this.attr, e.nodeAt(this.pos).attrs[this.attr]) } map(e) { let t = e.mapResult(this.pos, 1); return t.deletedAfter ? null : new Gm(t.pos, this.attr, this.value) } toJSON() { return { stepType: "attr", pos: this.pos, attr: this.attr, value: this.value } } static fromJSON(e, t) { if (typeof t.pos != "number" || typeof t.attr != "string") throw new RangeError("Invalid input for AttrStep.fromJSON"); return new Gm(t.pos, t.attr, t.value) } } Ni.jsonID("attr", Gm); class q0 extends Ni { constructor(e, t) { super(), this.attr = e, this.value = t } apply(e) { let t = Object.create(null); for (let i in e.attrs) t[i] = e.attrs[i]; t[this.attr] = this.value; let r = e.type.create(t, e.content, e.marks); return Ar.ok(r) } getMap() { return Na.empty } invert(e) { return new q0(this.attr, e.attrs[this.attr]) } map(e) { return this } toJSON() { return { stepType: "docAttr", attr: this.attr, value: this.value } } static fromJSON(e, t) { if (typeof t.attr != "string") throw new RangeError("Invalid input for DocAttrStep.fromJSON"); return new q0(t.attr, t.value) } } Ni.jsonID("docAttr", q0); let gg = class extends Error { }; gg = function n(e) { let t = Error.call(this, e); return t.__proto__ = n.prototype, t }; gg.prototype = Object.create(Error.prototype); gg.prototype.constructor = gg; gg.prototype.name = "TransformError"; class TR { constructor(e) { this.doc = e, this.steps = [], this.docs = [], this.mapping = new Um } get before() { return this.docs.length ? this.docs[0] : this.doc } step(e) { let t = this.maybeStep(e); if (t.failed) throw new gg(t.failed); return this } maybeStep(e) { let t = e.apply(this.doc); return t.failed || this.addStep(e, t.doc), t } get docChanged() { return this.steps.length > 0 } addStep(e, t) { this.docs.push(this.doc), this.steps.push(e), this.mapping.appendMap(e.getMap()), this.doc = t } replace(e, t = e, r = Qe.empty) { let i = Sk(this.doc, e, t, r); return i && this.step(i), this } replaceWith(e, t, r) { return this.replace(e, t, new Qe(Be.from(r), 0, 0)) } delete(e, t) { return this.replace(e, t, Qe.empty) } insert(e, t) { return this.replaceWith(e, e, t) } replaceRange(e, t, r) { return zTe(this, e, t, r), this } replaceRangeWith(e, t, r) { return VTe(this, e, t, r), this } deleteRange(e, t) { return HTe(this, e, t), this } lift(e, t) { return CTe(this, e, t), this } join(e, t = 1) { return RTe(this, e, t), this } wrap(e, t) { return MTe(this, e, t), this } setBlockType(e, t = e, r, i = null) { return OTe(this, e, t, r, i), this } setNodeMarkup(e, t, r = null, i) { return ITe(this, e, t, r, i), this } setNodeAttribute(e, t, r) { return this.step(new Gm(e, t, r)), this } setDocAttribute(e, t) { return this.step(new q0(e, t)), this } addNodeMark(e, t) { return this.step(new $u(e, t)), this } removeNodeMark(e, t) { if (!(t instanceof Hn)) { let r = this.doc.nodeAt(e); if (!r) throw new RangeError("No node at position " + e); if (t = t.isInSet(r.marks), !t) return this } return this.step(new mg(e, t)), this } split(e, t = 1, r) { return LTe(this, e, t, r), this } addMark(e, t, r) { return STe(this, e, t, r), this } removeMark(e, t, r) { return TTe(this, e, t, r), this } clearIncompatible(e, t, r) { return VZ(this, e, t, r), this } } const CE = Object.create(null); class vt { constructor(e, t, r) { this.$anchor = e, this.$head = t, this.ranges = r || [new YZ(e.min(t), e.max(t))] } get anchor() { return this.$anchor.pos } get head() { return this.$head.pos } get from() { return this.$from.pos } get to() { return this.$to.pos } get $from() { return this.ranges[0].$from } get $to() { return this.ranges[0].$to } get empty() { let e = this.ranges; for (let t = 0; t < e.length; t++)if (e[t].$from.pos != e[t].$to.pos) return !1; return !0 } content() { return this.$from.doc.slice(this.from, this.to, !0) } replace(e, t = Qe.empty) { let r = t.content.lastChild, i = null; for (let s = 0; s < t.openEnd; s++)i = r, r = r.lastChild; let a = e.steps.length, o = this.ranges; for (let s = 0; s < o.length; s++) { let { $from: l, $to: c } = o[s], u = e.mapping.slice(a); e.replaceRange(u.map(l.pos), u.map(c.pos), s ? Qe.empty : t), s == 0 && mF(e, a, (r ? r.isInline : i && i.isTextblock) ? -1 : 1) } } replaceWith(e, t) { let r = e.steps.length, i = this.ranges; for (let a = 0; a < i.length; a++) { let { $from: o, $to: s } = i[a], l = e.mapping.slice(r), c = l.map(o.pos), u = l.map(s.pos); a ? e.deleteRange(c, u) : (e.replaceRangeWith(c, u, t), mF(e, r, t.isInline ? -1 : 1)) } } static findFrom(e, t, r = !1) { let i = e.parent.inlineContent ? new ht(e) : mm(e.node(0), e.parent, e.pos, e.index(), t, r); if (i) return i; for (let a = e.depth - 1; a >= 0; a--) { let o = t < 0 ? mm(e.node(0), e.node(a), e.before(a + 1), e.index(a), t, r) : mm(e.node(0), e.node(a), e.after(a + 1), e.index(a) + 1, t, r); if (o) return o } return null } static near(e, t = 1) { return this.findFrom(e, t) || this.findFrom(e, -t) || new Ro(e.node(0)) } static atStart(e) { return mm(e, e, 0, 0, 1) || new Ro(e) } static atEnd(e) { return mm(e, e, e.content.size, e.childCount, -1) || new Ro(e) } static fromJSON(e, t) { if (!t || !t.type) throw new RangeError("Invalid input for Selection.fromJSON"); let r = CE[t.type]; if (!r) throw new RangeError(`No selection type ${t.type} defined`); return r.fromJSON(e, t) } static jsonID(e, t) { if (e in CE) throw new RangeError("Duplicate use of selection JSON ID " + e); return CE[e] = t, t.prototype.jsonID = e, t } getBookmark() { return ht.between(this.$anchor, this.$head).getBookmark() } } vt.prototype.visible = !0; class YZ { constructor(e, t) { this.$from = e, this.$to = t } } let hF = !1; function pF(n) { !hF && !n.parent.inlineContent && (hF = !0, console.warn("TextSelection endpoint not pointing into a node with inline content (" + n.parent.type.name + ")")) } class ht extends vt { constructor(e, t = e) { pF(e), pF(t), super(e, t) } get $cursor() { return this.$anchor.pos == this.$head.pos ? this.$head : null } map(e, t) { let r = e.resolve(t.map(this.head)); if (!r.parent.inlineContent) return vt.near(r); let i = e.resolve(t.map(this.anchor)); return new ht(i.parent.inlineContent ? i : r, r) } replace(e, t = Qe.empty) { if (super.replace(e, t), t == Qe.empty) { let r = this.$from.marksAcross(this.$to); r && e.ensureMarks(r) } } eq(e) { return e instanceof ht && e.anchor == this.anchor && e.head == this.head } getBookmark() { return new Tk(this.anchor, this.head) } toJSON() { return { type: "text", anchor: this.anchor, head: this.head } } static fromJSON(e, t) { if (typeof t.anchor != "number" || typeof t.head != "number") throw new RangeError("Invalid input for TextSelection.fromJSON"); return new ht(e.resolve(t.anchor), e.resolve(t.head)) } static create(e, t, r = t) { let i = e.resolve(t); return new this(i, r == t ? i : e.resolve(r)) } static between(e, t, r) { let i = e.pos - t.pos; if ((!r || i) && (r = i >= 0 ? 1 : -1), !t.parent.inlineContent) { let a = vt.findFrom(t, r, !0) || vt.findFrom(t, -r, !0); if (a) t = a.$head; else return vt.near(t, r) } return e.parent.inlineContent || (i == 0 ? e = t : (e = (vt.findFrom(e, -r, !0) || vt.findFrom(e, r, !0)).$anchor, e.pos < t.pos != i < 0 && (e = t))), new ht(e, t) } } vt.jsonID("text", ht); class Tk { constructor(e, t) { this.anchor = e, this.head = t } map(e) { return new Tk(e.map(this.anchor), e.map(this.head)) } resolve(e) { return ht.between(e.resolve(this.anchor), e.resolve(this.head)) } } class _t extends vt { constructor(e) { let t = e.nodeAfter, r = e.node(0).resolve(e.pos + t.nodeSize); super(e, r), this.node = t } map(e, t) { let { deleted: r, pos: i } = t.mapResult(this.anchor), a = e.resolve(i); return r ? vt.near(a) : new _t(a) } content() { return new Qe(Be.from(this.node), 0, 0) } eq(e) { return e instanceof _t && e.anchor == this.anchor } toJSON() { return { type: "node", anchor: this.anchor } } getBookmark() { return new kR(this.anchor) } static fromJSON(e, t) { if (typeof t.anchor != "number") throw new RangeError("Invalid input for NodeSelection.fromJSON"); return new _t(e.resolve(t.anchor)) } static create(e, t) { return new _t(e.resolve(t)) } static isSelectable(e) { return !e.isText && e.type.spec.selectable !== !1 } } _t.prototype.visible = !1; vt.jsonID("node", _t); class kR { constructor(e) { this.anchor = e } map(e) { let { deleted: t, pos: r } = e.mapResult(this.anchor); return t ? new Tk(r, r) : new kR(r) } resolve(e) { let t = e.resolve(this.anchor), r = t.nodeAfter; return r && _t.isSelectable(r) ? new _t(t) : vt.near(t) } } class Ro extends vt { constructor(e) { super(e.resolve(0), e.resolve(e.content.size)) } replace(e, t = Qe.empty) { if (t == Qe.empty) { e.delete(0, e.doc.content.size); let r = vt.atStart(e.doc); r.eq(e.selection) || e.setSelection(r) } else super.replace(e, t) } toJSON() { return { type: "all" } } static fromJSON(e) { return new Ro(e) } map(e) { return new Ro(e) } eq(e) { return e instanceof Ro } getBookmark() { return UTe } } vt.jsonID("all", Ro); const UTe = { map() { return this }, resolve(n) { return new Ro(n) } }; function mm(n, e, t, r, i, a = !1) { if (e.inlineContent) return ht.create(n, t); for (let o = r - (i > 0 ? 0 : 1); i > 0 ? o < e.childCount : o >= 0; o += i) { let s = e.child(o); if (s.isAtom) { if (!a && _t.isSelectable(s)) return _t.create(n, t - (i < 0 ? s.nodeSize : 0)) } else { let l = mm(n, s, t + i, i < 0 ? s.childCount : 0, i, a); if (l) return l } t += s.nodeSize * i } return null } function mF(n, e, t) { let r = n.steps.length - 1; if (r < e) return; let i = n.steps[r]; if (!(i instanceof Br || i instanceof Hr)) return; let a = n.mapping.maps[r], o; a.forEach((s, l, c, u) => { o == null && (o = u) }), n.setSelection(vt.near(n.doc.resolve(o), t)) } const gF = 1, X1 = 2, vF = 4; class GTe extends TR { constructor(e) { super(e.doc), this.curSelectionFor = 0, this.updated = 0, this.meta = Object.create(null), this.time = Date.now(), this.curSelection = e.selection, this.storedMarks = e.storedMarks } get selection() { return this.curSelectionFor < this.steps.length && (this.curSelection = this.curSelection.map(this.doc, this.mapping.slice(this.curSelectionFor)), this.curSelectionFor = this.steps.length), this.curSelection } setSelection(e) { if (e.$from.doc != this.doc) throw new RangeError("Selection passed to setSelection must point at the current document"); return this.curSelection = e, this.curSelectionFor = this.steps.length, this.updated = (this.updated | gF) & ~X1, this.storedMarks = null, this } get selectionSet() { return (this.updated & gF) > 0 } setStoredMarks(e) { return this.storedMarks = e, this.updated |= X1, this } ensureMarks(e) { return Hn.sameSet(this.storedMarks || this.selection.$from.marks(), e) || this.setStoredMarks(e), this } addStoredMark(e) { return this.ensureMarks(e.addToSet(this.storedMarks || this.selection.$head.marks())) } removeStoredMark(e) { return this.ensureMarks(e.removeFromSet(this.storedMarks || this.selection.$head.marks())) } get storedMarksSet() { return (this.updated & X1) > 0 } addStep(e, t) { super.addStep(e, t), this.updated = this.updated & ~X1, this.storedMarks = null } setTime(e) { return this.time = e, this } replaceSelection(e) { return this.selection.replace(this, e), this } replaceSelectionWith(e, t = !0) { let r = this.selection; return t && (e = e.mark(this.storedMarks || (r.empty ? r.$from.marks() : r.$from.marksAcross(r.$to) || Hn.none))), r.replaceWith(this, e), this } deleteSelection() { return this.selection.replace(this), this } insertText(e, t, r) { let i = this.doc.type.schema; if (t == null) return e ? this.replaceSelectionWith(i.text(e), !0) : this.deleteSelection(); { if (r == null && (r = t), r = r ?? t, !e) return this.deleteRange(t, r); let a = this.storedMarks; if (!a) { let o = this.doc.resolve(t); a = r == t ? o.marks() : o.marksAcross(this.doc.resolve(r)) } return this.replaceRangeWith(t, r, i.text(e, a)), this.selection.empty || this.setSelection(vt.near(this.selection.$to)), this } } setMeta(e, t) { return this.meta[typeof e == "string" ? e : e.key] = t, this } getMeta(e) { return this.meta[typeof e == "string" ? e : e.key] } get isGeneric() { for (let e in this.meta) return !1; return !0 } scrollIntoView() { return this.updated |= vF, this } get scrolledIntoView() { return (this.updated & vF) > 0 } } function yF(n, e) { return !e || !n ? n : n.bind(e) } class xy { constructor(e, t, r) { this.name = e, this.init = yF(t.init, r), this.apply = yF(t.apply, r) } } const WTe = [new xy("doc", { init(n) { return n.doc || n.schema.topNodeType.createAndFill() }, apply(n) { return n.doc } }), new xy("selection", { init(n, e) { return n.selection || vt.atStart(e.doc) }, apply(n) { return n.selection } }), new xy("storedMarks", { init(n) { return n.storedMarks || null }, apply(n, e, t, r) { return r.selection.$cursor ? n.storedMarks : null } }), new xy("scrollToSelection", { init() { return 0 }, apply(n, e) { return n.scrolledIntoView ? e + 1 : e } })]; class AE { constructor(e, t) { this.schema = e, this.plugins = [], this.pluginsByKey = Object.create(null), this.fields = WTe.slice(), t && t.forEach(r => { if (this.pluginsByKey[r.key]) throw new RangeError("Adding different instances of a keyed plugin (" + r.key + ")"); this.plugins.push(r), this.pluginsByKey[r.key] = r, r.spec.state && this.fields.push(new xy(r.key, r.spec.state, r)) }) } } class Om { constructor(e) { this.config = e } get schema() { return this.config.schema } get plugins() { return this.config.plugins } apply(e) { return this.applyTransaction(e).state } filterTransaction(e, t = -1) { for (let r = 0; r < this.config.plugins.length; r++)if (r != t) { let i = this.config.plugins[r]; if (i.spec.filterTransaction && !i.spec.filterTransaction.call(i, e, this)) return !1 } return !0 } applyTransaction(e) { if (!this.filterTransaction(e)) return { state: this, transactions: [] }; let t = [e], r = this.applyInner(e), i = null; for (; ;) { let a = !1; for (let o = 0; o < this.config.plugins.length; o++) { let s = this.config.plugins[o]; if (s.spec.appendTransaction) { let l = i ? i[o].n : 0, c = i ? i[o].state : this, u = l < t.length && s.spec.appendTransaction.call(s, l ? t.slice(l) : t, c, r); if (u && r.filterTransaction(u, o)) { if (u.setMeta("appendedTransaction", e), !i) { i = []; for (let d = 0; d < this.config.plugins.length; d++)i.push(d < o ? { state: r, n: t.length } : { state: this, n: 0 }) } t.push(u), r = r.applyInner(u), a = !0 } i && (i[o] = { state: r, n: t.length }) } } if (!a) return { state: r, transactions: t } } } applyInner(e) { if (!e.before.eq(this.doc)) throw new RangeError("Applying a mismatched transaction"); let t = new Om(this.config), r = this.config.fields; for (let i = 0; i < r.length; i++) { let a = r[i]; t[a.name] = a.apply(e, this[a.name], this, t) } return t } get tr() { return new GTe(this) } static create(e) { let t = new AE(e.doc ? e.doc.type.schema : e.schema, e.plugins), r = new Om(t); for (let i = 0; i < t.fields.length; i++)r[t.fields[i].name] = t.fields[i].init(e, r); return r } reconfigure(e) { let t = new AE(this.schema, e.plugins), r = t.fields, i = new Om(t); for (let a = 0; a < r.length; a++) { let o = r[a].name; i[o] = this.hasOwnProperty(o) ? this[o] : r[a].init(e, i) } return i } toJSON(e) { let t = { doc: this.doc.toJSON(), selection: this.selection.toJSON() }; if (this.storedMarks && (t.storedMarks = this.storedMarks.map(r => r.toJSON())), e && typeof e == "object") for (let r in e) { if (r == "doc" || r == "selection") throw new RangeError("The JSON fields `doc` and `selection` are reserved"); let i = e[r], a = i.spec.state; a && a.toJSON && (t[r] = a.toJSON.call(i, this[i.key])) } return t } static fromJSON(e, t, r) { if (!t) throw new RangeError("Invalid input for EditorState.fromJSON"); if (!e.schema) throw new RangeError("Required config field 'schema' missing"); let i = new AE(e.schema, e.plugins), a = new Om(i); return i.fields.forEach(o => { if (o.name == "doc") a.doc = td.fromJSON(e.schema, t.doc); else if (o.name == "selection") a.selection = vt.fromJSON(a.doc, t.selection); else if (o.name == "storedMarks") t.storedMarks && (a.storedMarks = t.storedMarks.map(e.schema.markFromJSON)); else { if (r) for (let s in r) { let l = r[s], c = l.spec.state; if (l.key == o.name && c && c.fromJSON && Object.prototype.hasOwnProperty.call(t, s)) { a[o.name] = c.fromJSON.call(l, e, t[s], a); return } } a[o.name] = o.init(e, a) } }), a } } function ZZ(n, e, t) { for (let r in n) { let i = n[r]; i instanceof Function ? i = i.bind(e) : r == "handleDOMEvents" && (i = ZZ(i, e, {})), t[r] = i } return t } class wn { constructor(e) { this.spec = e, this.props = {}, e.props && ZZ(e.props, this, this.props), this.key = e.key ? e.key.key : XZ("plugin") } getState(e) { return e[this.key] } } const EE = Object.create(null); function XZ(n) { return n in EE ? n + "$" + ++EE[n] : (EE[n] = 0, n + "$") } class xn { constructor(e = "key") { this.key = XZ(e) } get(e) { return e.config.pluginsByKey[this.key] } getState(e) { return e[this.key] } } const ci = function (n) { for (var e = 0; ; e++)if (n = n.previousSibling, !n) return e }, Y0 = function (n) { let e = n.assignedSlot || n.parentNode; return e && e.nodeType == 11 ? e.host : e }; let Ij = null; const rc = function (n, e, t) { let r = Ij || (Ij = document.createRange()); return r.setEnd(n, t ?? n.nodeValue.length), r.setStart(n, e || 0), r }, KTe = function () { Ij = null }, $h = function (n, e, t, r) { return t && (_F(n, e, t, r, -1) || _F(n, e, t, r, 1)) }, qTe = /^(img|br|input|textarea|hr)$/i; function _F(n, e, t, r, i) { for (; ;) { if (n == t && e == r) return !0; if (e == (i < 0 ? 0 : So(n))) { let a = n.parentNode; if (!a || a.nodeType != 1 || gb(n) || qTe.test(n.nodeName) || n.contentEditable == "false") return !1; e = ci(n) + (i < 0 ? 0 : 1), n = a } else if (n.nodeType == 1) { if (n = n.childNodes[e + (i < 0 ? -1 : 0)], n.contentEditable == "false") return !1; e = i < 0 ? So(n) : 0 } else return !1 } } function So(n) { return n.nodeType == 3 ? n.nodeValue.length : n.childNodes.length } function YTe(n, e) { for (; ;) { if (n.nodeType == 3 && e) return n; if (n.nodeType == 1 && e > 0) { if (n.contentEditable == "false") return null; n = n.childNodes[e - 1], e = So(n) } else if (n.parentNode && !gb(n)) e = ci(n), n = n.parentNode; else return null } } function ZTe(n, e) { for (; ;) { if (n.nodeType == 3 && e < n.nodeValue.length) return n; if (n.nodeType == 1 && e < n.childNodes.length) { if (n.contentEditable == "false") return null; n = n.childNodes[e], e = 0 } else if (n.parentNode && !gb(n)) e = ci(n) + 1, n = n.parentNode; else return null } } function XTe(n, e, t) { for (let r = e == 0, i = e == So(n); r || i;) { if (n == t) return !0; let a = ci(n); if (n = n.parentNode, !n) return !1; r = r && a == 0, i = i && a == So(n) } } function gb(n) { let e; for (let t = n; t && !(e = t.pmViewDesc); t = t.parentNode); return e && e.node && e.node.isBlock && (e.dom == n || e.contentDOM == n) } const kk = function (n) { return n.focusNode && $h(n.focusNode, n.focusOffset, n.anchorNode, n.anchorOffset) }; function Ff(n, e) { let t = document.createEvent("Event"); return t.initEvent("keydown", !0, !0), t.keyCode = n, t.key = t.code = e, t } function JTe(n) { let e = n.activeElement; for (; e && e.shadowRoot;)e = e.shadowRoot.activeElement; return e } function QTe(n, e, t) { if (n.caretPositionFromPoint) try { let r = n.caretPositionFromPoint(e, t); if (r) return { node: r.offsetNode, offset: Math.min(So(r.offsetNode), r.offset) } } catch { } if (n.caretRangeFromPoint) { let r = n.caretRangeFromPoint(e, t); if (r) return { node: r.startContainer, offset: Math.min(So(r.startContainer), r.startOffset) } } } const bl = typeof navigator < "u" ? navigator : null, bF = typeof document < "u" ? document : null, zd = bl && bl.userAgent || "", Lj = /Edge\/(\d+)/.exec(zd), JZ = /MSIE \d/.exec(zd), Rj = /Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(zd), Sa = !!(JZ || Rj || Lj), rd = JZ ? document.documentMode : Rj ? +Rj[1] : Lj ? +Lj[1] : 0, As = !Sa && /gecko\/(\d+)/i.test(zd); As && +(/Firefox\/(\d+)/.exec(zd) || [0, 0])[1]; const Nj = !Sa && /Chrome\/(\d+)/.exec(zd), Oi = !!Nj, QZ = Nj ? +Nj[1] : 0, Qi = !Sa && !!bl && /Apple Computer/.test(bl.vendor), vg = Qi && (/Mobile\/\w+/.test(zd) || !!bl && bl.maxTouchPoints > 2), _o = vg || (bl ? /Mac/.test(bl.platform) : !1), eke = bl ? /Win/.test(bl.platform) : !1, cs = /Android \d/.test(zd), vb = !!bF && "webkitFontSmoothing" in bF.documentElement.style, tke = vb ? +(/\bAppleWebKit\/(\d+)/.exec(navigator.userAgent) || [0, 0])[1] : 0; function nke(n) { let e = n.defaultView && n.defaultView.visualViewport; return e ? { left: 0, right: e.width, top: 0, bottom: e.height } : { left: 0, right: n.documentElement.clientWidth, top: 0, bottom: n.documentElement.clientHeight } } function Yl(n, e) { return typeof n == "number" ? n : n[e] } function rke(n) { let e = n.getBoundingClientRect(), t = e.width / n.offsetWidth || 1, r = e.height / n.offsetHeight || 1; return { left: e.left, right: e.left + n.clientWidth * t, top: e.top, bottom: e.top + n.clientHeight * r } } function wF(n, e, t) { let r = n.someProp("scrollThreshold") || 0, i = n.someProp("scrollMargin") || 5, a = n.dom.ownerDocument; for (let o = t || n.dom; o; o = Y0(o)) { if (o.nodeType != 1) continue; let s = o, l = s == a.body, c = l ? nke(a) : rke(s), u = 0, d = 0; if (e.top < c.top + Yl(r, "top") ? d = -(c.top - e.top + Yl(i, "top")) : e.bottom > c.bottom - Yl(r, "bottom") && (d = e.bottom - e.top > c.bottom - c.top ? e.top + Yl(i, "top") - c.top : e.bottom - c.bottom + Yl(i, "bottom")), e.left < c.left + Yl(r, "left") ? u = -(c.left - e.left + Yl(i, "left")) : e.right > c.right - Yl(r, "right") && (u = e.right - c.right + Yl(i, "right")), u || d) if (l) a.defaultView.scrollBy(u, d); else { let f = s.scrollLeft, h = s.scrollTop; d && (s.scrollTop += d), u && (s.scrollLeft += u); let p = s.scrollLeft - f, m = s.scrollTop - h; e = { left: e.left - p, top: e.top - m, right: e.right - p, bottom: e.bottom - m } } if (l || /^(fixed|sticky)$/.test(getComputedStyle(o).position)) break } } function ike(n) { let e = n.dom.getBoundingClientRect(), t = Math.max(0, e.top), r, i; for (let a = (e.left + e.right) / 2, o = t + 1; o < Math.min(innerHeight, e.bottom); o += 5) { let s = n.root.elementFromPoint(a, o); if (!s || s == n.dom || !n.dom.contains(s)) continue; let l = s.getBoundingClientRect(); if (l.top >= t - 20) { r = s, i = l.top; break } } return { refDOM: r, refTop: i, stack: eX(n.dom) } } function eX(n) { let e = [], t = n.ownerDocument; for (let r = n; r && (e.push({ dom: r, top: r.scrollTop, left: r.scrollLeft }), n != t); r = Y0(r)); return e } function ake({ refDOM: n, refTop: e, stack: t }) { let r = n ? n.getBoundingClientRect().top : 0; tX(t, r == 0 ? 0 : r - e) } function tX(n, e) { for (let t = 0; t < n.length; t++) { let { dom: r, top: i, left: a } = n[t]; r.scrollTop != i + e && (r.scrollTop = i + e), r.scrollLeft != a && (r.scrollLeft = a) } } let Lp = null; function oke(n) { if (n.setActive) return n.setActive(); if (Lp) return n.focus(Lp); let e = eX(n); n.focus(Lp == null ? { get preventScroll() { return Lp = { preventScroll: !0 }, !0 } } : void 0), Lp || (Lp = !1, tX(e, 0)) } function nX(n, e) { let t, r = 2e8, i, a = 0, o = e.top, s = e.top, l, c; for (let u = n.firstChild, d = 0; u; u = u.nextSibling, d++) { let f; if (u.nodeType == 1) f = u.getClientRects(); else if (u.nodeType == 3) f = rc(u).getClientRects(); else continue; for (let h = 0; h < f.length; h++) { let p = f[h]; if (p.top <= o && p.bottom >= s) { o = Math.max(p.bottom, o), s = Math.min(p.top, s); let m = p.left > e.left ? p.left - e.left : p.right < e.left ? e.left - p.right : 0; if (m < r) { t = u, r = m, i = m && t.nodeType == 3 ? { left: p.right < e.left ? p.right : p.left, top: e.top } : e, u.nodeType == 1 && m && (a = d + (e.left >= (p.left + p.right) / 2 ? 1 : 0)); continue } } else p.top > e.top && !l && p.left <= e.left && p.right >= e.left && (l = u, c = { left: Math.max(p.left, Math.min(p.right, e.left)), top: p.top }); !t && (e.left >= p.right && e.top >= p.top || e.left >= p.left && e.top >= p.bottom) && (a = d + 1) } } return !t && l && (t = l, i = c, r = 0), t && t.nodeType == 3 ? ske(t, i) : !t || r && t.nodeType == 1 ? { node: n, offset: a } : nX(t, i) } function ske(n, e) { let t = n.nodeValue.length, r = document.createRange(); for (let i = 0; i < t; i++) { r.setEnd(n, i + 1), r.setStart(n, i); let a = pu(r, 1); if (a.top != a.bottom && CR(e, a)) return { node: n, offset: i + (e.left >= (a.left + a.right) / 2 ? 1 : 0) } } return { node: n, offset: 0 } } function CR(n, e) { return n.left >= e.left - 1 && n.left <= e.right + 1 && n.top >= e.top - 1 && n.top <= e.bottom + 1 } function lke(n, e) { let t = n.parentNode; return t && /^li$/i.test(t.nodeName) && e.left < n.getBoundingClientRect().left ? t : n } function cke(n, e, t) { let { node: r, offset: i } = nX(e, t), a = -1; if (r.nodeType == 1 && !r.firstChild) { let o = r.getBoundingClientRect(); a = o.left != o.right && t.left > (o.left + o.right) / 2 ? 1 : -1 } return n.docView.posFromDOM(r, i, a) } function uke(n, e, t, r) { let i = -1; for (let a = e, o = !1; a != n.dom;) { let s = n.docView.nearestDesc(a, !0); if (!s) return null; if (s.dom.nodeType == 1 && (s.node.isBlock && s.parent || !s.contentDOM)) { let l = s.dom.getBoundingClientRect(); if (s.node.isBlock && s.parent && (!o && l.left > r.left || l.top > r.top ? i = s.posBefore : (!o && l.right < r.left || l.bottom < r.top) && (i = s.posAfter), o = !0), !s.contentDOM && i < 0 && !s.node.isText) return (s.node.isBlock ? r.top < (l.top + l.bottom) / 2 : r.left < (l.left + l.right) / 2) ? s.posBefore : s.posAfter } a = s.dom.parentNode } return i > -1 ? i : n.docView.posFromDOM(e, t, -1) } function rX(n, e, t) { let r = n.childNodes.length; if (r && t.top < t.bottom) for (let i = Math.max(0, Math.min(r - 1, Math.floor(r * (e.top - t.top) / (t.bottom - t.top)) - 2)), a = i; ;) { let o = n.childNodes[a]; if (o.nodeType == 1) { let s = o.getClientRects(); for (let l = 0; l < s.length; l++) { let c = s[l]; if (CR(e, c)) return rX(o, e, c) } } if ((a = (a + 1) % r) == i) break } return n } function dke(n, e) { let t = n.dom.ownerDocument, r, i = 0, a = QTe(t, e.left, e.top); a && ({ node: r, offset: i } = a); let o = (n.root.elementFromPoint ? n.root : t).elementFromPoint(e.left, e.top), s; if (!o || !n.dom.contains(o.nodeType != 1 ? o.parentNode : o)) { let c = n.dom.getBoundingClientRect(); if (!CR(e, c) || (o = rX(n.dom, e, c), !o)) return null } if (Qi) for (let c = o; r && c; c = Y0(c))c.draggable && (r = void 0); if (o = lke(o, e), r) { if (As && r.nodeType == 1 && (i = Math.min(i, r.childNodes.length), i < r.childNodes.length)) { let u = r.childNodes[i], d; u.nodeName == "IMG" && (d = u.getBoundingClientRect()).right <= e.left && d.bottom > e.top && i++ } let c; vb && i && r.nodeType == 1 && (c = r.childNodes[i - 1]).nodeType == 1 && c.contentEditable == "false" && c.getBoundingClientRect().top >= e.top && i--, r == n.dom && i == r.childNodes.length - 1 && r.lastChild.nodeType == 1 && e.top > r.lastChild.getBoundingClientRect().bottom ? s = n.state.doc.content.size : (i == 0 || r.nodeType != 1 || r.childNodes[i - 1].nodeName != "BR") && (s = uke(n, r, i, e)) } s == null && (s = cke(n, o, e)); let l = n.docView.nearestDesc(o, !0); return { pos: s, inside: l ? l.posAtStart - l.border : -1 } } function xF(n) { return n.top < n.bottom || n.left < n.right } function pu(n, e) { let t = n.getClientRects(); if (t.length) { let r = t[e < 0 ? 0 : t.length - 1]; if (xF(r)) return r } return Array.prototype.find.call(t, xF) || n.getBoundingClientRect() } const fke = /[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/; function iX(n, e, t) { let { node: r, offset: i, atom: a } = n.docView.domFromPos(e, t < 0 ? -1 : 1), o = vb || As; if (r.nodeType == 3) if (o && (fke.test(r.nodeValue) || (t < 0 ? !i : i == r.nodeValue.length))) { let l = pu(rc(r, i, i), t); if (As && i && /\s/.test(r.nodeValue[i - 1]) && i < r.nodeValue.length) { let c = pu(rc(r, i - 1, i - 1), -1); if (c.top == l.top) { let u = pu(rc(r, i, i + 1), -1); if (u.top != l.top) return Bv(u, u.left < c.left) } } return l } else { let l = i, c = i, u = t < 0 ? 1 : -1; return t < 0 && !i ? (c++, u = -1) : t >= 0 && i == r.nodeValue.length ? (l--, u = 1) : t < 0 ? l-- : c++, Bv(pu(rc(r, l, c), u), u < 0) } if (!n.state.doc.resolve(e - (a || 0)).parent.inlineContent) { if (a == null && i && (t < 0 || i == So(r))) { let l = r.childNodes[i - 1]; if (l.nodeType == 1) return ME(l.getBoundingClientRect(), !1) } if (a == null && i < So(r)) { let l = r.childNodes[i]; if (l.nodeType == 1) return ME(l.getBoundingClientRect(), !0) } return ME(r.getBoundingClientRect(), t >= 0) } if (a == null && i && (t < 0 || i == So(r))) { let l = r.childNodes[i - 1], c = l.nodeType == 3 ? rc(l, So(l) - (o ? 0 : 1)) : l.nodeType == 1 && (l.nodeName != "BR" || !l.nextSibling) ? l : null; if (c) return Bv(pu(c, 1), !1) } if (a == null && i < So(r)) { let l = r.childNodes[i]; for (; l.pmViewDesc && l.pmViewDesc.ignoreForCoords;)l = l.nextSibling; let c = l ? l.nodeType == 3 ? rc(l, 0, o ? 0 : 1) : l.nodeType == 1 ? l : null : null; if (c) return Bv(pu(c, -1), !0) } return Bv(pu(r.nodeType == 3 ? rc(r) : r, -t), t >= 0) } function Bv(n, e) { if (n.width == 0) return n; let t = e ? n.left : n.right; return { top: n.top, bottom: n.bottom, left: t, right: t } } function ME(n, e) { if (n.height == 0) return n; let t = e ? n.top : n.bottom; return { top: t, bottom: t, left: n.left, right: n.right } } function aX(n, e, t) { let r = n.state, i = n.root.activeElement; r != e && n.updateState(e), i != n.dom && n.focus(); try { return t() } finally { r != e && n.updateState(r), i != n.dom && i && i.focus() } } function hke(n, e, t) { let r = e.selection, i = t == "up" ? r.$from : r.$to; return aX(n, e, () => { let { node: a } = n.docView.domFromPos(i.pos, t == "up" ? -1 : 1); for (; ;) { let s = n.docView.nearestDesc(a, !0); if (!s) break; if (s.node.isBlock) { a = s.contentDOM || s.dom; break } a = s.dom.parentNode } let o = iX(n, i.pos, 1); for (let s = a.firstChild; s; s = s.nextSibling) { let l; if (s.nodeType == 1) l = s.getClientRects(); else if (s.nodeType == 3) l = rc(s, 0, s.nodeValue.length).getClientRects(); else continue; for (let c = 0; c < l.length; c++) { let u = l[c]; if (u.bottom > u.top + 1 && (t == "up" ? o.top - u.top > (u.bottom - o.top) * 2 : u.bottom - o.bottom > (o.bottom - u.top) * 2)) return !1 } } return !0 }) } const pke = /[\u0590-\u08ac]/; function mke(n, e, t) { let { $head: r } = e.selection; if (!r.parent.isTextblock) return !1; let i = r.parentOffset, a = !i, o = i == r.parent.content.size, s = n.domSelection(); return s ? !pke.test(r.parent.textContent) || !s.modify ? t == "left" || t == "backward" ? a : o : aX(n, e, () => { let { focusNode: l, focusOffset: c, anchorNode: u, anchorOffset: d } = n.domSelectionRange(), f = s.caretBidiLevel; s.modify("move", t, "character"); let h = r.depth ? n.docView.domAfterPos(r.before()) : n.dom, { focusNode: p, focusOffset: m } = n.domSelectionRange(), g = p && !h.contains(p.nodeType == 1 ? p : p.parentNode) || l == p && c == m; try { s.collapse(u, d), l && (l != u || c != d) && s.extend && s.extend(l, c) } catch { } return f != null && (s.caretBidiLevel = f), g }) : r.pos == r.start() || r.pos == r.end() } let SF = null, TF = null, kF = !1; function gke(n, e, t) { return SF == e && TF == t ? kF : (SF = e, TF = t, kF = t == "up" || t == "down" ? hke(n, e, t) : mke(n, e, t)) } const No = 0, CF = 1, Yf = 2, wl = 3; class yb {
  constructor(e, t, r, i) { this.parent = e, this.children = t, this.dom = r, this.contentDOM = i, this.dirty = No, r.pmViewDesc = this } matchesWidget(e) { return !1 } matchesMark(e) { return !1 } matchesNode(e, t, r) { return !1 } matchesHack(e) { return !1 } parseRule() { return null } stopEvent(e) { return !1 } get size() { let e = 0; for (let t = 0; t < this.children.length; t++)e += this.children[t].size; return e } get border() { return 0 } destroy() { this.parent = void 0, this.dom.pmViewDesc == this && (this.dom.pmViewDesc = void 0); for (let e = 0; e < this.children.length; e++)this.children[e].destroy() } posBeforeChild(e) { for (let t = 0, r = this.posAtStart; ; t++) { let i = this.children[t]; if (i == e) return r; r += i.size } } get posBefore() { return this.parent.posBeforeChild(this) } get posAtStart() { return this.parent ? this.parent.posBeforeChild(this) + this.border : 0 } get posAfter() { return this.posBefore + this.size } get posAtEnd() { return this.posAtStart + this.size - 2 * this.border } localPosFromDOM(e, t, r) { if (this.contentDOM && this.contentDOM.contains(e.nodeType == 1 ? e : e.parentNode)) if (r < 0) { let a, o; if (e == this.contentDOM) a = e.childNodes[t - 1]; else { for (; e.parentNode != this.contentDOM;)e = e.parentNode; a = e.previousSibling } for (; a && !((o = a.pmViewDesc) && o.parent == this);)a = a.previousSibling; return a ? this.posBeforeChild(o) + o.size : this.posAtStart } else { let a, o; if (e == this.contentDOM) a = e.childNodes[t]; else { for (; e.parentNode != this.contentDOM;)e = e.parentNode; a = e.nextSibling } for (; a && !((o = a.pmViewDesc) && o.parent == this);)a = a.nextSibling; return a ? this.posBeforeChild(o) : this.posAtEnd } let i; if (e == this.dom && this.contentDOM) i = t > ci(this.contentDOM); else if (this.contentDOM && this.contentDOM != this.dom && this.dom.contains(this.contentDOM)) i = e.compareDocumentPosition(this.contentDOM) & 2; else if (this.dom.firstChild) { if (t == 0) for (let a = e; ; a = a.parentNode) { if (a == this.dom) { i = !1; break } if (a.previousSibling) break } if (i == null && t == e.childNodes.length) for (let a = e; ; a = a.parentNode) { if (a == this.dom) { i = !0; break } if (a.nextSibling) break } } return i ?? r > 0 ? this.posAtEnd : this.posAtStart } nearestDesc(e, t = !1) { for (let r = !0, i = e; i; i = i.parentNode) { let a = this.getDesc(i), o; if (a && (!t || a.node)) if (r && (o = a.nodeDOM) && !(o.nodeType == 1 ? o.contains(e.nodeType == 1 ? e : e.parentNode) : o == e)) r = !1; else return a } } getDesc(e) { let t = e.pmViewDesc; for (let r = t; r; r = r.parent)if (r == this) return t } posFromDOM(e, t, r) { for (let i = e; i; i = i.parentNode) { let a = this.getDesc(i); if (a) return a.localPosFromDOM(e, t, r) } return -1 } descAt(e) { for (let t = 0, r = 0; t < this.children.length; t++) { let i = this.children[t], a = r + i.size; if (r == e && a != r) { for (; !i.border && i.children.length;)i = i.children[0]; return i } if (e < a) return i.descAt(e - r - i.border); r = a } } domFromPos(e, t) { if (!this.contentDOM) return { node: this.dom, offset: 0, atom: e + 1 }; let r = 0, i = 0; for (let a = 0; r < this.children.length; r++) { let o = this.children[r], s = a + o.size; if (s > e || o instanceof sX) { i = e - a; break } a = s } if (i) return this.children[r].domFromPos(i - this.children[r].border, t); for (let a; r && !(a = this.children[r - 1]).size && a instanceof oX && a.side >= 0; r--); if (t <= 0) { let a, o = !0; for (; a = r ? this.children[r - 1] : null, !(!a || a.dom.parentNode == this.contentDOM); r--, o = !1); return a && t && o && !a.border && !a.domAtom ? a.domFromPos(a.size, t) : { node: this.contentDOM, offset: a ? ci(a.dom) + 1 : 0 } } else { let a, o = !0; for (; a = r < this.children.length ? this.children[r] : null, !(!a || a.dom.parentNode == this.contentDOM); r++, o = !1); return a && o && !a.border && !a.domAtom ? a.domFromPos(0, t) : { node: this.contentDOM, offset: a ? ci(a.dom) : this.contentDOM.childNodes.length } } } parseRange(e, t, r = 0) { if (this.children.length == 0) return { node: this.contentDOM, from: e, to: t, fromOffset: 0, toOffset: this.contentDOM.childNodes.length }; let i = -1, a = -1; for (let o = r, s = 0; ; s++) { let l = this.children[s], c = o + l.size; if (i == -1 && e <= c) { let u = o + l.border; if (e >= u && t <= c - l.border && l.node && l.contentDOM && this.contentDOM.contains(l.contentDOM)) return l.parseRange(e, t, u); e = o; for (let d = s; d > 0; d--) { let f = this.children[d - 1]; if (f.size && f.dom.parentNode == this.contentDOM && !f.emptyChildAt(1)) { i = ci(f.dom) + 1; break } e -= f.size } i == -1 && (i = 0) } if (i > -1 && (c > t || s == this.children.length - 1)) { t = c; for (let u = s + 1; u < this.children.length; u++) { let d = this.children[u]; if (d.size && d.dom.parentNode == this.contentDOM && !d.emptyChildAt(-1)) { a = ci(d.dom); break } t += d.size } a == -1 && (a = this.contentDOM.childNodes.length); break } o = c } return { node: this.contentDOM, from: e, to: t, fromOffset: i, toOffset: a } } emptyChildAt(e) { if (this.border || !this.contentDOM || !this.children.length) return !1; let t = this.children[e < 0 ? 0 : this.children.length - 1]; return t.size == 0 || t.emptyChildAt(e) } domAfterPos(e) { let { node: t, offset: r } = this.domFromPos(e, 0); if (t.nodeType != 1 || r == t.childNodes.length) throw new RangeError("No node after pos " + e); return t.childNodes[r] } setSelection(e, t, r, i = !1) {
    let a = Math.min(e, t), o = Math.max(e, t); for (let f = 0, h = 0; f < this.children.length; f++) { let p = this.children[f], m = h + p.size; if (a > h && o < m) return p.setSelection(e - h - p.border, t - h - p.border, r, i); h = m } let s = this.domFromPos(e, e ? -1 : 1), l = t == e ? s : this.domFromPos(t, t ? -1 : 1), c = r.getSelection(), u = !1; if ((As || Qi) && e == t) {
      let { node: f, offset: h } = s; if (f.nodeType == 3) {
        if (u = !!(h && f.nodeValue[h - 1] == `
`), u && h == f.nodeValue.length) for (let p = f, m; p; p = p.parentNode) { if (m = p.nextSibling) { m.nodeName == "BR" && (s = l = { node: m.parentNode, offset: ci(m) + 1 }); break } let g = p.pmViewDesc; if (g && g.node && g.node.isBlock) break }
      } else { let p = f.childNodes[h - 1]; u = p && (p.nodeName == "BR" || p.contentEditable == "false") }
    } if (As && c.focusNode && c.focusNode != l.node && c.focusNode.nodeType == 1) { let f = c.focusNode.childNodes[c.focusOffset]; f && f.contentEditable == "false" && (i = !0) } if (!(i || u && Qi) && $h(s.node, s.offset, c.anchorNode, c.anchorOffset) && $h(l.node, l.offset, c.focusNode, c.focusOffset)) return; let d = !1; if ((c.extend || e == t) && !u) { c.collapse(s.node, s.offset); try { e != t && c.extend(l.node, l.offset), d = !0 } catch { } } if (!d) { if (e > t) { let h = s; s = l, l = h } let f = document.createRange(); f.setEnd(l.node, l.offset), f.setStart(s.node, s.offset), c.removeAllRanges(), c.addRange(f) }
  } ignoreMutation(e) { return !this.contentDOM && e.type != "selection" } get contentLost() { return this.contentDOM && this.contentDOM != this.dom && !this.dom.contains(this.contentDOM) } markDirty(e, t) { for (let r = 0, i = 0; i < this.children.length; i++) { let a = this.children[i], o = r + a.size; if (r == o ? e <= o && t >= r : e < o && t > r) { let s = r + a.border, l = o - a.border; if (e >= s && t <= l) { this.dirty = e == r || t == o ? Yf : CF, e == s && t == l && (a.contentLost || a.dom.parentNode != this.contentDOM) ? a.dirty = wl : a.markDirty(e - s, t - s); return } else a.dirty = a.dom == a.contentDOM && a.dom.parentNode == this.contentDOM && !a.children.length ? Yf : wl } r = o } this.dirty = Yf } markParentsDirty() { let e = 1; for (let t = this.parent; t; t = t.parent, e++) { let r = e == 1 ? Yf : CF; t.dirty < r && (t.dirty = r) } } get domAtom() { return !1 } get ignoreForCoords() { return !1 } isText(e) { return !1 }
} class oX extends yb { constructor(e, t, r, i) { let a, o = t.type.toDOM; if (typeof o == "function" && (o = o(r, () => { if (!a) return i; if (a.parent) return a.parent.posBeforeChild(a) })), !t.type.spec.raw) { if (o.nodeType != 1) { let s = document.createElement("span"); s.appendChild(o), o = s } o.contentEditable = "false", o.classList.add("ProseMirror-widget") } super(e, [], o, null), this.widget = t, this.widget = t, a = this } matchesWidget(e) { return this.dirty == No && e.type.eq(this.widget.type) } parseRule() { return { ignore: !0 } } stopEvent(e) { let t = this.widget.spec.stopEvent; return t ? t(e) : !1 } ignoreMutation(e) { return e.type != "selection" || this.widget.spec.ignoreSelection } destroy() { this.widget.type.destroy(this.dom), super.destroy() } get domAtom() { return !0 } get side() { return this.widget.type.side } } class vke extends yb { constructor(e, t, r, i) { super(e, [], t, null), this.textDOM = r, this.text = i } get size() { return this.text.length } localPosFromDOM(e, t) { return e != this.textDOM ? this.posAtStart + (t ? this.size : 0) : this.posAtStart + t } domFromPos(e) { return { node: this.textDOM, offset: e } } ignoreMutation(e) { return e.type === "characterData" && e.target.nodeValue == e.oldValue } } class Fh extends yb { constructor(e, t, r, i) { super(e, [], r, i), this.mark = t } static create(e, t, r, i) { let a = i.nodeViews[t.type.name], o = a && a(t, i, r); return (!o || !o.dom) && (o = Jh.renderSpec(document, t.type.spec.toDOM(t, r), null, t.attrs)), new Fh(e, t, o.dom, o.contentDOM || o.dom) } parseRule() { return this.dirty & wl || this.mark.type.spec.reparseInView ? null : { mark: this.mark.type.name, attrs: this.mark.attrs, contentElement: this.contentDOM } } matchesMark(e) { return this.dirty != wl && this.mark.eq(e) } markDirty(e, t) { if (super.markDirty(e, t), this.dirty != No) { let r = this.parent; for (; !r.node;)r = r.parent; r.dirty < this.dirty && (r.dirty = this.dirty), this.dirty = No } } slice(e, t, r) { let i = Fh.create(this.parent, this.mark, !0, r), a = this.children, o = this.size; t < o && (a = $j(a, t, o, r)), e > 0 && (a = $j(a, 0, e, r)); for (let s = 0; s < a.length; s++)a[s].parent = i; return i.children = a, i } } class id extends yb { constructor(e, t, r, i, a, o, s, l, c) { super(e, [], a, o), this.node = t, this.outerDeco = r, this.innerDeco = i, this.nodeDOM = s } static create(e, t, r, i, a, o) { let s = a.nodeViews[t.type.name], l, c = s && s(t, a, () => { if (!l) return o; if (l.parent) return l.parent.posBeforeChild(l) }, r, i), u = c && c.dom, d = c && c.contentDOM; if (t.isText) { if (!u) u = document.createTextNode(t.text); else if (u.nodeType != 3) throw new RangeError("Text must be rendered as a DOM text node") } else u || ({ dom: u, contentDOM: d } = Jh.renderSpec(document, t.type.spec.toDOM(t), null, t.attrs)); !d && !t.isText && u.nodeName != "BR" && (u.hasAttribute("contenteditable") || (u.contentEditable = "false"), t.type.spec.draggable && (u.draggable = !0)); let f = u; return u = uX(u, r, t), c ? l = new yke(e, t, r, i, u, d || null, f, c, a, o + 1) : t.isText ? new Ck(e, t, r, i, u, f, a) : new id(e, t, r, i, u, d || null, f, a, o + 1) } parseRule() { if (this.node.type.spec.reparseInView) return null; let e = { node: this.node.type.name, attrs: this.node.attrs }; if (this.node.type.whitespace == "pre" && (e.preserveWhitespace = "full"), !this.contentDOM) e.getContent = () => this.node.content; else if (!this.contentLost) e.contentElement = this.contentDOM; else { for (let t = this.children.length - 1; t >= 0; t--) { let r = this.children[t]; if (this.dom.contains(r.dom.parentNode)) { e.contentElement = r.dom.parentNode; break } } e.contentElement || (e.getContent = () => Be.empty) } return e } matchesNode(e, t, r) { return this.dirty == No && e.eq(this.node) && YS(t, this.outerDeco) && r.eq(this.innerDeco) } get size() { return this.node.nodeSize } get border() { return this.node.isLeaf ? 0 : 1 } updateChildren(e, t) { let r = this.node.inlineContent, i = t, a = e.composing ? this.localCompositionInfo(e, t) : null, o = a && a.pos > -1 ? a : null, s = a && a.pos < 0, l = new bke(this, o && o.node, e); Ske(this.node, this.innerDeco, (c, u, d) => { c.spec.marks ? l.syncToMarks(c.spec.marks, r, e) : c.type.side >= 0 && !d && l.syncToMarks(u == this.node.childCount ? Hn.none : this.node.child(u).marks, r, e), l.placeWidget(c, e, i) }, (c, u, d, f) => { l.syncToMarks(c.marks, r, e); let h; l.findNodeMatch(c, u, d, f) || s && e.state.selection.from > i && e.state.selection.to < i + c.nodeSize && (h = l.findIndexWithChild(a.node)) > -1 && l.updateNodeAt(c, u, d, h, e) || l.updateNextNode(c, u, d, e, f, i) || l.addNode(c, u, d, e, i), i += c.nodeSize }), l.syncToMarks([], r, e), this.node.isTextblock && l.addTextblockHacks(), l.destroyRest(), (l.changed || this.dirty == Yf) && (o && this.protectLocalComposition(e, o), lX(this.contentDOM, this.children, e), vg && Tke(this.dom)) } localCompositionInfo(e, t) { let { from: r, to: i } = e.state.selection; if (!(e.state.selection instanceof ht) || r < t || i > t + this.node.content.size) return null; let a = e.input.compositionNode; if (!a || !this.dom.contains(a.parentNode)) return null; if (this.node.inlineContent) { let o = a.nodeValue, s = kke(this.node.content, o, r - t, i - t); return s < 0 ? null : { node: a, pos: s, text: o } } else return { node: a, pos: -1, text: "" } } protectLocalComposition(e, { node: t, pos: r, text: i }) { if (this.getDesc(t)) return; let a = t; for (; a.parentNode != this.contentDOM; a = a.parentNode) { for (; a.previousSibling;)a.parentNode.removeChild(a.previousSibling); for (; a.nextSibling;)a.parentNode.removeChild(a.nextSibling); a.pmViewDesc && (a.pmViewDesc = void 0) } let o = new vke(this, a, t, i); e.input.compositionNodes.push(o), this.children = $j(this.children, r, r + i.length, e, o) } update(e, t, r, i) { return this.dirty == wl || !e.sameMarkup(this.node) ? !1 : (this.updateInner(e, t, r, i), !0) } updateInner(e, t, r, i) { this.updateOuterDeco(t), this.node = e, this.innerDeco = r, this.contentDOM && this.updateChildren(i, this.posAtStart), this.dirty = No } updateOuterDeco(e) { if (YS(e, this.outerDeco)) return; let t = this.nodeDOM.nodeType != 1, r = this.dom; this.dom = cX(this.dom, this.nodeDOM, Bj(this.outerDeco, this.node, t), Bj(e, this.node, t)), this.dom != r && (r.pmViewDesc = void 0, this.dom.pmViewDesc = this), this.outerDeco = e } selectNode() { this.nodeDOM.nodeType == 1 && this.nodeDOM.classList.add("ProseMirror-selectednode"), (this.contentDOM || !this.node.type.spec.draggable) && (this.dom.draggable = !0) } deselectNode() { this.nodeDOM.nodeType == 1 && (this.nodeDOM.classList.remove("ProseMirror-selectednode"), (this.contentDOM || !this.node.type.spec.draggable) && this.dom.removeAttribute("draggable")) } get domAtom() { return this.node.isAtom } } function AF(n, e, t, r, i) { uX(r, e, n); let a = new id(void 0, n, e, t, r, r, r, i, 0); return a.contentDOM && a.updateChildren(i, 0), a } class Ck extends id { constructor(e, t, r, i, a, o, s) { super(e, t, r, i, a, null, o, s, 0) } parseRule() { let e = this.nodeDOM.parentNode; for (; e && e != this.dom && !e.pmIsDeco;)e = e.parentNode; return { skip: e || !0 } } update(e, t, r, i) { return this.dirty == wl || this.dirty != No && !this.inParent() || !e.sameMarkup(this.node) ? !1 : (this.updateOuterDeco(t), (this.dirty != No || e.text != this.node.text) && e.text != this.nodeDOM.nodeValue && (this.nodeDOM.nodeValue = e.text, i.trackWrites == this.nodeDOM && (i.trackWrites = null)), this.node = e, this.dirty = No, !0) } inParent() { let e = this.parent.contentDOM; for (let t = this.nodeDOM; t; t = t.parentNode)if (t == e) return !0; return !1 } domFromPos(e) { return { node: this.nodeDOM, offset: e } } localPosFromDOM(e, t, r) { return e == this.nodeDOM ? this.posAtStart + Math.min(t, this.node.text.length) : super.localPosFromDOM(e, t, r) } ignoreMutation(e) { return e.type != "characterData" && e.type != "selection" } slice(e, t, r) { let i = this.node.cut(e, t), a = document.createTextNode(i.text); return new Ck(this.parent, i, this.outerDeco, this.innerDeco, a, a, r) } markDirty(e, t) { super.markDirty(e, t), this.dom != this.nodeDOM && (e == 0 || t == this.nodeDOM.nodeValue.length) && (this.dirty = wl) } get domAtom() { return !1 } isText(e) { return this.node.text == e } } class sX extends yb { parseRule() { return { ignore: !0 } } matchesHack(e) { return this.dirty == No && this.dom.nodeName == e } get domAtom() { return !0 } get ignoreForCoords() { return this.dom.nodeName == "IMG" } } class yke extends id { constructor(e, t, r, i, a, o, s, l, c, u) { super(e, t, r, i, a, o, s, c, u), this.spec = l } update(e, t, r, i) { if (this.dirty == wl) return !1; if (this.spec.update) { let a = this.spec.update(e, t, r); return a && this.updateInner(e, t, r, i), a } else return !this.contentDOM && !e.isLeaf ? !1 : super.update(e, t, r, i) } selectNode() { this.spec.selectNode ? this.spec.selectNode() : super.selectNode() } deselectNode() { this.spec.deselectNode ? this.spec.deselectNode() : super.deselectNode() } setSelection(e, t, r, i) { this.spec.setSelection ? this.spec.setSelection(e, t, r) : super.setSelection(e, t, r, i) } destroy() { this.spec.destroy && this.spec.destroy(), super.destroy() } stopEvent(e) { return this.spec.stopEvent ? this.spec.stopEvent(e) : !1 } ignoreMutation(e) { return this.spec.ignoreMutation ? this.spec.ignoreMutation(e) : super.ignoreMutation(e) } } function lX(n, e, t) { let r = n.firstChild, i = !1; for (let a = 0; a < e.length; a++) { let o = e[a], s = o.dom; if (s.parentNode == n) { for (; s != r;)r = EF(r), i = !0; r = r.nextSibling } else i = !0, n.insertBefore(s, r); if (o instanceof Fh) { let l = r ? r.previousSibling : n.lastChild; lX(o.contentDOM, o.children, t), r = l ? l.nextSibling : n.firstChild } } for (; r;)r = EF(r), i = !0; i && t.trackWrites == n && (t.trackWrites = null) } const n0 = function (n) { n && (this.nodeName = n) }; n0.prototype = Object.create(null); const Zf = [new n0]; function Bj(n, e, t) { if (n.length == 0) return Zf; let r = t ? Zf[0] : new n0, i = [r]; for (let a = 0; a < n.length; a++) { let o = n[a].type.attrs; if (o) { o.nodeName && i.push(r = new n0(o.nodeName)); for (let s in o) { let l = o[s]; l != null && (t && i.length == 1 && i.push(r = new n0(e.isInline ? "span" : "div")), s == "class" ? r.class = (r.class ? r.class + " " : "") + l : s == "style" ? r.style = (r.style ? r.style + ";" : "") + l : s != "nodeName" && (r[s] = l)) } } } return i } function cX(n, e, t, r) { if (t == Zf && r == Zf) return e; let i = e; for (let a = 0; a < r.length; a++) { let o = r[a], s = t[a]; if (a) { let l; s && s.nodeName == o.nodeName && i != n && (l = i.parentNode) && l.nodeName.toLowerCase() == o.nodeName || (l = document.createElement(o.nodeName), l.pmIsDeco = !0, l.appendChild(i), s = Zf[0]), i = l } _ke(i, s || Zf[0], o) } return i } function _ke(n, e, t) { for (let r in e) r != "class" && r != "style" && r != "nodeName" && !(r in t) && n.removeAttribute(r); for (let r in t) r != "class" && r != "style" && r != "nodeName" && t[r] != e[r] && n.setAttribute(r, t[r]); if (e.class != t.class) { let r = e.class ? e.class.split(" ").filter(Boolean) : [], i = t.class ? t.class.split(" ").filter(Boolean) : []; for (let a = 0; a < r.length; a++)i.indexOf(r[a]) == -1 && n.classList.remove(r[a]); for (let a = 0; a < i.length; a++)r.indexOf(i[a]) == -1 && n.classList.add(i[a]); n.classList.length == 0 && n.removeAttribute("class") } if (e.style != t.style) { if (e.style) { let r = /\s*([\w\-\xa1-\uffff]+)\s*:(?:"(?:\\.|[^"])*"|'(?:\\.|[^'])*'|\(.*?\)|[^;])*/g, i; for (; i = r.exec(e.style);)n.style.removeProperty(i[1]) } t.style && (n.style.cssText += t.style) } } function uX(n, e, t) { return cX(n, n, Zf, Bj(e, t, n.nodeType != 1)) } function YS(n, e) { if (n.length != e.length) return !1; for (let t = 0; t < n.length; t++)if (!n[t].type.eq(e[t].type)) return !1; return !0 } function EF(n) { let e = n.nextSibling; return n.parentNode.removeChild(n), e } class bke { constructor(e, t, r) { this.lock = t, this.view = r, this.index = 0, this.stack = [], this.changed = !1, this.top = e, this.preMatch = wke(e.node.content, e) } destroyBetween(e, t) { if (e != t) { for (let r = e; r < t; r++)this.top.children[r].destroy(); this.top.children.splice(e, t - e), this.changed = !0 } } destroyRest() { this.destroyBetween(this.index, this.top.children.length) } syncToMarks(e, t, r) { let i = 0, a = this.stack.length >> 1, o = Math.min(a, e.length); for (; i < o && (i == a - 1 ? this.top : this.stack[i + 1 << 1]).matchesMark(e[i]) && e[i].type.spec.spanning !== !1;)i++; for (; i < a;)this.destroyRest(), this.top.dirty = No, this.index = this.stack.pop(), this.top = this.stack.pop(), a--; for (; a < e.length;) { this.stack.push(this.top, this.index + 1); let s = -1; for (let l = this.index; l < Math.min(this.index + 3, this.top.children.length); l++) { let c = this.top.children[l]; if (c.matchesMark(e[a]) && !this.isLocked(c.dom)) { s = l; break } } if (s > -1) s > this.index && (this.changed = !0, this.destroyBetween(this.index, s)), this.top = this.top.children[this.index]; else { let l = Fh.create(this.top, e[a], t, r); this.top.children.splice(this.index, 0, l), this.top = l, this.changed = !0 } this.index = 0, a++ } } findNodeMatch(e, t, r, i) { let a = -1, o; if (i >= this.preMatch.index && (o = this.preMatch.matches[i - this.preMatch.index]).parent == this.top && o.matchesNode(e, t, r)) a = this.top.children.indexOf(o, this.index); else for (let s = this.index, l = Math.min(this.top.children.length, s + 5); s < l; s++) { let c = this.top.children[s]; if (c.matchesNode(e, t, r) && !this.preMatch.matched.has(c)) { a = s; break } } return a < 0 ? !1 : (this.destroyBetween(this.index, a), this.index++, !0) } updateNodeAt(e, t, r, i, a) { let o = this.top.children[i]; return o.dirty == wl && o.dom == o.contentDOM && (o.dirty = Yf), o.update(e, t, r, a) ? (this.destroyBetween(this.index, i), this.index++, !0) : !1 } findIndexWithChild(e) { for (; ;) { let t = e.parentNode; if (!t) return -1; if (t == this.top.contentDOM) { let r = e.pmViewDesc; if (r) { for (let i = this.index; i < this.top.children.length; i++)if (this.top.children[i] == r) return i } return -1 } e = t } } updateNextNode(e, t, r, i, a, o) { for (let s = this.index; s < this.top.children.length; s++) { let l = this.top.children[s]; if (l instanceof id) { let c = this.preMatch.matched.get(l); if (c != null && c != a) return !1; let u = l.dom, d, f = this.isLocked(u) && !(e.isText && l.node && l.node.isText && l.nodeDOM.nodeValue == e.text && l.dirty != wl && YS(t, l.outerDeco)); if (!f && l.update(e, t, r, i)) return this.destroyBetween(this.index, s), l.dom != u && (this.changed = !0), this.index++, !0; if (!f && (d = this.recreateWrapper(l, e, t, r, i, o))) return this.destroyBetween(this.index, s), this.top.children[this.index] = d, d.contentDOM && (d.dirty = Yf, d.updateChildren(i, o + 1), d.dirty = No), this.changed = !0, this.index++, !0; break } } return !1 } recreateWrapper(e, t, r, i, a, o) { if (e.dirty || t.isAtom || !e.children.length || !e.node.content.eq(t.content) || !YS(r, e.outerDeco) || !i.eq(e.innerDeco)) return null; let s = id.create(this.top, t, r, i, a, o); if (s.contentDOM) { s.children = e.children, e.children = []; for (let l of s.children) l.parent = s } return e.destroy(), s } addNode(e, t, r, i, a) { let o = id.create(this.top, e, t, r, i, a); o.contentDOM && o.updateChildren(i, a + 1), this.top.children.splice(this.index++, 0, o), this.changed = !0 } placeWidget(e, t, r) { let i = this.index < this.top.children.length ? this.top.children[this.index] : null; if (i && i.matchesWidget(e) && (e == i.widget || !i.widget.type.toDOM.parentNode)) this.index++; else { let a = new oX(this.top, e, t, r); this.top.children.splice(this.index++, 0, a), this.changed = !0 } } addTextblockHacks() { let e = this.top.children[this.index - 1], t = this.top; for (; e instanceof Fh;)t = e, e = t.children[t.children.length - 1]; (!e || !(e instanceof Ck) || /\n$/.test(e.node.text) || this.view.requiresGeckoHackNode && /\s$/.test(e.node.text)) && ((Qi || Oi) && e && e.dom.contentEditable == "false" && this.addHackNode("IMG", t), this.addHackNode("BR", this.top)) } addHackNode(e, t) { if (t == this.top && this.index < t.children.length && t.children[this.index].matchesHack(e)) this.index++; else { let r = document.createElement(e); e == "IMG" && (r.className = "ProseMirror-separator", r.alt = ""), e == "BR" && (r.className = "ProseMirror-trailingBreak"); let i = new sX(this.top, [], r, null); t != this.top ? t.children.push(i) : t.children.splice(this.index++, 0, i), this.changed = !0 } } isLocked(e) { return this.lock && (e == this.lock || e.nodeType == 1 && e.contains(this.lock.parentNode)) } } function wke(n, e) { let t = e, r = t.children.length, i = n.childCount, a = new Map, o = []; e: for (; i > 0;) { let s; for (; ;)if (r) { let c = t.children[r - 1]; if (c instanceof Fh) t = c, r = c.children.length; else { s = c, r--; break } } else { if (t == e) break e; r = t.parent.children.indexOf(t), t = t.parent } let l = s.node; if (l) { if (l != n.child(i - 1)) break; --i, a.set(s, i), o.push(s) } } return { index: i, matched: a, matches: o.reverse() } } function xke(n, e) { return n.type.side - e.type.side } function Ske(n, e, t, r) { let i = e.locals(n), a = 0; if (i.length == 0) { for (let c = 0; c < n.childCount; c++) { let u = n.child(c); r(u, i, e.forChild(a, u), c), a += u.nodeSize } return } let o = 0, s = [], l = null; for (let c = 0; ;) { let u, d; for (; o < i.length && i[o].to == a;) { let g = i[o++]; g.widget && (u ? (d || (d = [u])).push(g) : u = g) } if (u) if (d) { d.sort(xke); for (let g = 0; g < d.length; g++)t(d[g], c, !!l) } else t(u, c, !!l); let f, h; if (l) h = -1, f = l, l = null; else if (c < n.childCount) h = c, f = n.child(c++); else break; for (let g = 0; g < s.length; g++)s[g].to <= a && s.splice(g--, 1); for (; o < i.length && i[o].from <= a && i[o].to > a;)s.push(i[o++]); let p = a + f.nodeSize; if (f.isText) { let g = p; o < i.length && i[o].from < g && (g = i[o].from); for (let y = 0; y < s.length; y++)s[y].to < g && (g = s[y].to); g < p && (l = f.cut(g - a), f = f.cut(0, g - a), p = g, h = -1) } else for (; o < i.length && i[o].to < p;)o++; let m = f.isInline && !f.isLeaf ? s.filter(g => !g.inline) : s.slice(); r(f, m, e.forChild(a, f), h), a = p } } function Tke(n) { if (n.nodeName == "UL" || n.nodeName == "OL") { let e = n.style.cssText; n.style.cssText = e + "; list-style: square !important", window.getComputedStyle(n).listStyle, n.style.cssText = e } } function kke(n, e, t, r) { for (let i = 0, a = 0; i < n.childCount && a <= r;) { let o = n.child(i++), s = a; if (a += o.nodeSize, !o.isText) continue; let l = o.text; for (; i < n.childCount;) { let c = n.child(i++); if (a += c.nodeSize, !c.isText) break; l += c.text } if (a >= t) { if (a >= r && l.slice(r - e.length - s, r - s) == e) return r - e.length; let c = s < r ? l.lastIndexOf(e, r - s - 1) : -1; if (c >= 0 && c + e.length + s >= t) return s + c; if (t == r && l.length >= r + e.length - s && l.slice(r - s, r - s + e.length) == e) return r } } return -1 } function $j(n, e, t, r, i) { let a = []; for (let o = 0, s = 0; o < n.length; o++) { let l = n[o], c = s, u = s += l.size; c >= t || u <= e ? a.push(l) : (c < e && a.push(l.slice(0, e - c, r)), i && (a.push(i), i = void 0), u > t && a.push(l.slice(t - c, l.size, r))) } return a } function AR(n, e = null) { let t = n.domSelectionRange(), r = n.state.doc; if (!t.focusNode) return null; let i = n.docView.nearestDesc(t.focusNode), a = i && i.size == 0, o = n.docView.posFromDOM(t.focusNode, t.focusOffset, 1); if (o < 0) return null; let s = r.resolve(o), l, c; if (kk(t)) { for (l = o; i && !i.node;)i = i.parent; let d = i.node; if (i && d.isAtom && _t.isSelectable(d) && i.parent && !(d.isInline && XTe(t.focusNode, t.focusOffset, i.dom))) { let f = i.posBefore; c = new _t(o == f ? s : r.resolve(f)) } } else { if (t instanceof n.dom.ownerDocument.defaultView.Selection && t.rangeCount > 1) { let d = o, f = o; for (let h = 0; h < t.rangeCount; h++) { let p = t.getRangeAt(h); d = Math.min(d, n.docView.posFromDOM(p.startContainer, p.startOffset, 1)), f = Math.max(f, n.docView.posFromDOM(p.endContainer, p.endOffset, -1)) } if (d < 0) return null;[l, o] = f == n.state.selection.anchor ? [f, d] : [d, f], s = r.resolve(o) } else l = n.docView.posFromDOM(t.anchorNode, t.anchorOffset, 1); if (l < 0) return null } let u = r.resolve(l); if (!c) { let d = e == "pointer" || n.state.selection.head < s.pos && !a ? 1 : -1; c = ER(n, u, s, d) } return c } function dX(n) { return n.editable ? n.hasFocus() : hX(n) && document.activeElement && document.activeElement.contains(n.dom) } function yc(n, e = !1) { let t = n.state.selection; if (fX(n, t), !!dX(n)) { if (!e && n.input.mouseDown && n.input.mouseDown.allowDefault && Oi) { let r = n.domSelectionRange(), i = n.domObserver.currentSelection; if (r.anchorNode && i.anchorNode && $h(r.anchorNode, r.anchorOffset, i.anchorNode, i.anchorOffset)) { n.input.mouseDown.delayedSelectionSync = !0, n.domObserver.setCurSelection(); return } } if (n.domObserver.disconnectSelection(), n.cursorWrapper) Ake(n); else { let { anchor: r, head: i } = t, a, o; MF && !(t instanceof ht) && (t.$from.parent.inlineContent || (a = OF(n, t.from)), !t.empty && !t.$from.parent.inlineContent && (o = OF(n, t.to))), n.docView.setSelection(r, i, n.root, e), MF && (a && DF(a), o && DF(o)), t.visible ? n.dom.classList.remove("ProseMirror-hideselection") : (n.dom.classList.add("ProseMirror-hideselection"), "onselectionchange" in document && Cke(n)) } n.domObserver.setCurSelection(), n.domObserver.connectSelection() } } const MF = Qi || Oi && QZ < 63; function OF(n, e) { let { node: t, offset: r } = n.docView.domFromPos(e, 0), i = r < t.childNodes.length ? t.childNodes[r] : null, a = r ? t.childNodes[r - 1] : null; if (Qi && i && i.contentEditable == "false") return OE(i); if ((!i || i.contentEditable == "false") && (!a || a.contentEditable == "false")) { if (i) return OE(i); if (a) return OE(a) } } function OE(n) { return n.contentEditable = "true", Qi && n.draggable && (n.draggable = !1, n.wasDraggable = !0), n } function DF(n) { n.contentEditable = "false", n.wasDraggable && (n.draggable = !0, n.wasDraggable = null) } function Cke(n) { let e = n.dom.ownerDocument; e.removeEventListener("selectionchange", n.input.hideSelectionGuard); let t = n.domSelectionRange(), r = t.anchorNode, i = t.anchorOffset; e.addEventListener("selectionchange", n.input.hideSelectionGuard = () => { (t.anchorNode != r || t.anchorOffset != i) && (e.removeEventListener("selectionchange", n.input.hideSelectionGuard), setTimeout(() => { (!dX(n) || n.state.selection.visible) && n.dom.classList.remove("ProseMirror-hideselection") }, 20)) }) } function Ake(n) { let e = n.domSelection(), t = document.createRange(); if (!e) return; let r = n.cursorWrapper.dom, i = r.nodeName == "IMG"; i ? t.setStart(r.parentNode, ci(r) + 1) : t.setStart(r, 0), t.collapse(!0), e.removeAllRanges(), e.addRange(t), !i && !n.state.selection.visible && Sa && rd <= 11 && (r.disabled = !0, r.disabled = !1) } function fX(n, e) { if (e instanceof _t) { let t = n.docView.descAt(e.from); t != n.lastSelectedViewDesc && (jF(n), t && t.selectNode(), n.lastSelectedViewDesc = t) } else jF(n) } function jF(n) { n.lastSelectedViewDesc && (n.lastSelectedViewDesc.parent && n.lastSelectedViewDesc.deselectNode(), n.lastSelectedViewDesc = void 0) } function ER(n, e, t, r) { return n.someProp("createSelectionBetween", i => i(n, e, t)) || ht.between(e, t, r) } function PF(n) { return n.editable && !n.hasFocus() ? !1 : hX(n) } function hX(n) { let e = n.domSelectionRange(); if (!e.anchorNode) return !1; try { return n.dom.contains(e.anchorNode.nodeType == 3 ? e.anchorNode.parentNode : e.anchorNode) && (n.editable || n.dom.contains(e.focusNode.nodeType == 3 ? e.focusNode.parentNode : e.focusNode)) } catch { return !1 } } function Eke(n) { let e = n.docView.domFromPos(n.state.selection.anchor, 0), t = n.domSelectionRange(); return $h(e.node, e.offset, t.anchorNode, t.anchorOffset) } function Fj(n, e) { let { $anchor: t, $head: r } = n.selection, i = e > 0 ? t.max(r) : t.min(r), a = i.parent.inlineContent ? i.depth ? n.doc.resolve(e > 0 ? i.after() : i.before()) : null : i; return a && vt.findFrom(a, e) } function Tu(n, e) { return n.dispatch(n.state.tr.setSelection(e).scrollIntoView()), !0 } function IF(n, e, t) { let r = n.state.selection; if (r instanceof ht) if (t.indexOf("s") > -1) { let { $head: i } = r, a = i.textOffset ? null : e < 0 ? i.nodeBefore : i.nodeAfter; if (!a || a.isText || !a.isLeaf) return !1; let o = n.state.doc.resolve(i.pos + a.nodeSize * (e < 0 ? -1 : 1)); return Tu(n, new ht(r.$anchor, o)) } else if (r.empty) { if (n.endOfTextblock(e > 0 ? "forward" : "backward")) { let i = Fj(n.state, e); return i && i instanceof _t ? Tu(n, i) : !1 } else if (!(_o && t.indexOf("m") > -1)) { let i = r.$head, a = i.textOffset ? null : e < 0 ? i.nodeBefore : i.nodeAfter, o; if (!a || a.isText) return !1; let s = e < 0 ? i.pos - a.nodeSize : i.pos; return a.isAtom || (o = n.docView.descAt(s)) && !o.contentDOM ? _t.isSelectable(a) ? Tu(n, new _t(e < 0 ? n.state.doc.resolve(i.pos - a.nodeSize) : i)) : vb ? Tu(n, new ht(n.state.doc.resolve(e < 0 ? s : s + a.nodeSize))) : !1 : !1 } } else return !1; else { if (r instanceof _t && r.node.isInline) return Tu(n, new ht(e > 0 ? r.$to : r.$from)); { let i = Fj(n.state, e); return i ? Tu(n, i) : !1 } } } function ZS(n) { return n.nodeType == 3 ? n.nodeValue.length : n.childNodes.length } function r0(n, e) { let t = n.pmViewDesc; return t && t.size == 0 && (e < 0 || n.nextSibling || n.nodeName != "BR") } function Rp(n, e) { return e < 0 ? Mke(n) : Oke(n) } function Mke(n) { let e = n.domSelectionRange(), t = e.focusNode, r = e.focusOffset; if (!t) return; let i, a, o = !1; for (As && t.nodeType == 1 && r < ZS(t) && r0(t.childNodes[r], -1) && (o = !0); ;)if (r > 0) { if (t.nodeType != 1) break; { let s = t.childNodes[r - 1]; if (r0(s, -1)) i = t, a = --r; else if (s.nodeType == 3) t = s, r = t.nodeValue.length; else break } } else { if (pX(t)) break; { let s = t.previousSibling; for (; s && r0(s, -1);)i = t.parentNode, a = ci(s), s = s.previousSibling; if (s) t = s, r = ZS(t); else { if (t = t.parentNode, t == n.dom) break; r = 0 } } } o ? zj(n, t, r) : i && zj(n, i, a) } function Oke(n) { let e = n.domSelectionRange(), t = e.focusNode, r = e.focusOffset; if (!t) return; let i = ZS(t), a, o; for (; ;)if (r < i) { if (t.nodeType != 1) break; let s = t.childNodes[r]; if (r0(s, 1)) a = t, o = ++r; else break } else { if (pX(t)) break; { let s = t.nextSibling; for (; s && r0(s, 1);)a = s.parentNode, o = ci(s) + 1, s = s.nextSibling; if (s) t = s, r = 0, i = ZS(t); else { if (t = t.parentNode, t == n.dom) break; r = i = 0 } } } a && zj(n, a, o) } function pX(n) { let e = n.pmViewDesc; return e && e.node && e.node.isBlock } function Dke(n, e) { for (; n && e == n.childNodes.length && !gb(n);)e = ci(n) + 1, n = n.parentNode; for (; n && e < n.childNodes.length;) { let t = n.childNodes[e]; if (t.nodeType == 3) return t; if (t.nodeType == 1 && t.contentEditable == "false") break; n = t, e = 0 } } function jke(n, e) { for (; n && !e && !gb(n);)e = ci(n), n = n.parentNode; for (; n && e;) { let t = n.childNodes[e - 1]; if (t.nodeType == 3) return t; if (t.nodeType == 1 && t.contentEditable == "false") break; n = t, e = n.childNodes.length } } function zj(n, e, t) { if (e.nodeType != 3) { let a, o; (o = Dke(e, t)) ? (e = o, t = 0) : (a = jke(e, t)) && (e = a, t = a.nodeValue.length) } let r = n.domSelection(); if (!r) return; if (kk(r)) { let a = document.createRange(); a.setEnd(e, t), a.setStart(e, t), r.removeAllRanges(), r.addRange(a) } else r.extend && r.extend(e, t); n.domObserver.setCurSelection(); let { state: i } = n; setTimeout(() => { n.state == i && yc(n) }, 50) } function LF(n, e) { let t = n.state.doc.resolve(e); if (!(Oi || eke) && t.parent.inlineContent) { let i = n.coordsAtPos(e); if (e > t.start()) { let a = n.coordsAtPos(e - 1), o = (a.top + a.bottom) / 2; if (o > i.top && o < i.bottom && Math.abs(a.left - i.left) > 1) return a.left < i.left ? "ltr" : "rtl" } if (e < t.end()) { let a = n.coordsAtPos(e + 1), o = (a.top + a.bottom) / 2; if (o > i.top && o < i.bottom && Math.abs(a.left - i.left) > 1) return a.left > i.left ? "ltr" : "rtl" } } return getComputedStyle(n.dom).direction == "rtl" ? "rtl" : "ltr" } function RF(n, e, t) { let r = n.state.selection; if (r instanceof ht && !r.empty || t.indexOf("s") > -1 || _o && t.indexOf("m") > -1) return !1; let { $from: i, $to: a } = r; if (!i.parent.inlineContent || n.endOfTextblock(e < 0 ? "up" : "down")) { let o = Fj(n.state, e); if (o && o instanceof _t) return Tu(n, o) } if (!i.parent.inlineContent) { let o = e < 0 ? i : a, s = r instanceof Ro ? vt.near(o, e) : vt.findFrom(o, e); return s ? Tu(n, s) : !1 } return !1 } function NF(n, e) { if (!(n.state.selection instanceof ht)) return !0; let { $head: t, $anchor: r, empty: i } = n.state.selection; if (!t.sameParent(r)) return !0; if (!i) return !1; if (n.endOfTextblock(e > 0 ? "forward" : "backward")) return !0; let a = !t.textOffset && (e < 0 ? t.nodeBefore : t.nodeAfter); if (a && !a.isText) { let o = n.state.tr; return e < 0 ? o.delete(t.pos - a.nodeSize, t.pos) : o.delete(t.pos, t.pos + a.nodeSize), n.dispatch(o), !0 } return !1 } function BF(n, e, t) { n.domObserver.stop(), e.contentEditable = t, n.domObserver.start() } function Pke(n) { if (!Qi || n.state.selection.$head.parentOffset > 0) return !1; let { focusNode: e, focusOffset: t } = n.domSelectionRange(); if (e && e.nodeType == 1 && t == 0 && e.firstChild && e.firstChild.contentEditable == "false") { let r = e.firstChild; BF(n, r, "true"), setTimeout(() => BF(n, r, "false"), 20) } return !1 } function Ike(n) { let e = ""; return n.ctrlKey && (e += "c"), n.metaKey && (e += "m"), n.altKey && (e += "a"), n.shiftKey && (e += "s"), e } function Lke(n, e) { let t = e.keyCode, r = Ike(e); if (t == 8 || _o && t == 72 && r == "c") return NF(n, -1) || Rp(n, -1); if (t == 46 && !e.shiftKey || _o && t == 68 && r == "c") return NF(n, 1) || Rp(n, 1); if (t == 13 || t == 27) return !0; if (t == 37 || _o && t == 66 && r == "c") { let i = t == 37 ? LF(n, n.state.selection.from) == "ltr" ? -1 : 1 : -1; return IF(n, i, r) || Rp(n, i) } else if (t == 39 || _o && t == 70 && r == "c") { let i = t == 39 ? LF(n, n.state.selection.from) == "ltr" ? 1 : -1 : 1; return IF(n, i, r) || Rp(n, i) } else { if (t == 38 || _o && t == 80 && r == "c") return RF(n, -1, r) || Rp(n, -1); if (t == 40 || _o && t == 78 && r == "c") return Pke(n) || RF(n, 1, r) || Rp(n, 1); if (r == (_o ? "m" : "c") && (t == 66 || t == 73 || t == 89 || t == 90)) return !0 } return !1 } function mX(n, e) {
  n.someProp("transformCopied", h => { e = h(e, n) }); let t = [], { content: r, openStart: i, openEnd: a } = e; for (; i > 1 && a > 1 && r.childCount == 1 && r.firstChild.childCount == 1;) { i--, a--; let h = r.firstChild; t.push(h.type.name, h.attrs != h.type.defaultAttrs ? h.attrs : null), r = h.content } let o = n.someProp("clipboardSerializer") || Jh.fromSchema(n.state.schema), s = wX(), l = s.createElement("div"); l.appendChild(o.serializeFragment(r, { document: s })); let c = l.firstChild, u, d = 0; for (; c && c.nodeType == 1 && (u = bX[c.nodeName.toLowerCase()]);) { for (let h = u.length - 1; h >= 0; h--) { let p = s.createElement(u[h]); for (; l.firstChild;)p.appendChild(l.firstChild); l.appendChild(p), d++ } c = l.firstChild } c && c.nodeType == 1 && c.setAttribute("data-pm-slice", `${i} ${a}${d ? ` -${d}` : ""} ${JSON.stringify(t)}`); let f = n.someProp("clipboardTextSerializer", h => h(e, n)) || e.content.textBetween(0, e.content.size, `

`); return { dom: l, text: f, slice: e }
} function gX(n, e, t, r, i) {
  let a = i.parent.type.spec.code, o, s; if (!t && !e) return null; let l = e && (r || a || !t); if (l) {
    if (n.someProp("transformPastedText", f => { e = f(e, a || r, n) }), a) return e ? new Qe(Be.from(n.state.schema.text(e.replace(/\r\n?/g, `
`))), 0, 0) : Qe.empty; let d = n.someProp("clipboardTextParser", f => f(e, i, r, n)); if (d) s = d; else { let f = i.marks(), { schema: h } = n.state, p = Jh.fromSchema(h); o = document.createElement("div"), e.split(/(?:\r\n?|\n)+/).forEach(m => { let g = o.appendChild(document.createElement("p")); m && g.appendChild(p.serializeNode(h.text(m, f))) }) }
  } else n.someProp("transformPastedHTML", d => { t = d(t, n) }), o = $ke(t), vb && Fke(o); let c = o && o.querySelector("[data-pm-slice]"), u = c && /^(\d+) (\d+)(?: -(\d+))? (.*)/.exec(c.getAttribute("data-pm-slice") || ""); if (u && u[3]) for (let d = +u[3]; d > 0; d--) { let f = o.firstChild; for (; f && f.nodeType != 1;)f = f.nextSibling; if (!f) break; o = f } if (s || (s = (n.someProp("clipboardParser") || n.someProp("domParser") || nd.fromSchema(n.state.schema)).parseSlice(o, { preserveWhitespace: !!(l || u), context: i, ruleFromNode(f) { return f.nodeName == "BR" && !f.nextSibling && f.parentNode && !Rke.test(f.parentNode.nodeName) ? { ignore: !0 } : null } })), u) s = zke($F(s, +u[1], +u[2]), u[4]); else if (s = Qe.maxOpen(Nke(s.content, i), !0), s.openStart || s.openEnd) { let d = 0, f = 0; for (let h = s.content.firstChild; d < s.openStart && !h.type.spec.isolating; d++, h = h.firstChild); for (let h = s.content.lastChild; f < s.openEnd && !h.type.spec.isolating; f++, h = h.lastChild); s = $F(s, d, f) } return n.someProp("transformPasted", d => { s = d(s, n) }), s
} const Rke = /^(a|abbr|acronym|b|cite|code|del|em|i|ins|kbd|label|output|q|ruby|s|samp|span|strong|sub|sup|time|u|tt|var)$/i; function Nke(n, e) { if (n.childCount < 2) return n; for (let t = e.depth; t >= 0; t--) { let i = e.node(t).contentMatchAt(e.index(t)), a, o = []; if (n.forEach(s => { if (!o) return; let l = i.findWrapping(s.type), c; if (!l) return o = null; if (c = o.length && a.length && yX(l, a, s, o[o.length - 1], 0)) o[o.length - 1] = c; else { o.length && (o[o.length - 1] = _X(o[o.length - 1], a.length)); let u = vX(s, l); o.push(u), i = i.matchType(u.type), a = l } }), o) return Be.from(o) } return n } function vX(n, e, t = 0) { for (let r = e.length - 1; r >= t; r--)n = e[r].create(null, Be.from(n)); return n } function yX(n, e, t, r, i) { if (i < n.length && i < e.length && n[i] == e[i]) { let a = yX(n, e, t, r.lastChild, i + 1); if (a) return r.copy(r.content.replaceChild(r.childCount - 1, a)); if (r.contentMatchAt(r.childCount).matchType(i == n.length - 1 ? t.type : n[i + 1])) return r.copy(r.content.append(Be.from(vX(t, n, i + 1)))) } } function _X(n, e) { if (e == 0) return n; let t = n.content.replaceChild(n.childCount - 1, _X(n.lastChild, e - 1)), r = n.contentMatchAt(n.childCount).fillBefore(Be.empty, !0); return n.copy(t.append(r)) } function Vj(n, e, t, r, i, a) { let o = e < 0 ? n.firstChild : n.lastChild, s = o.content; return n.childCount > 1 && (a = 0), i < r - 1 && (s = Vj(s, e, t, r, i + 1, a)), i >= t && (s = e < 0 ? o.contentMatchAt(0).fillBefore(s, a <= i).append(s) : s.append(o.contentMatchAt(o.childCount).fillBefore(Be.empty, !0))), n.replaceChild(e < 0 ? 0 : n.childCount - 1, o.copy(s)) } function $F(n, e, t) { return e < n.openStart && (n = new Qe(Vj(n.content, -1, e, n.openStart, 0, n.openEnd), e, n.openEnd)), t < n.openEnd && (n = new Qe(Vj(n.content, 1, t, n.openEnd, 0, 0), n.openStart, t)), n } const bX = { thead: ["table"], tbody: ["table"], tfoot: ["table"], caption: ["table"], colgroup: ["table"], col: ["table", "colgroup"], tr: ["table", "tbody"], td: ["table", "tbody", "tr"], th: ["table", "tbody", "tr"] }; let FF = null; function wX() { return FF || (FF = document.implementation.createHTMLDocument("title")) } function Bke(n) { let e = window.trustedTypes; return e ? e.createPolicy("detachedDocument", { createHTML: t => t }).createHTML(n) : n } function $ke(n) { let e = /^(\s*<meta [^>]*>)*/.exec(n); e && (n = n.slice(e[0].length)); let t = wX().createElement("div"), r = /<([a-z][^>\s]+)/i.exec(n), i; if ((i = r && bX[r[1].toLowerCase()]) && (n = i.map(a => "<" + a + ">").join("") + n + i.map(a => "</" + a + ">").reverse().join("")), t.innerHTML = Bke(n), i) for (let a = 0; a < i.length; a++)t = t.querySelector(i[a]) || t; return t } function Fke(n) { let e = n.querySelectorAll(Oi ? "span:not([class]):not([style])" : "span.Apple-converted-space"); for (let t = 0; t < e.length; t++) { let r = e[t]; r.childNodes.length == 1 && r.textContent == "" && r.parentNode && r.parentNode.replaceChild(n.ownerDocument.createTextNode(" "), r) } } function zke(n, e) { if (!n.size) return n; let t = n.content.firstChild.type.schema, r; try { r = JSON.parse(e) } catch { return n } let { content: i, openStart: a, openEnd: o } = n; for (let s = r.length - 2; s >= 0; s -= 2) { let l = t.nodes[r[s]]; if (!l || l.hasRequiredAttrs()) break; i = Be.from(l.create(r[s + 1], i)), a++, o++ } return new Qe(i, a, o) } const ea = {}, ta = {}, Vke = { touchstart: !0, touchmove: !0 }; class Hke { constructor() { this.shiftKey = !1, this.mouseDown = null, this.lastKeyCode = null, this.lastKeyCodeTime = 0, this.lastClick = { time: 0, x: 0, y: 0, type: "" }, this.lastSelectionOrigin = null, this.lastSelectionTime = 0, this.lastIOSEnter = 0, this.lastIOSEnterFallbackTimeout = -1, this.lastFocus = 0, this.lastTouch = 0, this.lastAndroidDelete = 0, this.composing = !1, this.compositionNode = null, this.composingTimeout = -1, this.compositionNodes = [], this.compositionEndedAt = -2e8, this.compositionID = 1, this.compositionPendingChanges = 0, this.domChangeCount = 0, this.eventHandlers = Object.create(null), this.hideSelectionGuard = null } } function Uke(n) { for (let e in ea) { let t = ea[e]; n.dom.addEventListener(e, n.input.eventHandlers[e] = r => { Wke(n, r) && !MR(n, r) && (n.editable || !(r.type in ta)) && t(n, r) }, Vke[e] ? { passive: !0 } : void 0) } Qi && n.dom.addEventListener("input", () => null), Hj(n) } function Fu(n, e) { n.input.lastSelectionOrigin = e, n.input.lastSelectionTime = Date.now() } function Gke(n) { n.domObserver.stop(); for (let e in n.input.eventHandlers) n.dom.removeEventListener(e, n.input.eventHandlers[e]); clearTimeout(n.input.composingTimeout), clearTimeout(n.input.lastIOSEnterFallbackTimeout) } function Hj(n) { n.someProp("handleDOMEvents", e => { for (let t in e) n.input.eventHandlers[t] || n.dom.addEventListener(t, n.input.eventHandlers[t] = r => MR(n, r)) }) } function MR(n, e) { return n.someProp("handleDOMEvents", t => { let r = t[e.type]; return r ? r(n, e) || e.defaultPrevented : !1 }) } function Wke(n, e) { if (!e.bubbles) return !0; if (e.defaultPrevented) return !1; for (let t = e.target; t != n.dom; t = t.parentNode)if (!t || t.nodeType == 11 || t.pmViewDesc && t.pmViewDesc.stopEvent(e)) return !1; return !0 } function Kke(n, e) { !MR(n, e) && ea[e.type] && (n.editable || !(e.type in ta)) && ea[e.type](n, e) } ta.keydown = (n, e) => { let t = e; if (n.input.shiftKey = t.keyCode == 16 || t.shiftKey, !SX(n, t) && (n.input.lastKeyCode = t.keyCode, n.input.lastKeyCodeTime = Date.now(), !(cs && Oi && t.keyCode == 13))) if (n.domObserver.selectionChanged(n.domSelectionRange()) ? n.domObserver.flush() : t.keyCode != 229 && n.domObserver.forceFlush(), vg && t.keyCode == 13 && !t.ctrlKey && !t.altKey && !t.metaKey) { let r = Date.now(); n.input.lastIOSEnter = r, n.input.lastIOSEnterFallbackTimeout = setTimeout(() => { n.input.lastIOSEnter == r && (n.someProp("handleKeyDown", i => i(n, Ff(13, "Enter"))), n.input.lastIOSEnter = 0) }, 200) } else n.someProp("handleKeyDown", r => r(n, t)) || Lke(n, t) ? t.preventDefault() : Fu(n, "key") }; ta.keyup = (n, e) => { e.keyCode == 16 && (n.input.shiftKey = !1) }; ta.keypress = (n, e) => { let t = e; if (SX(n, t) || !t.charCode || t.ctrlKey && !t.altKey || _o && t.metaKey) return; if (n.someProp("handleKeyPress", i => i(n, t))) { t.preventDefault(); return } let r = n.state.selection; if (!(r instanceof ht) || !r.$from.sameParent(r.$to)) { let i = String.fromCharCode(t.charCode); !/[\r\n]/.test(i) && !n.someProp("handleTextInput", a => a(n, r.$from.pos, r.$to.pos, i)) && n.dispatch(n.state.tr.insertText(i).scrollIntoView()), t.preventDefault() } }; function Ak(n) { return { left: n.clientX, top: n.clientY } } function qke(n, e) { let t = e.x - n.clientX, r = e.y - n.clientY; return t * t + r * r < 100 } function OR(n, e, t, r, i) { if (r == -1) return !1; let a = n.state.doc.resolve(r); for (let o = a.depth + 1; o > 0; o--)if (n.someProp(e, s => o > a.depth ? s(n, t, a.nodeAfter, a.before(o), i, !0) : s(n, t, a.node(o), a.before(o), i, !1))) return !0; return !1 } function Wm(n, e, t) { if (n.focused || n.focus(), n.state.selection.eq(e)) return; let r = n.state.tr.setSelection(e); t == "pointer" && r.setMeta("pointer", !0), n.dispatch(r) } function Yke(n, e) { if (e == -1) return !1; let t = n.state.doc.resolve(e), r = t.nodeAfter; return r && r.isAtom && _t.isSelectable(r) ? (Wm(n, new _t(t), "pointer"), !0) : !1 } function Zke(n, e) { if (e == -1) return !1; let t = n.state.selection, r, i; t instanceof _t && (r = t.node); let a = n.state.doc.resolve(e); for (let o = a.depth + 1; o > 0; o--) { let s = o > a.depth ? a.nodeAfter : a.node(o); if (_t.isSelectable(s)) { r && t.$from.depth > 0 && o >= t.$from.depth && a.before(t.$from.depth + 1) == t.$from.pos ? i = a.before(t.$from.depth) : i = a.before(o); break } } return i != null ? (Wm(n, _t.create(n.state.doc, i), "pointer"), !0) : !1 } function Xke(n, e, t, r, i) { return OR(n, "handleClickOn", e, t, r) || n.someProp("handleClick", a => a(n, e, r)) || (i ? Zke(n, t) : Yke(n, t)) } function Jke(n, e, t, r) { return OR(n, "handleDoubleClickOn", e, t, r) || n.someProp("handleDoubleClick", i => i(n, e, r)) } function Qke(n, e, t, r) { return OR(n, "handleTripleClickOn", e, t, r) || n.someProp("handleTripleClick", i => i(n, e, r)) || eCe(n, t, r) } function eCe(n, e, t) { if (t.button != 0) return !1; let r = n.state.doc; if (e == -1) return r.inlineContent ? (Wm(n, ht.create(r, 0, r.content.size), "pointer"), !0) : !1; let i = r.resolve(e); for (let a = i.depth + 1; a > 0; a--) { let o = a > i.depth ? i.nodeAfter : i.node(a), s = i.before(a); if (o.inlineContent) Wm(n, ht.create(r, s + 1, s + 1 + o.content.size), "pointer"); else if (_t.isSelectable(o)) Wm(n, _t.create(r, s), "pointer"); else continue; return !0 } } function DR(n) { return XS(n) } const xX = _o ? "metaKey" : "ctrlKey"; ea.mousedown = (n, e) => { let t = e; n.input.shiftKey = t.shiftKey; let r = DR(n), i = Date.now(), a = "singleClick"; i - n.input.lastClick.time < 500 && qke(t, n.input.lastClick) && !t[xX] && (n.input.lastClick.type == "singleClick" ? a = "doubleClick" : n.input.lastClick.type == "doubleClick" && (a = "tripleClick")), n.input.lastClick = { time: i, x: t.clientX, y: t.clientY, type: a }; let o = n.posAtCoords(Ak(t)); o && (a == "singleClick" ? (n.input.mouseDown && n.input.mouseDown.done(), n.input.mouseDown = new tCe(n, o, t, !!r)) : (a == "doubleClick" ? Jke : Qke)(n, o.pos, o.inside, t) ? t.preventDefault() : Fu(n, "pointer")) }; class tCe { constructor(e, t, r, i) { this.view = e, this.pos = t, this.event = r, this.flushed = i, this.delayedSelectionSync = !1, this.mightDrag = null, this.startDoc = e.state.doc, this.selectNode = !!r[xX], this.allowDefault = r.shiftKey; let a, o; if (t.inside > -1) a = e.state.doc.nodeAt(t.inside), o = t.inside; else { let u = e.state.doc.resolve(t.pos); a = u.parent, o = u.depth ? u.before() : 0 } const s = i ? null : r.target, l = s ? e.docView.nearestDesc(s, !0) : null; this.target = l && l.dom.nodeType == 1 ? l.dom : null; let { selection: c } = e.state; (r.button == 0 && a.type.spec.draggable && a.type.spec.selectable !== !1 || c instanceof _t && c.from <= o && c.to > o) && (this.mightDrag = { node: a, pos: o, addAttr: !!(this.target && !this.target.draggable), setUneditable: !!(this.target && As && !this.target.hasAttribute("contentEditable")) }), this.target && this.mightDrag && (this.mightDrag.addAttr || this.mightDrag.setUneditable) && (this.view.domObserver.stop(), this.mightDrag.addAttr && (this.target.draggable = !0), this.mightDrag.setUneditable && setTimeout(() => { this.view.input.mouseDown == this && this.target.setAttribute("contentEditable", "false") }, 20), this.view.domObserver.start()), e.root.addEventListener("mouseup", this.up = this.up.bind(this)), e.root.addEventListener("mousemove", this.move = this.move.bind(this)), Fu(e, "pointer") } done() { this.view.root.removeEventListener("mouseup", this.up), this.view.root.removeEventListener("mousemove", this.move), this.mightDrag && this.target && (this.view.domObserver.stop(), this.mightDrag.addAttr && this.target.removeAttribute("draggable"), this.mightDrag.setUneditable && this.target.removeAttribute("contentEditable"), this.view.domObserver.start()), this.delayedSelectionSync && setTimeout(() => yc(this.view)), this.view.input.mouseDown = null } up(e) { if (this.done(), !this.view.dom.contains(e.target)) return; let t = this.pos; this.view.state.doc != this.startDoc && (t = this.view.posAtCoords(Ak(e))), this.updateAllowDefault(e), this.allowDefault || !t ? Fu(this.view, "pointer") : Xke(this.view, t.pos, t.inside, e, this.selectNode) ? e.preventDefault() : e.button == 0 && (this.flushed || Qi && this.mightDrag && !this.mightDrag.node.isAtom || Oi && !this.view.state.selection.visible && Math.min(Math.abs(t.pos - this.view.state.selection.from), Math.abs(t.pos - this.view.state.selection.to)) <= 2) ? (Wm(this.view, vt.near(this.view.state.doc.resolve(t.pos)), "pointer"), e.preventDefault()) : Fu(this.view, "pointer") } move(e) { this.updateAllowDefault(e), Fu(this.view, "pointer"), e.buttons == 0 && this.done() } updateAllowDefault(e) { !this.allowDefault && (Math.abs(this.event.x - e.clientX) > 4 || Math.abs(this.event.y - e.clientY) > 4) && (this.allowDefault = !0) } } ea.touchstart = n => { n.input.lastTouch = Date.now(), DR(n), Fu(n, "pointer") }; ea.touchmove = n => { n.input.lastTouch = Date.now(), Fu(n, "pointer") }; ea.contextmenu = n => DR(n); function SX(n, e) { return n.composing ? !0 : Qi && Math.abs(e.timeStamp - n.input.compositionEndedAt) < 500 ? (n.input.compositionEndedAt = -2e8, !0) : !1 } const nCe = cs ? 5e3 : -1; ta.compositionstart = ta.compositionupdate = n => { if (!n.composing) { n.domObserver.flush(); let { state: e } = n, t = e.selection.$to; if (e.selection instanceof ht && (e.storedMarks || !t.textOffset && t.parentOffset && t.nodeBefore.marks.some(r => r.type.spec.inclusive === !1))) n.markCursor = n.state.storedMarks || t.marks(), XS(n, !0), n.markCursor = null; else if (XS(n, !e.selection.empty), As && e.selection.empty && t.parentOffset && !t.textOffset && t.nodeBefore.marks.length) { let r = n.domSelectionRange(); for (let i = r.focusNode, a = r.focusOffset; i && i.nodeType == 1 && a != 0;) { let o = a < 0 ? i.lastChild : i.childNodes[a - 1]; if (!o) break; if (o.nodeType == 3) { let s = n.domSelection(); s && s.collapse(o, o.nodeValue.length); break } else i = o, a = -1 } } n.input.composing = !0 } TX(n, nCe) }; ta.compositionend = (n, e) => { n.composing && (n.input.composing = !1, n.input.compositionEndedAt = e.timeStamp, n.input.compositionPendingChanges = n.domObserver.pendingRecords().length ? n.input.compositionID : 0, n.input.compositionNode = null, n.input.compositionPendingChanges && Promise.resolve().then(() => n.domObserver.flush()), n.input.compositionID++, TX(n, 20)) }; function TX(n, e) { clearTimeout(n.input.composingTimeout), e > -1 && (n.input.composingTimeout = setTimeout(() => XS(n), e)) } function kX(n) { for (n.composing && (n.input.composing = !1, n.input.compositionEndedAt = iCe()); n.input.compositionNodes.length > 0;)n.input.compositionNodes.pop().markParentsDirty() } function rCe(n) { let e = n.domSelectionRange(); if (!e.focusNode) return null; let t = YTe(e.focusNode, e.focusOffset), r = ZTe(e.focusNode, e.focusOffset); if (t && r && t != r) { let i = r.pmViewDesc, a = n.domObserver.lastChangedTextNode; if (t == a || r == a) return a; if (!i || !i.isText(r.nodeValue)) return r; if (n.input.compositionNode == r) { let o = t.pmViewDesc; if (!(!o || !o.isText(t.nodeValue))) return r } } return t || r } function iCe() { let n = document.createEvent("Event"); return n.initEvent("event", !0, !0), n.timeStamp } function XS(n, e = !1) { if (!(cs && n.domObserver.flushingSoon >= 0)) { if (n.domObserver.forceFlush(), kX(n), e || n.docView && n.docView.dirty) { let t = AR(n); return t && !t.eq(n.state.selection) ? n.dispatch(n.state.tr.setSelection(t)) : (n.markCursor || e) && !n.state.selection.empty ? n.dispatch(n.state.tr.deleteSelection()) : n.updateState(n.state), !0 } return !1 } } function aCe(n, e) { if (!n.dom.parentNode) return; let t = n.dom.parentNode.appendChild(document.createElement("div")); t.appendChild(e), t.style.cssText = "position: fixed; left: -10000px; top: 10px"; let r = getSelection(), i = document.createRange(); i.selectNodeContents(e), n.dom.blur(), r.removeAllRanges(), r.addRange(i), setTimeout(() => { t.parentNode && t.parentNode.removeChild(t), n.focus() }, 50) } const Z0 = Sa && rd < 15 || vg && tke < 604; ea.copy = ta.cut = (n, e) => { let t = e, r = n.state.selection, i = t.type == "cut"; if (r.empty) return; let a = Z0 ? null : t.clipboardData, o = r.content(), { dom: s, text: l } = mX(n, o); a ? (t.preventDefault(), a.clearData(), a.setData("text/html", s.innerHTML), a.setData("text/plain", l)) : aCe(n, s), i && n.dispatch(n.state.tr.deleteSelection().scrollIntoView().setMeta("uiEvent", "cut")) }; function oCe(n) { return n.openStart == 0 && n.openEnd == 0 && n.content.childCount == 1 ? n.content.firstChild : null } function sCe(n, e) { if (!n.dom.parentNode) return; let t = n.input.shiftKey || n.state.selection.$from.parent.type.spec.code, r = n.dom.parentNode.appendChild(document.createElement(t ? "textarea" : "div")); t || (r.contentEditable = "true"), r.style.cssText = "position: fixed; left: -10000px; top: 10px", r.focus(); let i = n.input.shiftKey && n.input.lastKeyCode != 45; setTimeout(() => { n.focus(), r.parentNode && r.parentNode.removeChild(r), t ? X0(n, r.value, null, i, e) : X0(n, r.textContent, r.innerHTML, i, e) }, 50) } function X0(n, e, t, r, i) { let a = gX(n, e, t, r, n.state.selection.$from); if (n.someProp("handlePaste", l => l(n, i, a || Qe.empty))) return !0; if (!a) return !1; let o = oCe(a), s = o ? n.state.tr.replaceSelectionWith(o, r) : n.state.tr.replaceSelection(a); return n.dispatch(s.scrollIntoView().setMeta("paste", !0).setMeta("uiEvent", "paste")), !0 } function CX(n) { let e = n.getData("text/plain") || n.getData("Text"); if (e) return e; let t = n.getData("text/uri-list"); return t ? t.replace(/\r?\n/g, " ") : "" } ta.paste = (n, e) => { let t = e; if (n.composing && !cs) return; let r = Z0 ? null : t.clipboardData, i = n.input.shiftKey && n.input.lastKeyCode != 45; r && X0(n, CX(r), r.getData("text/html"), i, t) ? t.preventDefault() : sCe(n, t) }; class AX { constructor(e, t, r) { this.slice = e, this.move = t, this.node = r } } const EX = _o ? "altKey" : "ctrlKey"; ea.dragstart = (n, e) => { let t = e, r = n.input.mouseDown; if (r && r.done(), !t.dataTransfer) return; let i = n.state.selection, a = i.empty ? null : n.posAtCoords(Ak(t)), o; if (!(a && a.pos >= i.from && a.pos <= (i instanceof _t ? i.to - 1 : i.to))) { if (r && r.mightDrag) o = _t.create(n.state.doc, r.mightDrag.pos); else if (t.target && t.target.nodeType == 1) { let d = n.docView.nearestDesc(t.target, !0); d && d.node.type.spec.draggable && d != n.docView && (o = _t.create(n.state.doc, d.posBefore)) } } let s = (o || n.state.selection).content(), { dom: l, text: c, slice: u } = mX(n, s); (!t.dataTransfer.files.length || !Oi || QZ > 120) && t.dataTransfer.clearData(), t.dataTransfer.setData(Z0 ? "Text" : "text/html", l.innerHTML), t.dataTransfer.effectAllowed = "copyMove", Z0 || t.dataTransfer.setData("text/plain", c), n.dragging = new AX(u, !t[EX], o) }; ea.dragend = n => { let e = n.dragging; window.setTimeout(() => { n.dragging == e && (n.dragging = null) }, 50) }; ta.dragover = ta.dragenter = (n, e) => e.preventDefault(); ta.drop = (n, e) => { let t = e, r = n.dragging; if (n.dragging = null, !t.dataTransfer) return; let i = n.posAtCoords(Ak(t)); if (!i) return; let a = n.state.doc.resolve(i.pos), o = r && r.slice; o ? n.someProp("transformPasted", p => { o = p(o, n) }) : o = gX(n, CX(t.dataTransfer), Z0 ? null : t.dataTransfer.getData("text/html"), !1, a); let s = !!(r && !t[EX]); if (n.someProp("handleDrop", p => p(n, t, o || Qe.empty, s))) { t.preventDefault(); return } if (!o) return; t.preventDefault(); let l = o ? UZ(n.state.doc, a.pos, o) : a.pos; l == null && (l = a.pos); let c = n.state.tr; if (s) { let { node: p } = r; p ? p.replace(c) : c.deleteSelection() } let u = c.mapping.map(l), d = o.openStart == 0 && o.openEnd == 0 && o.content.childCount == 1, f = c.doc; if (d ? c.replaceRangeWith(u, u, o.content.firstChild) : c.replaceRange(u, u, o), c.doc.eq(f)) return; let h = c.doc.resolve(u); if (d && _t.isSelectable(o.content.firstChild) && h.nodeAfter && h.nodeAfter.sameMarkup(o.content.firstChild)) c.setSelection(new _t(h)); else { let p = c.mapping.map(l); c.mapping.maps[c.mapping.maps.length - 1].forEach((m, g, y, b) => p = b), c.setSelection(ER(n, h, c.doc.resolve(p))) } n.focus(), n.dispatch(c.setMeta("uiEvent", "drop")) }; ea.focus = n => { n.input.lastFocus = Date.now(), n.focused || (n.domObserver.stop(), n.dom.classList.add("ProseMirror-focused"), n.domObserver.start(), n.focused = !0, setTimeout(() => { n.docView && n.hasFocus() && !n.domObserver.currentSelection.eq(n.domSelectionRange()) && yc(n) }, 20)) }; ea.blur = (n, e) => { let t = e; n.focused && (n.domObserver.stop(), n.dom.classList.remove("ProseMirror-focused"), n.domObserver.start(), t.relatedTarget && n.dom.contains(t.relatedTarget) && n.domObserver.currentSelection.clear(), n.focused = !1) }; ea.beforeinput = (n, e) => { if (Oi && cs && e.inputType == "deleteContentBackward") { n.domObserver.flushSoon(); let { domChangeCount: r } = n.input; setTimeout(() => { if (n.input.domChangeCount != r || (n.dom.blur(), n.focus(), n.someProp("handleKeyDown", a => a(n, Ff(8, "Backspace"))))) return; let { $cursor: i } = n.state.selection; i && i.pos > 0 && n.dispatch(n.state.tr.delete(i.pos - 1, i.pos).scrollIntoView()) }, 50) } }; for (let n in ta) ea[n] = ta[n]; function J0(n, e) { if (n == e) return !0; for (let t in n) if (n[t] !== e[t]) return !1; for (let t in e) if (!(t in n)) return !1; return !0 } class JS { constructor(e, t) { this.toDOM = e, this.spec = t || mh, this.side = this.spec.side || 0 } map(e, t, r, i) { let { pos: a, deleted: o } = e.mapResult(t.from + i, this.side < 0 ? -1 : 1); return o ? null : new di(a - r, a - r, this) } valid() { return !0 } eq(e) { return this == e || e instanceof JS && (this.spec.key && this.spec.key == e.spec.key || this.toDOM == e.toDOM && J0(this.spec, e.spec)) } destroy(e) { this.spec.destroy && this.spec.destroy(e) } } class ad { constructor(e, t) { this.attrs = e, this.spec = t || mh } map(e, t, r, i) { let a = e.map(t.from + i, this.spec.inclusiveStart ? -1 : 1) - r, o = e.map(t.to + i, this.spec.inclusiveEnd ? 1 : -1) - r; return a >= o ? null : new di(a, o, this) } valid(e, t) { return t.from < t.to } eq(e) { return this == e || e instanceof ad && J0(this.attrs, e.attrs) && J0(this.spec, e.spec) } static is(e) { return e.type instanceof ad } destroy() { } } class jR { constructor(e, t) { this.attrs = e, this.spec = t || mh } map(e, t, r, i) { let a = e.mapResult(t.from + i, 1); if (a.deleted) return null; let o = e.mapResult(t.to + i, -1); return o.deleted || o.pos <= a.pos ? null : new di(a.pos - r, o.pos - r, this) } valid(e, t) { let { index: r, offset: i } = e.content.findIndex(t.from), a; return i == t.from && !(a = e.child(r)).isText && i + a.nodeSize == t.to } eq(e) { return this == e || e instanceof jR && J0(this.attrs, e.attrs) && J0(this.spec, e.spec) } destroy() { } } class di { constructor(e, t, r) { this.from = e, this.to = t, this.type = r } copy(e, t) { return new di(e, t, this.type) } eq(e, t = 0) { return this.type.eq(e.type) && this.from + t == e.from && this.to + t == e.to } map(e, t, r) { return this.type.map(e, this, t, r) } static widget(e, t, r) { return new di(e, e, new JS(t, r)) } static inline(e, t, r, i) { return new di(e, t, new ad(r, i)) } static node(e, t, r, i) { return new di(e, t, new jR(r, i)) } get spec() { return this.type.spec } get inline() { return this.type instanceof ad } get widget() { return this.type instanceof JS } } const gm = [], mh = {}; class Xn { constructor(e, t) { this.local = e.length ? e : gm, this.children = t.length ? t : gm } static create(e, t) { return t.length ? QS(t, e, 0, mh) : Si } find(e, t, r) { let i = []; return this.findInner(e ?? 0, t ?? 1e9, i, 0, r), i } findInner(e, t, r, i, a) { for (let o = 0; o < this.local.length; o++) { let s = this.local[o]; s.from <= t && s.to >= e && (!a || a(s.spec)) && r.push(s.copy(s.from + i, s.to + i)) } for (let o = 0; o < this.children.length; o += 3)if (this.children[o] < t && this.children[o + 1] > e) { let s = this.children[o] + 1; this.children[o + 2].findInner(e - s, t - s, r, i + s, a) } } map(e, t, r) { return this == Si || e.maps.length == 0 ? this : this.mapInner(e, t, 0, 0, r || mh) } mapInner(e, t, r, i, a) { let o; for (let s = 0; s < this.local.length; s++) { let l = this.local[s].map(e, r, i); l && l.type.valid(t, l) ? (o || (o = [])).push(l) : a.onRemove && a.onRemove(this.local[s].spec) } return this.children.length ? lCe(this.children, o || [], e, t, r, i, a) : o ? new Xn(o.sort(gh), gm) : Si } add(e, t) { return t.length ? this == Si ? Xn.create(e, t) : this.addInner(e, t, 0) : this } addInner(e, t, r) { let i, a = 0; e.forEach((s, l) => { let c = l + r, u; if (u = OX(t, s, c)) { for (i || (i = this.children.slice()); a < i.length && i[a] < l;)a += 3; i[a] == l ? i[a + 2] = i[a + 2].addInner(s, u, c + 1) : i.splice(a, 0, l, l + s.nodeSize, QS(u, s, c + 1, mh)), a += 3 } }); let o = MX(a ? DX(t) : t, -r); for (let s = 0; s < o.length; s++)o[s].type.valid(e, o[s]) || o.splice(s--, 1); return new Xn(o.length ? this.local.concat(o).sort(gh) : this.local, i || this.children) } remove(e) { return e.length == 0 || this == Si ? this : this.removeInner(e, 0) } removeInner(e, t) { let r = this.children, i = this.local; for (let a = 0; a < r.length; a += 3) { let o, s = r[a] + t, l = r[a + 1] + t; for (let u = 0, d; u < e.length; u++)(d = e[u]) && d.from > s && d.to < l && (e[u] = null, (o || (o = [])).push(d)); if (!o) continue; r == this.children && (r = this.children.slice()); let c = r[a + 2].removeInner(o, s + 1); c != Si ? r[a + 2] = c : (r.splice(a, 3), a -= 3) } if (i.length) { for (let a = 0, o; a < e.length; a++)if (o = e[a]) for (let s = 0; s < i.length; s++)i[s].eq(o, t) && (i == this.local && (i = this.local.slice()), i.splice(s--, 1)) } return r == this.children && i == this.local ? this : i.length || r.length ? new Xn(i, r) : Si } forChild(e, t) { if (this == Si) return this; if (t.isLeaf) return Xn.empty; let r, i; for (let s = 0; s < this.children.length; s += 3)if (this.children[s] >= e) { this.children[s] == e && (r = this.children[s + 2]); break } let a = e + 1, o = a + t.content.size; for (let s = 0; s < this.local.length; s++) { let l = this.local[s]; if (l.from < o && l.to > a && l.type instanceof ad) { let c = Math.max(a, l.from) - a, u = Math.min(o, l.to) - a; c < u && (i || (i = [])).push(l.copy(c, u)) } } if (i) { let s = new Xn(i.sort(gh), gm); return r ? new ju([s, r]) : s } return r || Si } eq(e) { if (this == e) return !0; if (!(e instanceof Xn) || this.local.length != e.local.length || this.children.length != e.children.length) return !1; for (let t = 0; t < this.local.length; t++)if (!this.local[t].eq(e.local[t])) return !1; for (let t = 0; t < this.children.length; t += 3)if (this.children[t] != e.children[t] || this.children[t + 1] != e.children[t + 1] || !this.children[t + 2].eq(e.children[t + 2])) return !1; return !0 } locals(e) { return PR(this.localsInner(e)) } localsInner(e) { if (this == Si) return gm; if (e.inlineContent || !this.local.some(ad.is)) return this.local; let t = []; for (let r = 0; r < this.local.length; r++)this.local[r].type instanceof ad || t.push(this.local[r]); return t } forEachSet(e) { e(this) } } Xn.empty = new Xn([], []); Xn.removeOverlap = PR; const Si = Xn.empty; class ju { constructor(e) { this.members = e } map(e, t) { const r = this.members.map(i => i.map(e, t, mh)); return ju.from(r) } forChild(e, t) { if (t.isLeaf) return Xn.empty; let r = []; for (let i = 0; i < this.members.length; i++) { let a = this.members[i].forChild(e, t); a != Si && (a instanceof ju ? r = r.concat(a.members) : r.push(a)) } return ju.from(r) } eq(e) { if (!(e instanceof ju) || e.members.length != this.members.length) return !1; for (let t = 0; t < this.members.length; t++)if (!this.members[t].eq(e.members[t])) return !1; return !0 } locals(e) { let t, r = !0; for (let i = 0; i < this.members.length; i++) { let a = this.members[i].localsInner(e); if (a.length) if (!t) t = a; else { r && (t = t.slice(), r = !1); for (let o = 0; o < a.length; o++)t.push(a[o]) } } return t ? PR(r ? t : t.sort(gh)) : gm } static from(e) { switch (e.length) { case 0: return Si; case 1: return e[0]; default: return new ju(e.every(t => t instanceof Xn) ? e : e.reduce((t, r) => t.concat(r instanceof Xn ? r : r.members), [])) } } forEachSet(e) { for (let t = 0; t < this.members.length; t++)this.members[t].forEachSet(e) } } function lCe(n, e, t, r, i, a, o) { let s = n.slice(); for (let c = 0, u = a; c < t.maps.length; c++) { let d = 0; t.maps[c].forEach((f, h, p, m) => { let g = m - p - (h - f); for (let y = 0; y < s.length; y += 3) { let b = s[y + 1]; if (b < 0 || f > b + u - d) continue; let w = s[y] + u - d; h >= w ? s[y + 1] = f <= w ? -2 : -1 : f >= u && g && (s[y] += g, s[y + 1] += g) } d += g }), u = t.maps[c].map(u, -1) } let l = !1; for (let c = 0; c < s.length; c += 3)if (s[c + 1] < 0) { if (s[c + 1] == -2) { l = !0, s[c + 1] = -1; continue } let u = t.map(n[c] + a), d = u - i; if (d < 0 || d >= r.content.size) { l = !0; continue } let f = t.map(n[c + 1] + a, -1), h = f - i, { index: p, offset: m } = r.content.findIndex(d), g = r.maybeChild(p); if (g && m == d && m + g.nodeSize == h) { let y = s[c + 2].mapInner(t, g, u + 1, n[c] + a + 1, o); y != Si ? (s[c] = d, s[c + 1] = h, s[c + 2] = y) : (s[c + 1] = -2, l = !0) } else l = !0 } if (l) { let c = cCe(s, n, e, t, i, a, o), u = QS(c, r, 0, o); e = u.local; for (let d = 0; d < s.length; d += 3)s[d + 1] < 0 && (s.splice(d, 3), d -= 3); for (let d = 0, f = 0; d < u.children.length; d += 3) { let h = u.children[d]; for (; f < s.length && s[f] < h;)f += 3; s.splice(f, 0, u.children[d], u.children[d + 1], u.children[d + 2]) } } return new Xn(e.sort(gh), s) } function MX(n, e) { if (!e || !n.length) return n; let t = []; for (let r = 0; r < n.length; r++) { let i = n[r]; t.push(new di(i.from + e, i.to + e, i.type)) } return t } function cCe(n, e, t, r, i, a, o) { function s(l, c) { for (let u = 0; u < l.local.length; u++) { let d = l.local[u].map(r, i, c); d ? t.push(d) : o.onRemove && o.onRemove(l.local[u].spec) } for (let u = 0; u < l.children.length; u += 3)s(l.children[u + 2], l.children[u] + c + 1) } for (let l = 0; l < n.length; l += 3)n[l + 1] == -1 && s(n[l + 2], e[l] + a + 1); return t } function OX(n, e, t) { if (e.isLeaf) return null; let r = t + e.nodeSize, i = null; for (let a = 0, o; a < n.length; a++)(o = n[a]) && o.from > t && o.to < r && ((i || (i = [])).push(o), n[a] = null); return i } function DX(n) { let e = []; for (let t = 0; t < n.length; t++)n[t] != null && e.push(n[t]); return e } function QS(n, e, t, r) { let i = [], a = !1; e.forEach((s, l) => { let c = OX(n, s, l + t); if (c) { a = !0; let u = QS(c, s, t + l + 1, r); u != Si && i.push(l, l + s.nodeSize, u) } }); let o = MX(a ? DX(n) : n, -t).sort(gh); for (let s = 0; s < o.length; s++)o[s].type.valid(e, o[s]) || (r.onRemove && r.onRemove(o[s].spec), o.splice(s--, 1)); return o.length || i.length ? new Xn(o, i) : Si } function gh(n, e) { return n.from - e.from || n.to - e.to } function PR(n) { let e = n; for (let t = 0; t < e.length - 1; t++) { let r = e[t]; if (r.from != r.to) for (let i = t + 1; i < e.length; i++) { let a = e[i]; if (a.from == r.from) { a.to != r.to && (e == n && (e = n.slice()), e[i] = a.copy(a.from, r.to), zF(e, i + 1, a.copy(r.to, a.to))); continue } else { a.from < r.to && (e == n && (e = n.slice()), e[t] = r.copy(r.from, a.from), zF(e, i, r.copy(a.from, r.to))); break } } } return e } function zF(n, e, t) { for (; e < n.length && gh(t, n[e]) > 0;)e++; n.splice(e, 0, t) } function DE(n) { let e = []; return n.someProp("decorations", t => { let r = t(n.state); r && r != Si && e.push(r) }), n.cursorWrapper && e.push(Xn.create(n.state.doc, [n.cursorWrapper.deco])), ju.from(e) } const uCe = { childList: !0, characterData: !0, characterDataOldValue: !0, attributes: !0, attributeOldValue: !0, subtree: !0 }, dCe = Sa && rd <= 11; class fCe { constructor() { this.anchorNode = null, this.anchorOffset = 0, this.focusNode = null, this.focusOffset = 0 } set(e) { this.anchorNode = e.anchorNode, this.anchorOffset = e.anchorOffset, this.focusNode = e.focusNode, this.focusOffset = e.focusOffset } clear() { this.anchorNode = this.focusNode = null } eq(e) { return e.anchorNode == this.anchorNode && e.anchorOffset == this.anchorOffset && e.focusNode == this.focusNode && e.focusOffset == this.focusOffset } } class hCe { constructor(e, t) { this.view = e, this.handleDOMChange = t, this.queue = [], this.flushingSoon = -1, this.observer = null, this.currentSelection = new fCe, this.onCharData = null, this.suppressingSelectionUpdates = !1, this.lastChangedTextNode = null, this.observer = window.MutationObserver && new window.MutationObserver(r => { for (let i = 0; i < r.length; i++)this.queue.push(r[i]); Sa && rd <= 11 && r.some(i => i.type == "childList" && i.removedNodes.length || i.type == "characterData" && i.oldValue.length > i.target.nodeValue.length) ? this.flushSoon() : this.flush() }), dCe && (this.onCharData = r => { this.queue.push({ target: r.target, type: "characterData", oldValue: r.prevValue }), this.flushSoon() }), this.onSelectionChange = this.onSelectionChange.bind(this) } flushSoon() { this.flushingSoon < 0 && (this.flushingSoon = window.setTimeout(() => { this.flushingSoon = -1, this.flush() }, 20)) } forceFlush() { this.flushingSoon > -1 && (window.clearTimeout(this.flushingSoon), this.flushingSoon = -1, this.flush()) } start() { this.observer && (this.observer.takeRecords(), this.observer.observe(this.view.dom, uCe)), this.onCharData && this.view.dom.addEventListener("DOMCharacterDataModified", this.onCharData), this.connectSelection() } stop() { if (this.observer) { let e = this.observer.takeRecords(); if (e.length) { for (let t = 0; t < e.length; t++)this.queue.push(e[t]); window.setTimeout(() => this.flush(), 20) } this.observer.disconnect() } this.onCharData && this.view.dom.removeEventListener("DOMCharacterDataModified", this.onCharData), this.disconnectSelection() } connectSelection() { this.view.dom.ownerDocument.addEventListener("selectionchange", this.onSelectionChange) } disconnectSelection() { this.view.dom.ownerDocument.removeEventListener("selectionchange", this.onSelectionChange) } suppressSelectionUpdates() { this.suppressingSelectionUpdates = !0, setTimeout(() => this.suppressingSelectionUpdates = !1, 50) } onSelectionChange() { if (PF(this.view)) { if (this.suppressingSelectionUpdates) return yc(this.view); if (Sa && rd <= 11 && !this.view.state.selection.empty) { let e = this.view.domSelectionRange(); if (e.focusNode && $h(e.focusNode, e.focusOffset, e.anchorNode, e.anchorOffset)) return this.flushSoon() } this.flush() } } setCurSelection() { this.currentSelection.set(this.view.domSelectionRange()) } ignoreSelectionChange(e) { if (!e.focusNode) return !0; let t = new Set, r; for (let a = e.focusNode; a; a = Y0(a))t.add(a); for (let a = e.anchorNode; a; a = Y0(a))if (t.has(a)) { r = a; break } let i = r && this.view.docView.nearestDesc(r); if (i && i.ignoreMutation({ type: "selection", target: r.nodeType == 3 ? r.parentNode : r })) return this.setCurSelection(), !0 } pendingRecords() { if (this.observer) for (let e of this.observer.takeRecords()) this.queue.push(e); return this.queue } selectionChanged(e) { return !this.suppressingSelectionUpdates && !this.currentSelection.eq(e) && PF(this.view) && !this.ignoreSelectionChange(e) } flush() { let { view: e } = this; if (!e.docView || this.flushingSoon > -1) return; let t = this.pendingRecords(); t.length && (this.queue = []); let r = e.domSelectionRange(), i = this.selectionChanged(r), a = -1, o = -1, s = !1, l = []; if (e.editable) for (let u = 0; u < t.length; u++) { let d = this.registerMutation(t[u], l); d && (a = a < 0 ? d.from : Math.min(d.from, a), o = o < 0 ? d.to : Math.max(d.to, o), d.typeOver && (s = !0)) } if (As && l.length) { let u = l.filter(d => d.nodeName == "BR"); if (u.length == 2) { let [d, f] = u; d.parentNode && d.parentNode.parentNode == f.parentNode ? f.remove() : d.remove() } else { let { focusNode: d } = this.currentSelection; for (let f of u) { let h = f.parentNode; h && h.nodeName == "LI" && (!d || gCe(e, d) != h) && f.remove() } } } let c = null; a < 0 && i && e.input.lastFocus > Date.now() - 200 && Math.max(e.input.lastTouch, e.input.lastClick.time) < Date.now() - 300 && kk(r) && (c = AR(e)) && c.eq(vt.near(e.state.doc.resolve(0), 1)) ? (e.input.lastFocus = 0, yc(e), this.currentSelection.set(r), e.scrollToSelection()) : (a > -1 || i) && (a > -1 && (e.docView.markDirty(a, o), pCe(e)), this.handleDOMChange(a, o, s, l), e.docView && e.docView.dirty ? e.updateState(e.state) : this.currentSelection.eq(r) || yc(e), this.currentSelection.set(r)) } registerMutation(e, t) { if (t.indexOf(e.target) > -1) return null; let r = this.view.docView.nearestDesc(e.target); if (e.type == "attributes" && (r == this.view.docView || e.attributeName == "contenteditable" || e.attributeName == "style" && !e.oldValue && !e.target.getAttribute("style")) || !r || r.ignoreMutation(e)) return null; if (e.type == "childList") { for (let u = 0; u < e.addedNodes.length; u++) { let d = e.addedNodes[u]; t.push(d), d.nodeType == 3 && (this.lastChangedTextNode = d) } if (r.contentDOM && r.contentDOM != r.dom && !r.contentDOM.contains(e.target)) return { from: r.posBefore, to: r.posAfter }; let i = e.previousSibling, a = e.nextSibling; if (Sa && rd <= 11 && e.addedNodes.length) for (let u = 0; u < e.addedNodes.length; u++) { let { previousSibling: d, nextSibling: f } = e.addedNodes[u]; (!d || Array.prototype.indexOf.call(e.addedNodes, d) < 0) && (i = d), (!f || Array.prototype.indexOf.call(e.addedNodes, f) < 0) && (a = f) } let o = i && i.parentNode == e.target ? ci(i) + 1 : 0, s = r.localPosFromDOM(e.target, o, -1), l = a && a.parentNode == e.target ? ci(a) : e.target.childNodes.length, c = r.localPosFromDOM(e.target, l, 1); return { from: s, to: c } } else return e.type == "attributes" ? { from: r.posAtStart - r.border, to: r.posAtEnd + r.border } : (this.lastChangedTextNode = e.target, { from: r.posAtStart, to: r.posAtEnd, typeOver: e.target.nodeValue == e.oldValue }) } } let VF = new WeakMap, HF = !1; function pCe(n) { if (!VF.has(n) && (VF.set(n, null), ["normal", "nowrap", "pre-line"].indexOf(getComputedStyle(n.dom).whiteSpace) !== -1)) { if (n.requiresGeckoHackNode = As, HF) return; console.warn("ProseMirror expects the CSS white-space property to be set, preferably to 'pre-wrap'. It is recommended to load style/prosemirror.css from the prosemirror-view package."), HF = !0 } } function UF(n, e) { let t = e.startContainer, r = e.startOffset, i = e.endContainer, a = e.endOffset, o = n.domAtPos(n.state.selection.anchor); return $h(o.node, o.offset, i, a) && ([t, r, i, a] = [i, a, t, r]), { anchorNode: t, anchorOffset: r, focusNode: i, focusOffset: a } } function mCe(n, e) { if (e.getComposedRanges) { let i = e.getComposedRanges(n.root)[0]; if (i) return UF(n, i) } let t; function r(i) { i.preventDefault(), i.stopImmediatePropagation(), t = i.getTargetRanges()[0] } return n.dom.addEventListener("beforeinput", r, !0), document.execCommand("indent"), n.dom.removeEventListener("beforeinput", r, !0), t ? UF(n, t) : null } function gCe(n, e) { for (let t = e.parentNode; t && t != n.dom; t = t.parentNode) { let r = n.docView.nearestDesc(t, !0); if (r && r.node.isBlock) return t } return null } function vCe(n, e, t) { let { node: r, fromOffset: i, toOffset: a, from: o, to: s } = n.docView.parseRange(e, t), l = n.domSelectionRange(), c, u = l.anchorNode; if (u && n.dom.contains(u.nodeType == 1 ? u : u.parentNode) && (c = [{ node: u, offset: l.anchorOffset }], kk(l) || c.push({ node: l.focusNode, offset: l.focusOffset })), Oi && n.input.lastKeyCode === 8) for (let g = a; g > i; g--) { let y = r.childNodes[g - 1], b = y.pmViewDesc; if (y.nodeName == "BR" && !b) { a = g; break } if (!b || b.size) break } let d = n.state.doc, f = n.someProp("domParser") || nd.fromSchema(n.state.schema), h = d.resolve(o), p = null, m = f.parse(r, { topNode: h.parent, topMatch: h.parent.contentMatchAt(h.index()), topOpen: !0, from: i, to: a, preserveWhitespace: h.parent.type.whitespace == "pre" ? "full" : !0, findPositions: c, ruleFromNode: yCe, context: h }); if (c && c[0].pos != null) { let g = c[0].pos, y = c[1] && c[1].pos; y == null && (y = g), p = { anchor: g + o, head: y + o } } return { doc: m, sel: p, from: o, to: s } } function yCe(n) { let e = n.pmViewDesc; if (e) return e.parseRule(); if (n.nodeName == "BR" && n.parentNode) { if (Qi && /^(ul|ol)$/i.test(n.parentNode.nodeName)) { let t = document.createElement("div"); return t.appendChild(document.createElement("li")), { skip: t } } else if (n.parentNode.lastChild == n || Qi && /^(tr|table)$/i.test(n.parentNode.nodeName)) return { ignore: !0 } } else if (n.nodeName == "IMG" && n.getAttribute("mark-placeholder")) return { ignore: !0 }; return null } const _Ce = /^(a|abbr|acronym|b|bd[io]|big|br|button|cite|code|data(list)?|del|dfn|em|i|ins|kbd|label|map|mark|meter|output|q|ruby|s|samp|small|span|strong|su[bp]|time|u|tt|var)$/i; function bCe(n, e, t, r, i) { let a = n.input.compositionPendingChanges || (n.composing ? n.input.compositionID : 0); if (n.input.compositionPendingChanges = 0, e < 0) { let C = n.input.lastSelectionTime > Date.now() - 50 ? n.input.lastSelectionOrigin : null, E = AR(n, C); if (E && !n.state.selection.eq(E)) { if (Oi && cs && n.input.lastKeyCode === 13 && Date.now() - 100 < n.input.lastKeyCodeTime && n.someProp("handleKeyDown", j => j(n, Ff(13, "Enter")))) return; let O = n.state.tr.setSelection(E); C == "pointer" ? O.setMeta("pointer", !0) : C == "key" && O.scrollIntoView(), a && O.setMeta("composition", a), n.dispatch(O) } return } let o = n.state.doc.resolve(e), s = o.sharedDepth(t); e = o.before(s + 1), t = n.state.doc.resolve(t).after(s + 1); let l = n.state.selection, c = vCe(n, e, t), u = n.state.doc, d = u.slice(c.from, c.to), f, h; n.input.lastKeyCode === 8 && Date.now() - 100 < n.input.lastKeyCodeTime ? (f = n.state.selection.to, h = "end") : (f = n.state.selection.from, h = "start"), n.input.lastKeyCode = null; let p = SCe(d.content, c.doc.content, c.from, f, h); if (p && n.input.domChangeCount++, (vg && n.input.lastIOSEnter > Date.now() - 225 || cs) && i.some(C => C.nodeType == 1 && !_Ce.test(C.nodeName)) && (!p || p.endA >= p.endB) && n.someProp("handleKeyDown", C => C(n, Ff(13, "Enter")))) { n.input.lastIOSEnter = 0; return } if (!p) if (r && l instanceof ht && !l.empty && l.$head.sameParent(l.$anchor) && !n.composing && !(c.sel && c.sel.anchor != c.sel.head)) p = { start: l.from, endA: l.to, endB: l.to }; else { if (c.sel) { let C = GF(n, n.state.doc, c.sel); if (C && !C.eq(n.state.selection)) { let E = n.state.tr.setSelection(C); a && E.setMeta("composition", a), n.dispatch(E) } } return } n.state.selection.from < n.state.selection.to && p.start == p.endB && n.state.selection instanceof ht && (p.start > n.state.selection.from && p.start <= n.state.selection.from + 2 && n.state.selection.from >= c.from ? p.start = n.state.selection.from : p.endA < n.state.selection.to && p.endA >= n.state.selection.to - 2 && n.state.selection.to <= c.to && (p.endB += n.state.selection.to - p.endA, p.endA = n.state.selection.to)), Sa && rd <= 11 && p.endB == p.start + 1 && p.endA == p.start && p.start > c.from && c.doc.textBetween(p.start - c.from - 1, p.start - c.from + 1) == " " && (p.start--, p.endA--, p.endB--); let m = c.doc.resolveNoCache(p.start - c.from), g = c.doc.resolveNoCache(p.endB - c.from), y = u.resolve(p.start), b = m.sameParent(g) && m.parent.inlineContent && y.end() >= p.endA, w; if ((vg && n.input.lastIOSEnter > Date.now() - 225 && (!b || i.some(C => C.nodeName == "DIV" || C.nodeName == "P")) || !b && m.pos < c.doc.content.size && !m.sameParent(g) && (w = vt.findFrom(c.doc.resolve(m.pos + 1), 1, !0)) && w.head == g.pos) && n.someProp("handleKeyDown", C => C(n, Ff(13, "Enter")))) { n.input.lastIOSEnter = 0; return } if (n.state.selection.anchor > p.start && xCe(u, p.start, p.endA, m, g) && n.someProp("handleKeyDown", C => C(n, Ff(8, "Backspace")))) { cs && Oi && n.domObserver.suppressSelectionUpdates(); return } Oi && cs && p.endB == p.start && (n.input.lastAndroidDelete = Date.now()), cs && !b && m.start() != g.start() && g.parentOffset == 0 && m.depth == g.depth && c.sel && c.sel.anchor == c.sel.head && c.sel.head == p.endA && (p.endB -= 2, g = c.doc.resolveNoCache(p.endB - c.from), setTimeout(() => { n.someProp("handleKeyDown", function (C) { return C(n, Ff(13, "Enter")) }) }, 20)); let v = p.start, S = p.endA, x, k, A; if (b) { if (m.pos == g.pos) Sa && rd <= 11 && m.parentOffset == 0 && (n.domObserver.suppressSelectionUpdates(), setTimeout(() => yc(n), 20)), x = n.state.tr.delete(v, S), k = u.resolve(p.start).marksAcross(u.resolve(p.endA)); else if (p.endA == p.endB && (A = wCe(m.parent.content.cut(m.parentOffset, g.parentOffset), y.parent.content.cut(y.parentOffset, p.endA - y.start())))) x = n.state.tr, A.type == "add" ? x.addMark(v, S, A.mark) : x.removeMark(v, S, A.mark); else if (m.parent.child(m.index()).isText && m.index() == g.index() - (g.textOffset ? 0 : 1)) { let C = m.parent.textBetween(m.parentOffset, g.parentOffset); if (n.someProp("handleTextInput", E => E(n, v, S, C))) return; x = n.state.tr.insertText(C, v, S) } } if (x || (x = n.state.tr.replace(v, S, c.doc.slice(p.start - c.from, p.endB - c.from))), c.sel) { let C = GF(n, x.doc, c.sel); C && !(Oi && cs && n.composing && C.empty && (p.start != p.endB || n.input.lastAndroidDelete < Date.now() - 100) && (C.head == v || C.head == x.mapping.map(S) - 1) || Sa && C.empty && C.head == v) && x.setSelection(C) } k && x.ensureMarks(k), a && x.setMeta("composition", a), n.dispatch(x.scrollIntoView()) } function GF(n, e, t) { return Math.max(t.anchor, t.head) > e.content.size ? null : ER(n, e.resolve(t.anchor), e.resolve(t.head)) } function wCe(n, e) { let t = n.firstChild.marks, r = e.firstChild.marks, i = t, a = r, o, s, l; for (let u = 0; u < r.length; u++)i = r[u].removeFromSet(i); for (let u = 0; u < t.length; u++)a = t[u].removeFromSet(a); if (i.length == 1 && a.length == 0) s = i[0], o = "add", l = u => u.mark(s.addToSet(u.marks)); else if (i.length == 0 && a.length == 1) s = a[0], o = "remove", l = u => u.mark(s.removeFromSet(u.marks)); else return null; let c = []; for (let u = 0; u < e.childCount; u++)c.push(l(e.child(u))); if (Be.from(c).eq(n)) return { mark: s, type: o } } function xCe(n, e, t, r, i) { if (t - e <= i.pos - r.pos || jE(r, !0, !1) < i.pos) return !1; let a = n.resolve(e); if (!r.parent.isTextblock) { let s = a.nodeAfter; return s != null && t == e + s.nodeSize } if (a.parentOffset < a.parent.content.size || !a.parent.isTextblock) return !1; let o = n.resolve(jE(a, !0, !0)); return !o.parent.isTextblock || o.pos > t || jE(o, !0, !1) < t ? !1 : r.parent.content.cut(r.parentOffset).eq(o.parent.content) } function jE(n, e, t) { let r = n.depth, i = e ? n.end() : n.pos; for (; r > 0 && (e || n.indexAfter(r) == n.node(r).childCount);)r--, i++, e = !1; if (t) { let a = n.node(r).maybeChild(n.indexAfter(r)); for (; a && !a.isLeaf;)a = a.firstChild, i++ } return i } function SCe(n, e, t, r, i) { let a = n.findDiffStart(e, t); if (a == null) return null; let { a: o, b: s } = n.findDiffEnd(e, t + n.size, t + e.size); if (i == "end") { let l = Math.max(0, a - Math.min(o, s)); r -= o + l - a } if (o < a && n.size < e.size) { let l = r <= a && r >= o ? a - r : 0; a -= l, a && a < e.size && WF(e.textBetween(a - 1, a + 1)) && (a += l ? 1 : -1), s = a + (s - o), o = a } else if (s < a) { let l = r <= a && r >= s ? a - r : 0; a -= l, a && a < n.size && WF(n.textBetween(a - 1, a + 1)) && (a += l ? 1 : -1), o = a + (o - s), s = a } return { start: a, endA: o, endB: s } } function WF(n) { if (n.length != 2) return !1; let e = n.charCodeAt(0), t = n.charCodeAt(1); return e >= 56320 && e <= 57343 && t >= 55296 && t <= 56319 } class TCe { constructor(e, t) { this._root = null, this.focused = !1, this.trackWrites = null, this.mounted = !1, this.markCursor = null, this.cursorWrapper = null, this.lastSelectedViewDesc = void 0, this.input = new Hke, this.prevDirectPlugins = [], this.pluginViews = [], this.requiresGeckoHackNode = !1, this.dragging = null, this._props = t, this.state = t.state, this.directPlugins = t.plugins || [], this.directPlugins.forEach(XF), this.dispatch = this.dispatch.bind(this), this.dom = e && e.mount || document.createElement("div"), e && (e.appendChild ? e.appendChild(this.dom) : typeof e == "function" ? e(this.dom) : e.mount && (this.mounted = !0)), this.editable = YF(this), qF(this), this.nodeViews = ZF(this), this.docView = AF(this.state.doc, KF(this), DE(this), this.dom, this), this.domObserver = new hCe(this, (r, i, a, o) => bCe(this, r, i, a, o)), this.domObserver.start(), Uke(this), this.updatePluginViews() } get composing() { return this.input.composing } get props() { if (this._props.state != this.state) { let e = this._props; this._props = {}; for (let t in e) this._props[t] = e[t]; this._props.state = this.state } return this._props } update(e) { e.handleDOMEvents != this._props.handleDOMEvents && Hj(this); let t = this._props; this._props = e, e.plugins && (e.plugins.forEach(XF), this.directPlugins = e.plugins), this.updateStateInner(e.state, t) } setProps(e) { let t = {}; for (let r in this._props) t[r] = this._props[r]; t.state = this.state; for (let r in e) t[r] = e[r]; this.update(t) } updateState(e) { this.updateStateInner(e, this._props) } updateStateInner(e, t) { var r; let i = this.state, a = !1, o = !1; e.storedMarks && this.composing && (kX(this), o = !0), this.state = e; let s = i.plugins != e.plugins || this._props.plugins != t.plugins; if (s || this._props.plugins != t.plugins || this._props.nodeViews != t.nodeViews) { let h = ZF(this); CCe(h, this.nodeViews) && (this.nodeViews = h, a = !0) } (s || t.handleDOMEvents != this._props.handleDOMEvents) && Hj(this), this.editable = YF(this), qF(this); let l = DE(this), c = KF(this), u = i.plugins != e.plugins && !i.doc.eq(e.doc) ? "reset" : e.scrollToSelection > i.scrollToSelection ? "to selection" : "preserve", d = a || !this.docView.matchesNode(e.doc, c, l); (d || !e.selection.eq(i.selection)) && (o = !0); let f = u == "preserve" && o && this.dom.style.overflowAnchor == null && ike(this); if (o) { this.domObserver.stop(); let h = d && (Sa || Oi) && !this.composing && !i.selection.empty && !e.selection.empty && kCe(i.selection, e.selection); if (d) { let p = Oi ? this.trackWrites = this.domSelectionRange().focusNode : null; this.composing && (this.input.compositionNode = rCe(this)), (a || !this.docView.update(e.doc, c, l, this)) && (this.docView.updateOuterDeco(c), this.docView.destroy(), this.docView = AF(e.doc, c, l, this.dom, this)), p && !this.trackWrites && (h = !0) } h || !(this.input.mouseDown && this.domObserver.currentSelection.eq(this.domSelectionRange()) && Eke(this)) ? yc(this, h) : (fX(this, e.selection), this.domObserver.setCurSelection()), this.domObserver.start() } this.updatePluginViews(i), !((r = this.dragging) === null || r === void 0) && r.node && !i.doc.eq(e.doc) && this.updateDraggedNode(this.dragging, i), u == "reset" ? this.dom.scrollTop = 0 : u == "to selection" ? this.scrollToSelection() : f && ake(f) } scrollToSelection() { let e = this.domSelectionRange().focusNode; if (!this.someProp("handleScrollToSelection", t => t(this))) if (this.state.selection instanceof _t) { let t = this.docView.domAfterPos(this.state.selection.from); t.nodeType == 1 && wF(this, t.getBoundingClientRect(), e) } else wF(this, this.coordsAtPos(this.state.selection.head, 1), e) } destroyPluginViews() { let e; for (; e = this.pluginViews.pop();)e.destroy && e.destroy() } updatePluginViews(e) { if (!e || e.plugins != this.state.plugins || this.directPlugins != this.prevDirectPlugins) { this.prevDirectPlugins = this.directPlugins, this.destroyPluginViews(); for (let t = 0; t < this.directPlugins.length; t++) { let r = this.directPlugins[t]; r.spec.view && this.pluginViews.push(r.spec.view(this)) } for (let t = 0; t < this.state.plugins.length; t++) { let r = this.state.plugins[t]; r.spec.view && this.pluginViews.push(r.spec.view(this)) } } else for (let t = 0; t < this.pluginViews.length; t++) { let r = this.pluginViews[t]; r.update && r.update(this, e) } } updateDraggedNode(e, t) { let r = e.node, i = -1; if (this.state.doc.nodeAt(r.from) == r.node) i = r.from; else { let a = r.from + (this.state.doc.content.size - t.doc.content.size); (a > 0 && this.state.doc.nodeAt(a)) == r.node && (i = a) } this.dragging = new AX(e.slice, e.move, i < 0 ? void 0 : _t.create(this.state.doc, i)) } someProp(e, t) { let r = this._props && this._props[e], i; if (r != null && (i = t ? t(r) : r)) return i; for (let o = 0; o < this.directPlugins.length; o++) { let s = this.directPlugins[o].props[e]; if (s != null && (i = t ? t(s) : s)) return i } let a = this.state.plugins; if (a) for (let o = 0; o < a.length; o++) { let s = a[o].props[e]; if (s != null && (i = t ? t(s) : s)) return i } } hasFocus() { if (Sa) { let e = this.root.activeElement; if (e == this.dom) return !0; if (!e || !this.dom.contains(e)) return !1; for (; e && this.dom != e && this.dom.contains(e);) { if (e.contentEditable == "false") return !1; e = e.parentElement } return !0 } return this.root.activeElement == this.dom } focus() { this.domObserver.stop(), this.editable && oke(this.dom), yc(this), this.domObserver.start() } get root() { let e = this._root; if (e == null) { for (let t = this.dom.parentNode; t; t = t.parentNode)if (t.nodeType == 9 || t.nodeType == 11 && t.host) return t.getSelection || (Object.getPrototypeOf(t).getSelection = () => t.ownerDocument.getSelection()), this._root = t } return e || document } updateRoot() { this._root = null } posAtCoords(e) { return dke(this, e) } coordsAtPos(e, t = 1) { return iX(this, e, t) } domAtPos(e, t = 0) { return this.docView.domFromPos(e, t) } nodeDOM(e) { let t = this.docView.descAt(e); return t ? t.nodeDOM : null } posAtDOM(e, t, r = -1) { let i = this.docView.posFromDOM(e, t, r); if (i == null) throw new RangeError("DOM position not inside the editor"); return i } endOfTextblock(e, t) { return gke(this, t || this.state, e) } pasteHTML(e, t) { return X0(this, "", e, !1, t || new ClipboardEvent("paste")) } pasteText(e, t) { return X0(this, e, null, !0, t || new ClipboardEvent("paste")) } destroy() { this.docView && (Gke(this), this.destroyPluginViews(), this.mounted ? (this.docView.update(this.state.doc, [], DE(this), this), this.dom.textContent = "") : this.dom.parentNode && this.dom.parentNode.removeChild(this.dom), this.docView.destroy(), this.docView = null, KTe()) } get isDestroyed() { return this.docView == null } dispatchEvent(e) { return Kke(this, e) } dispatch(e) { let t = this._props.dispatchTransaction; t ? t.call(this, e) : this.updateState(this.state.apply(e)) } domSelectionRange() { let e = this.domSelection(); return e ? Qi && this.root.nodeType === 11 && JTe(this.dom.ownerDocument) == this.dom && mCe(this, e) || e : { focusNode: null, focusOffset: 0, anchorNode: null, anchorOffset: 0 } } domSelection() { return this.root.getSelection() } } function KF(n) { let e = Object.create(null); return e.class = "ProseMirror", e.contenteditable = String(n.editable), n.someProp("attributes", t => { if (typeof t == "function" && (t = t(n.state)), t) for (let r in t) r == "class" ? e.class += " " + t[r] : r == "style" ? e.style = (e.style ? e.style + ";" : "") + t[r] : !e[r] && r != "contenteditable" && r != "nodeName" && (e[r] = String(t[r])) }), e.translate || (e.translate = "no"), [di.node(0, n.state.doc.content.size, e)] } function qF(n) { if (n.markCursor) { let e = document.createElement("img"); e.className = "ProseMirror-separator", e.setAttribute("mark-placeholder", "true"), e.setAttribute("alt", ""), n.cursorWrapper = { dom: e, deco: di.widget(n.state.selection.from, e, { raw: !0, marks: n.markCursor }) } } else n.cursorWrapper = null } function YF(n) { return !n.someProp("editable", e => e(n.state) === !1) } function kCe(n, e) { let t = Math.min(n.$anchor.sharedDepth(n.head), e.$anchor.sharedDepth(e.head)); return n.$anchor.start(t) != e.$anchor.start(t) } function ZF(n) { let e = Object.create(null); function t(r) { for (let i in r) Object.prototype.hasOwnProperty.call(e, i) || (e[i] = r[i]) } return n.someProp("nodeViews", t), n.someProp("markViews", t), e } function CCe(n, e) { let t = 0, r = 0; for (let i in n) { if (n[i] != e[i]) return !0; t++ } for (let i in e) r++; return t != r } function XF(n) { if (n.spec.state || n.spec.filterTransaction || n.spec.appendTransaction) throw new RangeError("Plugins passed directly to the view must not have a state component") } var Sd = { 8: "Backspace", 9: "Tab", 10: "Enter", 12: "NumLock", 13: "Enter", 16: "Shift", 17: "Control", 18: "Alt", 20: "CapsLock", 27: "Escape", 32: " ", 33: "PageUp", 34: "PageDown", 35: "End", 36: "Home", 37: "ArrowLeft", 38: "ArrowUp", 39: "ArrowRight", 40: "ArrowDown", 44: "PrintScreen", 45: "Insert", 46: "Delete", 59: ";", 61: "=", 91: "Meta", 92: "Meta", 106: "*", 107: "+", 108: ",", 109: "-", 110: ".", 111: "/", 144: "NumLock", 145: "ScrollLock", 160: "Shift", 161: "Shift", 162: "Control", 163: "Control", 164: "Alt", 165: "Alt", 173: "-", 186: ";", 187: "=", 188: ",", 189: "-", 190: ".", 191: "/", 192: "`", 219: "[", 220: "\\", 221: "]", 222: "'" }, e2 = { 48: ")", 49: "!", 50: "@", 51: "#", 52: "$", 53: "%", 54: "^", 55: "&", 56: "*", 57: "(", 59: ":", 61: "+", 173: "_", 186: ":", 187: "+", 188: "<", 189: "_", 190: ">", 191: "?", 192: "~", 219: "{", 220: "|", 221: "}", 222: '"' }, ACe = typeof navigator < "u" && /Mac/.test(navigator.platform), ECe = typeof navigator < "u" && /MSIE \d|Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(navigator.userAgent); for (var ui = 0; ui < 10; ui++)Sd[48 + ui] = Sd[96 + ui] = String(ui); for (var ui = 1; ui <= 24; ui++)Sd[ui + 111] = "F" + ui; for (var ui = 65; ui <= 90; ui++)Sd[ui] = String.fromCharCode(ui + 32), e2[ui] = String.fromCharCode(ui); for (var PE in Sd) e2.hasOwnProperty(PE) || (e2[PE] = Sd[PE]); function MCe(n) { var e = ACe && n.metaKey && n.shiftKey && !n.ctrlKey && !n.altKey || ECe && n.shiftKey && n.key && n.key.length == 1 || n.key == "Unidentified", t = !e && n.key || (n.shiftKey ? e2 : Sd)[n.keyCode] || n.key || "Unidentified"; return t == "Esc" && (t = "Escape"), t == "Del" && (t = "Delete"), t == "Left" && (t = "ArrowLeft"), t == "Up" && (t = "ArrowUp"), t == "Right" && (t = "ArrowRight"), t == "Down" && (t = "ArrowDown"), t } const OCe = typeof navigator < "u" ? /Mac|iP(hone|[oa]d)/.test(navigator.platform) : !1; function DCe(n) { let e = n.split(/-(?!$)/), t = e[e.length - 1]; t == "Space" && (t = " "); let r, i, a, o; for (let s = 0; s < e.length - 1; s++) { let l = e[s]; if (/^(cmd|meta|m)$/i.test(l)) o = !0; else if (/^a(lt)?$/i.test(l)) r = !0; else if (/^(c|ctrl|control)$/i.test(l)) i = !0; else if (/^s(hift)?$/i.test(l)) a = !0; else if (/^mod$/i.test(l)) OCe ? o = !0 : i = !0; else throw new Error("Unrecognized modifier name: " + l) } return r && (t = "Alt-" + t), i && (t = "Ctrl-" + t), o && (t = "Meta-" + t), a && (t = "Shift-" + t), t } function jCe(n) { let e = Object.create(null); for (let t in n) e[DCe(t)] = n[t]; return e } function IE(n, e, t = !0) { return e.altKey && (n = "Alt-" + n), e.ctrlKey && (n = "Ctrl-" + n), e.metaKey && (n = "Meta-" + n), t && e.shiftKey && (n = "Shift-" + n), n } function PCe(n) { return new wn({ props: { handleKeyDown: IR(n) } }) } function IR(n) { let e = jCe(n); return function (t, r) { let i = MCe(r), a, o = e[IE(i, r)]; if (o && o(t.state, t.dispatch, t)) return !0; if (i.length == 1 && i != " ") { if (r.shiftKey) { let s = e[IE(i, r, !1)]; if (s && s(t.state, t.dispatch, t)) return !0 } if ((r.shiftKey || r.altKey || r.metaKey || i.charCodeAt(0) > 127) && (a = Sd[r.keyCode]) && a != i) { let s = e[IE(a, r)]; if (s && s(t.state, t.dispatch, t)) return !0 } } return !1 } } const jX = (n, e) => n.selection.empty ? !1 : (e && e(n.tr.deleteSelection().scrollIntoView()), !0); function PX(n, e) { let { $cursor: t } = n.selection; return !t || (e ? !e.endOfTextblock("backward", n) : t.parentOffset > 0) ? null : t } const IX = (n, e, t) => { let r = PX(n, t); if (!r) return !1; let i = LR(r); if (!i) { let o = r.blockRange(), s = o && Qh(o); return s == null ? !1 : (e && e(n.tr.lift(o, s).scrollIntoView()), !0) } let a = i.nodeBefore; if (XX(n, i, e, -1)) return !0; if (r.parent.content.size == 0 && (yg(a, "end") || _t.isSelectable(a))) for (let o = r.depth; ; o--) { let s = Sk(n.doc, r.before(o), r.after(o), Qe.empty); if (s && s.slice.size < s.to - s.from) { if (e) { let l = n.tr.step(s); l.setSelection(yg(a, "end") ? vt.findFrom(l.doc.resolve(l.mapping.map(i.pos, -1)), -1) : _t.create(l.doc, i.pos - a.nodeSize)), e(l.scrollIntoView()) } return !0 } if (o == 1 || r.node(o - 1).childCount > 1) break } return a.isAtom && i.depth == r.depth - 1 ? (e && e(n.tr.delete(i.pos - a.nodeSize, i.pos).scrollIntoView()), !0) : !1 }, LX = (n, e, t) => { let r = PX(n, t); if (!r) return !1; let i = LR(r); return i ? NX(n, i, e) : !1 }, RX = (n, e, t) => { let r = $X(n, t); if (!r) return !1; let i = RR(r); return i ? NX(n, i, e) : !1 }; function NX(n, e, t) { let r = e.nodeBefore, i = r, a = e.pos - 1; for (; !i.isTextblock; a--) { if (i.type.spec.isolating) return !1; let u = i.lastChild; if (!u) return !1; i = u } let o = e.nodeAfter, s = o, l = e.pos + 1; for (; !s.isTextblock; l++) { if (s.type.spec.isolating) return !1; let u = s.firstChild; if (!u) return !1; s = u } let c = Sk(n.doc, a, l, Qe.empty); if (!c || c.from != a || c instanceof Br && c.slice.size >= l - a) return !1; if (t) { let u = n.tr.step(c); u.setSelection(ht.create(u.doc, a)), t(u.scrollIntoView()) } return !0 } function yg(n, e, t = !1) { for (let r = n; r; r = e == "start" ? r.firstChild : r.lastChild) { if (r.isTextblock) return !0; if (t && r.childCount != 1) return !1 } return !1 } const BX = (n, e, t) => { let { $head: r, empty: i } = n.selection, a = r; if (!i) return !1; if (r.parent.isTextblock) { if (t ? !t.endOfTextblock("backward", n) : r.parentOffset > 0) return !1; a = LR(r) } let o = a && a.nodeBefore; return !o || !_t.isSelectable(o) ? !1 : (e && e(n.tr.setSelection(_t.create(n.doc, a.pos - o.nodeSize)).scrollIntoView()), !0) }; function LR(n) { if (!n.parent.type.spec.isolating) for (let e = n.depth - 1; e >= 0; e--) { if (n.index(e) > 0) return n.doc.resolve(n.before(e + 1)); if (n.node(e).type.spec.isolating) break } return null } function $X(n, e) { let { $cursor: t } = n.selection; return !t || (e ? !e.endOfTextblock("forward", n) : t.parentOffset < t.parent.content.size) ? null : t } const FX = (n, e, t) => { let r = $X(n, t); if (!r) return !1; let i = RR(r); if (!i) return !1; let a = i.nodeAfter; if (XX(n, i, e, 1)) return !0; if (r.parent.content.size == 0 && (yg(a, "start") || _t.isSelectable(a))) { let o = Sk(n.doc, r.before(), r.after(), Qe.empty); if (o && o.slice.size < o.to - o.from) { if (e) { let s = n.tr.step(o); s.setSelection(yg(a, "start") ? vt.findFrom(s.doc.resolve(s.mapping.map(i.pos)), 1) : _t.create(s.doc, s.mapping.map(i.pos))), e(s.scrollIntoView()) } return !0 } } return a.isAtom && i.depth == r.depth - 1 ? (e && e(n.tr.delete(i.pos, i.pos + a.nodeSize).scrollIntoView()), !0) : !1 }, zX = (n, e, t) => { let { $head: r, empty: i } = n.selection, a = r; if (!i) return !1; if (r.parent.isTextblock) { if (t ? !t.endOfTextblock("forward", n) : r.parentOffset < r.parent.content.size) return !1; a = RR(r) } let o = a && a.nodeAfter; return !o || !_t.isSelectable(o) ? !1 : (e && e(n.tr.setSelection(_t.create(n.doc, a.pos)).scrollIntoView()), !0) }; function RR(n) { if (!n.parent.type.spec.isolating) for (let e = n.depth - 1; e >= 0; e--) { let t = n.node(e); if (n.index(e) + 1 < t.childCount) return n.doc.resolve(n.after(e + 1)); if (t.type.spec.isolating) break } return null } const VX = (n, e) => { let t = n.selection, r = t instanceof _t, i; if (r) { if (t.node.isTextblock || !Dl(n.doc, t.from)) return !1; i = t.from } else if (i = Hg(n.doc, t.from, -1), i == null) return !1; if (e) { let a = n.tr.join(i); r && a.setSelection(_t.create(a.doc, i - n.doc.resolve(i).nodeBefore.nodeSize)), e(a.scrollIntoView()) } return !0 }, HX = (n, e) => { let t = n.selection, r; if (t instanceof _t) { if (t.node.isTextblock || !Dl(n.doc, t.to)) return !1; r = t.to } else if (r = Hg(n.doc, t.to, 1), r == null) return !1; return e && e(n.tr.join(r).scrollIntoView()), !0 }, UX = (n, e) => { let { $from: t, $to: r } = n.selection, i = t.blockRange(r), a = i && Qh(i); return a == null ? !1 : (e && e(n.tr.lift(i, a).scrollIntoView()), !0) }, GX = (n, e) => {
  let { $head: t, $anchor: r } = n.selection; return !t.parent.type.spec.code || !t.sameParent(r) ? !1 : (e && e(n.tr.insertText(`
`).scrollIntoView()), !0)
}; function WX(n) { for (let e = 0; e < n.edgeCount; e++) { let { type: t } = n.edge(e); if (t.isTextblock && !t.hasRequiredAttrs()) return t } return null } const KX = (n, e) => { let { $head: t, $anchor: r } = n.selection; if (!t.parent.type.spec.code || !t.sameParent(r)) return !1; let i = t.node(-1), a = t.indexAfter(-1), o = WX(i.contentMatchAt(a)); if (!o || !i.canReplaceWith(a, a, o)) return !1; if (e) { let s = t.after(), l = n.tr.replaceWith(s, s, o.createAndFill()); l.setSelection(vt.near(l.doc.resolve(s), 1)), e(l.scrollIntoView()) } return !0 }, qX = (n, e) => { let t = n.selection, { $from: r, $to: i } = t; if (t instanceof Ro || r.parent.inlineContent || i.parent.inlineContent) return !1; let a = WX(i.parent.contentMatchAt(i.indexAfter())); if (!a || !a.isTextblock) return !1; if (e) { let o = (!r.parentOffset && i.index() < i.parent.childCount ? r : i).pos, s = n.tr.insert(o, a.createAndFill()); s.setSelection(ht.create(s.doc, o + 1)), e(s.scrollIntoView()) } return !0 }, YX = (n, e) => { let { $cursor: t } = n.selection; if (!t || t.parent.content.size) return !1; if (t.depth > 1 && t.after() != t.end(-1)) { let a = t.before(); if (hl(n.doc, a)) return e && e(n.tr.split(a).scrollIntoView()), !0 } let r = t.blockRange(), i = r && Qh(r); return i == null ? !1 : (e && e(n.tr.lift(r, i).scrollIntoView()), !0) }, ZX = (n, e) => { let { $from: t, to: r } = n.selection, i, a = t.sharedDepth(r); return a == 0 ? !1 : (i = t.before(a), e && e(n.tr.setSelection(_t.create(n.doc, i))), !0) }; function ICe(n, e, t) { let r = e.nodeBefore, i = e.nodeAfter, a = e.index(); return !r || !i || !r.type.compatibleContent(i.type) ? !1 : !r.content.size && e.parent.canReplace(a - 1, a) ? (t && t(n.tr.delete(e.pos - r.nodeSize, e.pos).scrollIntoView()), !0) : !e.parent.canReplace(a, a + 1) || !(i.isTextblock || Dl(n.doc, e.pos)) ? !1 : (t && t(n.tr.clearIncompatible(e.pos, r.type, r.contentMatchAt(r.childCount)).join(e.pos).scrollIntoView()), !0) } function XX(n, e, t, r) { let i = e.nodeBefore, a = e.nodeAfter, o, s, l = i.type.spec.isolating || a.type.spec.isolating; if (!l && ICe(n, e, t)) return !0; let c = !l && e.parent.canReplace(e.index(), e.index() + 1); if (c && (o = (s = i.contentMatchAt(i.childCount)).findWrapping(a.type)) && s.matchType(o[0] || a.type).validEnd) { if (t) { let h = e.pos + a.nodeSize, p = Be.empty; for (let y = o.length - 1; y >= 0; y--)p = Be.from(o[y].create(null, p)); p = Be.from(i.copy(p)); let m = n.tr.step(new Hr(e.pos - 1, h, e.pos, h, new Qe(p, 1, 0), o.length, !0)), g = h + 2 * o.length; Dl(m.doc, g) && m.join(g), t(m.scrollIntoView()) } return !0 } let u = a.type.spec.isolating || r > 0 && l ? null : vt.findFrom(e, 1), d = u && u.$from.blockRange(u.$to), f = d && Qh(d); if (f != null && f >= e.depth) return t && t(n.tr.lift(d, f).scrollIntoView()), !0; if (c && yg(a, "start", !0) && yg(i, "end")) { let h = i, p = []; for (; p.push(h), !h.isTextblock;)h = h.lastChild; let m = a, g = 1; for (; !m.isTextblock; m = m.firstChild)g++; if (h.canReplace(h.childCount, h.childCount, m.content)) { if (t) { let y = Be.empty; for (let w = p.length - 1; w >= 0; w--)y = Be.from(p[w].copy(y)); let b = n.tr.step(new Hr(e.pos - p.length, e.pos + a.nodeSize, e.pos + g, e.pos + a.nodeSize - g, new Qe(y, p.length, 0), 0, !0)); t(b.scrollIntoView()) } return !0 } } return !1 } function JX(n) { return function (e, t) { let r = e.selection, i = n < 0 ? r.$from : r.$to, a = i.depth; for (; i.node(a).isInline;) { if (!a) return !1; a-- } return i.node(a).isTextblock ? (t && t(e.tr.setSelection(ht.create(e.doc, n < 0 ? i.start(a) : i.end(a)))), !0) : !1 } } const QX = JX(-1), eJ = JX(1); function tJ(n, e = null) { return function (t, r) { let { $from: i, $to: a } = t.selection, o = i.blockRange(a), s = o && SR(o, n, e); return s ? (r && r(t.tr.wrap(o, s).scrollIntoView()), !0) : !1 } } function t2(n, e = null) { return function (t, r) { let i = !1; for (let a = 0; a < t.selection.ranges.length && !i; a++) { let { $from: { pos: o }, $to: { pos: s } } = t.selection.ranges[a]; t.doc.nodesBetween(o, s, (l, c) => { if (i) return !1; if (!(!l.isTextblock || l.hasMarkup(n, e))) if (l.type == n) i = !0; else { let u = t.doc.resolve(c), d = u.index(); i = u.parent.canReplaceWith(d, d + 1, n) } }) } if (!i) return !1; if (r) { let a = t.tr; for (let o = 0; o < t.selection.ranges.length; o++) { let { $from: { pos: s }, $to: { pos: l } } = t.selection.ranges[o]; a.setBlockType(s, l, n, e) } r(a.scrollIntoView()) } return !0 } } typeof navigator < "u" ? /Mac|iP(hone|[oa]d)/.test(navigator.platform) : typeof os < "u" && os.platform && os.platform() == "darwin"; function nJ(n, e = null) { return function (t, r) { let { $from: i, $to: a } = t.selection, o = i.blockRange(a), s = !1, l = o; if (!o) return !1; if (o.depth >= 2 && i.node(o.depth - 1).type.compatibleContent(n) && o.startIndex == 0) { if (i.index(o.depth - 1) == 0) return !1; let u = t.doc.resolve(o.start - 2); l = new GS(u, u, o.depth), o.endIndex < o.parent.childCount && (o = new GS(i, t.doc.resolve(a.end(o.depth)), o.depth)), s = !0 } let c = SR(l, n, e, o); return c ? (r && r(LCe(t.tr, o, c, s, n).scrollIntoView()), !0) : !1 } } function LCe(n, e, t, r, i) { let a = Be.empty; for (let u = t.length - 1; u >= 0; u--)a = Be.from(t[u].type.create(t[u].attrs, a)); n.step(new Hr(e.start - (r ? 2 : 0), e.end, e.start, e.end, new Qe(a, 0, 0), t.length, !0)); let o = 0; for (let u = 0; u < t.length; u++)t[u].type == i && (o = u + 1); let s = t.length - o, l = e.start + t.length - (r ? 2 : 0), c = e.parent; for (let u = e.startIndex, d = e.endIndex, f = !0; u < d; u++, f = !1)!f && hl(n.doc, l, s) && (n.split(l, s), l += 2 * s), l += c.child(u).nodeSize; return n } function rJ(n) { return function (e, t) { let { $from: r, $to: i } = e.selection, a = r.blockRange(i, o => o.childCount > 0 && o.firstChild.type == n); return a ? t ? r.node(a.depth - 1).type == n ? RCe(e, t, n, a) : NCe(e, t, a) : !0 : !1 } } function RCe(n, e, t, r) { let i = n.tr, a = r.end, o = r.$to.end(r.depth); a < o && (i.step(new Hr(a - 1, o, a, o, new Qe(Be.from(t.create(null, r.parent.copy())), 1, 0), 1, !0)), r = new GS(i.doc.resolve(r.$from.pos), i.doc.resolve(o), r.depth)); const s = Qh(r); if (s == null) return !1; i.lift(r, s); let l = i.mapping.map(a, -1) - 1; return Dl(i.doc, l) && i.join(l), e(i.scrollIntoView()), !0 } function NCe(n, e, t) { let r = n.tr, i = t.parent; for (let h = t.end, p = t.endIndex - 1, m = t.startIndex; p > m; p--)h -= i.child(p).nodeSize, r.delete(h - 1, h + 1); let a = r.doc.resolve(t.start), o = a.nodeAfter; if (r.mapping.map(t.end) != t.start + a.nodeAfter.nodeSize) return !1; let s = t.startIndex == 0, l = t.endIndex == i.childCount, c = a.node(-1), u = a.index(-1); if (!c.canReplace(u + (s ? 0 : 1), u + 1, o.content.append(l ? Be.empty : Be.from(i)))) return !1; let d = a.pos, f = d + o.nodeSize; return r.step(new Hr(d - (s ? 1 : 0), f + (l ? 1 : 0), d + 1, f - 1, new Qe((s ? Be.empty : Be.from(i.copy(Be.empty))).append(l ? Be.empty : Be.from(i.copy(Be.empty))), s ? 0 : 1, l ? 0 : 1), s ? 0 : 1)), e(r.scrollIntoView()), !0 } function iJ(n) { return function (e, t) { let { $from: r, $to: i } = e.selection, a = r.blockRange(i, c => c.childCount > 0 && c.firstChild.type == n); if (!a) return !1; let o = a.startIndex; if (o == 0) return !1; let s = a.parent, l = s.child(o - 1); if (l.type != n) return !1; if (t) { let c = l.lastChild && l.lastChild.type == s.type, u = Be.from(c ? n.create() : null), d = new Qe(Be.from(n.create(null, Be.from(s.type.create(null, u)))), c ? 3 : 1, 0), f = a.start, h = a.end; t(e.tr.step(new Hr(f - (c ? 3 : 1), h, f, h, d, 1, !0)).scrollIntoView()) } return !0 } } function Ek(n) { const { state: e, transaction: t } = n; let { selection: r } = t, { doc: i } = t, { storedMarks: a } = t; return { ...e, apply: e.apply.bind(e), applyTransaction: e.applyTransaction.bind(e), plugins: e.plugins, schema: e.schema, reconfigure: e.reconfigure.bind(e), toJSON: e.toJSON.bind(e), get storedMarks() { return a }, get selection() { return r }, get doc() { return i }, get tr() { return r = t.selection, i = t.doc, a = t.storedMarks, t } } } let Mk = class { constructor(e) { this.editor = e.editor, this.rawCommands = this.editor.extensionManager.commands, this.customState = e.state } get hasCustomState() { return !!this.customState } get state() { return this.customState || this.editor.state } get commands() { const { rawCommands: e, editor: t, state: r } = this, { view: i } = t, { tr: a } = r, o = this.buildProps(a); return Object.fromEntries(Object.entries(e).map(([s, l]) => [s, (...u) => { const d = l(...u)(o); return !a.getMeta("preventDispatch") && !this.hasCustomState && i.dispatch(a), d }])) } get chain() { return () => this.createChain() } get can() { return () => this.createCan() } createChain(e, t = !0) { const { rawCommands: r, editor: i, state: a } = this, { view: o } = i, s = [], l = !!e, c = e || a.tr, u = () => (!l && t && !c.getMeta("preventDispatch") && !this.hasCustomState && o.dispatch(c), s.every(f => f === !0)), d = { ...Object.fromEntries(Object.entries(r).map(([f, h]) => [f, (...m) => { const g = this.buildProps(c, t), y = h(...m)(g); return s.push(y), d }])), run: u }; return d } createCan(e) { const { rawCommands: t, state: r } = this, i = !1, a = e || r.tr, o = this.buildProps(a, i); return { ...Object.fromEntries(Object.entries(t).map(([l, c]) => [l, (...u) => c(...u)({ ...o, dispatch: void 0 })])), chain: () => this.createChain(a, i) } } buildProps(e, t = !0) { const { rawCommands: r, editor: i, state: a } = this, { view: o } = i, s = { tr: e, editor: i, view: o, state: Ek({ state: a, transaction: e }), dispatch: t ? () => { } : void 0, chain: () => this.createChain(e, t), can: () => this.createCan(e), get commands() { return Object.fromEntries(Object.entries(r).map(([l, c]) => [l, (...u) => c(...u)(s)])) } }; return s } }; class BCe { constructor() { this.callbacks = {} } on(e, t) { return this.callbacks[e] || (this.callbacks[e] = []), this.callbacks[e].push(t), this } emit(e, ...t) { const r = this.callbacks[e]; return r && r.forEach(i => i.apply(this, t)), this } off(e, t) { const r = this.callbacks[e]; return r && (t ? this.callbacks[e] = r.filter(i => i !== t) : delete this.callbacks[e]), this } once(e, t) { const r = (...i) => { this.off(e, r), t.apply(this, i) }; return this.on(e, r) } removeAllListeners() { this.callbacks = {} } } function dt(n, e, t) { return n.config[e] === void 0 && n.parent ? dt(n.parent, e, t) : typeof n.config[e] == "function" ? n.config[e].bind({ ...t, parent: n.parent ? dt(n.parent, e, t) : null }) : n.config[e] } function Ok(n) { const e = n.filter(i => i.type === "extension"), t = n.filter(i => i.type === "node"), r = n.filter(i => i.type === "mark"); return { baseExtensions: e, nodeExtensions: t, markExtensions: r } } function aJ(n) { const e = [], { nodeExtensions: t, markExtensions: r } = Ok(n), i = [...t, ...r], a = { default: null, rendered: !0, renderHTML: null, parseHTML: null, keepOnSplit: !0, isRequired: !1 }; return n.forEach(o => { const s = { name: o.name, options: o.options, storage: o.storage, extensions: i }, l = dt(o, "addGlobalAttributes", s); if (!l) return; l().forEach(u => { u.types.forEach(d => { Object.entries(u.attributes).forEach(([f, h]) => { e.push({ type: d, name: f, attribute: { ...a, ...h } }) }) }) }) }), i.forEach(o => { const s = { name: o.name, options: o.options, storage: o.storage }, l = dt(o, "addAttributes", s); if (!l) return; const c = l(); Object.entries(c).forEach(([u, d]) => { const f = { ...a, ...d }; typeof (f == null ? void 0 : f.default) == "function" && (f.default = f.default()), f != null && f.isRequired && (f == null ? void 0 : f.default) === void 0 && delete f.default, e.push({ type: o.name, name: u, attribute: f }) }) }), e } function ei(n, e) { if (typeof n == "string") { if (!e.nodes[n]) throw Error(`There is no node type named '${n}'. Maybe you forgot to add the extension?`); return e.nodes[n] } return n } function Zr(...n) { return n.filter(e => !!e).reduce((e, t) => { const r = { ...e }; return Object.entries(t).forEach(([i, a]) => { if (!r[i]) { r[i] = a; return } if (i === "class") { const s = a ? String(a).split(" ") : [], l = r[i] ? r[i].split(" ") : [], c = s.filter(u => !l.includes(u)); r[i] = [...l, ...c].join(" ") } else if (i === "style") { const s = a ? a.split(";").map(u => u.trim()).filter(Boolean) : [], l = r[i] ? r[i].split(";").map(u => u.trim()).filter(Boolean) : [], c = new Map; l.forEach(u => { const [d, f] = u.split(":").map(h => h.trim()); c.set(d, f) }), s.forEach(u => { const [d, f] = u.split(":").map(h => h.trim()); c.set(d, f) }), r[i] = Array.from(c.entries()).map(([u, d]) => `${u}: ${d}`).join("; ") } else r[i] = a }), r }, {}) } function Uj(n, e) { return e.filter(t => t.type === n.type.name).filter(t => t.attribute.rendered).map(t => t.attribute.renderHTML ? t.attribute.renderHTML(n.attrs) || {} : { [t.name]: n.attrs[t.name] }).reduce((t, r) => Zr(t, r), {}) } function oJ(n) { return typeof n == "function" } function cn(n, e = void 0, ...t) { return oJ(n) ? e ? n.bind(e)(...t) : n(...t) : n } function $Ce(n = {}) { return Object.keys(n).length === 0 && n.constructor === Object } function FCe(n) { return typeof n != "string" ? n : n.match(/^[+-]?(?:\d*\.)?\d+$/) ? Number(n) : n === "true" ? !0 : n === "false" ? !1 : n } function JF(n, e) { return "style" in n ? n : { ...n, getAttrs: t => { const r = n.getAttrs ? n.getAttrs(t) : n.attrs; if (r === !1) return !1; const i = e.reduce((a, o) => { const s = o.attribute.parseHTML ? o.attribute.parseHTML(t) : FCe(t.getAttribute(o.name)); return s == null ? a : { ...a, [o.name]: s } }, {}); return { ...r, ...i } } } } function QF(n) { return Object.fromEntries(Object.entries(n).filter(([e, t]) => e === "attrs" && $Ce(t) ? !1 : t != null)) } function zCe(n, e) { var t; const r = aJ(n), { nodeExtensions: i, markExtensions: a } = Ok(n), o = (t = i.find(c => dt(c, "topNode"))) === null || t === void 0 ? void 0 : t.name, s = Object.fromEntries(i.map(c => { const u = r.filter(y => y.type === c.name), d = { name: c.name, options: c.options, storage: c.storage, editor: e }, f = n.reduce((y, b) => { const w = dt(b, "extendNodeSchema", d); return { ...y, ...w ? w(c) : {} } }, {}), h = QF({ ...f, content: cn(dt(c, "content", d)), marks: cn(dt(c, "marks", d)), group: cn(dt(c, "group", d)), inline: cn(dt(c, "inline", d)), atom: cn(dt(c, "atom", d)), selectable: cn(dt(c, "selectable", d)), draggable: cn(dt(c, "draggable", d)), code: cn(dt(c, "code", d)), whitespace: cn(dt(c, "whitespace", d)), linebreakReplacement: cn(dt(c, "linebreakReplacement", d)), defining: cn(dt(c, "defining", d)), isolating: cn(dt(c, "isolating", d)), attrs: Object.fromEntries(u.map(y => { var b; return [y.name, { default: (b = y == null ? void 0 : y.attribute) === null || b === void 0 ? void 0 : b.default }] })) }), p = cn(dt(c, "parseHTML", d)); p && (h.parseDOM = p.map(y => JF(y, u))); const m = dt(c, "renderHTML", d); m && (h.toDOM = y => m({ node: y, HTMLAttributes: Uj(y, u) })); const g = dt(c, "renderText", d); return g && (h.toText = g), [c.name, h] })), l = Object.fromEntries(a.map(c => { const u = r.filter(g => g.type === c.name), d = { name: c.name, options: c.options, storage: c.storage, editor: e }, f = n.reduce((g, y) => { const b = dt(y, "extendMarkSchema", d); return { ...g, ...b ? b(c) : {} } }, {}), h = QF({ ...f, inclusive: cn(dt(c, "inclusive", d)), excludes: cn(dt(c, "excludes", d)), group: cn(dt(c, "group", d)), spanning: cn(dt(c, "spanning", d)), code: cn(dt(c, "code", d)), attrs: Object.fromEntries(u.map(g => { var y; return [g.name, { default: (y = g == null ? void 0 : g.attribute) === null || y === void 0 ? void 0 : y.default }] })) }), p = cn(dt(c, "parseHTML", d)); p && (h.parseDOM = p.map(g => JF(g, u))); const m = dt(c, "renderHTML", d); return m && (h.toDOM = g => m({ mark: g, HTMLAttributes: Uj(g, u) })), [c.name, h] })); return new wR({ topNode: o, nodes: s, marks: l }) } function LE(n, e) { return e.nodes[n] || e.marks[n] || null } function ez(n, e) { return Array.isArray(e) ? e.some(t => (typeof t == "string" ? t : t.name) === n.name) : e } function NR(n, e) { const t = Jh.fromSchema(e).serializeFragment(n), i = document.implementation.createHTMLDocument().createElement("div"); return i.appendChild(t), i.innerHTML } const VCe = (n, e = 500) => { let t = ""; const r = n.parentOffset; return n.parent.nodesBetween(Math.max(0, r - e), r, (i, a, o, s) => { var l, c; const u = ((c = (l = i.type.spec).toText) === null || c === void 0 ? void 0 : c.call(l, { node: i, pos: a, parent: o, index: s })) || i.textContent || "%leaf%"; t += i.isAtom && !i.isText ? u : u.slice(0, Math.max(0, r - a)) }), t }; function BR(n) { return Object.prototype.toString.call(n) === "[object RegExp]" } let $R = class { constructor(e) { this.find = e.find, this.handler = e.handler } }; const HCe = (n, e) => { if (BR(e)) return e.exec(n); const t = e(n); if (!t) return null; const r = [t.text]; return r.index = t.index, r.input = n, r.data = t.data, t.replaceWith && (t.text.includes(t.replaceWith) || console.warn('[tiptap warn]: "inputRuleMatch.replaceWith" must be part of "inputRuleMatch.text".'), r.push(t.replaceWith)), r }; function J1(n) { var e; const { editor: t, from: r, to: i, text: a, rules: o, plugin: s } = n, { view: l } = t; if (l.composing) return !1; const c = l.state.doc.resolve(r); if (c.parent.type.spec.code || !((e = c.nodeBefore || c.nodeAfter) === null || e === void 0) && e.marks.find(f => f.type.spec.code)) return !1; let u = !1; const d = VCe(c) + a; return o.forEach(f => { if (u) return; const h = HCe(d, f.find); if (!h) return; const p = l.state.tr, m = Ek({ state: l.state, transaction: p }), g = { from: r - (h[0].length - a.length), to: i }, { commands: y, chain: b, can: w } = new Mk({ editor: t, state: m }); f.handler({ state: m, range: g, match: h, commands: y, chain: b, can: w }) === null || !p.steps.length || (p.setMeta(s, { transform: p, from: r, to: i, text: a }), l.dispatch(p), u = !0) }), u } function UCe(n) {
  const { editor: e, rules: t } = n, r = new wn({
    state: { init() { return null }, apply(i, a, o) { const s = i.getMeta(r); if (s) return s; const l = i.getMeta("applyInputRules"); return !!l && setTimeout(() => { let { text: u } = l; typeof u == "string" ? u = u : u = NR(Be.from(u), o.schema); const { from: d } = l, f = d + u.length; J1({ editor: e, from: d, to: f, text: u, rules: t, plugin: r }) }), i.selectionSet || i.docChanged ? null : a } }, props: {
      handleTextInput(i, a, o, s) { return J1({ editor: e, from: a, to: o, text: s, rules: t, plugin: r }) }, handleDOMEvents: { compositionend: i => (setTimeout(() => { const { $cursor: a } = i.state.selection; a && J1({ editor: e, from: a.pos, to: a.pos, text: "", rules: t, plugin: r }) }), !1) }, handleKeyDown(i, a) {
        if (a.key !== "Enter") return !1; const { $cursor: o } = i.state.selection; return o ? J1({
          editor: e, from: o.pos, to: o.pos, text: `
`, rules: t, plugin: r
        }) : !1
      }
    }, isInputRules: !0
  }); return r
} function GCe(n) { return Object.prototype.toString.call(n).slice(8, -1) } function Q1(n) { return GCe(n) !== "Object" ? !1 : n.constructor === Object && Object.getPrototypeOf(n) === Object.prototype } function Dk(n, e) { const t = { ...n }; return Q1(n) && Q1(e) && Object.keys(e).forEach(r => { Q1(e[r]) && Q1(n[r]) ? t[r] = Dk(n[r], e[r]) : t[r] = e[r] }), t } let jk = class Gj { constructor(e = {}) { this.type = "mark", this.name = "mark", this.parent = null, this.child = null, this.config = { name: this.name, defaultOptions: {} }, this.config = { ...this.config, ...e }, this.name = this.config.name, e.defaultOptions && Object.keys(e.defaultOptions).length > 0 && console.warn(`[tiptap warn]: BREAKING CHANGE: "defaultOptions" is deprecated. Please use "addOptions" instead. Found in extension: "${this.name}".`), this.options = this.config.defaultOptions, this.config.addOptions && (this.options = cn(dt(this, "addOptions", { name: this.name }))), this.storage = cn(dt(this, "addStorage", { name: this.name, options: this.options })) || {} } static create(e = {}) { return new Gj(e) } configure(e = {}) { const t = this.extend({ ...this.config, addOptions: () => Dk(this.options, e) }); return t.name = this.name, t.parent = this.parent, t } extend(e = {}) { const t = new Gj(e); return t.parent = this, this.child = t, t.name = e.name ? e.name : t.parent.name, e.defaultOptions && Object.keys(e.defaultOptions).length > 0 && console.warn(`[tiptap warn]: BREAKING CHANGE: "defaultOptions" is deprecated. Please use "addOptions" instead. Found in extension: "${t.name}".`), t.options = cn(dt(t, "addOptions", { name: t.name })), t.storage = cn(dt(t, "addStorage", { name: t.name, options: t.options })), t } static handleExit({ editor: e, mark: t }) { const { tr: r } = e.state, i = e.state.selection.$from; if (i.pos === i.end()) { const o = i.marks(); if (!!!o.find(c => (c == null ? void 0 : c.type.name) === t.name)) return !1; const l = o.find(c => (c == null ? void 0 : c.type.name) === t.name); return l && r.removeStoredMark(l), r.insertText(" ", i.pos), e.view.dispatch(r), !0 } return !1 } }; function WCe(n) { return typeof n == "number" } let KCe = class { constructor(e) { this.find = e.find, this.handler = e.handler } }; const qCe = (n, e, t) => { if (BR(e)) return [...n.matchAll(e)]; const r = e(n, t); return r ? r.map(i => { const a = [i.text]; return a.index = i.index, a.input = n, a.data = i.data, i.replaceWith && (i.text.includes(i.replaceWith) || console.warn('[tiptap warn]: "pasteRuleMatch.replaceWith" must be part of "pasteRuleMatch.text".'), a.push(i.replaceWith)), a }) : [] }; function YCe(n) { const { editor: e, state: t, from: r, to: i, rule: a, pasteEvent: o, dropEvent: s } = n, { commands: l, chain: c, can: u } = new Mk({ editor: e, state: t }), d = []; return t.doc.nodesBetween(r, i, (h, p) => { if (!h.isTextblock || h.type.spec.code) return; const m = Math.max(r, p), g = Math.min(i, p + h.content.size), y = h.textBetween(m - p, g - p, void 0, ""); qCe(y, a.find, o).forEach(w => { if (w.index === void 0) return; const v = m + w.index + 1, S = v + w[0].length, x = { from: t.tr.mapping.map(v), to: t.tr.mapping.map(S) }, k = a.handler({ state: t, range: x, match: w, commands: l, chain: c, can: u, pasteEvent: o, dropEvent: s }); d.push(k) }) }), d.every(h => h !== null) } let ew = null; const ZCe = n => { var e; const t = new ClipboardEvent("paste", { clipboardData: new DataTransfer }); return (e = t.clipboardData) === null || e === void 0 || e.setData("text/html", n), t }; function XCe(n) { const { editor: e, rules: t } = n; let r = null, i = !1, a = !1, o = typeof ClipboardEvent < "u" ? new ClipboardEvent("paste") : null, s; try { s = typeof DragEvent < "u" ? new DragEvent("drop") : null } catch { s = null } const l = ({ state: u, from: d, to: f, rule: h, pasteEvt: p }) => { const m = u.tr, g = Ek({ state: u, transaction: m }); if (!(!YCe({ editor: e, state: g, from: Math.max(d - 1, 0), to: f.b - 1, rule: h, pasteEvent: p, dropEvent: s }) || !m.steps.length)) { try { s = typeof DragEvent < "u" ? new DragEvent("drop") : null } catch { s = null } return o = typeof ClipboardEvent < "u" ? new ClipboardEvent("paste") : null, m } }; return t.map(u => new wn({ view(d) { const f = p => { var m; r = !((m = d.dom.parentElement) === null || m === void 0) && m.contains(p.target) ? d.dom.parentElement : null, r && (ew = e) }, h = () => { ew && (ew = null) }; return window.addEventListener("dragstart", f), window.addEventListener("dragend", h), { destroy() { window.removeEventListener("dragstart", f), window.removeEventListener("dragend", h) } } }, props: { handleDOMEvents: { drop: (d, f) => { if (a = r === d.dom.parentElement, s = f, !a) { const h = ew; h && setTimeout(() => { const p = h.state.selection; p && h.commands.deleteRange({ from: p.from, to: p.to }) }, 10) } return !1 }, paste: (d, f) => { var h; const p = (h = f.clipboardData) === null || h === void 0 ? void 0 : h.getData("text/html"); return o = f, i = !!(p != null && p.includes("data-pm-slice")), !1 } } }, appendTransaction: (d, f, h) => { const p = d[0], m = p.getMeta("uiEvent") === "paste" && !i, g = p.getMeta("uiEvent") === "drop" && !a, y = p.getMeta("applyPasteRules"), b = !!y; if (!m && !g && !b) return; if (b) { let { text: S } = y; typeof S == "string" ? S = S : S = NR(Be.from(S), h.schema); const { from: x } = y, k = x + S.length, A = ZCe(S); return l({ rule: u, state: h, from: x, to: { b: k }, pasteEvt: A }) } const w = f.doc.content.findDiffStart(h.doc.content), v = f.doc.content.findDiffEnd(h.doc.content); if (!(!WCe(w) || !v || w === v.b)) return l({ rule: u, state: h, from: w, to: v, pasteEvt: o }) } })) } function JCe(n) { const e = n.filter((t, r) => n.indexOf(t) !== r); return Array.from(new Set(e)) } class Dm { constructor(e, t) { this.splittableMarks = [], this.editor = t, this.extensions = Dm.resolve(e), this.schema = zCe(this.extensions, t), this.setupExtensions() } static resolve(e) { const t = Dm.sort(Dm.flatten(e)), r = JCe(t.map(i => i.name)); return r.length && console.warn(`[tiptap warn]: Duplicate extension names found: [${r.map(i => `'${i}'`).join(", ")}]. This can lead to issues.`), t } static flatten(e) { return e.map(t => { const r = { name: t.name, options: t.options, storage: t.storage }, i = dt(t, "addExtensions", r); return i ? [t, ...this.flatten(i())] : t }).flat(10) } static sort(e) { return e.sort((r, i) => { const a = dt(r, "priority") || 100, o = dt(i, "priority") || 100; return a > o ? -1 : a < o ? 1 : 0 }) } get commands() { return this.extensions.reduce((e, t) => { const r = { name: t.name, options: t.options, storage: t.storage, editor: this.editor, type: LE(t.name, this.schema) }, i = dt(t, "addCommands", r); return i ? { ...e, ...i() } : e }, {}) } get plugins() { const { editor: e } = this, t = Dm.sort([...this.extensions].reverse()), r = [], i = [], a = t.map(o => { const s = { name: o.name, options: o.options, storage: o.storage, editor: e, type: LE(o.name, this.schema) }, l = [], c = dt(o, "addKeyboardShortcuts", s); let u = {}; if (o.type === "mark" && dt(o, "exitable", s) && (u.ArrowRight = () => jk.handleExit({ editor: e, mark: o })), c) { const m = Object.fromEntries(Object.entries(c()).map(([g, y]) => [g, () => y({ editor: e })])); u = { ...u, ...m } } const d = PCe(u); l.push(d); const f = dt(o, "addInputRules", s); ez(o, e.options.enableInputRules) && f && r.push(...f()); const h = dt(o, "addPasteRules", s); ez(o, e.options.enablePasteRules) && h && i.push(...h()); const p = dt(o, "addProseMirrorPlugins", s); if (p) { const m = p(); l.push(...m) } return l }).flat(); return [UCe({ editor: e, rules: r }), ...XCe({ editor: e, rules: i }), ...a] } get attributes() { return aJ(this.extensions) } get nodeViews() { const { editor: e } = this, { nodeExtensions: t } = Ok(this.extensions); return Object.fromEntries(t.filter(r => !!dt(r, "addNodeView")).map(r => { const i = this.attributes.filter(l => l.type === r.name), a = { name: r.name, options: r.options, storage: r.storage, editor: e, type: ei(r.name, this.schema) }, o = dt(r, "addNodeView", a); if (!o) return []; const s = (l, c, u, d, f) => { const h = Uj(l, i); return o()({ node: l, view: c, getPos: u, decorations: d, innerDecorations: f, editor: e, extension: r, HTMLAttributes: h }) }; return [r.name, s] })) } setupExtensions() { this.extensions.forEach(e => { var t; this.editor.extensionStorage[e.name] = e.storage; const r = { name: e.name, options: e.options, storage: e.storage, editor: this.editor, type: LE(e.name, this.schema) }; e.type === "mark" && (!((t = cn(dt(e, "keepOnSplit", r))) !== null && t !== void 0) || t) && this.splittableMarks.push(e.name); const i = dt(e, "onBeforeCreate", r), a = dt(e, "onCreate", r), o = dt(e, "onUpdate", r), s = dt(e, "onSelectionUpdate", r), l = dt(e, "onTransaction", r), c = dt(e, "onFocus", r), u = dt(e, "onBlur", r), d = dt(e, "onDestroy", r); i && this.editor.on("beforeCreate", i), a && this.editor.on("create", a), o && this.editor.on("update", o), s && this.editor.on("selectionUpdate", s), l && this.editor.on("transaction", l), c && this.editor.on("focus", c), u && this.editor.on("blur", u), d && this.editor.on("destroy", d) }) } } let Bi = class Wj { constructor(e = {}) { this.type = "extension", this.name = "extension", this.parent = null, this.child = null, this.config = { name: this.name, defaultOptions: {} }, this.config = { ...this.config, ...e }, this.name = this.config.name, e.defaultOptions && Object.keys(e.defaultOptions).length > 0 && console.warn(`[tiptap warn]: BREAKING CHANGE: "defaultOptions" is deprecated. Please use "addOptions" instead. Found in extension: "${this.name}".`), this.options = this.config.defaultOptions, this.config.addOptions && (this.options = cn(dt(this, "addOptions", { name: this.name }))), this.storage = cn(dt(this, "addStorage", { name: this.name, options: this.options })) || {} } static create(e = {}) { return new Wj(e) } configure(e = {}) { const t = this.extend({ ...this.config, addOptions: () => Dk(this.options, e) }); return t.name = this.name, t.parent = this.parent, t } extend(e = {}) { const t = new Wj({ ...this.config, ...e }); return t.parent = this, this.child = t, t.name = e.name ? e.name : t.parent.name, e.defaultOptions && Object.keys(e.defaultOptions).length > 0 && console.warn(`[tiptap warn]: BREAKING CHANGE: "defaultOptions" is deprecated. Please use "addOptions" instead. Found in extension: "${t.name}".`), t.options = cn(dt(t, "addOptions", { name: t.name })), t.storage = cn(dt(t, "addStorage", { name: t.name, options: t.options })), t } }; function sJ(n, e, t) {
  const { from: r, to: i } = e, { blockSeparator: a = `

`, textSerializers: o = {} } = t || {}; let s = ""; return n.nodesBetween(r, i, (l, c, u, d) => { var f; l.isBlock && c > r && (s += a); const h = o == null ? void 0 : o[l.type.name]; if (h) return u && (s += h({ node: l, pos: c, parent: u, index: d, range: e })), !1; l.isText && (s += (f = l == null ? void 0 : l.text) === null || f === void 0 ? void 0 : f.slice(Math.max(r, c) - c, i - c)) }), s
} function lJ(n) { return Object.fromEntries(Object.entries(n.nodes).filter(([, e]) => e.spec.toText).map(([e, t]) => [e, t.spec.toText])) } const QCe = Bi.create({ name: "clipboardTextSerializer", addOptions() { return { blockSeparator: void 0 } }, addProseMirrorPlugins() { return [new wn({ key: new xn("clipboardTextSerializer"), props: { clipboardTextSerializer: () => { const { editor: n } = this, { state: e, schema: t } = n, { doc: r, selection: i } = e, { ranges: a } = i, o = Math.min(...a.map(u => u.$from.pos)), s = Math.max(...a.map(u => u.$to.pos)), l = lJ(t); return sJ(r, { from: o, to: s }, { ...this.options.blockSeparator !== void 0 ? { blockSeparator: this.options.blockSeparator } : {}, textSerializers: l }) } } })] } }), eAe = () => ({ editor: n, view: e }) => (requestAnimationFrame(() => { var t; n.isDestroyed || (e.dom.blur(), (t = window == null ? void 0 : window.getSelection()) === null || t === void 0 || t.removeAllRanges()) }), !0), tAe = (n = !1) => ({ commands: e }) => e.setContent("", n), nAe = () => ({ state: n, tr: e, dispatch: t }) => { const { selection: r } = e, { ranges: i } = r; return t && i.forEach(({ $from: a, $to: o }) => { n.doc.nodesBetween(a.pos, o.pos, (s, l) => { if (s.type.isText) return; const { doc: c, mapping: u } = e, d = c.resolve(u.map(l)), f = c.resolve(u.map(l + s.nodeSize)), h = d.blockRange(f); if (!h) return; const p = Qh(h); if (s.type.isTextblock) { const { defaultType: m } = d.parent.contentMatchAt(d.index()); e.setNodeMarkup(h.start, m) } (p || p === 0) && e.lift(h, p) }) }), !0 }, rAe = n => e => n(e), iAe = () => ({ state: n, dispatch: e }) => qX(n, e), aAe = (n, e) => ({ editor: t, tr: r }) => { const { state: i } = t, a = i.doc.slice(n.from, n.to); r.deleteRange(n.from, n.to); const o = r.mapping.map(e); return r.insert(o, a.content), r.setSelection(new ht(r.doc.resolve(o - 1))), !0 }, oAe = () => ({ tr: n, dispatch: e }) => { const { selection: t } = n, r = t.$anchor.node(); if (r.content.size > 0) return !1; const i = n.selection.$anchor; for (let a = i.depth; a > 0; a -= 1)if (i.node(a).type === r.type) { if (e) { const s = i.before(a), l = i.after(a); n.delete(s, l).scrollIntoView() } return !0 } return !1 }, sAe = n => ({ tr: e, state: t, dispatch: r }) => { const i = ei(n, t.schema), a = e.selection.$anchor; for (let o = a.depth; o > 0; o -= 1)if (a.node(o).type === i) { if (r) { const l = a.before(o), c = a.after(o); e.delete(l, c).scrollIntoView() } return !0 } return !1 }, lAe = n => ({ tr: e, dispatch: t }) => { const { from: r, to: i } = n; return t && e.delete(r, i), !0 }, cAe = () => ({ state: n, dispatch: e }) => jX(n, e), uAe = () => ({ commands: n }) => n.keyboardShortcut("Enter"), dAe = () => ({ state: n, dispatch: e }) => KX(n, e); function n2(n, e, t = { strict: !0 }) { const r = Object.keys(e); return r.length ? r.every(i => t.strict ? e[i] === n[i] : BR(e[i]) ? e[i].test(n[i]) : e[i] === n[i]) : !0 } function cJ(n, e, t = {}) { return n.find(r => r.type === e && n2(Object.fromEntries(Object.keys(t).map(i => [i, r.attrs[i]])), t)) } function tz(n, e, t = {}) { return !!cJ(n, e, t) } function Pk(n, e, t) { var r; if (!n || !e) return; let i = n.parent.childAfter(n.parentOffset); if ((!i.node || !i.node.marks.some(u => u.type === e)) && (i = n.parent.childBefore(n.parentOffset)), !i.node || !i.node.marks.some(u => u.type === e) || (t = t || ((r = i.node.marks[0]) === null || r === void 0 ? void 0 : r.attrs), !cJ([...i.node.marks], e, t))) return; let o = i.index, s = n.start() + i.offset, l = o + 1, c = s + i.node.nodeSize; for (; o > 0 && tz([...n.parent.child(o - 1).marks], e, t);)o -= 1, s -= n.parent.child(o).nodeSize; for (; l < n.parent.childCount && tz([...n.parent.child(l).marks], e, t);)c += n.parent.child(l).nodeSize, l += 1; return { from: s, to: c } } function Vd(n, e) { if (typeof n == "string") { if (!e.marks[n]) throw Error(`There is no mark type named '${n}'. Maybe you forgot to add the extension?`); return e.marks[n] } return n } const fAe = (n, e = {}) => ({ tr: t, state: r, dispatch: i }) => { const a = Vd(n, r.schema), { doc: o, selection: s } = t, { $from: l, from: c, to: u } = s; if (i) { const d = Pk(l, a, e); if (d && d.from <= c && d.to >= u) { const f = ht.create(o, d.from, d.to); t.setSelection(f) } } return !0 }, hAe = n => e => { const t = typeof n == "function" ? n(e) : n; for (let r = 0; r < t.length; r += 1)if (t[r](e)) return !0; return !1 }; function FR(n) { return n instanceof ht } function hc(n = 0, e = 0, t = 0) { return Math.min(Math.max(n, e), t) } function uJ(n, e = null) { if (!e) return null; const t = vt.atStart(n), r = vt.atEnd(n); if (e === "start" || e === !0) return t; if (e === "end") return r; const i = t.from, a = r.to; return e === "all" ? ht.create(n, hc(0, i, a), hc(n.content.size, i, a)) : ht.create(n, hc(e, i, a), hc(e, i, a)) } function dJ() { return navigator.platform === "Android" || /android/i.test(navigator.userAgent) } function Ik() { return ["iPad Simulator", "iPhone Simulator", "iPod Simulator", "iPad", "iPhone", "iPod"].includes(navigator.platform) || navigator.userAgent.includes("Mac") && "ontouchend" in document } const pAe = (n = null, e = {}) => ({ editor: t, view: r, tr: i, dispatch: a }) => { e = { scrollIntoView: !0, ...e }; const o = () => { (Ik() || dJ()) && r.dom.focus(), requestAnimationFrame(() => { t.isDestroyed || (r.focus(), e != null && e.scrollIntoView && t.commands.scrollIntoView()) }) }; if (r.hasFocus() && n === null || n === !1) return !0; if (a && n === null && !FR(t.state.selection)) return o(), !0; const s = uJ(i.doc, n) || t.state.selection, l = t.state.selection.eq(s); return a && (l || i.setSelection(s), l && i.storedMarks && i.setStoredMarks(i.storedMarks), o()), !0 }, mAe = (n, e) => t => n.every((r, i) => e(r, { ...t, index: i })), gAe = (n, e) => ({ tr: t, commands: r }) => r.insertContentAt({ from: t.selection.from, to: t.selection.to }, n, e), fJ = n => { const e = n.childNodes; for (let t = e.length - 1; t >= 0; t -= 1) { const r = e[t]; r.nodeType === 3 && r.nodeValue && /^(\n\s\s|\n)$/.test(r.nodeValue) ? n.removeChild(r) : r.nodeType === 1 && fJ(r) } return n }; function tw(n) { const e = `<body>${n}</body>`, t = new window.DOMParser().parseFromString(e, "text/html").body; return fJ(t) } function r2(n, e, t) { if (n instanceof td || n instanceof Be) return n; t = { slice: !0, parseOptions: {}, ...t }; const r = typeof n == "object" && n !== null, i = typeof n == "string"; if (r) try { if (Array.isArray(n) && n.length > 0) return Be.fromArray(n.map(s => e.nodeFromJSON(s))); const o = e.nodeFromJSON(n); return t.errorOnInvalidContent && o.check(), o } catch (a) { if (t.errorOnInvalidContent) throw new Error("[tiptap error]: Invalid JSON content", { cause: a }); return console.warn("[tiptap warn]: Invalid content.", "Passed value:", n, "Error:", a), r2("", e, t) } if (i) { if (t.errorOnInvalidContent) { let o = !1, s = ""; const l = new wR({ topNode: e.spec.topNode, marks: e.spec.marks, nodes: e.spec.nodes.append({ __tiptap__private__unknown__catch__all__node: { content: "inline*", group: "block", parseDOM: [{ tag: "*", getAttrs: c => (o = !0, s = typeof c == "string" ? c : c.outerHTML, null) }] } }) }); if (t.slice ? nd.fromSchema(l).parseSlice(tw(n), t.parseOptions) : nd.fromSchema(l).parse(tw(n), t.parseOptions), t.errorOnInvalidContent && o) throw new Error("[tiptap error]: Invalid HTML content", { cause: new Error(`Invalid element found: ${s}`) }) } const a = nd.fromSchema(e); return t.slice ? a.parseSlice(tw(n), t.parseOptions).content : a.parse(tw(n), t.parseOptions) } return r2("", e, t) } function vAe(n, e, t) { const r = n.steps.length - 1; if (r < e) return; const i = n.steps[r]; if (!(i instanceof Br || i instanceof Hr)) return; const a = n.mapping.maps[r]; let o = 0; a.forEach((s, l, c, u) => { o === 0 && (o = u) }), n.setSelection(vt.near(n.doc.resolve(o), t)) } const yAe = n => !("type" in n), _Ae = (n, e, t) => ({ tr: r, dispatch: i, editor: a }) => { var o; if (i) { t = { parseOptions: a.options.parseOptions, updateSelection: !0, applyInputRules: !1, applyPasteRules: !1, ...t }; let s; try { s = r2(e, a.schema, { parseOptions: { preserveWhitespace: "full", ...t.parseOptions }, errorOnInvalidContent: (o = t.errorOnInvalidContent) !== null && o !== void 0 ? o : a.options.enableContentCheck }) } catch (p) { return a.emit("contentError", { editor: a, error: p, disableCollaboration: () => { a.storage.collaboration && (a.storage.collaboration.isDisabled = !0) } }), !1 } let { from: l, to: c } = typeof n == "number" ? { from: n, to: n } : { from: n.from, to: n.to }, u = !0, d = !0; if ((yAe(s) ? s : [s]).forEach(p => { p.check(), u = u ? p.isText && p.marks.length === 0 : !1, d = d ? p.isBlock : !1 }), l === c && d) { const { parent: p } = r.doc.resolve(l); p.isTextblock && !p.type.spec.code && !p.childCount && (l -= 1, c += 1) } let h; if (u) { if (Array.isArray(e)) h = e.map(p => p.text || "").join(""); else if (e instanceof Be) { let p = ""; e.forEach(m => { m.text && (p += m.text) }), h = p } else typeof e == "object" && e && e.text ? h = e.text : h = e; r.insertText(h, l, c) } else h = s, r.replaceWith(l, c, h); t.updateSelection && vAe(r, r.steps.length - 1, -1), t.applyInputRules && r.setMeta("applyInputRules", { from: l, text: h }), t.applyPasteRules && r.setMeta("applyPasteRules", { from: l, text: h }) } return !0 }, bAe = () => ({ state: n, dispatch: e }) => VX(n, e), wAe = () => ({ state: n, dispatch: e }) => HX(n, e), xAe = () => ({ state: n, dispatch: e }) => IX(n, e), SAe = () => ({ state: n, dispatch: e }) => FX(n, e), TAe = () => ({ state: n, dispatch: e, tr: t }) => { try { const r = Hg(n.doc, n.selection.$from.pos, -1); return r == null ? !1 : (t.join(r, 2), e && e(t), !0) } catch { return !1 } }, kAe = () => ({ state: n, dispatch: e, tr: t }) => { try { const r = Hg(n.doc, n.selection.$from.pos, 1); return r == null ? !1 : (t.join(r, 2), e && e(t), !0) } catch { return !1 } }, CAe = () => ({ state: n, dispatch: e }) => LX(n, e), AAe = () => ({ state: n, dispatch: e }) => RX(n, e); function hJ() { return typeof navigator < "u" ? /Mac/.test(navigator.platform) : !1 } function EAe(n) { const e = n.split(/-(?!$)/); let t = e[e.length - 1]; t === "Space" && (t = " "); let r, i, a, o; for (let s = 0; s < e.length - 1; s += 1) { const l = e[s]; if (/^(cmd|meta|m)$/i.test(l)) o = !0; else if (/^a(lt)?$/i.test(l)) r = !0; else if (/^(c|ctrl|control)$/i.test(l)) i = !0; else if (/^s(hift)?$/i.test(l)) a = !0; else if (/^mod$/i.test(l)) Ik() || hJ() ? o = !0 : i = !0; else throw new Error(`Unrecognized modifier name: ${l}`) } return r && (t = `Alt-${t}`), i && (t = `Ctrl-${t}`), o && (t = `Meta-${t}`), a && (t = `Shift-${t}`), t } const MAe = n => ({ editor: e, view: t, tr: r, dispatch: i }) => { const a = EAe(n).split(/-(?!$)/), o = a.find(c => !["Alt", "Ctrl", "Meta", "Shift"].includes(c)), s = new KeyboardEvent("keydown", { key: o === "Space" ? " " : o, altKey: a.includes("Alt"), ctrlKey: a.includes("Ctrl"), metaKey: a.includes("Meta"), shiftKey: a.includes("Shift"), bubbles: !0, cancelable: !0 }), l = e.captureTransaction(() => { t.someProp("handleKeyDown", c => c(t, s)) }); return l == null || l.steps.forEach(c => { const u = c.map(r.mapping); u && i && r.maybeStep(u) }), !0 }; function Q0(n, e, t = {}) { const { from: r, to: i, empty: a } = n.selection, o = e ? ei(e, n.schema) : null, s = []; n.doc.nodesBetween(r, i, (d, f) => { if (d.isText) return; const h = Math.max(r, f), p = Math.min(i, f + d.nodeSize); s.push({ node: d, from: h, to: p }) }); const l = i - r, c = s.filter(d => o ? o.name === d.node.type.name : !0).filter(d => n2(d.node.attrs, t, { strict: !1 })); return a ? !!c.length : c.reduce((d, f) => d + f.to - f.from, 0) >= l } const OAe = (n, e = {}) => ({ state: t, dispatch: r }) => { const i = ei(n, t.schema); return Q0(t, i, e) ? UX(t, r) : !1 }, DAe = () => ({ state: n, dispatch: e }) => YX(n, e), jAe = n => ({ state: e, dispatch: t }) => { const r = ei(n, e.schema); return rJ(r)(e, t) }, PAe = () => ({ state: n, dispatch: e }) => GX(n, e); function Lk(n, e) { return e.nodes[n] ? "node" : e.marks[n] ? "mark" : null } function nz(n, e) { const t = typeof e == "string" ? [e] : e; return Object.keys(n).reduce((r, i) => (t.includes(i) || (r[i] = n[i]), r), {}) } const IAe = (n, e) => ({ tr: t, state: r, dispatch: i }) => { let a = null, o = null; const s = Lk(typeof n == "string" ? n : n.name, r.schema); return s ? (s === "node" && (a = ei(n, r.schema)), s === "mark" && (o = Vd(n, r.schema)), i && t.selection.ranges.forEach(l => { r.doc.nodesBetween(l.$from.pos, l.$to.pos, (c, u) => { a && a === c.type && t.setNodeMarkup(u, void 0, nz(c.attrs, e)), o && c.marks.length && c.marks.forEach(d => { o === d.type && t.addMark(u, u + c.nodeSize, o.create(nz(d.attrs, e))) }) }) }), !0) : !1 }, LAe = () => ({ tr: n, dispatch: e }) => (e && n.scrollIntoView(), !0), RAe = () => ({ tr: n, dispatch: e }) => { if (e) { const t = new Ro(n.doc); n.setSelection(t) } return !0 }, NAe = () => ({ state: n, dispatch: e }) => BX(n, e), BAe = () => ({ state: n, dispatch: e }) => zX(n, e), $Ae = () => ({ state: n, dispatch: e }) => ZX(n, e), FAe = () => ({ state: n, dispatch: e }) => eJ(n, e), zAe = () => ({ state: n, dispatch: e }) => QX(n, e); function Kj(n, e, t = {}, r = {}) { return r2(n, e, { slice: !1, parseOptions: t, errorOnInvalidContent: r.errorOnInvalidContent }) } const VAe = (n, e = !1, t = {}, r = {}) => ({ editor: i, tr: a, dispatch: o, commands: s }) => { var l, c; const { doc: u } = a; if (t.preserveWhitespace !== "full") { const d = Kj(n, i.schema, t, { errorOnInvalidContent: (l = r.errorOnInvalidContent) !== null && l !== void 0 ? l : i.options.enableContentCheck }); return o && a.replaceWith(0, u.content.size, d).setMeta("preventUpdate", !e), !0 } return o && a.setMeta("preventUpdate", !e), s.insertContentAt({ from: 0, to: u.content.size }, n, { parseOptions: t, errorOnInvalidContent: (c = r.errorOnInvalidContent) !== null && c !== void 0 ? c : i.options.enableContentCheck }) }; function zR(n, e) { const t = Vd(e, n.schema), { from: r, to: i, empty: a } = n.selection, o = []; a ? (n.storedMarks && o.push(...n.storedMarks), o.push(...n.selection.$head.marks())) : n.doc.nodesBetween(r, i, l => { o.push(...l.marks) }); const s = o.find(l => l.type.name === t.name); return s ? { ...s.attrs } : {} } function HAe(n, e) { const t = new TR(n); return e.forEach(r => { r.steps.forEach(i => { t.step(i) }) }), t } function UAe(n) { for (let e = 0; e < n.edgeCount; e += 1) { const { type: t } = n.edge(e); if (t.isTextblock && !t.hasRequiredAttrs()) return t } return null } function qj(n, e) { const t = []; return n.descendants((r, i) => { e(r) && t.push({ node: r, pos: i }) }), t } function GAe(n, e, t) { const r = []; return n.nodesBetween(e.from, e.to, (i, a) => { t(i) && r.push({ node: i, pos: a }) }), r } function pJ(n, e) { for (let t = n.depth; t > 0; t -= 1) { const r = n.node(t); if (e(r)) return { pos: t > 0 ? n.before(t) : 0, start: n.start(t), depth: t, node: r } } } function VR(n) { return e => pJ(e.$from, n) } function WAe(n, e) { const t = { from: 0, to: n.content.size }; return sJ(n, t, e) } function KAe(n, e) { const t = ei(e, n.schema), { from: r, to: i } = n.selection, a = []; n.doc.nodesBetween(r, i, s => { a.push(s) }); const o = a.reverse().find(s => s.type.name === t.name); return o ? { ...o.attrs } : {} } function mJ(n, e) { const t = Lk(typeof e == "string" ? e : e.name, n.schema); return t === "node" ? KAe(n, e) : t === "mark" ? zR(n, e) : {} } function qAe(n, e = JSON.stringify) { const t = {}; return n.filter(r => { const i = e(r); return Object.prototype.hasOwnProperty.call(t, i) ? !1 : t[i] = !0 }) } function YAe(n) { const e = qAe(n); return e.length === 1 ? e : e.filter((t, r) => !e.filter((a, o) => o !== r).some(a => t.oldRange.from >= a.oldRange.from && t.oldRange.to <= a.oldRange.to && t.newRange.from >= a.newRange.from && t.newRange.to <= a.newRange.to)) } function ZAe(n) { const { mapping: e, steps: t } = n, r = []; return e.maps.forEach((i, a) => { const o = []; if (i.ranges.length) i.forEach((s, l) => { o.push({ from: s, to: l }) }); else { const { from: s, to: l } = t[a]; if (s === void 0 || l === void 0) return; o.push({ from: s, to: l }) } o.forEach(({ from: s, to: l }) => { const c = e.slice(a).map(s, -1), u = e.slice(a).map(l), d = e.invert().map(c, -1), f = e.invert().map(u); r.push({ oldRange: { from: d, to: f }, newRange: { from: c, to: u } }) }) }), YAe(r) } function gJ(n, e, t) { const r = []; return n === e ? t.resolve(n).marks().forEach(i => { const a = t.resolve(n), o = Pk(a, i.type); o && r.push({ mark: i, ...o }) }) : t.nodesBetween(n, e, (i, a) => { !i || (i == null ? void 0 : i.nodeSize) === void 0 || r.push(...i.marks.map(o => ({ from: a, to: a + i.nodeSize, mark: o }))) }), r } function $x(n, e, t) { return Object.fromEntries(Object.entries(t).filter(([r]) => { const i = n.find(a => a.type === e && a.name === r); return i ? i.attribute.keepOnSplit : !1 })) } function Yj(n, e, t = {}) { const { empty: r, ranges: i } = n.selection, a = e ? Vd(e, n.schema) : null; if (r) return !!(n.storedMarks || n.selection.$from.marks()).filter(d => a ? a.name === d.type.name : !0).find(d => n2(d.attrs, t, { strict: !1 })); let o = 0; const s = []; if (i.forEach(({ $from: d, $to: f }) => { const h = d.pos, p = f.pos; n.doc.nodesBetween(h, p, (m, g) => { if (!m.isText && !m.marks.length) return; const y = Math.max(h, g), b = Math.min(p, g + m.nodeSize), w = b - y; o += w, s.push(...m.marks.map(v => ({ mark: v, from: y, to: b }))) }) }), o === 0) return !1; const l = s.filter(d => a ? a.name === d.mark.type.name : !0).filter(d => n2(d.mark.attrs, t, { strict: !1 })).reduce((d, f) => d + f.to - f.from, 0), c = s.filter(d => a ? d.mark.type !== a && d.mark.type.excludes(a) : !0).reduce((d, f) => d + f.to - f.from, 0); return (l > 0 ? l + c : l) >= o } function XAe(n, e, t = {}) { if (!e) return Q0(n, null, t) || Yj(n, null, t); const r = Lk(e, n.schema); return r === "node" ? Q0(n, e, t) : r === "mark" ? Yj(n, e, t) : !1 } function rz(n, e) { const { nodeExtensions: t } = Ok(e), r = t.find(o => o.name === n); if (!r) return !1; const i = { name: r.name, options: r.options, storage: r.storage }, a = cn(dt(r, "group", i)); return typeof a != "string" ? !1 : a.split(" ").includes("list") } function Rk(n, { checkChildren: e = !0, ignoreWhitespace: t = !1 } = {}) { var r; if (t) { if (n.type.name === "hardBreak") return !0; if (n.isText) return /^\s*$/m.test((r = n.text) !== null && r !== void 0 ? r : "") } if (n.isText) return !n.text; if (n.isAtom || n.isLeaf) return !1; if (n.content.childCount === 0) return !0; if (e) { let i = !0; return n.content.forEach(a => { i !== !1 && (Rk(a, { ignoreWhitespace: t, checkChildren: e }) || (i = !1)) }), i } return !1 } function JAe(n) { return n instanceof _t } function vJ(n, e, t) { const i = n.state.doc.content.size, a = hc(e, 0, i), o = hc(t, 0, i), s = n.coordsAtPos(a), l = n.coordsAtPos(o, -1), c = Math.min(s.top, l.top), u = Math.max(s.bottom, l.bottom), d = Math.min(s.left, l.left), f = Math.max(s.right, l.right), h = f - d, p = u - c, y = { top: c, bottom: u, left: d, right: f, width: h, height: p, x: d, y: c }; return { ...y, toJSON: () => y } } function QAe(n, e, t) { var r; const { selection: i } = e; let a = null; if (FR(i) && (a = i.$cursor), a) { const s = (r = n.storedMarks) !== null && r !== void 0 ? r : a.marks(); return !!t.isInSet(s) || !s.some(l => l.type.excludes(t)) } const { ranges: o } = i; return o.some(({ $from: s, $to: l }) => { let c = s.depth === 0 ? n.doc.inlineContent && n.doc.type.allowsMarkType(t) : !1; return n.doc.nodesBetween(s.pos, l.pos, (u, d, f) => { if (c) return !1; if (u.isInline) { const h = !f || f.type.allowsMarkType(t), p = !!t.isInSet(u.marks) || !u.marks.some(m => m.type.excludes(t)); c = h && p } return !c }), c }) } const eEe = (n, e = {}) => ({ tr: t, state: r, dispatch: i }) => { const { selection: a } = t, { empty: o, ranges: s } = a, l = Vd(n, r.schema); if (i) if (o) { const c = zR(r, l); t.addStoredMark(l.create({ ...c, ...e })) } else s.forEach(c => { const u = c.$from.pos, d = c.$to.pos; r.doc.nodesBetween(u, d, (f, h) => { const p = Math.max(h, u), m = Math.min(h + f.nodeSize, d); f.marks.find(y => y.type === l) ? f.marks.forEach(y => { l === y.type && t.addMark(p, m, l.create({ ...y.attrs, ...e })) }) : t.addMark(p, m, l.create(e)) }) }); return QAe(r, t, l) }, tEe = (n, e) => ({ tr: t }) => (t.setMeta(n, e), !0), nEe = (n, e = {}) => ({ state: t, dispatch: r, chain: i }) => { const a = ei(n, t.schema); let o; return t.selection.$anchor.sameParent(t.selection.$head) && (o = t.selection.$anchor.parent.attrs), a.isTextblock ? i().command(({ commands: s }) => t2(a, { ...o, ...e })(t) ? !0 : s.clearNodes()).command(({ state: s }) => t2(a, { ...o, ...e })(s, r)).run() : (console.warn('[tiptap warn]: Currently "setNode()" only supports text block nodes.'), !1) }, rEe = n => ({ tr: e, dispatch: t }) => { if (t) { const { doc: r } = e, i = hc(n, 0, r.content.size), a = _t.create(r, i); e.setSelection(a) } return !0 }, iEe = n => ({ tr: e, dispatch: t }) => { if (t) { const { doc: r } = e, { from: i, to: a } = typeof n == "number" ? { from: n, to: n } : n, o = ht.atStart(r).from, s = ht.atEnd(r).to, l = hc(i, o, s), c = hc(a, o, s), u = ht.create(r, l, c); e.setSelection(u) } return !0 }, aEe = n => ({ state: e, dispatch: t }) => { const r = ei(n, e.schema); return iJ(r)(e, t) }; function iz(n, e) { const t = n.storedMarks || n.selection.$to.parentOffset && n.selection.$from.marks(); if (t) { const r = t.filter(i => e == null ? void 0 : e.includes(i.type.name)); n.tr.ensureMarks(r) } } const oEe = ({ keepMarks: n = !0 } = {}) => ({ tr: e, state: t, dispatch: r, editor: i }) => { const { selection: a, doc: o } = e, { $from: s, $to: l } = a, c = i.extensionManager.attributes, u = $x(c, s.node().type.name, s.node().attrs); if (a instanceof _t && a.node.isBlock) return !s.parentOffset || !hl(o, s.pos) ? !1 : (r && (n && iz(t, i.extensionManager.splittableMarks), e.split(s.pos).scrollIntoView()), !0); if (!s.parent.isBlock) return !1; const d = l.parentOffset === l.parent.content.size, f = s.depth === 0 ? void 0 : UAe(s.node(-1).contentMatchAt(s.indexAfter(-1))); let h = d && f ? [{ type: f, attrs: u }] : void 0, p = hl(e.doc, e.mapping.map(s.pos), 1, h); if (!h && !p && hl(e.doc, e.mapping.map(s.pos), 1, f ? [{ type: f }] : void 0) && (p = !0, h = f ? [{ type: f, attrs: u }] : void 0), r) { if (p && (a instanceof ht && e.deleteSelection(), e.split(e.mapping.map(s.pos), 1, h), f && !d && !s.parentOffset && s.parent.type !== f)) { const m = e.mapping.map(s.before()), g = e.doc.resolve(m); s.node(-1).canReplaceWith(g.index(), g.index() + 1, f) && e.setNodeMarkup(e.mapping.map(s.before()), f) } n && iz(t, i.extensionManager.splittableMarks), e.scrollIntoView() } return p }, sEe = (n, e = {}) => ({ tr: t, state: r, dispatch: i, editor: a }) => { var o; const s = ei(n, r.schema), { $from: l, $to: c } = r.selection, u = r.selection.node; if (u && u.isBlock || l.depth < 2 || !l.sameParent(c)) return !1; const d = l.node(-1); if (d.type !== s) return !1; const f = a.extensionManager.attributes; if (l.parent.content.size === 0 && l.node(-1).childCount === l.indexAfter(-1)) { if (l.depth === 2 || l.node(-3).type !== s || l.index(-2) !== l.node(-2).childCount - 1) return !1; if (i) { let y = Be.empty; const b = l.index(-1) ? 1 : l.index(-2) ? 2 : 3; for (let A = l.depth - b; A >= l.depth - 3; A -= 1)y = Be.from(l.node(A).copy(y)); const w = l.indexAfter(-1) < l.node(-2).childCount ? 1 : l.indexAfter(-2) < l.node(-3).childCount ? 2 : 3, v = { ...$x(f, l.node().type.name, l.node().attrs), ...e }, S = ((o = s.contentMatch.defaultType) === null || o === void 0 ? void 0 : o.createAndFill(v)) || void 0; y = y.append(Be.from(s.createAndFill(null, S) || void 0)); const x = l.before(l.depth - (b - 1)); t.replace(x, l.after(-w), new Qe(y, 4 - b, 0)); let k = -1; t.doc.nodesBetween(x, t.doc.content.size, (A, C) => { if (k > -1) return !1; A.isTextblock && A.content.size === 0 && (k = C + 1) }), k > -1 && t.setSelection(ht.near(t.doc.resolve(k))), t.scrollIntoView() } return !0 } const h = c.pos === l.end() ? d.contentMatchAt(0).defaultType : null, p = { ...$x(f, d.type.name, d.attrs), ...e }, m = { ...$x(f, l.node().type.name, l.node().attrs), ...e }; t.delete(l.pos, c.pos); const g = h ? [{ type: s, attrs: p }, { type: h, attrs: m }] : [{ type: s, attrs: p }]; if (!hl(t.doc, l.pos, 2)) return !1; if (i) { const { selection: y, storedMarks: b } = r, { splittableMarks: w } = a.extensionManager, v = b || y.$to.parentOffset && y.$from.marks(); if (t.split(l.pos, 2, g).scrollIntoView(), !v || !i) return !0; const S = v.filter(x => w.includes(x.type.name)); t.ensureMarks(S) } return !0 }, RE = (n, e) => { const t = VR(o => o.type === e)(n.selection); if (!t) return !0; const r = n.doc.resolve(Math.max(0, t.pos - 1)).before(t.depth); if (r === void 0) return !0; const i = n.doc.nodeAt(r); return t.node.type === (i == null ? void 0 : i.type) && Dl(n.doc, t.pos) && n.join(t.pos), !0 }, NE = (n, e) => { const t = VR(o => o.type === e)(n.selection); if (!t) return !0; const r = n.doc.resolve(t.start).after(t.depth); if (r === void 0) return !0; const i = n.doc.nodeAt(r); return t.node.type === (i == null ? void 0 : i.type) && Dl(n.doc, r) && n.join(r), !0 }, lEe = (n, e, t, r = {}) => ({ editor: i, tr: a, state: o, dispatch: s, chain: l, commands: c, can: u }) => { const { extensions: d, splittableMarks: f } = i.extensionManager, h = ei(n, o.schema), p = ei(e, o.schema), { selection: m, storedMarks: g } = o, { $from: y, $to: b } = m, w = y.blockRange(b), v = g || m.$to.parentOffset && m.$from.marks(); if (!w) return !1; const S = VR(x => rz(x.type.name, d))(m); if (w.depth >= 1 && S && w.depth - S.depth <= 1) { if (S.node.type === h) return c.liftListItem(p); if (rz(S.node.type.name, d) && h.validContent(S.node.content) && s) return l().command(() => (a.setNodeMarkup(S.pos, h), !0)).command(() => RE(a, h)).command(() => NE(a, h)).run() } return !t || !v || !s ? l().command(() => u().wrapInList(h, r) ? !0 : c.clearNodes()).wrapInList(h, r).command(() => RE(a, h)).command(() => NE(a, h)).run() : l().command(() => { const x = u().wrapInList(h, r), k = v.filter(A => f.includes(A.type.name)); return a.ensureMarks(k), x ? !0 : c.clearNodes() }).wrapInList(h, r).command(() => RE(a, h)).command(() => NE(a, h)).run() }, cEe = (n, e = {}, t = {}) => ({ state: r, commands: i }) => { const { extendEmptyMarkRange: a = !1 } = t, o = Vd(n, r.schema); return Yj(r, o, e) ? i.unsetMark(o, { extendEmptyMarkRange: a }) : i.setMark(o, e) }, uEe = (n, e, t = {}) => ({ state: r, commands: i }) => { const a = ei(n, r.schema), o = ei(e, r.schema), s = Q0(r, a, t); let l; return r.selection.$anchor.sameParent(r.selection.$head) && (l = r.selection.$anchor.parent.attrs), s ? i.setNode(o, l) : i.setNode(a, { ...l, ...t }) }, dEe = (n, e = {}) => ({ state: t, commands: r }) => { const i = ei(n, t.schema); return Q0(t, i, e) ? r.lift(i) : r.wrapIn(i, e) }, fEe = () => ({ state: n, dispatch: e }) => { const t = n.plugins; for (let r = 0; r < t.length; r += 1) { const i = t[r]; let a; if (i.spec.isInputRules && (a = i.getState(n))) { if (e) { const o = n.tr, s = a.transform; for (let l = s.steps.length - 1; l >= 0; l -= 1)o.step(s.steps[l].invert(s.docs[l])); if (a.text) { const l = o.doc.resolve(a.from).marks(); o.replaceWith(a.from, a.to, n.schema.text(a.text, l)) } else o.delete(a.from, a.to) } return !0 } } return !1 }, hEe = () => ({ tr: n, dispatch: e }) => { const { selection: t } = n, { empty: r, ranges: i } = t; return r || e && i.forEach(a => { n.removeMark(a.$from.pos, a.$to.pos) }), !0 }, pEe = (n, e = {}) => ({ tr: t, state: r, dispatch: i }) => { var a; const { extendEmptyMarkRange: o = !1 } = e, { selection: s } = t, l = Vd(n, r.schema), { $from: c, empty: u, ranges: d } = s; if (!i) return !0; if (u && o) { let { from: f, to: h } = s; const p = (a = c.marks().find(g => g.type === l)) === null || a === void 0 ? void 0 : a.attrs, m = Pk(c, l, p); m && (f = m.from, h = m.to), t.removeMark(f, h, l) } else d.forEach(f => { t.removeMark(f.$from.pos, f.$to.pos, l) }); return t.removeStoredMark(l), !0 }, mEe = (n, e = {}) => ({ tr: t, state: r, dispatch: i }) => { let a = null, o = null; const s = Lk(typeof n == "string" ? n : n.name, r.schema); return s ? (s === "node" && (a = ei(n, r.schema)), s === "mark" && (o = Vd(n, r.schema)), i && t.selection.ranges.forEach(l => { const c = l.$from.pos, u = l.$to.pos; let d, f, h, p; t.selection.empty ? r.doc.nodesBetween(c, u, (m, g) => { a && a === m.type && (h = Math.max(g, c), p = Math.min(g + m.nodeSize, u), d = g, f = m) }) : r.doc.nodesBetween(c, u, (m, g) => { g < c && a && a === m.type && (h = Math.max(g, c), p = Math.min(g + m.nodeSize, u), d = g, f = m), g >= c && g <= u && (a && a === m.type && t.setNodeMarkup(g, void 0, { ...m.attrs, ...e }), o && m.marks.length && m.marks.forEach(y => { if (o === y.type) { const b = Math.max(g, c), w = Math.min(g + m.nodeSize, u); t.addMark(b, w, o.create({ ...y.attrs, ...e })) } })) }), f && (d !== void 0 && t.setNodeMarkup(d, void 0, { ...f.attrs, ...e }), o && f.marks.length && f.marks.forEach(m => { o === m.type && t.addMark(h, p, o.create({ ...m.attrs, ...e })) })) }), !0) : !1 }, gEe = (n, e = {}) => ({ state: t, dispatch: r }) => { const i = ei(n, t.schema); return tJ(i, e)(t, r) }, vEe = (n, e = {}) => ({ state: t, dispatch: r }) => { const i = ei(n, t.schema); return nJ(i, e)(t, r) }; var yEe = Object.freeze({ __proto__: null, blur: eAe, clearContent: tAe, clearNodes: nAe, command: rAe, createParagraphNear: iAe, cut: aAe, deleteCurrentNode: oAe, deleteNode: sAe, deleteRange: lAe, deleteSelection: cAe, enter: uAe, exitCode: dAe, extendMarkRange: fAe, first: hAe, focus: pAe, forEach: mAe, insertContent: gAe, insertContentAt: _Ae, joinBackward: xAe, joinDown: wAe, joinForward: SAe, joinItemBackward: TAe, joinItemForward: kAe, joinTextblockBackward: CAe, joinTextblockForward: AAe, joinUp: bAe, keyboardShortcut: MAe, lift: OAe, liftEmptyBlock: DAe, liftListItem: jAe, newlineInCode: PAe, resetAttributes: IAe, scrollIntoView: LAe, selectAll: RAe, selectNodeBackward: NAe, selectNodeForward: BAe, selectParentNode: $Ae, selectTextblockEnd: FAe, selectTextblockStart: zAe, setContent: VAe, setMark: eEe, setMeta: tEe, setNode: nEe, setNodeSelection: rEe, setTextSelection: iEe, sinkListItem: aEe, splitBlock: oEe, splitListItem: sEe, toggleList: lEe, toggleMark: cEe, toggleNode: uEe, toggleWrap: dEe, undoInputRule: fEe, unsetAllMarks: hEe, unsetMark: pEe, updateAttributes: mEe, wrapIn: gEe, wrapInList: vEe }); const _Ee = Bi.create({ name: "commands", addCommands() { return { ...yEe } } }), bEe = Bi.create({ name: "drop", addProseMirrorPlugins() { return [new wn({ key: new xn("tiptapDrop"), props: { handleDrop: (n, e, t, r) => { this.editor.emit("drop", { editor: this.editor, event: e, slice: t, moved: r }) } } })] } }), wEe = Bi.create({ name: "editable", addProseMirrorPlugins() { return [new wn({ key: new xn("editable"), props: { editable: () => this.editor.options.editable } })] } }), xEe = new xn("focusEvents"), SEe = Bi.create({ name: "focusEvents", addProseMirrorPlugins() { const { editor: n } = this; return [new wn({ key: xEe, props: { handleDOMEvents: { focus: (e, t) => { n.isFocused = !0; const r = n.state.tr.setMeta("focus", { event: t }).setMeta("addToHistory", !1); return e.dispatch(r), !1 }, blur: (e, t) => { n.isFocused = !1; const r = n.state.tr.setMeta("blur", { event: t }).setMeta("addToHistory", !1); return e.dispatch(r), !1 } } } })] } }), TEe = Bi.create({ name: "keymap", addKeyboardShortcuts() { const n = () => this.editor.commands.first(({ commands: o }) => [() => o.undoInputRule(), () => o.command(({ tr: s }) => { const { selection: l, doc: c } = s, { empty: u, $anchor: d } = l, { pos: f, parent: h } = d, p = d.parent.isTextblock && f > 0 ? s.doc.resolve(f - 1) : d, m = p.parent.type.spec.isolating, g = d.pos - d.parentOffset, y = m && p.parent.childCount === 1 ? g === d.pos : vt.atStart(c).from === f; return !u || !h.type.isTextblock || h.textContent.length || !y || y && d.parent.type.name === "paragraph" ? !1 : o.clearNodes() }), () => o.deleteSelection(), () => o.joinBackward(), () => o.selectNodeBackward()]), e = () => this.editor.commands.first(({ commands: o }) => [() => o.deleteSelection(), () => o.deleteCurrentNode(), () => o.joinForward(), () => o.selectNodeForward()]), r = { Enter: () => this.editor.commands.first(({ commands: o }) => [() => o.newlineInCode(), () => o.createParagraphNear(), () => o.liftEmptyBlock(), () => o.splitBlock()]), "Mod-Enter": () => this.editor.commands.exitCode(), Backspace: n, "Mod-Backspace": n, "Shift-Backspace": n, Delete: e, "Mod-Delete": e, "Mod-a": () => this.editor.commands.selectAll() }, i = { ...r }, a = { ...r, "Ctrl-h": n, "Alt-Backspace": n, "Ctrl-d": e, "Ctrl-Alt-Backspace": e, "Alt-Delete": e, "Alt-d": e, "Ctrl-a": () => this.editor.commands.selectTextblockStart(), "Ctrl-e": () => this.editor.commands.selectTextblockEnd() }; return Ik() || hJ() ? a : i }, addProseMirrorPlugins() { return [new wn({ key: new xn("clearDocument"), appendTransaction: (n, e, t) => { if (n.some(m => m.getMeta("composition"))) return; const r = n.some(m => m.docChanged) && !e.doc.eq(t.doc), i = n.some(m => m.getMeta("preventClearDocument")); if (!r || i) return; const { empty: a, from: o, to: s } = e.selection, l = vt.atStart(e.doc).from, c = vt.atEnd(e.doc).to; if (a || !(o === l && s === c) || !Rk(t.doc)) return; const f = t.tr, h = Ek({ state: t, transaction: f }), { commands: p } = new Mk({ editor: this.editor, state: h }); if (p.clearNodes(), !!f.steps.length) return f } })] } }), kEe = Bi.create({ name: "paste", addProseMirrorPlugins() { return [new wn({ key: new xn("tiptapPaste"), props: { handlePaste: (n, e, t) => { this.editor.emit("paste", { editor: this.editor, event: e, slice: t }) } } })] } }), CEe = Bi.create({ name: "tabindex", addProseMirrorPlugins() { return [new wn({ key: new xn("tabindex"), props: { attributes: () => this.editor.isEditable ? { tabindex: "0" } : {} } })] } }); class zf { get name() { return this.node.type.name } constructor(e, t, r = !1, i = null) { this.currentNode = null, this.actualDepth = null, this.isBlock = r, this.resolvedPos = e, this.editor = t, this.currentNode = i } get node() { return this.currentNode || this.resolvedPos.node() } get element() { return this.editor.view.domAtPos(this.pos).node } get depth() { var e; return (e = this.actualDepth) !== null && e !== void 0 ? e : this.resolvedPos.depth } get pos() { return this.resolvedPos.pos } get content() { return this.node.content } set content(e) { let t = this.from, r = this.to; if (this.isBlock) { if (this.content.size === 0) { console.error(`You cant set content on a block node. Tried to set content on ${this.name} at ${this.pos}`); return } t = this.from + 1, r = this.to - 1 } this.editor.commands.insertContentAt({ from: t, to: r }, e) } get attributes() { return this.node.attrs } get textContent() { return this.node.textContent } get size() { return this.node.nodeSize } get from() { return this.isBlock ? this.pos : this.resolvedPos.start(this.resolvedPos.depth) } get range() { return { from: this.from, to: this.to } } get to() { return this.isBlock ? this.pos + this.size : this.resolvedPos.end(this.resolvedPos.depth) + (this.node.isText ? 0 : 1) } get parent() { if (this.depth === 0) return null; const e = this.resolvedPos.start(this.resolvedPos.depth - 1), t = this.resolvedPos.doc.resolve(e); return new zf(t, this.editor) } get before() { let e = this.resolvedPos.doc.resolve(this.from - (this.isBlock ? 1 : 2)); return e.depth !== this.depth && (e = this.resolvedPos.doc.resolve(this.from - 3)), new zf(e, this.editor) } get after() { let e = this.resolvedPos.doc.resolve(this.to + (this.isBlock ? 2 : 1)); return e.depth !== this.depth && (e = this.resolvedPos.doc.resolve(this.to + 3)), new zf(e, this.editor) } get children() { const e = []; return this.node.content.forEach((t, r) => { const i = t.isBlock && !t.isTextblock, a = t.isAtom && !t.isText, o = this.pos + r + (a ? 0 : 1), s = this.resolvedPos.doc.resolve(o); if (!i && s.depth <= this.depth) return; const l = new zf(s, this.editor, i, i ? t : null); i && (l.actualDepth = this.depth + 1), e.push(new zf(s, this.editor, i, i ? t : null)) }), e } get firstChild() { return this.children[0] || null } get lastChild() { const e = this.children; return e[e.length - 1] || null } closest(e, t = {}) { let r = null, i = this.parent; for (; i && !r;) { if (i.node.type.name === e) if (Object.keys(t).length > 0) { const a = i.node.attrs, o = Object.keys(t); for (let s = 0; s < o.length; s += 1) { const l = o[s]; if (a[l] !== t[l]) break } } else r = i; i = i.parent } return r } querySelector(e, t = {}) { return this.querySelectorAll(e, t, !0)[0] || null } querySelectorAll(e, t = {}, r = !1) { let i = []; if (!this.children || this.children.length === 0) return i; const a = Object.keys(t); return this.children.forEach(o => { r && i.length > 0 || (o.node.type.name === e && a.every(l => t[l] === o.node.attrs[l]) && i.push(o), !(r && i.length > 0) && (i = i.concat(o.querySelectorAll(e, t, r)))) }), i } setAttribute(e) { const { tr: t } = this.editor.state; t.setNodeMarkup(this.from, void 0, { ...this.node.attrs, ...e }), this.editor.view.dispatch(t) } } const AEe = `.ProseMirror {
  position: relative;
}

.ProseMirror {
  word-wrap: break-word;
  white-space: pre-wrap;
  white-space: break-spaces;
  -webkit-font-variant-ligatures: none;
  font-variant-ligatures: none;
  font-feature-settings: "liga" 0; /* the above doesn't seem to work in Edge */
}

.ProseMirror [contenteditable="false"] {
  white-space: normal;
}

.ProseMirror [contenteditable="false"] [contenteditable="true"] {
  white-space: pre-wrap;
}

.ProseMirror pre {
  white-space: pre-wrap;
}

img.ProseMirror-separator {
  display: inline !important;
  border: none !important;
  margin: 0 !important;
  width: 0 !important;
  height: 0 !important;
}

.ProseMirror-gapcursor {
  display: none;
  pointer-events: none;
  position: absolute;
  margin: 0;
}

.ProseMirror-gapcursor:after {
  content: "";
  display: block;
  position: absolute;
  top: -2px;
  width: 20px;
  border-top: 1px solid black;
  animation: ProseMirror-cursor-blink 1.1s steps(2, start) infinite;
}

@keyframes ProseMirror-cursor-blink {
  to {
    visibility: hidden;
  }
}

.ProseMirror-hideselection *::selection {
  background: transparent;
}

.ProseMirror-hideselection *::-moz-selection {
  background: transparent;
}

.ProseMirror-hideselection * {
  caret-color: transparent;
}

.ProseMirror-focused .ProseMirror-gapcursor {
  display: block;
}

.tippy-box[data-animation=fade][data-state=hidden] {
  opacity: 0
}`; function EEe(n, e, t) { const r = document.querySelector(`style[data-tiptap-style${t ? `-${t}` : ""}]`); if (r !== null) return r; const i = document.createElement("style"); return e && i.setAttribute("nonce", e), i.setAttribute(`data-tiptap-style${t ? `-${t}` : ""}`, ""), i.innerHTML = n, document.getElementsByTagName("head")[0].appendChild(i), i } let MEe = class extends BCe {
  constructor(e = {}) { super(), this.isFocused = !1, this.isInitialized = !1, this.extensionStorage = {}, this.options = { element: document.createElement("div"), content: "", injectCSS: !0, injectNonce: void 0, extensions: [], autofocus: !1, editable: !0, editorProps: {}, parseOptions: {}, coreExtensionOptions: {}, enableInputRules: !0, enablePasteRules: !0, enableCoreExtensions: !0, enableContentCheck: !1, onBeforeCreate: () => null, onCreate: () => null, onUpdate: () => null, onSelectionUpdate: () => null, onTransaction: () => null, onFocus: () => null, onBlur: () => null, onDestroy: () => null, onContentError: ({ error: t }) => { throw t }, onPaste: () => null, onDrop: () => null }, this.isCapturingTransaction = !1, this.capturedTransaction = null, this.setOptions(e), this.createExtensionManager(), this.createCommandManager(), this.createSchema(), this.on("beforeCreate", this.options.onBeforeCreate), this.emit("beforeCreate", { editor: this }), this.on("contentError", this.options.onContentError), this.createView(), this.injectCSS(), this.on("create", this.options.onCreate), this.on("update", this.options.onUpdate), this.on("selectionUpdate", this.options.onSelectionUpdate), this.on("transaction", this.options.onTransaction), this.on("focus", this.options.onFocus), this.on("blur", this.options.onBlur), this.on("destroy", this.options.onDestroy), this.on("drop", ({ event: t, slice: r, moved: i }) => this.options.onDrop(t, r, i)), this.on("paste", ({ event: t, slice: r }) => this.options.onPaste(t, r)), window.setTimeout(() => { this.isDestroyed || (this.commands.focus(this.options.autofocus), this.emit("create", { editor: this }), this.isInitialized = !0) }, 0) } get storage() { return this.extensionStorage } get commands() { return this.commandManager.commands } chain() { return this.commandManager.chain() } can() { return this.commandManager.can() } injectCSS() { this.options.injectCSS && document && (this.css = EEe(AEe, this.options.injectNonce)) } setOptions(e = {}) { this.options = { ...this.options, ...e }, !(!this.view || !this.state || this.isDestroyed) && (this.options.editorProps && this.view.setProps(this.options.editorProps), this.view.updateState(this.state)) } setEditable(e, t = !0) { this.setOptions({ editable: e }), t && this.emit("update", { editor: this, transaction: this.state.tr }) } get isEditable() { return this.options.editable && this.view && this.view.editable } get state() { return this.view.state } registerPlugin(e, t) { const r = oJ(t) ? t(e, [...this.state.plugins]) : [...this.state.plugins, e], i = this.state.reconfigure({ plugins: r }); return this.view.updateState(i), i } unregisterPlugin(e) { if (this.isDestroyed) return; const t = this.state.plugins; let r = t; if ([].concat(e).forEach(a => { const o = typeof a == "string" ? `${a}$` : a.key; r = r.filter(s => !s.key.startsWith(o)) }), t.length === r.length) return; const i = this.state.reconfigure({ plugins: r }); return this.view.updateState(i), i } createExtensionManager() { var e, t; const i = [...this.options.enableCoreExtensions ? [wEe, QCe.configure({ blockSeparator: (t = (e = this.options.coreExtensionOptions) === null || e === void 0 ? void 0 : e.clipboardTextSerializer) === null || t === void 0 ? void 0 : t.blockSeparator }), _Ee, SEe, TEe, CEe, bEe, kEe].filter(a => typeof this.options.enableCoreExtensions == "object" ? this.options.enableCoreExtensions[a.name] !== !1 : !0) : [], ...this.options.extensions].filter(a => ["extension", "node", "mark"].includes(a == null ? void 0 : a.type)); this.extensionManager = new Dm(i, this) } createCommandManager() { this.commandManager = new Mk({ editor: this }) } createSchema() { this.schema = this.extensionManager.schema } createView() { var e; let t; try { t = Kj(this.options.content, this.schema, this.options.parseOptions, { errorOnInvalidContent: this.options.enableContentCheck }) } catch (o) { if (!(o instanceof Error) || !["[tiptap error]: Invalid JSON content", "[tiptap error]: Invalid HTML content"].includes(o.message)) throw o; this.emit("contentError", { editor: this, error: o, disableCollaboration: () => { this.storage.collaboration && (this.storage.collaboration.isDisabled = !0), this.options.extensions = this.options.extensions.filter(s => s.name !== "collaboration"), this.createExtensionManager() } }), t = Kj(this.options.content, this.schema, this.options.parseOptions, { errorOnInvalidContent: !1 }) } const r = uJ(t, this.options.autofocus); this.view = new TCe(this.options.element, { ...this.options.editorProps, attributes: { role: "textbox", ...(e = this.options.editorProps) === null || e === void 0 ? void 0 : e.attributes }, dispatchTransaction: this.dispatchTransaction.bind(this), state: Om.create({ doc: t, selection: r || void 0 }) }); const i = this.state.reconfigure({ plugins: this.extensionManager.plugins }); this.view.updateState(i), this.createNodeViews(), this.prependClass(); const a = this.view.dom; a.editor = this } createNodeViews() { this.view.isDestroyed || this.view.setProps({ nodeViews: this.extensionManager.nodeViews }) } prependClass() { this.view.dom.className = `tiptap ${this.view.dom.className}` } captureTransaction(e) { this.isCapturingTransaction = !0, e(), this.isCapturingTransaction = !1; const t = this.capturedTransaction; return this.capturedTransaction = null, t } dispatchTransaction(e) { if (this.view.isDestroyed) return; if (this.isCapturingTransaction) { if (!this.capturedTransaction) { this.capturedTransaction = e; return } e.steps.forEach(o => { var s; return (s = this.capturedTransaction) === null || s === void 0 ? void 0 : s.step(o) }); return } const t = this.state.apply(e), r = !this.state.selection.eq(t.selection); this.emit("beforeTransaction", { editor: this, transaction: e, nextState: t }), this.view.updateState(t), this.emit("transaction", { editor: this, transaction: e }), r && this.emit("selectionUpdate", { editor: this, transaction: e }); const i = e.getMeta("focus"), a = e.getMeta("blur"); i && this.emit("focus", { editor: this, event: i.event, transaction: e }), a && this.emit("blur", { editor: this, event: a.event, transaction: e }), !(!e.docChanged || e.getMeta("preventUpdate")) && this.emit("update", { editor: this, transaction: e }) } getAttributes(e) { return mJ(this.state, e) } isActive(e, t) { const r = typeof e == "string" ? e : null, i = typeof e == "string" ? t : e; return XAe(this.state, r, i) } getJSON() { return this.state.doc.toJSON() } getHTML() { return NR(this.state.doc.content, this.schema) } getText(e) {
    const { blockSeparator: t = `

`, textSerializers: r = {} } = e || {}; return WAe(this.state.doc, { blockSeparator: t, textSerializers: { ...lJ(this.schema), ...r } })
  } get isEmpty() { return Rk(this.state.doc) } getCharacterCount() { return console.warn('[tiptap warn]: "editor.getCharacterCount()" is deprecated. Please use "editor.storage.characterCount.characters()" instead.'), this.state.doc.content.size - 2 } destroy() { if (this.emit("destroy"), this.view) { const e = this.view.dom; e && e.editor && delete e.editor, this.view.destroy() } this.removeAllListeners() } get isDestroyed() { var e; return !(!((e = this.view) === null || e === void 0) && e.docView) } $node(e, t) { var r; return ((r = this.$doc) === null || r === void 0 ? void 0 : r.querySelector(e, t)) || null } $nodes(e, t) { var r; return ((r = this.$doc) === null || r === void 0 ? void 0 : r.querySelectorAll(e, t)) || null } $pos(e) { const t = this.state.doc.resolve(e); return new zf(t, this) } get $doc() { return this.$pos(0) }
}; function OEe(n) { return new $R({ find: n.find, handler: ({ state: e, range: t, match: r }) => { const i = cn(n.getAttributes, void 0, r) || {}, { tr: a } = e, o = t.from; let s = t.to; const l = n.type.create(i); if (r[1]) { const c = r[0].lastIndexOf(r[1]); let u = o + c; u > s ? u = s : s = u + r[1].length; const d = r[0][r[0].length - 1]; a.insertText(d, o + r[0].length - 1), a.replaceWith(u, s, l) } else if (r[0]) { const c = n.type.isInline ? o : o - 1; a.insert(c, n.type.create(i)).delete(a.mapping.map(o), a.mapping.map(s)) } a.scrollIntoView() } }) } function i2(n) { return new $R({ find: n.find, handler: ({ state: e, range: t, match: r }) => { const i = e.doc.resolve(t.from), a = cn(n.getAttributes, void 0, r) || {}; if (!i.node(-1).canReplaceWith(i.index(-1), i.indexAfter(-1), n.type)) return null; e.tr.delete(t.from, t.to).setBlockType(t.from, t.from, n.type, a) } }) } function yr(n) { return new $R({ find: n.find, handler: ({ state: e, range: t, match: r }) => { let i = n.replace, a = t.from; const o = t.to; if (r[1]) { const s = r[0].lastIndexOf(r[1]); i += r[0].slice(s + r[1].length), a += s; const l = a - o; l > 0 && (i = r[0].slice(s - l, s) + i, a = o) } e.tr.insertText(i, a, o) } }) } let jl = class Zj { constructor(e = {}) { this.type = "node", this.name = "node", this.parent = null, this.child = null, this.config = { name: this.name, defaultOptions: {} }, this.config = { ...this.config, ...e }, this.name = this.config.name, e.defaultOptions && Object.keys(e.defaultOptions).length > 0 && console.warn(`[tiptap warn]: BREAKING CHANGE: "defaultOptions" is deprecated. Please use "addOptions" instead. Found in extension: "${this.name}".`), this.options = this.config.defaultOptions, this.config.addOptions && (this.options = cn(dt(this, "addOptions", { name: this.name }))), this.storage = cn(dt(this, "addStorage", { name: this.name, options: this.options })) || {} } static create(e = {}) { return new Zj(e) } configure(e = {}) { const t = this.extend({ ...this.config, addOptions: () => Dk(this.options, e) }); return t.name = this.name, t.parent = this.parent, t } extend(e = {}) { const t = new Zj(e); return t.parent = this, this.child = t, t.name = e.name ? e.name : t.parent.name, e.defaultOptions && Object.keys(e.defaultOptions).length > 0 && console.warn(`[tiptap warn]: BREAKING CHANGE: "defaultOptions" is deprecated. Please use "addOptions" instead. Found in extension: "${t.name}".`), t.options = cn(dt(t, "addOptions", { name: t.name })), t.storage = cn(dt(t, "addStorage", { name: t.name, options: t.options })), t } }; class DEe { constructor(e, t, r) { this.isDragging = !1, this.component = e, this.editor = t.editor, this.options = { stopEvent: null, ignoreMutation: null, ...r }, this.extension = t.extension, this.node = t.node, this.decorations = t.decorations, this.innerDecorations = t.innerDecorations, this.view = t.view, this.HTMLAttributes = t.HTMLAttributes, this.getPos = t.getPos, this.mount() } mount() { } get dom() { return this.editor.view.dom } get contentDOM() { return null } onDragStart(e) { var t, r, i, a, o, s, l; const { view: c } = this.editor, u = e.target, d = u.nodeType === 3 ? (t = u.parentElement) === null || t === void 0 ? void 0 : t.closest("[data-drag-handle]") : u.closest("[data-drag-handle]"); if (!this.dom || !((r = this.contentDOM) === null || r === void 0) && r.contains(u) || !d) return; let f = 0, h = 0; if (this.dom !== d) { const b = this.dom.getBoundingClientRect(), w = d.getBoundingClientRect(), v = (i = e.offsetX) !== null && i !== void 0 ? i : (a = e.nativeEvent) === null || a === void 0 ? void 0 : a.offsetX, S = (o = e.offsetY) !== null && o !== void 0 ? o : (s = e.nativeEvent) === null || s === void 0 ? void 0 : s.offsetY; f = w.x - b.x + v, h = w.y - b.y + S } const p = this.dom.cloneNode(!0); (l = e.dataTransfer) === null || l === void 0 || l.setDragImage(p, f, h); const m = this.getPos(); if (typeof m != "number") return; const g = _t.create(c.state.doc, m), y = c.state.tr.setSelection(g); c.dispatch(y) } stopEvent(e) { var t; if (!this.dom) return !1; if (typeof this.options.stopEvent == "function") return this.options.stopEvent({ event: e }); const r = e.target; if (!(this.dom.contains(r) && !(!((t = this.contentDOM) === null || t === void 0) && t.contains(r)))) return !1; const a = e.type.startsWith("drag"), o = e.type === "drop"; if ((["INPUT", "BUTTON", "SELECT", "TEXTAREA"].includes(r.tagName) || r.isContentEditable) && !o && !a) return !0; const { isEditable: l } = this.editor, { isDragging: c } = this, u = !!this.node.type.spec.draggable, d = _t.isSelectable(this.node), f = e.type === "copy", h = e.type === "paste", p = e.type === "cut", m = e.type === "mousedown"; if (!u && d && a && e.target === this.dom && e.preventDefault(), u && a && !c && e.target === this.dom) return e.preventDefault(), !1; if (u && l && !c && m) { const g = r.closest("[data-drag-handle]"); g && (this.dom === g || this.dom.contains(g)) && (this.isDragging = !0, document.addEventListener("dragend", () => { this.isDragging = !1 }, { once: !0 }), document.addEventListener("drop", () => { this.isDragging = !1 }, { once: !0 }), document.addEventListener("mouseup", () => { this.isDragging = !1 }, { once: !0 })) } return !(c || o || f || h || p || m && d) } ignoreMutation(e) { return !this.dom || !this.contentDOM ? !0 : typeof this.options.ignoreMutation == "function" ? this.options.ignoreMutation({ mutation: e }) : this.node.isLeaf || this.node.isAtom ? !0 : e.type === "selection" || this.dom.contains(e.target) && e.type === "childList" && (Ik() || dJ()) && this.editor.isFocused && [...Array.from(e.addedNodes), ...Array.from(e.removedNodes)].every(r => r.isContentEditable) ? !1 : this.contentDOM === e.target && e.type === "attributes" ? !0 : !this.contentDOM.contains(e.target) } updateAttributes(e) { this.editor.commands.command(({ tr: t }) => { const r = this.getPos(); return typeof r != "number" ? !1 : (t.setNodeMarkup(r, void 0, { ...this.node.attrs, ...e }), !0) }) } deleteNode() { const e = this.getPos(); if (typeof e != "number") return; const t = e + this.node.nodeSize; this.editor.commands.deleteRange({ from: e, to: t }) } } function jEe(n) { return new KCe({ find: n.find, handler: ({ state: e, range: t, match: r, pasteEvent: i }) => { const a = cn(n.getAttributes, void 0, r, i); if (a === !1 || a === null) return null; const { tr: o } = e, s = r[r.length - 1], l = r[0]; let c = t.to; if (s) { const u = l.search(/\S/), d = t.from + l.indexOf(s), f = d + s.length; if (gJ(t.from, t.to, e.doc).filter(p => p.mark.type.excluded.find(g => g === n.type && g !== p.mark.type)).filter(p => p.to > d).length) return null; f < t.to && o.delete(f, t.to), d > t.from && o.delete(t.from + u, d), c = t.from + u + s.length, o.addMark(t.from + u, c, n.type.create(a || {})), o.removeStoredMark(n.type) } } }) } function PEe(n) { return n.replace(/[-/\\^$*+?.()|[\]{}]/g, "\\$&") } const IEe = /^```([a-z]+)?[\s\n]$/, LEe = /^~~~([a-z]+)?[\s\n]$/, REe = jl.create({
  name: "codeBlock", addOptions() { return { languageClassPrefix: "language-", exitOnTripleEnter: !0, exitOnArrowDown: !0, defaultLanguage: null, HTMLAttributes: {} } }, content: "text*", marks: "", group: "block", code: !0, defining: !0, addAttributes() { return { language: { default: this.options.defaultLanguage, parseHTML: n => { var e; const { languageClassPrefix: t } = this.options, a = [...((e = n.firstElementChild) === null || e === void 0 ? void 0 : e.classList) || []].filter(o => o.startsWith(t)).map(o => o.replace(t, ""))[0]; return a || null }, rendered: !1 } } }, parseHTML() { return [{ tag: "pre", preserveWhitespace: "full" }] }, renderHTML({ node: n, HTMLAttributes: e }) { return ["pre", Zr(this.options.HTMLAttributes, e), ["code", { class: n.attrs.language ? this.options.languageClassPrefix + n.attrs.language : null }, 0]] }, addCommands() { return { setCodeBlock: n => ({ commands: e }) => e.setNode(this.name, n), toggleCodeBlock: n => ({ commands: e }) => e.toggleNode(this.name, "paragraph", n) } }, addKeyboardShortcuts() {
    return {
      "Mod-Alt-c": () => this.editor.commands.toggleCodeBlock(), Backspace: () => { const { empty: n, $anchor: e } = this.editor.state.selection, t = e.pos === 1; return !n || e.parent.type.name !== this.name ? !1 : t || !e.parent.textContent.length ? this.editor.commands.clearNodes() : !1 }, Enter: ({ editor: n }) => {
        if (!this.options.exitOnTripleEnter) return !1; const { state: e } = n, { selection: t } = e, { $from: r, empty: i } = t; if (!i || r.parent.type !== this.type) return !1; const a = r.parentOffset === r.parent.nodeSize - 2, o = r.parent.textContent.endsWith(`

`); return !a || !o ? !1 : n.chain().command(({ tr: s }) => (s.delete(r.pos - 2, r.pos), !0)).exitCode().run()
      }, ArrowDown: ({ editor: n }) => { if (!this.options.exitOnArrowDown) return !1; const { state: e } = n, { selection: t, doc: r } = e, { $from: i, empty: a } = t; if (!a || i.parent.type !== this.type || !(i.parentOffset === i.parent.nodeSize - 2)) return !1; const s = i.after(); return s === void 0 ? !1 : r.nodeAt(s) ? n.commands.command(({ tr: c }) => (c.setSelection(vt.near(r.resolve(s))), !0)) : n.commands.exitCode() }
    }
  }, addInputRules() { return [i2({ find: IEe, type: this.type, getAttributes: n => ({ language: n[1] }) }), i2({ find: LEe, type: this.type, getAttributes: n => ({ language: n[1] }) })] }, addProseMirrorPlugins() {
    return [new wn({
      key: new xn("codeBlockVSCodeHandler"), props: {
        handlePaste: (n, e) => {
          if (!e.clipboardData || this.editor.isActive(this.type.name)) return !1; const t = e.clipboardData.getData("text/plain"), r = e.clipboardData.getData("vscode-editor-data"), i = r ? JSON.parse(r) : void 0, a = i == null ? void 0 : i.mode; if (!t || !a) return !1; const { tr: o, schema: s } = n.state, l = s.text(t.replace(/\r\n?/g, `
`)); return o.replaceSelectionWith(this.type.create({ language: a }, l)), o.selection.$from.parent.type !== this.type && o.setSelection(ht.near(o.doc.resolve(Math.max(0, o.selection.from - 2)))), o.setMeta("paste", !0), n.dispatch(o), !0
        }
      }
    })]
  }
}); function NEe(n) { return n && n.__esModule && Object.prototype.hasOwnProperty.call(n, "default") ? n.default : n } function yJ(n) { return n instanceof Map ? n.clear = n.delete = n.set = function () { throw new Error("map is read-only") } : n instanceof Set && (n.add = n.clear = n.delete = function () { throw new Error("set is read-only") }), Object.freeze(n), Object.getOwnPropertyNames(n).forEach(e => { const t = n[e], r = typeof t; (r === "object" || r === "function") && !Object.isFrozen(t) && yJ(t) }), n } let az = class { constructor(e) { e.data === void 0 && (e.data = {}), this.data = e.data, this.isMatchIgnored = !1 } ignoreMatch() { this.isMatchIgnored = !0 } }; function _J(n) { return n.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&#x27;") } function zu(n, ...e) { const t = Object.create(null); for (const r in n) t[r] = n[r]; return e.forEach(function (r) { for (const i in r) t[i] = r[i] }), t } const BEe = "</span>", oz = n => !!n.scope, $Ee = (n, { prefix: e }) => { if (n.startsWith("language:")) return n.replace("language:", "language-"); if (n.includes(".")) { const t = n.split("."); return [`${e}${t.shift()}`, ...t.map((r, i) => `${r}${"_".repeat(i + 1)}`)].join(" ") } return `${e}${n}` }; let FEe = class { constructor(e, t) { this.buffer = "", this.classPrefix = t.classPrefix, e.walk(this) } addText(e) { this.buffer += _J(e) } openNode(e) { if (!oz(e)) return; const t = $Ee(e.scope, { prefix: this.classPrefix }); this.span(t) } closeNode(e) { oz(e) && (this.buffer += BEe) } value() { return this.buffer } span(e) { this.buffer += `<span class="${e}">` } }; const sz = (n = {}) => { const e = { children: [] }; return Object.assign(e, n), e }; let zEe = class bJ { constructor() { this.rootNode = sz(), this.stack = [this.rootNode] } get top() { return this.stack[this.stack.length - 1] } get root() { return this.rootNode } add(e) { this.top.children.push(e) } openNode(e) { const t = sz({ scope: e }); this.add(t), this.stack.push(t) } closeNode() { if (this.stack.length > 1) return this.stack.pop() } closeAllNodes() { for (; this.closeNode();); } toJSON() { return JSON.stringify(this.rootNode, null, 4) } walk(e) { return this.constructor._walk(e, this.rootNode) } static _walk(e, t) { return typeof t == "string" ? e.addText(t) : t.children && (e.openNode(t), t.children.forEach(r => this._walk(e, r)), e.closeNode(t)), e } static _collapse(e) { typeof e != "string" && e.children && (e.children.every(t => typeof t == "string") ? e.children = [e.children.join("")] : e.children.forEach(t => { bJ._collapse(t) })) } }, VEe = class extends zEe { constructor(e) { super(), this.options = e } addText(e) { e !== "" && this.add(e) } startScope(e) { this.openNode(e) } endScope() { this.closeNode() } __addSublanguage(e, t) { const r = e.root; t && (r.scope = `language:${t}`), this.add(r) } toHTML() { return new FEe(this, this.options).value() } finalize() { return this.closeAllNodes(), !0 } }; function e_(n) { return n ? typeof n == "string" ? n : n.source : null } function wJ(n) { return ep("(?=", n, ")") } function HEe(n) { return ep("(?:", n, ")*") } function UEe(n) { return ep("(?:", n, ")?") } function ep(...n) { return n.map(t => e_(t)).join("") } function GEe(n) { const e = n[n.length - 1]; return typeof e == "object" && e.constructor === Object ? (n.splice(n.length - 1, 1), e) : {} } function HR(...n) { return "(" + (GEe(n).capture ? "" : "?:") + n.map(r => e_(r)).join("|") + ")" } function xJ(n) { return new RegExp(n.toString() + "|").exec("").length - 1 } function WEe(n, e) { const t = n && n.exec(e); return t && t.index === 0 } const KEe = /\[(?:[^\\\]]|\\.)*\]|\(\??|\\([1-9][0-9]*)|\\./; function UR(n, { joinWith: e }) { let t = 0; return n.map(r => { t += 1; const i = t; let a = e_(r), o = ""; for (; a.length > 0;) { const s = KEe.exec(a); if (!s) { o += a; break } o += a.substring(0, s.index), a = a.substring(s.index + s[0].length), s[0][0] === "\\" && s[1] ? o += "\\" + String(Number(s[1]) + i) : (o += s[0], s[0] === "(" && t++) } return o }).map(r => `(${r})`).join(e) } const qEe = /\b\B/, SJ = "[a-zA-Z]\\w*", GR = "[a-zA-Z_]\\w*", TJ = "\\b\\d+(\\.\\d+)?", kJ = "(-?)(\\b0[xX][a-fA-F0-9]+|(\\b\\d+(\\.\\d*)?|\\.\\d+)([eE][-+]?\\d+)?)", CJ = "\\b(0b[01]+)", YEe = "!|!=|!==|%|%=|&|&&|&=|\\*|\\*=|\\+|\\+=|,|-|-=|/=|/|:|;|<<|<<=|<=|<|===|==|=|>>>=|>>=|>=|>>>|>>|>|\\?|\\[|\\{|\\(|\\^|\\^=|\\||\\|=|\\|\\||~", ZEe = (n = {}) => { const e = /^#![ ]*\//; return n.binary && (n.begin = ep(e, /.*\b/, n.binary, /\b.*/)), zu({ scope: "meta", begin: e, end: /$/, relevance: 0, "on:begin": (t, r) => { t.index !== 0 && r.ignoreMatch() } }, n) }, t_ = { begin: "\\\\[\\s\\S]", relevance: 0 }, XEe = { scope: "string", begin: "'", end: "'", illegal: "\\n", contains: [t_] }, JEe = { scope: "string", begin: '"', end: '"', illegal: "\\n", contains: [t_] }, QEe = { begin: /\b(a|an|the|are|I'm|isn't|don't|doesn't|won't|but|just|should|pretty|simply|enough|gonna|going|wtf|so|such|will|you|your|they|like|more)\b/ }, Nk = function (n, e, t = {}) { const r = zu({ scope: "comment", begin: n, end: e, contains: [] }, t); r.contains.push({ scope: "doctag", begin: "[ ]*(?=(TODO|FIXME|NOTE|BUG|OPTIMIZE|HACK|XXX):)", end: /(TODO|FIXME|NOTE|BUG|OPTIMIZE|HACK|XXX):/, excludeBegin: !0, relevance: 0 }); const i = HR("I", "a", "is", "so", "us", "to", "at", "if", "in", "it", "on", /[A-Za-z]+['](d|ve|re|ll|t|s|n)/, /[A-Za-z]+[-][a-z]+/, /[A-Za-z][a-z]{2,}/); return r.contains.push({ begin: ep(/[ ]+/, "(", i, /[.]?[:]?([.][ ]|[ ])/, "){3}") }), r }, eMe = Nk("//", "$"), tMe = Nk("/\\*", "\\*/"), nMe = Nk("#", "$"), rMe = { scope: "number", begin: TJ, relevance: 0 }, iMe = { scope: "number", begin: kJ, relevance: 0 }, aMe = { scope: "number", begin: CJ, relevance: 0 }, oMe = { scope: "regexp", begin: /\/(?=[^/\n]*\/)/, end: /\/[gimuy]*/, contains: [t_, { begin: /\[/, end: /\]/, relevance: 0, contains: [t_] }] }, sMe = { scope: "title", begin: SJ, relevance: 0 }, lMe = { scope: "title", begin: GR, relevance: 0 }, cMe = { begin: "\\.\\s*" + GR, relevance: 0 }, uMe = function (n) { return Object.assign(n, { "on:begin": (e, t) => { t.data._beginMatch = e[1] }, "on:end": (e, t) => { t.data._beginMatch !== e[1] && t.ignoreMatch() } }) }; var nw = Object.freeze({ __proto__: null, APOS_STRING_MODE: XEe, BACKSLASH_ESCAPE: t_, BINARY_NUMBER_MODE: aMe, BINARY_NUMBER_RE: CJ, COMMENT: Nk, C_BLOCK_COMMENT_MODE: tMe, C_LINE_COMMENT_MODE: eMe, C_NUMBER_MODE: iMe, C_NUMBER_RE: kJ, END_SAME_AS_BEGIN: uMe, HASH_COMMENT_MODE: nMe, IDENT_RE: SJ, MATCH_NOTHING_RE: qEe, METHOD_GUARD: cMe, NUMBER_MODE: rMe, NUMBER_RE: TJ, PHRASAL_WORDS_MODE: QEe, QUOTE_STRING_MODE: JEe, REGEXP_MODE: oMe, RE_STARTERS_RE: YEe, SHEBANG: ZEe, TITLE_MODE: sMe, UNDERSCORE_IDENT_RE: GR, UNDERSCORE_TITLE_MODE: lMe }); function dMe(n, e) { n.input[n.index - 1] === "." && e.ignoreMatch() } function fMe(n, e) { n.className !== void 0 && (n.scope = n.className, delete n.className) } function hMe(n, e) { e && n.beginKeywords && (n.begin = "\\b(" + n.beginKeywords.split(" ").join("|") + ")(?!\\.)(?=\\b|\\s)", n.__beforeBegin = dMe, n.keywords = n.keywords || n.beginKeywords, delete n.beginKeywords, n.relevance === void 0 && (n.relevance = 0)) } function pMe(n, e) { Array.isArray(n.illegal) && (n.illegal = HR(...n.illegal)) } function mMe(n, e) { if (n.match) { if (n.begin || n.end) throw new Error("begin & end are not supported with match"); n.begin = n.match, delete n.match } } function gMe(n, e) { n.relevance === void 0 && (n.relevance = 1) } const vMe = (n, e) => { if (!n.beforeMatch) return; if (n.starts) throw new Error("beforeMatch cannot be used with starts"); const t = Object.assign({}, n); Object.keys(n).forEach(r => { delete n[r] }), n.keywords = t.keywords, n.begin = ep(t.beforeMatch, wJ(t.begin)), n.starts = { relevance: 0, contains: [Object.assign(t, { endsParent: !0 })] }, n.relevance = 0, delete t.beforeMatch }, yMe = ["of", "and", "for", "in", "not", "or", "if", "then", "parent", "list", "value"], _Me = "keyword"; function AJ(n, e, t = _Me) { const r = Object.create(null); return typeof n == "string" ? i(t, n.split(" ")) : Array.isArray(n) ? i(t, n) : Object.keys(n).forEach(function (a) { Object.assign(r, AJ(n[a], e, a)) }), r; function i(a, o) { e && (o = o.map(s => s.toLowerCase())), o.forEach(function (s) { const l = s.split("|"); r[l[0]] = [a, bMe(l[0], l[1])] }) } } function bMe(n, e) { return e ? Number(e) : wMe(n) ? 0 : 1 } function wMe(n) { return yMe.includes(n.toLowerCase()) } const lz = {}, vh = n => { console.error(n) }, cz = (n, ...e) => { console.log(`WARN: ${n}`, ...e) }, Np = (n, e) => { lz[`${n}/${e}`] || (console.log(`Deprecated as of ${n}. ${e}`), lz[`${n}/${e}`] = !0) }, a2 = new Error; function EJ(n, e, { key: t }) { let r = 0; const i = n[t], a = {}, o = {}; for (let s = 1; s <= e.length; s++)o[s + r] = i[s], a[s + r] = !0, r += xJ(e[s - 1]); n[t] = o, n[t]._emit = a, n[t]._multi = !0 } function xMe(n) { if (Array.isArray(n.begin)) { if (n.skip || n.excludeBegin || n.returnBegin) throw vh("skip, excludeBegin, returnBegin not compatible with beginScope: {}"), a2; if (typeof n.beginScope != "object" || n.beginScope === null) throw vh("beginScope must be object"), a2; EJ(n, n.begin, { key: "beginScope" }), n.begin = UR(n.begin, { joinWith: "" }) } } function SMe(n) { if (Array.isArray(n.end)) { if (n.skip || n.excludeEnd || n.returnEnd) throw vh("skip, excludeEnd, returnEnd not compatible with endScope: {}"), a2; if (typeof n.endScope != "object" || n.endScope === null) throw vh("endScope must be object"), a2; EJ(n, n.end, { key: "endScope" }), n.end = UR(n.end, { joinWith: "" }) } } function TMe(n) { n.scope && typeof n.scope == "object" && n.scope !== null && (n.beginScope = n.scope, delete n.scope) } function kMe(n) { TMe(n), typeof n.beginScope == "string" && (n.beginScope = { _wrap: n.beginScope }), typeof n.endScope == "string" && (n.endScope = { _wrap: n.endScope }), xMe(n), SMe(n) } function CMe(n) { function e(o, s) { return new RegExp(e_(o), "m" + (n.case_insensitive ? "i" : "") + (n.unicodeRegex ? "u" : "") + (s ? "g" : "")) } class t { constructor() { this.matchIndexes = {}, this.regexes = [], this.matchAt = 1, this.position = 0 } addRule(s, l) { l.position = this.position++, this.matchIndexes[this.matchAt] = l, this.regexes.push([l, s]), this.matchAt += xJ(s) + 1 } compile() { this.regexes.length === 0 && (this.exec = () => null); const s = this.regexes.map(l => l[1]); this.matcherRe = e(UR(s, { joinWith: "|" }), !0), this.lastIndex = 0 } exec(s) { this.matcherRe.lastIndex = this.lastIndex; const l = this.matcherRe.exec(s); if (!l) return null; const c = l.findIndex((d, f) => f > 0 && d !== void 0), u = this.matchIndexes[c]; return l.splice(0, c), Object.assign(l, u) } } class r { constructor() { this.rules = [], this.multiRegexes = [], this.count = 0, this.lastIndex = 0, this.regexIndex = 0 } getMatcher(s) { if (this.multiRegexes[s]) return this.multiRegexes[s]; const l = new t; return this.rules.slice(s).forEach(([c, u]) => l.addRule(c, u)), l.compile(), this.multiRegexes[s] = l, l } resumingScanAtSamePosition() { return this.regexIndex !== 0 } considerAll() { this.regexIndex = 0 } addRule(s, l) { this.rules.push([s, l]), l.type === "begin" && this.count++ } exec(s) { const l = this.getMatcher(this.regexIndex); l.lastIndex = this.lastIndex; let c = l.exec(s); if (this.resumingScanAtSamePosition() && !(c && c.index === this.lastIndex)) { const u = this.getMatcher(0); u.lastIndex = this.lastIndex + 1, c = u.exec(s) } return c && (this.regexIndex += c.position + 1, this.regexIndex === this.count && this.considerAll()), c } } function i(o) { const s = new r; return o.contains.forEach(l => s.addRule(l.begin, { rule: l, type: "begin" })), o.terminatorEnd && s.addRule(o.terminatorEnd, { type: "end" }), o.illegal && s.addRule(o.illegal, { type: "illegal" }), s } function a(o, s) { const l = o; if (o.isCompiled) return l;[fMe, mMe, kMe, vMe].forEach(u => u(o, s)), n.compilerExtensions.forEach(u => u(o, s)), o.__beforeBegin = null, [hMe, pMe, gMe].forEach(u => u(o, s)), o.isCompiled = !0; let c = null; return typeof o.keywords == "object" && o.keywords.$pattern && (o.keywords = Object.assign({}, o.keywords), c = o.keywords.$pattern, delete o.keywords.$pattern), c = c || /\w+/, o.keywords && (o.keywords = AJ(o.keywords, n.case_insensitive)), l.keywordPatternRe = e(c, !0), s && (o.begin || (o.begin = /\B|\b/), l.beginRe = e(l.begin), !o.end && !o.endsWithParent && (o.end = /\B|\b/), o.end && (l.endRe = e(l.end)), l.terminatorEnd = e_(l.end) || "", o.endsWithParent && s.terminatorEnd && (l.terminatorEnd += (o.end ? "|" : "") + s.terminatorEnd)), o.illegal && (l.illegalRe = e(o.illegal)), o.contains || (o.contains = []), o.contains = [].concat(...o.contains.map(function (u) { return AMe(u === "self" ? o : u) })), o.contains.forEach(function (u) { a(u, l) }), o.starts && a(o.starts, s), l.matcher = i(l), l } if (n.compilerExtensions || (n.compilerExtensions = []), n.contains && n.contains.includes("self")) throw new Error("ERR: contains `self` is not supported at the top-level of a language.  See documentation."); return n.classNameAliases = zu(n.classNameAliases || {}), a(n) } function MJ(n) { return n ? n.endsWithParent || MJ(n.starts) : !1 } function AMe(n) { return n.variants && !n.cachedVariants && (n.cachedVariants = n.variants.map(function (e) { return zu(n, { variants: null }, e) })), n.cachedVariants ? n.cachedVariants : MJ(n) ? zu(n, { starts: n.starts ? zu(n.starts) : null }) : Object.isFrozen(n) ? zu(n) : n } var EMe = "11.10.0"; let MMe = class extends Error { constructor(e, t) { super(e), this.name = "HTMLInjectionError", this.html = t } }; const BE = _J, uz = zu, dz = Symbol("nomatch"), OMe = 7, OJ = function (n) {
  const e = Object.create(null), t = Object.create(null), r = []; let i = !0; const a = "Could not find the language '{}', did you forget to load/include a language module?", o = { disableAutodetect: !0, name: "Plain text", contains: [] }; let s = { ignoreUnescapedHTML: !1, throwUnescapedHTML: !1, noHighlightRe: /^(no-?highlight)$/i, languageDetectRe: /\blang(?:uage)?-([\w-]+)\b/i, classPrefix: "hljs-", cssSelector: "pre code", languages: null, __emitter: VEe }; function l(P) { return s.noHighlightRe.test(P) } function c(P) { let B = P.className + " "; B += P.parentNode ? P.parentNode.className : ""; const F = s.languageDetectRe.exec(B); if (F) { const K = C(F[1]); return K || (cz(a.replace("{}", F[1])), cz("Falling back to no-highlight mode for this block.", P)), K ? F[1] : "no-highlight" } return B.split(/\s+/).find(K => l(K) || C(K)) } function u(P, B, F) {
    let K = "", V = ""; typeof B == "object" ? (K = P, F = B.ignoreIllegals, V = B.language) : (Np("10.7.0", "highlight(lang, code, ...args) has been deprecated."), Np("10.7.0", `Please use highlight(code, options) instead.
https://github.com/highlightjs/highlight.js/issues/2277`), V = P, K = B), F === void 0 && (F = !0); const W = { code: K, language: V }; R("before:highlight", W); const J = W.result ? W.result : d(W.language, W.code, F); return J.code = W.code, R("after:highlight", J), J
  } function d(P, B, F, K) { const V = Object.create(null); function W(ce, Te) { return ce.keywords[Te] } function J() { if (!we.keywords) { ve.addText(Se); return } let ce = 0; we.keywordPatternRe.lastIndex = 0; let Te = we.keywordPatternRe.exec(Se), Le = ""; for (; Te;) { Le += Se.substring(ce, Te.index); const st = de.case_insensitive ? Te[0].toLowerCase() : Te[0], jt = W(we, st); if (jt) { const [Dn, rr] = jt; if (ve.addText(Le), Le = "", V[st] = (V[st] || 0) + 1, V[st] <= OMe && (Ke += rr), Dn.startsWith("_")) Le += Te[0]; else { const Ce = de.classNameAliases[Dn] || Dn; De(Te[0], Ce) } } else Le += Te[0]; ce = we.keywordPatternRe.lastIndex, Te = we.keywordPatternRe.exec(Se) } Le += Se.substring(ce), ve.addText(Le) } function ie() { if (Se === "") return; let ce = null; if (typeof we.subLanguage == "string") { if (!e[we.subLanguage]) { ve.addText(Se); return } ce = d(we.subLanguage, Se, !0, Oe[we.subLanguage]), Oe[we.subLanguage] = ce._top } else ce = h(Se, we.subLanguage.length ? we.subLanguage : null); we.relevance > 0 && (Ke += ce.relevance), ve.__addSublanguage(ce._emitter, ce.language) } function le() { we.subLanguage != null ? ie() : J(), Se = "" } function De(ce, Te) { ce !== "" && (ve.startScope(Te), ve.addText(ce), ve.endScope()) } function ae(ce, Te) { let Le = 1; const st = Te.length - 1; for (; Le <= st;) { if (!ce._emit[Le]) { Le++; continue } const jt = de.classNameAliases[ce[Le]] || ce[Le], Dn = Te[Le]; jt ? De(Dn, jt) : (Se = Dn, J(), Se = ""), Le++ } } function pe(ce, Te) { return ce.scope && typeof ce.scope == "string" && ve.openNode(de.classNameAliases[ce.scope] || ce.scope), ce.beginScope && (ce.beginScope._wrap ? (De(Se, de.classNameAliases[ce.beginScope._wrap] || ce.beginScope._wrap), Se = "") : ce.beginScope._multi && (ae(ce.beginScope, Te), Se = "")), we = Object.create(ce, { parent: { value: we } }), we } function se(ce, Te, Le) { let st = WEe(ce.endRe, Le); if (st) { if (ce["on:end"]) { const jt = new az(ce); ce["on:end"](Te, jt), jt.isMatchIgnored && (st = !1) } if (st) { for (; ce.endsParent && ce.parent;)ce = ce.parent; return ce } } if (ce.endsWithParent) return se(ce.parent, Te, Le) } function ge(ce) { return we.matcher.regexIndex === 0 ? (Se += ce[0], 1) : (Ee = !0, 0) } function _e(ce) { const Te = ce[0], Le = ce.rule, st = new az(Le), jt = [Le.__beforeBegin, Le["on:begin"]]; for (const Dn of jt) if (Dn && (Dn(ce, st), st.isMatchIgnored)) return ge(Te); return Le.skip ? Se += Te : (Le.excludeBegin && (Se += Te), le(), !Le.returnBegin && !Le.excludeBegin && (Se = Te)), pe(Le, ce), Le.returnBegin ? 0 : Te.length } function je(ce) { const Te = ce[0], Le = B.substring(ce.index), st = se(we, ce, Le); if (!st) return dz; const jt = we; we.endScope && we.endScope._wrap ? (le(), De(Te, we.endScope._wrap)) : we.endScope && we.endScope._multi ? (le(), ae(we.endScope, ce)) : jt.skip ? Se += Te : (jt.returnEnd || jt.excludeEnd || (Se += Te), le(), jt.excludeEnd && (Se = Te)); do we.scope && ve.closeNode(), !we.skip && !we.subLanguage && (Ke += we.relevance), we = we.parent; while (we !== st.parent); return st.starts && pe(st.starts, ce), jt.returnEnd ? 0 : Te.length } function U() { const ce = []; for (let Te = we; Te !== de; Te = Te.parent)Te.scope && ce.unshift(Te.scope); ce.forEach(Te => ve.openNode(Te)) } let q = {}; function ee(ce, Te) { const Le = Te && Te[0]; if (Se += ce, Le == null) return le(), 0; if (q.type === "begin" && Te.type === "end" && q.index === Te.index && Le === "") { if (Se += B.slice(Te.index, Te.index + 1), !i) { const st = new Error(`0 width match regex (${P})`); throw st.languageName = P, st.badRule = q.rule, st } return 1 } if (q = Te, Te.type === "begin") return _e(Te); if (Te.type === "illegal" && !F) { const st = new Error('Illegal lexeme "' + Le + '" for mode "' + (we.scope || "<unnamed>") + '"'); throw st.mode = we, st } else if (Te.type === "end") { const st = je(Te); if (st !== dz) return st } if (Te.type === "illegal" && Le === "") return 1; if (Xe > 1e5 && Xe > Te.index * 3) throw new Error("potential infinite loop, way more iterations than matches"); return Se += Le, Le.length } const de = C(P); if (!de) throw vh(a.replace("{}", P)), new Error('Unknown language: "' + P + '"'); const me = CMe(de); let fe = "", we = K || me; const Oe = {}, ve = new s.__emitter(s); U(); let Se = "", Ke = 0, ze = 0, Xe = 0, Ee = !1; try { if (de.__emitTokens) de.__emitTokens(B, ve); else { for (we.matcher.considerAll(); ;) { Xe++, Ee ? Ee = !1 : we.matcher.considerAll(), we.matcher.lastIndex = ze; const ce = we.matcher.exec(B); if (!ce) break; const Te = B.substring(ze, ce.index), Le = ee(Te, ce); ze = ce.index + Le } ee(B.substring(ze)) } return ve.finalize(), fe = ve.toHTML(), { language: P, value: fe, relevance: Ke, illegal: !1, _emitter: ve, _top: we } } catch (ce) { if (ce.message && ce.message.includes("Illegal")) return { language: P, value: BE(B), illegal: !0, relevance: 0, _illegalBy: { message: ce.message, index: ze, context: B.slice(ze - 100, ze + 100), mode: ce.mode, resultSoFar: fe }, _emitter: ve }; if (i) return { language: P, value: BE(B), illegal: !1, relevance: 0, errorRaised: ce, _emitter: ve, _top: we }; throw ce } } function f(P) { const B = { value: BE(P), illegal: !1, relevance: 0, _top: o, _emitter: new s.__emitter(s) }; return B._emitter.addText(P), B } function h(P, B) { B = B || s.languages || Object.keys(e); const F = f(P), K = B.filter(C).filter(O).map(le => d(le, P, !1)); K.unshift(F); const V = K.sort((le, De) => { if (le.relevance !== De.relevance) return De.relevance - le.relevance; if (le.language && De.language) { if (C(le.language).supersetOf === De.language) return 1; if (C(De.language).supersetOf === le.language) return -1 } return 0 }), [W, J] = V, ie = W; return ie.secondBest = J, ie } function p(P, B, F) { const K = B && t[B] || F; P.classList.add("hljs"), P.classList.add(`language-${K}`) } function m(P) { let B = null; const F = c(P); if (l(F)) return; if (R("before:highlightElement", { el: P, language: F }), P.dataset.highlighted) { console.log("Element previously highlighted. To highlight again, first unset `dataset.highlighted`.", P); return } if (P.children.length > 0 && (s.ignoreUnescapedHTML || (console.warn("One of your code blocks includes unescaped HTML. This is a potentially serious security risk."), console.warn("https://github.com/highlightjs/highlight.js/wiki/security"), console.warn("The element with unescaped HTML:"), console.warn(P)), s.throwUnescapedHTML)) throw new MMe("One of your code blocks includes unescaped HTML.", P.innerHTML); B = P; const K = B.textContent, V = F ? u(K, { language: F, ignoreIllegals: !0 }) : h(K); P.innerHTML = V.value, P.dataset.highlighted = "yes", p(P, F, V.language), P.result = { language: V.language, re: V.relevance, relevance: V.relevance }, V.secondBest && (P.secondBest = { language: V.secondBest.language, relevance: V.secondBest.relevance }), R("after:highlightElement", { el: P, result: V, text: K }) } function g(P) { s = uz(s, P) } const y = () => { v(), Np("10.6.0", "initHighlighting() deprecated.  Use highlightAll() now.") }; function b() { v(), Np("10.6.0", "initHighlightingOnLoad() deprecated.  Use highlightAll() now.") } let w = !1; function v() { if (document.readyState === "loading") { w = !0; return } document.querySelectorAll(s.cssSelector).forEach(m) } function S() { w && v() } typeof window < "u" && window.addEventListener && window.addEventListener("DOMContentLoaded", S, !1); function x(P, B) { let F = null; try { F = B(n) } catch (K) { if (vh("Language definition for '{}' could not be registered.".replace("{}", P)), i) vh(K); else throw K; F = o } F.name || (F.name = P), e[P] = F, F.rawDefinition = B.bind(null, n), F.aliases && E(F.aliases, { languageName: P }) } function k(P) { delete e[P]; for (const B of Object.keys(t)) t[B] === P && delete t[B] } function A() { return Object.keys(e) } function C(P) { return P = (P || "").toLowerCase(), e[P] || e[t[P]] } function E(P, { languageName: B }) { typeof P == "string" && (P = [P]), P.forEach(F => { t[F.toLowerCase()] = B }) } function O(P) { const B = C(P); return B && !B.disableAutodetect } function j(P) { P["before:highlightBlock"] && !P["before:highlightElement"] && (P["before:highlightElement"] = B => { P["before:highlightBlock"](Object.assign({ block: B.el }, B)) }), P["after:highlightBlock"] && !P["after:highlightElement"] && (P["after:highlightElement"] = B => { P["after:highlightBlock"](Object.assign({ block: B.el }, B)) }) } function I(P) { j(P), r.push(P) } function L(P) { const B = r.indexOf(P); B !== -1 && r.splice(B, 1) } function R(P, B) { const F = P; r.forEach(function (K) { K[F] && K[F](B) }) } function D(P) { return Np("10.7.0", "highlightBlock will be removed entirely in v12.0"), Np("10.7.0", "Please use highlightElement now."), m(P) } Object.assign(n, { highlight: u, highlightAuto: h, highlightAll: v, highlightElement: m, highlightBlock: D, configure: g, initHighlighting: y, initHighlightingOnLoad: b, registerLanguage: x, unregisterLanguage: k, listLanguages: A, getLanguage: C, registerAliases: E, autoDetection: O, inherit: uz, addPlugin: I, removePlugin: L }), n.debugMode = function () { i = !1 }, n.safeMode = function () { i = !0 }, n.versionString = EMe, n.regex = { concat: ep, lookahead: wJ, either: HR, optional: UEe, anyNumberOfTimes: HEe }; for (const P in nw) typeof nw[P] == "object" && yJ(nw[P]); return Object.assign(n, nw), n
}, _g = OJ({}); _g.newInstance = () => OJ({}); var DMe = _g; _g.HighlightJS = _g; _g.default = _g; var jMe = NEe(DMe); function DJ(n, e = []) { return n.map(t => { const r = [...e, ...t.properties ? t.properties.className : []]; return t.children ? DJ(t.children, r) : { text: t.value, classes: r } }).flat() } function fz(n) { return n.value || n.children || [] } function PMe(n) { return !!jMe.getLanguage(n) } function hz({ doc: n, name: e, lowlight: t, defaultLanguage: r }) { const i = []; return qj(n, a => a.type.name === e).forEach(a => { var o; let s = a.pos + 1; const l = a.node.attrs.language || r, c = t.listLanguages(), u = l && (c.includes(l) || PMe(l) || !((o = t.registered) === null || o === void 0) && o.call(t, l)) ? fz(t.highlight(l, a.node.textContent)) : fz(t.highlightAuto(a.node.textContent)); DJ(u).forEach(d => { const f = s + d.text.length; if (d.classes.length) { const h = di.inline(s, f, { class: d.classes.join(" ") }); i.push(h) } s = f }) }), Xn.create(n, i) } function IMe(n) { return typeof n == "function" } function LMe({ name: n, lowlight: e, defaultLanguage: t }) { if (!["highlight", "highlightAuto", "listLanguages"].every(i => IMe(e[i]))) throw Error("You should provide an instance of lowlight to use the code-block-lowlight extension"); const r = new wn({ key: new xn("lowlight"), state: { init: (i, { doc: a }) => hz({ doc: a, name: n, lowlight: e, defaultLanguage: t }), apply: (i, a, o, s) => { const l = o.selection.$head.parent.type.name, c = s.selection.$head.parent.type.name, u = qj(o.doc, f => f.type.name === n), d = qj(s.doc, f => f.type.name === n); return i.docChanged && ([l, c].includes(n) || d.length !== u.length || i.steps.some(f => f.from !== void 0 && f.to !== void 0 && u.some(h => h.pos >= f.from && h.pos + h.node.nodeSize <= f.to))) ? hz({ doc: i.doc, name: n, lowlight: e, defaultLanguage: t }) : a.map(i.mapping, i.doc) } }, props: { decorations(i) { return r.getState(i) } } }); return r } const RMe = REe.extend({ addOptions() { var n; return { ...(n = this.parent) === null || n === void 0 ? void 0 : n.call(this), lowlight: {}, languageClassPrefix: "language-", exitOnTripleEnter: !0, exitOnArrowDown: !0, defaultLanguage: null, HTMLAttributes: {} } }, addProseMirrorPlugins() { var n; return [...((n = this.parent) === null || n === void 0 ? void 0 : n.call(this)) || [], LMe({ name: this.name, lowlight: this.options.lowlight, defaultLanguage: this.options.defaultLanguage })] } }), NMe = Bi.create({ name: "placeholder", addOptions() { return { emptyEditorClass: "is-editor-empty", emptyNodeClass: "is-empty", placeholder: "Write something ", showOnlyWhenEditable: !0, showOnlyCurrent: !0, includeChildren: !1 } }, addProseMirrorPlugins() { return [new wn({ key: new xn("placeholder"), props: { decorations: ({ doc: n, selection: e }) => { const t = this.editor.isEditable || !this.options.showOnlyWhenEditable, { anchor: r } = e, i = []; if (!t) return null; const a = this.editor.isEmpty; return n.descendants((o, s) => { const l = r >= s && r <= s + o.nodeSize, c = !o.isLeaf && Rk(o); if ((l || !this.options.showOnlyCurrent) && c) { const u = [this.options.emptyNodeClass]; a && u.push(this.options.emptyEditorClass); const d = di.node(s, s + o.nodeSize, { class: u.join(" "), "data-placeholder": typeof this.options.placeholder == "function" ? this.options.placeholder({ editor: this.editor, node: o, pos: s, hasAnchor: l }) : this.options.placeholder }); i.push(d) } return this.options.includeChildren }), Xn.create(n, i) } } })] } }); var Xj, Jj; if (typeof WeakMap < "u") { let n = new WeakMap; Xj = e => n.get(e), Jj = (e, t) => (n.set(e, t), t) } else { const n = []; let t = 0; Xj = r => { for (let i = 0; i < n.length; i += 2)if (n[i] == r) return n[i + 1] }, Jj = (r, i) => (t == 10 && (t = 0), n[t++] = r, n[t++] = i) } var pr = class { constructor(n, e, t, r) { this.width = n, this.height = e, this.map = t, this.problems = r } findCell(n) { for (let e = 0; e < this.map.length; e++) { const t = this.map[e]; if (t != n) continue; const r = e % this.width, i = e / this.width | 0; let a = r + 1, o = i + 1; for (let s = 1; a < this.width && this.map[e + s] == t; s++)a++; for (let s = 1; o < this.height && this.map[e + this.width * s] == t; s++)o++; return { left: r, top: i, right: a, bottom: o } } throw new RangeError(`No cell with offset ${n} found`) } colCount(n) { for (let e = 0; e < this.map.length; e++)if (this.map[e] == n) return e % this.width; throw new RangeError(`No cell with offset ${n} found`) } nextCell(n, e, t) { const { left: r, right: i, top: a, bottom: o } = this.findCell(n); return e == "horiz" ? (t < 0 ? r == 0 : i == this.width) ? null : this.map[a * this.width + (t < 0 ? r - 1 : i)] : (t < 0 ? a == 0 : o == this.height) ? null : this.map[r + this.width * (t < 0 ? a - 1 : o)] } rectBetween(n, e) { const { left: t, right: r, top: i, bottom: a } = this.findCell(n), { left: o, right: s, top: l, bottom: c } = this.findCell(e); return { left: Math.min(t, o), top: Math.min(i, l), right: Math.max(r, s), bottom: Math.max(a, c) } } cellsInRect(n) { const e = [], t = {}; for (let r = n.top; r < n.bottom; r++)for (let i = n.left; i < n.right; i++) { const a = r * this.width + i, o = this.map[a]; t[o] || (t[o] = !0, !(i == n.left && i && this.map[a - 1] == o || r == n.top && r && this.map[a - this.width] == o) && e.push(o)) } return e } positionAt(n, e, t) { for (let r = 0, i = 0; ; r++) { const a = i + t.child(r).nodeSize; if (r == n) { let o = e + n * this.width; const s = (n + 1) * this.width; for (; o < s && this.map[o] < i;)o++; return o == s ? a - 1 : this.map[o] } i = a } } static get(n) { return Xj(n) || Jj(n, BMe(n)) } }; function BMe(n) { if (n.type.spec.tableRole != "table") throw new RangeError("Not a table node: " + n.type.name); const e = $Me(n), t = n.childCount, r = []; let i = 0, a = null; const o = []; for (let c = 0, u = e * t; c < u; c++)r[c] = 0; for (let c = 0, u = 0; c < t; c++) { const d = n.child(c); u++; for (let p = 0; ; p++) { for (; i < r.length && r[i] != 0;)i++; if (p == d.childCount) break; const m = d.child(p), { colspan: g, rowspan: y, colwidth: b } = m.attrs; for (let w = 0; w < y; w++) { if (w + c >= t) { (a || (a = [])).push({ type: "overlong_rowspan", pos: u, n: y - w }); break } const v = i + w * e; for (let S = 0; S < g; S++) { r[v + S] == 0 ? r[v + S] = u : (a || (a = [])).push({ type: "collision", row: c, pos: u, n: g - S }); const x = b && b[S]; if (x) { const k = (v + S) % e * 2, A = o[k]; A == null || A != x && o[k + 1] == 1 ? (o[k] = x, o[k + 1] = 1) : A == x && o[k + 1]++ } } } i += g, u += m.nodeSize } const f = (c + 1) * e; let h = 0; for (; i < f;)r[i++] == 0 && h++; h && (a || (a = [])).push({ type: "missing", row: c, n: h }), u++ } const s = new pr(e, t, r, a); let l = !1; for (let c = 0; !l && c < o.length; c += 2)o[c] != null && o[c + 1] < t && (l = !0); return l && FMe(s, o, n), s } function $Me(n) { let e = -1, t = !1; for (let r = 0; r < n.childCount; r++) { const i = n.child(r); let a = 0; if (t) for (let o = 0; o < r; o++) { const s = n.child(o); for (let l = 0; l < s.childCount; l++) { const c = s.child(l); o + c.attrs.rowspan > r && (a += c.attrs.colspan) } } for (let o = 0; o < i.childCount; o++) { const s = i.child(o); a += s.attrs.colspan, s.attrs.rowspan > 1 && (t = !0) } e == -1 ? e = a : e != a && (e = Math.max(e, a)) } return e } function FMe(n, e, t) { n.problems || (n.problems = []); const r = {}; for (let i = 0; i < n.map.length; i++) { const a = n.map[i]; if (r[a]) continue; r[a] = !0; const o = t.nodeAt(a); if (!o) throw new RangeError(`No cell with offset ${a} found`); let s = null; const l = o.attrs; for (let c = 0; c < l.colspan; c++) { const u = (i + c) % n.width, d = e[u * 2]; d != null && (!l.colwidth || l.colwidth[c] != d) && ((s || (s = zMe(l)))[c] = d) } s && n.problems.unshift({ type: "colwidth mismatch", pos: a, colwidth: s }) } } function zMe(n) { if (n.colwidth) return n.colwidth.slice(); const e = []; for (let t = 0; t < n.colspan; t++)e.push(0); return e } function ji(n) { let e = n.cached.tableNodeTypes; if (!e) { e = n.cached.tableNodeTypes = {}; for (const t in n.nodes) { const r = n.nodes[t], i = r.spec.tableRole; i && (e[i] = r) } } return e } var Pu = new xn("selectingCells"); function Ug(n) { for (let e = n.depth - 1; e > 0; e--)if (n.node(e).type.spec.tableRole == "row") return n.node(0).resolve(n.before(e + 1)); return null } function VMe(n) { for (let e = n.depth; e > 0; e--) { const t = n.node(e).type.spec.tableRole; if (t === "cell" || t === "header_cell") return n.node(e) } return null } function Ds(n) { const e = n.selection.$head; for (let t = e.depth; t > 0; t--)if (e.node(t).type.spec.tableRole == "row") return !0; return !1 } function Bk(n) { const e = n.selection; if ("$anchorCell" in e && e.$anchorCell) return e.$anchorCell.pos > e.$headCell.pos ? e.$anchorCell : e.$headCell; if ("node" in e && e.node && e.node.type.spec.tableRole == "cell") return e.$anchor; const t = Ug(e.$head) || HMe(e.$head); if (t) return t; throw new RangeError(`No cell found around position ${e.head}`) } function HMe(n) { for (let e = n.nodeAfter, t = n.pos; e; e = e.firstChild, t++) { const r = e.type.spec.tableRole; if (r == "cell" || r == "header_cell") return n.doc.resolve(t) } for (let e = n.nodeBefore, t = n.pos; e; e = e.lastChild, t--) { const r = e.type.spec.tableRole; if (r == "cell" || r == "header_cell") return n.doc.resolve(t - e.nodeSize) } } function Qj(n) { return n.parent.type.spec.tableRole == "row" && !!n.nodeAfter } function UMe(n) { return n.node(0).resolve(n.pos + n.nodeAfter.nodeSize) } function WR(n, e) { return n.depth == e.depth && n.pos >= e.start(-1) && n.pos <= e.end(-1) } function jJ(n, e, t) { const r = n.node(-1), i = pr.get(r), a = n.start(-1), o = i.nextCell(n.pos - a, e, t); return o == null ? null : n.node(0).resolve(a + o) } function zh(n, e, t = 1) { const r = { ...n, colspan: n.colspan - t }; return r.colwidth && (r.colwidth = r.colwidth.slice(), r.colwidth.splice(e, t), r.colwidth.some(i => i > 0) || (r.colwidth = null)), r } function PJ(n, e, t = 1) { const r = { ...n, colspan: n.colspan + t }; if (r.colwidth) { r.colwidth = r.colwidth.slice(); for (let i = 0; i < t; i++)r.colwidth.splice(e, 0, 0) } return r } function GMe(n, e, t) { const r = ji(e.type.schema).header_cell; for (let i = 0; i < n.height; i++)if (e.nodeAt(n.map[t + i * n.width]).type != r) return !1; return !0 } var qn = class Ql extends vt { constructor(e, t = e) { const r = e.node(-1), i = pr.get(r), a = e.start(-1), o = i.rectBetween(e.pos - a, t.pos - a), s = e.node(0), l = i.cellsInRect(o).filter(u => u != t.pos - a); l.unshift(t.pos - a); const c = l.map(u => { const d = r.nodeAt(u); if (!d) throw RangeError(`No cell with offset ${u} found`); const f = a + u + 1; return new YZ(s.resolve(f), s.resolve(f + d.content.size)) }); super(c[0].$from, c[0].$to, c), this.$anchorCell = e, this.$headCell = t } map(e, t) { const r = e.resolve(t.map(this.$anchorCell.pos)), i = e.resolve(t.map(this.$headCell.pos)); if (Qj(r) && Qj(i) && WR(r, i)) { const a = this.$anchorCell.node(-1) != r.node(-1); return a && this.isRowSelection() ? Ql.rowSelection(r, i) : a && this.isColSelection() ? Ql.colSelection(r, i) : new Ql(r, i) } return ht.between(r, i) } content() { const e = this.$anchorCell.node(-1), t = pr.get(e), r = this.$anchorCell.start(-1), i = t.rectBetween(this.$anchorCell.pos - r, this.$headCell.pos - r), a = {}, o = []; for (let l = i.top; l < i.bottom; l++) { const c = []; for (let u = l * t.width + i.left, d = i.left; d < i.right; d++, u++) { const f = t.map[u]; if (a[f]) continue; a[f] = !0; const h = t.findCell(f); let p = e.nodeAt(f); if (!p) throw RangeError(`No cell with offset ${f} found`); const m = i.left - h.left, g = h.right - i.right; if (m > 0 || g > 0) { let y = p.attrs; if (m > 0 && (y = zh(y, 0, m)), g > 0 && (y = zh(y, y.colspan - g, g)), h.left < i.left) { if (p = p.type.createAndFill(y), !p) throw RangeError(`Could not create cell with attrs ${JSON.stringify(y)}`) } else p = p.type.create(y, p.content) } if (h.top < i.top || h.bottom > i.bottom) { const y = { ...p.attrs, rowspan: Math.min(h.bottom, i.bottom) - Math.max(h.top, i.top) }; h.top < i.top ? p = p.type.createAndFill(y) : p = p.type.create(y, p.content) } c.push(p) } o.push(e.child(l).copy(Be.from(c))) } const s = this.isColSelection() && this.isRowSelection() ? e : o; return new Qe(Be.from(s), 1, 1) } replace(e, t = Qe.empty) { const r = e.steps.length, i = this.ranges; for (let o = 0; o < i.length; o++) { const { $from: s, $to: l } = i[o], c = e.mapping.slice(r); e.replace(c.map(s.pos), c.map(l.pos), o ? Qe.empty : t) } const a = vt.findFrom(e.doc.resolve(e.mapping.slice(r).map(this.to)), -1); a && e.setSelection(a) } replaceWith(e, t) { this.replace(e, new Qe(Be.from(t), 0, 0)) } forEachCell(e) { const t = this.$anchorCell.node(-1), r = pr.get(t), i = this.$anchorCell.start(-1), a = r.cellsInRect(r.rectBetween(this.$anchorCell.pos - i, this.$headCell.pos - i)); for (let o = 0; o < a.length; o++)e(t.nodeAt(a[o]), i + a[o]) } isColSelection() { const e = this.$anchorCell.index(-1), t = this.$headCell.index(-1); if (Math.min(e, t) > 0) return !1; const r = e + this.$anchorCell.nodeAfter.attrs.rowspan, i = t + this.$headCell.nodeAfter.attrs.rowspan; return Math.max(r, i) == this.$headCell.node(-1).childCount } static colSelection(e, t = e) { const r = e.node(-1), i = pr.get(r), a = e.start(-1), o = i.findCell(e.pos - a), s = i.findCell(t.pos - a), l = e.node(0); return o.top <= s.top ? (o.top > 0 && (e = l.resolve(a + i.map[o.left])), s.bottom < i.height && (t = l.resolve(a + i.map[i.width * (i.height - 1) + s.right - 1]))) : (s.top > 0 && (t = l.resolve(a + i.map[s.left])), o.bottom < i.height && (e = l.resolve(a + i.map[i.width * (i.height - 1) + o.right - 1]))), new Ql(e, t) } isRowSelection() { const e = this.$anchorCell.node(-1), t = pr.get(e), r = this.$anchorCell.start(-1), i = t.colCount(this.$anchorCell.pos - r), a = t.colCount(this.$headCell.pos - r); if (Math.min(i, a) > 0) return !1; const o = i + this.$anchorCell.nodeAfter.attrs.colspan, s = a + this.$headCell.nodeAfter.attrs.colspan; return Math.max(o, s) == t.width } eq(e) { return e instanceof Ql && e.$anchorCell.pos == this.$anchorCell.pos && e.$headCell.pos == this.$headCell.pos } static rowSelection(e, t = e) { const r = e.node(-1), i = pr.get(r), a = e.start(-1), o = i.findCell(e.pos - a), s = i.findCell(t.pos - a), l = e.node(0); return o.left <= s.left ? (o.left > 0 && (e = l.resolve(a + i.map[o.top * i.width])), s.right < i.width && (t = l.resolve(a + i.map[i.width * (s.top + 1) - 1]))) : (s.left > 0 && (t = l.resolve(a + i.map[s.top * i.width])), o.right < i.width && (e = l.resolve(a + i.map[i.width * (o.top + 1) - 1]))), new Ql(e, t) } toJSON() { return { type: "cell", anchor: this.$anchorCell.pos, head: this.$headCell.pos } } static fromJSON(e, t) { return new Ql(e.resolve(t.anchor), e.resolve(t.head)) } static create(e, t, r = t) { return new Ql(e.resolve(t), e.resolve(r)) } getBookmark() { return new WMe(this.$anchorCell.pos, this.$headCell.pos) } }; qn.prototype.visible = !1; vt.jsonID("cell", qn); var WMe = class IJ { constructor(e, t) { this.anchor = e, this.head = t } map(e) { return new IJ(e.map(this.anchor), e.map(this.head)) } resolve(e) { const t = e.resolve(this.anchor), r = e.resolve(this.head); return t.parent.type.spec.tableRole == "row" && r.parent.type.spec.tableRole == "row" && t.index() < t.parent.childCount && r.index() < r.parent.childCount && WR(t, r) ? new qn(t, r) : vt.near(r, 1) } }; function KMe(n) { if (!(n.selection instanceof qn)) return null; const e = []; return n.selection.forEachCell((t, r) => { e.push(di.node(r, r + t.nodeSize, { class: "selectedCell" })) }), Xn.create(n.doc, e) } function qMe({ $from: n, $to: e }) { if (n.pos == e.pos || n.pos < n.pos - 6) return !1; let t = n.pos, r = e.pos, i = n.depth; for (; i >= 0 && !(n.after(i + 1) < n.end(i)); i--, t++); for (let a = e.depth; a >= 0 && !(e.before(a + 1) > e.start(a)); a--, r--); return t == r && /row|table/.test(n.node(i).type.spec.tableRole) } function YMe({ $from: n, $to: e }) { let t, r; for (let i = n.depth; i > 0; i--) { const a = n.node(i); if (a.type.spec.tableRole === "cell" || a.type.spec.tableRole === "header_cell") { t = a; break } } for (let i = e.depth; i > 0; i--) { const a = e.node(i); if (a.type.spec.tableRole === "cell" || a.type.spec.tableRole === "header_cell") { r = a; break } } return t !== r && e.parentOffset === 0 } function ZMe(n, e, t) { const r = (e || n).selection, i = (e || n).doc; let a, o; if (r instanceof _t && (o = r.node.type.spec.tableRole)) { if (o == "cell" || o == "header_cell") a = qn.create(i, r.from); else if (o == "row") { const s = i.resolve(r.from + 1); a = qn.rowSelection(s, s) } else if (!t) { const s = pr.get(r.node), l = r.from + 1, c = l + s.map[s.width * s.height - 1]; a = qn.create(i, l + 1, c) } } else r instanceof ht && qMe(r) ? a = ht.create(i, r.from) : r instanceof ht && YMe(r) && (a = ht.create(i, r.$from.start(), r.$from.end())); return a && (e || (e = n.tr)).setSelection(a), e } var XMe = new xn("fix-tables"); function LJ(n, e, t, r) { const i = n.childCount, a = e.childCount; e: for (let o = 0, s = 0; o < a; o++) { const l = e.child(o); for (let c = s, u = Math.min(i, o + 3); c < u; c++)if (n.child(c) == l) { s = c + 1, t += l.nodeSize; continue e } r(l, t), s < i && n.child(s).sameMarkup(l) ? LJ(n.child(s), l, t + 1, r) : l.nodesBetween(0, l.content.size, r, t + 1), t += l.nodeSize } } function RJ(n, e) { let t; const r = (i, a) => { i.type.spec.tableRole == "table" && (t = JMe(n, i, a, t)) }; return e ? e.doc != n.doc && LJ(e.doc, n.doc, 0, r) : n.doc.descendants(r), t } function JMe(n, e, t, r) { const i = pr.get(e); if (!i.problems) return r; r || (r = n.tr); const a = []; for (let l = 0; l < i.height; l++)a.push(0); for (let l = 0; l < i.problems.length; l++) { const c = i.problems[l]; if (c.type == "collision") { const u = e.nodeAt(c.pos); if (!u) continue; const d = u.attrs; for (let f = 0; f < d.rowspan; f++)a[c.row + f] += c.n; r.setNodeMarkup(r.mapping.map(t + 1 + c.pos), null, zh(d, d.colspan - c.n, c.n)) } else if (c.type == "missing") a[c.row] += c.n; else if (c.type == "overlong_rowspan") { const u = e.nodeAt(c.pos); if (!u) continue; r.setNodeMarkup(r.mapping.map(t + 1 + c.pos), null, { ...u.attrs, rowspan: u.attrs.rowspan - c.n }) } else if (c.type == "colwidth mismatch") { const u = e.nodeAt(c.pos); if (!u) continue; r.setNodeMarkup(r.mapping.map(t + 1 + c.pos), null, { ...u.attrs, colwidth: c.colwidth }) } } let o, s; for (let l = 0; l < a.length; l++)a[l] && (o == null && (o = l), s = l); for (let l = 0, c = t + 1; l < i.height; l++) { const u = e.child(l), d = c + u.nodeSize, f = a[l]; if (f > 0) { let h = "cell"; u.firstChild && (h = u.firstChild.type.spec.tableRole); const p = []; for (let g = 0; g < f; g++) { const y = ji(n.schema)[h].createAndFill(); y && p.push(y) } const m = (l == 0 || o == l - 1) && s == l ? c + 1 : d - 1; r.insert(r.mapping.map(m), p) } c = d } return r.setMeta(XMe, { fixTables: !0 }) } function Pl(n) { const e = n.selection, t = Bk(n), r = t.node(-1), i = t.start(-1), a = pr.get(r); return { ...e instanceof qn ? a.rectBetween(e.$anchorCell.pos - i, e.$headCell.pos - i) : a.findCell(t.pos - i), tableStart: i, map: a, table: r } } function NJ(n, { map: e, tableStart: t, table: r }, i) { let a = i > 0 ? -1 : 0; GMe(e, r, i + a) && (a = i == 0 || i == e.width ? null : 0); for (let o = 0; o < e.height; o++) { const s = o * e.width + i; if (i > 0 && i < e.width && e.map[s - 1] == e.map[s]) { const l = e.map[s], c = r.nodeAt(l); n.setNodeMarkup(n.mapping.map(t + l), null, PJ(c.attrs, i - e.colCount(l))), o += c.attrs.rowspan - 1 } else { const l = a == null ? ji(r.type.schema).cell : r.nodeAt(e.map[s + a]).type, c = e.positionAt(o, i, r); n.insert(n.mapping.map(t + c), l.createAndFill()) } } return n } function QMe(n, e) { if (!Ds(n)) return !1; if (e) { const t = Pl(n); e(NJ(n.tr, t, t.left)) } return !0 } function eOe(n, e) { if (!Ds(n)) return !1; if (e) { const t = Pl(n); e(NJ(n.tr, t, t.right)) } return !0 } function tOe(n, { map: e, table: t, tableStart: r }, i) { const a = n.mapping.maps.length; for (let o = 0; o < e.height;) { const s = o * e.width + i, l = e.map[s], c = t.nodeAt(l), u = c.attrs; if (i > 0 && e.map[s - 1] == l || i < e.width - 1 && e.map[s + 1] == l) n.setNodeMarkup(n.mapping.slice(a).map(r + l), null, zh(u, i - e.colCount(l))); else { const d = n.mapping.slice(a).map(r + l); n.delete(d, d + c.nodeSize) } o += u.rowspan } } function nOe(n, e) { if (!Ds(n)) return !1; if (e) { const t = Pl(n), r = n.tr; if (t.left == 0 && t.right == t.map.width) return !1; for (let i = t.right - 1; tOe(r, t, i), i != t.left; i--) { const a = t.tableStart ? r.doc.nodeAt(t.tableStart - 1) : r.doc; if (!a) throw RangeError("No table found"); t.table = a, t.map = pr.get(a) } e(r) } return !0 } function rOe(n, e, t) { var r; const i = ji(e.type.schema).header_cell; for (let a = 0; a < n.width; a++)if (((r = e.nodeAt(n.map[a + t * n.width])) == null ? void 0 : r.type) != i) return !1; return !0 } function BJ(n, { map: e, tableStart: t, table: r }, i) { var a; let o = t; for (let c = 0; c < i; c++)o += r.child(c).nodeSize; const s = []; let l = i > 0 ? -1 : 0; rOe(e, r, i + l) && (l = i == 0 || i == e.height ? null : 0); for (let c = 0, u = e.width * i; c < e.width; c++, u++)if (i > 0 && i < e.height && e.map[u] == e.map[u - e.width]) { const d = e.map[u], f = r.nodeAt(d).attrs; n.setNodeMarkup(t + d, null, { ...f, rowspan: f.rowspan + 1 }), c += f.colspan - 1 } else { const d = l == null ? ji(r.type.schema).cell : (a = r.nodeAt(e.map[u + l * e.width])) == null ? void 0 : a.type, f = d == null ? void 0 : d.createAndFill(); f && s.push(f) } return n.insert(o, ji(r.type.schema).row.create(null, s)), n } function iOe(n, e) { if (!Ds(n)) return !1; if (e) { const t = Pl(n); e(BJ(n.tr, t, t.top)) } return !0 } function aOe(n, e) { if (!Ds(n)) return !1; if (e) { const t = Pl(n); e(BJ(n.tr, t, t.bottom)) } return !0 } function oOe(n, { map: e, table: t, tableStart: r }, i) { let a = 0; for (let c = 0; c < i; c++)a += t.child(c).nodeSize; const o = a + t.child(i).nodeSize, s = n.mapping.maps.length; n.delete(a + r, o + r); const l = new Set; for (let c = 0, u = i * e.width; c < e.width; c++, u++) { const d = e.map[u]; if (!l.has(d)) { if (l.add(d), i > 0 && d == e.map[u - e.width]) { const f = t.nodeAt(d).attrs; n.setNodeMarkup(n.mapping.slice(s).map(d + r), null, { ...f, rowspan: f.rowspan - 1 }), c += f.colspan - 1 } else if (i < e.height && d == e.map[u + e.width]) { const f = t.nodeAt(d), h = f.attrs, p = f.type.create({ ...h, rowspan: f.attrs.rowspan - 1 }, f.content), m = e.positionAt(i + 1, c, t); n.insert(n.mapping.slice(s).map(r + m), p), c += h.colspan - 1 } } } } function sOe(n, e) { if (!Ds(n)) return !1; if (e) { const t = Pl(n), r = n.tr; if (t.top == 0 && t.bottom == t.map.height) return !1; for (let i = t.bottom - 1; oOe(r, t, i), i != t.top; i--) { const a = t.tableStart ? r.doc.nodeAt(t.tableStart - 1) : r.doc; if (!a) throw RangeError("No table found"); t.table = a, t.map = pr.get(t.table) } e(r) } return !0 } function pz(n) { const e = n.content; return e.childCount == 1 && e.child(0).isTextblock && e.child(0).childCount == 0 } function lOe({ width: n, height: e, map: t }, r) { let i = r.top * n + r.left, a = i, o = (r.bottom - 1) * n + r.left, s = i + (r.right - r.left - 1); for (let l = r.top; l < r.bottom; l++) { if (r.left > 0 && t[a] == t[a - 1] || r.right < n && t[s] == t[s + 1]) return !0; a += n, s += n } for (let l = r.left; l < r.right; l++) { if (r.top > 0 && t[i] == t[i - n] || r.bottom < e && t[o] == t[o + n]) return !0; i++, o++ } return !1 } function mz(n, e) { const t = n.selection; if (!(t instanceof qn) || t.$anchorCell.pos == t.$headCell.pos) return !1; const r = Pl(n), { map: i } = r; if (lOe(i, r)) return !1; if (e) { const a = n.tr, o = {}; let s = Be.empty, l, c; for (let u = r.top; u < r.bottom; u++)for (let d = r.left; d < r.right; d++) { const f = i.map[u * i.width + d], h = r.table.nodeAt(f); if (!(o[f] || !h)) if (o[f] = !0, l == null) l = f, c = h; else { pz(h) || (s = s.append(h.content)); const p = a.mapping.map(f + r.tableStart); a.delete(p, p + h.nodeSize) } } if (l == null || c == null) return !0; if (a.setNodeMarkup(l + r.tableStart, null, { ...PJ(c.attrs, c.attrs.colspan, r.right - r.left - c.attrs.colspan), rowspan: r.bottom - r.top }), s.size) { const u = l + 1 + c.content.size, d = pz(c) ? l + 1 : u; a.replaceWith(d + r.tableStart, u + r.tableStart, s) } a.setSelection(new qn(a.doc.resolve(l + r.tableStart))), e(a) } return !0 } function gz(n, e) { const t = ji(n.schema); return cOe(({ node: r }) => t[r.type.spec.tableRole])(n, e) } function cOe(n) { return (e, t) => { var r; const i = e.selection; let a, o; if (i instanceof qn) { if (i.$anchorCell.pos != i.$headCell.pos) return !1; a = i.$anchorCell.nodeAfter, o = i.$anchorCell.pos } else { if (a = VMe(i.$from), !a) return !1; o = (r = Ug(i.$from)) == null ? void 0 : r.pos } if (a == null || o == null || a.attrs.colspan == 1 && a.attrs.rowspan == 1) return !1; if (t) { let s = a.attrs; const l = [], c = s.colwidth; s.rowspan > 1 && (s = { ...s, rowspan: 1 }), s.colspan > 1 && (s = { ...s, colspan: 1 }); const u = Pl(e), d = e.tr; for (let h = 0; h < u.right - u.left; h++)l.push(c ? { ...s, colwidth: c && c[h] ? [c[h]] : null } : s); let f; for (let h = u.top; h < u.bottom; h++) { let p = u.map.positionAt(h, u.left, u.table); h == u.top && (p += a.nodeSize); for (let m = u.left, g = 0; m < u.right; m++, g++)m == u.left && h == u.top || d.insert(f = d.mapping.map(p + u.tableStart, 1), n({ node: a, row: h, col: m }).createAndFill(l[g])) } d.setNodeMarkup(o, n({ node: a, row: u.top, col: u.left }), l[0]), i instanceof qn && d.setSelection(new qn(d.doc.resolve(i.$anchorCell.pos), f ? d.doc.resolve(f) : void 0)), t(d) } return !0 } } function uOe(n, e) { return function (t, r) { if (!Ds(t)) return !1; const i = Bk(t); if (i.nodeAfter.attrs[n] === e) return !1; if (r) { const a = t.tr; t.selection instanceof qn ? t.selection.forEachCell((o, s) => { o.attrs[n] !== e && a.setNodeMarkup(s, null, { ...o.attrs, [n]: e }) }) : a.setNodeMarkup(i.pos, null, { ...i.nodeAfter.attrs, [n]: e }), r(a) } return !0 } } function dOe(n) { return function (e, t) { if (!Ds(e)) return !1; if (t) { const r = ji(e.schema), i = Pl(e), a = e.tr, o = i.map.cellsInRect(n == "column" ? { left: i.left, top: 0, right: i.right, bottom: i.map.height } : n == "row" ? { left: 0, top: i.top, right: i.map.width, bottom: i.bottom } : i), s = o.map(l => i.table.nodeAt(l)); for (let l = 0; l < o.length; l++)s[l].type == r.header_cell && a.setNodeMarkup(i.tableStart + o[l], r.cell, s[l].attrs); if (a.steps.length == 0) for (let l = 0; l < o.length; l++)a.setNodeMarkup(i.tableStart + o[l], r.header_cell, s[l].attrs); t(a) } return !0 } } function vz(n, e, t) { const r = e.map.cellsInRect({ left: 0, top: 0, right: n == "row" ? e.map.width : 1, bottom: n == "column" ? e.map.height : 1 }); for (let i = 0; i < r.length; i++) { const a = e.table.nodeAt(r[i]); if (a && a.type !== t.header_cell) return !1 } return !0 } function n_(n, e) { return e = e || { useDeprecatedLogic: !1 }, e.useDeprecatedLogic ? dOe(n) : function (t, r) { if (!Ds(t)) return !1; if (r) { const i = ji(t.schema), a = Pl(t), o = t.tr, s = vz("row", a, i), l = vz("column", a, i), u = (n === "column" ? s : n === "row" ? l : !1) ? 1 : 0, d = n == "column" ? { left: 0, top: u, right: 1, bottom: a.map.height } : n == "row" ? { left: u, top: 0, right: a.map.width, bottom: 1 } : a, f = n == "column" ? l ? i.cell : i.header_cell : n == "row" ? s ? i.cell : i.header_cell : i.cell; a.map.cellsInRect(d).forEach(h => { const p = h + a.tableStart, m = o.doc.nodeAt(p); m && o.setNodeMarkup(p, f, m.attrs) }), r(o) } return !0 } } n_("row", { useDeprecatedLogic: !0 }); n_("column", { useDeprecatedLogic: !0 }); var fOe = n_("cell", { useDeprecatedLogic: !0 }); function hOe(n, e) { if (e < 0) { const t = n.nodeBefore; if (t) return n.pos - t.nodeSize; for (let r = n.index(-1) - 1, i = n.before(); r >= 0; r--) { const a = n.node(-1).child(r), o = a.lastChild; if (o) return i - 1 - o.nodeSize; i -= a.nodeSize } } else { if (n.index() < n.parent.childCount - 1) return n.pos + n.nodeAfter.nodeSize; const t = n.node(-1); for (let r = n.indexAfter(-1), i = n.after(); r < t.childCount; r++) { const a = t.child(r); if (a.childCount) return i + 1; i += a.nodeSize } } return null } function yz(n) { return function (e, t) { if (!Ds(e)) return !1; const r = hOe(Bk(e), n); if (r == null) return !1; if (t) { const i = e.doc.resolve(r); t(e.tr.setSelection(ht.between(i, UMe(i))).scrollIntoView()) } return !0 } } function pOe(n, e) { const t = n.selection.$anchor; for (let r = t.depth; r > 0; r--)if (t.node(r).type.spec.tableRole == "table") return e && e(n.tr.delete(t.before(r), t.after(r)).scrollIntoView()), !0; return !1 } function rw(n, e) { const t = n.selection; if (!(t instanceof qn)) return !1; if (e) { const r = n.tr, i = ji(n.schema).cell.createAndFill().content; t.forEachCell((a, o) => { a.content.eq(i) || r.replace(r.mapping.map(o + 1), r.mapping.map(o + a.nodeSize - 1), new Qe(i, 0, 0)) }), r.docChanged && e(r) } return !0 } function mOe(n) { if (!n.size) return null; let { content: e, openStart: t, openEnd: r } = n; for (; e.childCount == 1 && (t > 0 && r > 0 || e.child(0).type.spec.tableRole == "table");)t--, r--, e = e.child(0).content; const i = e.child(0), a = i.type.spec.tableRole, o = i.type.schema, s = []; if (a == "row") for (let l = 0; l < e.childCount; l++) { let c = e.child(l).content; const u = l ? 0 : Math.max(0, t - 1), d = l < e.childCount - 1 ? 0 : Math.max(0, r - 1); (u || d) && (c = eP(ji(o).row, new Qe(c, u, d)).content), s.push(c) } else if (a == "cell" || a == "header_cell") s.push(t || r ? eP(ji(o).row, new Qe(e, t, r)).content : e); else return null; return gOe(o, s) } function gOe(n, e) { const t = []; for (let i = 0; i < e.length; i++) { const a = e[i]; for (let o = a.childCount - 1; o >= 0; o--) { const { rowspan: s, colspan: l } = a.child(o).attrs; for (let c = i; c < i + s; c++)t[c] = (t[c] || 0) + l } } let r = 0; for (let i = 0; i < t.length; i++)r = Math.max(r, t[i]); for (let i = 0; i < t.length; i++)if (i >= e.length && e.push(Be.empty), t[i] < r) { const a = ji(n).cell.createAndFill(), o = []; for (let s = t[i]; s < r; s++)o.push(a); e[i] = e[i].append(Be.from(o)) } return { height: e.length, width: r, rows: e } } function eP(n, e) { const t = n.createAndFill(); return new TR(t).replace(0, t.content.size, e).doc } function vOe({ width: n, height: e, rows: t }, r, i) { if (n != r) { const a = [], o = []; for (let s = 0; s < t.length; s++) { const l = t[s], c = []; for (let u = a[s] || 0, d = 0; u < r; d++) { let f = l.child(d % l.childCount); u + f.attrs.colspan > r && (f = f.type.createChecked(zh(f.attrs, f.attrs.colspan, u + f.attrs.colspan - r), f.content)), c.push(f), u += f.attrs.colspan; for (let h = 1; h < f.attrs.rowspan; h++)a[s + h] = (a[s + h] || 0) + f.attrs.colspan } o.push(Be.from(c)) } t = o, n = r } if (e != i) { const a = []; for (let o = 0, s = 0; o < i; o++, s++) { const l = [], c = t[s % e]; for (let u = 0; u < c.childCount; u++) { let d = c.child(u); o + d.attrs.rowspan > i && (d = d.type.create({ ...d.attrs, rowspan: Math.max(1, i - d.attrs.rowspan) }, d.content)), l.push(d) } a.push(Be.from(l)) } t = a, e = i } return { width: n, height: e, rows: t } } function yOe(n, e, t, r, i, a, o) { const s = n.doc.type.schema, l = ji(s); let c, u; if (i > e.width) for (let d = 0, f = 0; d < e.height; d++) { const h = t.child(d); f += h.nodeSize; const p = []; let m; h.lastChild == null || h.lastChild.type == l.cell ? m = c || (c = l.cell.createAndFill()) : m = u || (u = l.header_cell.createAndFill()); for (let g = e.width; g < i; g++)p.push(m); n.insert(n.mapping.slice(o).map(f - 1 + r), p) } if (a > e.height) { const d = []; for (let p = 0, m = (e.height - 1) * e.width; p < Math.max(e.width, i); p++) { const g = p >= e.width ? !1 : t.nodeAt(e.map[m + p]).type == l.header_cell; d.push(g ? u || (u = l.header_cell.createAndFill()) : c || (c = l.cell.createAndFill())) } const f = l.row.create(null, Be.from(d)), h = []; for (let p = e.height; p < a; p++)h.push(f); n.insert(n.mapping.slice(o).map(r + t.nodeSize - 2), h) } return !!(c || u) } function _z(n, e, t, r, i, a, o, s) { if (o == 0 || o == e.height) return !1; let l = !1; for (let c = i; c < a; c++) { const u = o * e.width + c, d = e.map[u]; if (e.map[u - e.width] == d) { l = !0; const f = t.nodeAt(d), { top: h, left: p } = e.findCell(d); n.setNodeMarkup(n.mapping.slice(s).map(d + r), null, { ...f.attrs, rowspan: o - h }), n.insert(n.mapping.slice(s).map(e.positionAt(o, p, t)), f.type.createAndFill({ ...f.attrs, rowspan: h + f.attrs.rowspan - o })), c += f.attrs.colspan - 1 } } return l } function bz(n, e, t, r, i, a, o, s) { if (o == 0 || o == e.width) return !1; let l = !1; for (let c = i; c < a; c++) { const u = c * e.width + o, d = e.map[u]; if (e.map[u - 1] == d) { l = !0; const f = t.nodeAt(d), h = e.colCount(d), p = n.mapping.slice(s).map(d + r); n.setNodeMarkup(p, null, zh(f.attrs, o - h, f.attrs.colspan - (o - h))), n.insert(p + f.nodeSize, f.type.createAndFill(zh(f.attrs, 0, o - h))), c += f.attrs.rowspan - 1 } } return l } function wz(n, e, t, r, i) { let a = t ? n.doc.nodeAt(t - 1) : n.doc; if (!a) throw new Error("No table found"); let o = pr.get(a); const { top: s, left: l } = r, c = l + i.width, u = s + i.height, d = n.tr; let f = 0; function h() { if (a = t ? d.doc.nodeAt(t - 1) : d.doc, !a) throw new Error("No table found"); o = pr.get(a), f = d.mapping.maps.length } yOe(d, o, a, t, c, u, f) && h(), _z(d, o, a, t, l, c, s, f) && h(), _z(d, o, a, t, l, c, u, f) && h(), bz(d, o, a, t, s, u, l, f) && h(), bz(d, o, a, t, s, u, c, f) && h(); for (let p = s; p < u; p++) { const m = o.positionAt(p, l, a), g = o.positionAt(p, c, a); d.replace(d.mapping.slice(f).map(m + t), d.mapping.slice(f).map(g + t), new Qe(i.rows[p - s], 0, 0)) } h(), d.setSelection(new qn(d.doc.resolve(t + o.positionAt(s, l, a)), d.doc.resolve(t + o.positionAt(u - 1, c - 1, a)))), e(d) } var _Oe = IR({ ArrowLeft: iw("horiz", -1), ArrowRight: iw("horiz", 1), ArrowUp: iw("vert", -1), ArrowDown: iw("vert", 1), "Shift-ArrowLeft": aw("horiz", -1), "Shift-ArrowRight": aw("horiz", 1), "Shift-ArrowUp": aw("vert", -1), "Shift-ArrowDown": aw("vert", 1), Backspace: rw, "Mod-Backspace": rw, Delete: rw, "Mod-Delete": rw }); function Fx(n, e, t) { return t.eq(n.selection) ? !1 : (e && e(n.tr.setSelection(t).scrollIntoView()), !0) } function iw(n, e) { return (t, r, i) => { if (!i) return !1; const a = t.selection; if (a instanceof qn) return Fx(t, r, vt.near(a.$headCell, e)); if (n != "horiz" && !a.empty) return !1; const o = $J(i, n, e); if (o == null) return !1; if (n == "horiz") return Fx(t, r, vt.near(t.doc.resolve(a.head + e), e)); { const s = t.doc.resolve(o), l = jJ(s, n, e); let c; return l ? c = vt.near(l, 1) : e < 0 ? c = vt.near(t.doc.resolve(s.before(-1)), -1) : c = vt.near(t.doc.resolve(s.after(-1)), 1), Fx(t, r, c) } } } function aw(n, e) { return (t, r, i) => { if (!i) return !1; const a = t.selection; let o; if (a instanceof qn) o = a; else { const l = $J(i, n, e); if (l == null) return !1; o = new qn(t.doc.resolve(l)) } const s = jJ(o.$headCell, n, e); return s ? Fx(t, r, new qn(o.$anchorCell, s)) : !1 } } function bOe(n, e) { const t = n.state.doc, r = Ug(t.resolve(e)); return r ? (n.dispatch(n.state.tr.setSelection(new qn(r))), !0) : !1 } function wOe(n, e, t) { if (!Ds(n.state)) return !1; let r = mOe(t); const i = n.state.selection; if (i instanceof qn) { r || (r = { width: 1, height: 1, rows: [Be.from(eP(ji(n.state.schema).cell, t))] }); const a = i.$anchorCell.node(-1), o = i.$anchorCell.start(-1), s = pr.get(a).rectBetween(i.$anchorCell.pos - o, i.$headCell.pos - o); return r = vOe(r, s.right - s.left, s.bottom - s.top), wz(n.state, n.dispatch, o, s, r), !0 } else if (r) { const a = Bk(n.state), o = a.start(-1); return wz(n.state, n.dispatch, o, pr.get(a.node(-1)).findCell(a.pos - o), r), !0 } else return !1 } function xOe(n, e) { var t; if (e.ctrlKey || e.metaKey) return; const r = xz(n, e.target); let i; if (e.shiftKey && n.state.selection instanceof qn) a(n.state.selection.$anchorCell, e), e.preventDefault(); else if (e.shiftKey && r && (i = Ug(n.state.selection.$anchor)) != null && ((t = $E(n, e)) == null ? void 0 : t.pos) != i.pos) a(i, e), e.preventDefault(); else if (!r) return; function a(l, c) { let u = $E(n, c); const d = Pu.getState(n.state) == null; if (!u || !WR(l, u)) if (d) u = l; else return; const f = new qn(l, u); if (d || !n.state.selection.eq(f)) { const h = n.state.tr.setSelection(f); d && h.setMeta(Pu, l.pos), n.dispatch(h) } } function o() { n.root.removeEventListener("mouseup", o), n.root.removeEventListener("dragstart", o), n.root.removeEventListener("mousemove", s), Pu.getState(n.state) != null && n.dispatch(n.state.tr.setMeta(Pu, -1)) } function s(l) { const c = l, u = Pu.getState(n.state); let d; if (u != null) d = n.state.doc.resolve(u); else if (xz(n, c.target) != r && (d = $E(n, e), !d)) return o(); d && a(d, c) } n.root.addEventListener("mouseup", o), n.root.addEventListener("dragstart", o), n.root.addEventListener("mousemove", s) } function $J(n, e, t) { if (!(n.state.selection instanceof ht)) return null; const { $head: r } = n.state.selection; for (let i = r.depth - 1; i >= 0; i--) { const a = r.node(i); if ((t < 0 ? r.index(i) : r.indexAfter(i)) != (t < 0 ? 0 : a.childCount)) return null; if (a.type.spec.tableRole == "cell" || a.type.spec.tableRole == "header_cell") { const s = r.before(i), l = e == "vert" ? t > 0 ? "down" : "up" : t > 0 ? "right" : "left"; return n.endOfTextblock(l) ? s : null } } return null } function xz(n, e) { for (; e && e != n.dom; e = e.parentNode)if (e.nodeName == "TD" || e.nodeName == "TH") return e; return null } function $E(n, e) { const t = n.posAtCoords({ left: e.clientX, top: e.clientY }); return t && t ? Ug(n.state.doc.resolve(t.pos)) : null } var SOe = class { constructor(e, t) { this.node = e, this.cellMinWidth = t, this.dom = document.createElement("div"), this.dom.className = "tableWrapper", this.table = this.dom.appendChild(document.createElement("table")), this.colgroup = this.table.appendChild(document.createElement("colgroup")), tP(e, this.colgroup, this.table, t), this.contentDOM = this.table.appendChild(document.createElement("tbody")) } update(e) { return e.type != this.node.type ? !1 : (this.node = e, tP(e, this.colgroup, this.table, this.cellMinWidth), !0) } ignoreMutation(e) { return e.type == "attributes" && (e.target == this.table || this.colgroup.contains(e.target)) } }; function tP(n, e, t, r, i, a) { var o; let s = 0, l = !0, c = e.firstChild; const u = n.firstChild; if (u) { for (let d = 0, f = 0; d < u.childCount; d++) { const { colspan: h, colwidth: p } = u.child(d).attrs; for (let m = 0; m < h; m++, f++) { const g = i == f ? a : p && p[m], y = g ? g + "px" : ""; s += g || r, g || (l = !1), c ? (c.style.width != y && (c.style.width = y), c = c.nextSibling) : e.appendChild(document.createElement("col")).style.width = y } } for (; c;) { const d = c.nextSibling; (o = c.parentNode) == null || o.removeChild(c), c = d } l ? (t.style.width = s + "px", t.style.minWidth = "") : (t.style.width = "", t.style.minWidth = s + "px") } } var To = new xn("tableColumnResizing"); function TOe({ handleWidth: n = 5, cellMinWidth: e = 25, View: t = SOe, lastColumnResizable: r = !0 } = {}) { const i = new wn({ key: To, state: { init(a, o) { var s, l; const c = (l = (s = i.spec) == null ? void 0 : s.props) == null ? void 0 : l.nodeViews, u = ji(o.schema).table.name; return t && c && (c[u] = (d, f) => new t(d, e, f)), new kOe(-1, !1) }, apply(a, o) { return o.apply(a) } }, props: { attributes: a => { const o = To.getState(a); return o && o.activeHandle > -1 ? { class: "resize-cursor" } : {} }, handleDOMEvents: { mousemove: (a, o) => { COe(a, o, n, e, r) }, mouseleave: a => { AOe(a) }, mousedown: (a, o) => { EOe(a, o, e) } }, decorations: a => { const o = To.getState(a); if (o && o.activeHandle > -1) return IOe(a, o.activeHandle) }, nodeViews: {} } }); return i } var kOe = class zx { constructor(e, t) { this.activeHandle = e, this.dragging = t } apply(e) { const t = this, r = e.getMeta(To); if (r && r.setHandle != null) return new zx(r.setHandle, !1); if (r && r.setDragging !== void 0) return new zx(t.activeHandle, r.setDragging); if (t.activeHandle > -1 && e.docChanged) { let i = e.mapping.map(t.activeHandle, -1); return Qj(e.doc.resolve(i)) || (i = -1), new zx(i, t.dragging) } return t } }; function COe(n, e, t, r, i) { const a = To.getState(n.state); if (a && !a.dragging) { const o = OOe(e.target); let s = -1; if (o) { const { left: l, right: c } = o.getBoundingClientRect(); e.clientX - l <= t ? s = Sz(n, e, "left", t) : c - e.clientX <= t && (s = Sz(n, e, "right", t)) } if (s != a.activeHandle) { if (!i && s !== -1) { const l = n.state.doc.resolve(s), c = l.node(-1), u = pr.get(c), d = l.start(-1); if (u.colCount(l.pos - d) + l.nodeAfter.attrs.colspan - 1 == u.width - 1) return } FJ(n, s) } } } function AOe(n) { const e = To.getState(n.state); e && e.activeHandle > -1 && !e.dragging && FJ(n, -1) } function EOe(n, e, t) { var r; const i = (r = n.dom.ownerDocument.defaultView) != null ? r : window, a = To.getState(n.state); if (!a || a.activeHandle == -1 || a.dragging) return !1; const o = n.state.doc.nodeAt(a.activeHandle), s = MOe(n, a.activeHandle, o.attrs); n.dispatch(n.state.tr.setMeta(To, { setDragging: { startX: e.clientX, startWidth: s } })); function l(u) { i.removeEventListener("mouseup", l), i.removeEventListener("mousemove", c); const d = To.getState(n.state); d != null && d.dragging && (DOe(n, d.activeHandle, Tz(d.dragging, u, t)), n.dispatch(n.state.tr.setMeta(To, { setDragging: null }))) } function c(u) { if (!u.which) return l(u); const d = To.getState(n.state); if (d && d.dragging) { const f = Tz(d.dragging, u, t); jOe(n, d.activeHandle, f, t) } } return i.addEventListener("mouseup", l), i.addEventListener("mousemove", c), e.preventDefault(), !0 } function MOe(n, e, { colspan: t, colwidth: r }) { const i = r && r[r.length - 1]; if (i) return i; const a = n.domAtPos(e); let s = a.node.childNodes[a.offset].offsetWidth, l = t; if (r) for (let c = 0; c < t; c++)r[c] && (s -= r[c], l--); return s / l } function OOe(n) { for (; n && n.nodeName != "TD" && n.nodeName != "TH";)n = n.classList && n.classList.contains("ProseMirror") ? null : n.parentNode; return n } function Sz(n, e, t, r) { const i = t == "right" ? -r : r, a = n.posAtCoords({ left: e.clientX + i, top: e.clientY }); if (!a) return -1; const { pos: o } = a, s = Ug(n.state.doc.resolve(o)); if (!s) return -1; if (t == "right") return s.pos; const l = pr.get(s.node(-1)), c = s.start(-1), u = l.map.indexOf(s.pos - c); return u % l.width == 0 ? -1 : c + l.map[u - 1] } function Tz(n, e, t) { const r = e.clientX - n.startX; return Math.max(t, n.startWidth + r) } function FJ(n, e) { n.dispatch(n.state.tr.setMeta(To, { setHandle: e })) } function DOe(n, e, t) { const r = n.state.doc.resolve(e), i = r.node(-1), a = pr.get(i), o = r.start(-1), s = a.colCount(r.pos - o) + r.nodeAfter.attrs.colspan - 1, l = n.state.tr; for (let c = 0; c < a.height; c++) { const u = c * a.width + s; if (c && a.map[u] == a.map[u - a.width]) continue; const d = a.map[u], f = i.nodeAt(d).attrs, h = f.colspan == 1 ? 0 : s - a.colCount(d); if (f.colwidth && f.colwidth[h] == t) continue; const p = f.colwidth ? f.colwidth.slice() : POe(f.colspan); p[h] = t, l.setNodeMarkup(o + d, null, { ...f, colwidth: p }) } l.docChanged && n.dispatch(l) } function jOe(n, e, t, r) { const i = n.state.doc.resolve(e), a = i.node(-1), o = i.start(-1), s = pr.get(a).colCount(i.pos - o) + i.nodeAfter.attrs.colspan - 1; let l = n.domAtPos(i.start(-1)).node; for (; l && l.nodeName != "TABLE";)l = l.parentNode; l && tP(a, l.firstChild, l, r, s, t) } function POe(n) { return Array(n).fill(0) } function IOe(n, e) { const t = [], r = n.doc.resolve(e), i = r.node(-1); if (!i) return Xn.empty; const a = pr.get(i), o = r.start(-1), s = a.colCount(r.pos - o) + r.nodeAfter.attrs.colspan - 1; for (let l = 0; l < a.height; l++) { const c = s + l * a.width; if ((s == a.width - 1 || a.map[c] != a.map[c + 1]) && (l == 0 || a.map[c] != a.map[c - a.width])) { const u = a.map[c], d = o + u + i.nodeAt(u).nodeSize - 1, f = document.createElement("div"); f.className = "column-resize-handle", t.push(di.widget(d, f)) } } return Xn.create(n.doc, t) } function LOe({ allowTableNodeSelection: n = !1 } = {}) { return new wn({ key: Pu, state: { init() { return null }, apply(e, t) { const r = e.getMeta(Pu); if (r != null) return r == -1 ? null : r; if (t == null || !e.docChanged) return t; const { deleted: i, pos: a } = e.mapping.mapResult(t); return i ? null : a } }, props: { decorations: KMe, handleDOMEvents: { mousedown: xOe }, createSelectionBetween(e) { return Pu.getState(e.state) != null ? e.state.selection : null }, handleTripleClick: bOe, handleKeyDown: _Oe, handlePaste: wOe }, appendTransaction(e, t, r) { return ZMe(r, RJ(r, t), n) } }) } function kz(n, e, t, r, i, a) { let o = 0, s = !0, l = e.firstChild; const c = n.firstChild; for (let u = 0, d = 0; u < c.childCount; u += 1) { const { colspan: f, colwidth: h } = c.child(u).attrs; for (let p = 0; p < f; p += 1, d += 1) { const m = i === d ? a : h && h[p], g = m ? `${m}px` : ""; o += m || r, m || (s = !1), l ? (l.style.width !== g && (l.style.width = g), l = l.nextSibling) : e.appendChild(document.createElement("col")).style.width = g } } for (; l;) { const u = l.nextSibling; l.parentNode.removeChild(l), l = u } s ? (t.style.width = `${o}px`, t.style.minWidth = "") : (t.style.width = "", t.style.minWidth = `${o}px`) } class ROe { constructor(e, t) { this.node = e, this.cellMinWidth = t, this.dom = document.createElement("div"), this.dom.className = "tableWrapper", this.table = this.dom.appendChild(document.createElement("table")), this.colgroup = this.table.appendChild(document.createElement("colgroup")), kz(e, this.colgroup, this.table, t), this.contentDOM = this.table.appendChild(document.createElement("tbody")) } update(e) { return e.type !== this.node.type ? !1 : (this.node = e, kz(e, this.colgroup, this.table, this.cellMinWidth), !0) } ignoreMutation(e) { return e.type === "attributes" && (e.target === this.table || this.colgroup.contains(e.target)) } } function NOe(n, e, t, r) { let i = 0, a = !0; const o = [], s = n.firstChild; if (!s) return {}; for (let d = 0, f = 0; d < s.childCount; d += 1) { const { colspan: h, colwidth: p } = s.child(d).attrs; for (let m = 0; m < h; m += 1, f += 1) { const g = t === f ? r : p && p[m], y = g ? `${g}px` : ""; i += g || e, g || (a = !1), o.push(["col", y ? { style: `width: ${y}` } : {}]) } } const l = a ? `${i}px` : "", c = a ? "" : `${i}px`; return { colgroup: ["colgroup", {}, ...o], tableWidth: l, tableMinWidth: c } } function Cz(n, e) { return e ? n.createChecked(null, e) : n.createAndFill() } function BOe(n) { if (n.cached.tableNodeTypes) return n.cached.tableNodeTypes; const e = {}; return Object.keys(n.nodes).forEach(t => { const r = n.nodes[t]; r.spec.tableRole && (e[r.spec.tableRole] = r) }), n.cached.tableNodeTypes = e, e } function $Oe(n, e, t, r, i) { const a = BOe(n), o = [], s = []; for (let c = 0; c < t; c += 1) { const u = Cz(a.cell, i); if (u && s.push(u), r) { const d = Cz(a.header_cell, i); d && o.push(d) } } const l = []; for (let c = 0; c < e; c += 1)l.push(a.row.createChecked(null, r && c === 0 ? o : s)); return a.table.createChecked(null, l) } function FOe(n) { return n instanceof qn } const ow = ({ editor: n }) => { const { selection: e } = n.state; if (!FOe(e)) return !1; let t = 0; const r = pJ(e.ranges[0].$from, a => a.type.name === "table"); return r == null || r.node.descendants(a => { if (a.type.name === "table") return !1;["tableCell", "tableHeader"].includes(a.type.name) && (t += 1) }), t === e.ranges.length ? (n.commands.deleteTable(), !0) : !1 }, zOe = jl.create({ name: "table", addOptions() { return { HTMLAttributes: {}, resizable: !1, handleWidth: 5, cellMinWidth: 25, View: ROe, lastColumnResizable: !0, allowTableNodeSelection: !1 } }, content: "tableRow+", tableRole: "table", isolating: !0, group: "block", parseHTML() { return [{ tag: "table" }] }, renderHTML({ node: n, HTMLAttributes: e }) { const { colgroup: t, tableWidth: r, tableMinWidth: i } = NOe(n, this.options.cellMinWidth); return ["table", Zr(this.options.HTMLAttributes, e, { style: r ? `width: ${r}` : `min-width: ${i}` }), t, ["tbody", 0]] }, addCommands() { return { insertTable: ({ rows: n = 3, cols: e = 3, withHeaderRow: t = !0 } = {}) => ({ tr: r, dispatch: i, editor: a }) => { const o = $Oe(a.schema, n, e, t); if (i) { const s = r.selection.from + 1; r.replaceSelectionWith(o).scrollIntoView().setSelection(ht.near(r.doc.resolve(s))) } return !0 }, addColumnBefore: () => ({ state: n, dispatch: e }) => QMe(n, e), addColumnAfter: () => ({ state: n, dispatch: e }) => eOe(n, e), deleteColumn: () => ({ state: n, dispatch: e }) => nOe(n, e), addRowBefore: () => ({ state: n, dispatch: e }) => iOe(n, e), addRowAfter: () => ({ state: n, dispatch: e }) => aOe(n, e), deleteRow: () => ({ state: n, dispatch: e }) => sOe(n, e), deleteTable: () => ({ state: n, dispatch: e }) => pOe(n, e), mergeCells: () => ({ state: n, dispatch: e }) => mz(n, e), splitCell: () => ({ state: n, dispatch: e }) => gz(n, e), toggleHeaderColumn: () => ({ state: n, dispatch: e }) => n_("column")(n, e), toggleHeaderRow: () => ({ state: n, dispatch: e }) => n_("row")(n, e), toggleHeaderCell: () => ({ state: n, dispatch: e }) => fOe(n, e), mergeOrSplit: () => ({ state: n, dispatch: e }) => mz(n, e) ? !0 : gz(n, e), setCellAttribute: (n, e) => ({ state: t, dispatch: r }) => uOe(n, e)(t, r), goToNextCell: () => ({ state: n, dispatch: e }) => yz(1)(n, e), goToPreviousCell: () => ({ state: n, dispatch: e }) => yz(-1)(n, e), fixTables: () => ({ state: n, dispatch: e }) => (e && RJ(n), !0), setCellSelection: n => ({ tr: e, dispatch: t }) => { if (t) { const r = qn.create(e.doc, n.anchorCell, n.headCell); e.setSelection(r) } return !0 } } }, addKeyboardShortcuts() { return { Tab: () => this.editor.commands.goToNextCell() ? !0 : this.editor.can().addRowAfter() ? this.editor.chain().addRowAfter().goToNextCell().run() : !1, "Shift-Tab": () => this.editor.commands.goToPreviousCell(), Backspace: ow, "Mod-Backspace": ow, Delete: ow, "Mod-Delete": ow } }, addProseMirrorPlugins() { return [...this.options.resizable && this.editor.isEditable ? [TOe({ handleWidth: this.options.handleWidth, cellMinWidth: this.options.cellMinWidth, View: this.options.View, lastColumnResizable: this.options.lastColumnResizable })] : [], LOe({ allowTableNodeSelection: this.options.allowTableNodeSelection })] }, extendNodeSchema(n) { const e = { name: n.name, options: n.options, storage: n.storage }; return { tableRole: cn(dt(n, "tableRole", e)) } } }), VOe = jl.create({ name: "tableCell", addOptions() { return { HTMLAttributes: {} } }, content: "block+", addAttributes() { return { colspan: { default: 1 }, rowspan: { default: 1 }, colwidth: { default: null, parseHTML: n => { const e = n.getAttribute("colwidth"); return e ? [parseInt(e, 10)] : null } } } }, tableRole: "cell", isolating: !0, parseHTML() { return [{ tag: "td" }] }, renderHTML({ HTMLAttributes: n }) { return ["td", Zr(this.options.HTMLAttributes, n), 0] } }), HOe = jl.create({ name: "tableHeader", addOptions() { return { HTMLAttributes: {} } }, content: "block+", addAttributes() { return { colspan: { default: 1 }, rowspan: { default: 1 }, colwidth: { default: null, parseHTML: n => { const e = n.getAttribute("colwidth"); return e ? [parseInt(e, 10)] : null } } } }, tableRole: "header_cell", isolating: !0, parseHTML() { return [{ tag: "th" }] }, renderHTML({ HTMLAttributes: n }) { return ["th", Zr(this.options.HTMLAttributes, n), 0] } }), UOe = jl.create({ name: "tableRow", addOptions() { return { HTMLAttributes: {} } }, content: "(tableCell | tableHeader)*", tableRole: "row", parseHTML() { return [{ tag: "tr" }] }, renderHTML({ HTMLAttributes: n }) { return ["tr", Zr(this.options.HTMLAttributes, n), 0] } }), GOe = Bi.create({ name: "textAlign", addOptions() { return { types: [], alignments: ["left", "center", "right", "justify"], defaultAlignment: "left" } }, addGlobalAttributes() { return [{ types: this.options.types, attributes: { textAlign: { default: this.options.defaultAlignment, parseHTML: n => { const e = n.style.textAlign || this.options.defaultAlignment; return this.options.alignments.includes(e) ? e : this.options.defaultAlignment }, renderHTML: n => n.textAlign === this.options.defaultAlignment ? {} : { style: `text-align: ${n.textAlign}` } } } }] }, addCommands() { return { setTextAlign: n => ({ commands: e }) => this.options.alignments.includes(n) ? this.options.types.map(t => e.updateAttributes(t, { textAlign: n })).every(t => t) : !1, unsetTextAlign: () => ({ commands: n }) => this.options.types.map(e => n.resetAttributes(e, "textAlign")).every(e => e) } }, addKeyboardShortcuts() { return { "Mod-Shift-l": () => this.editor.commands.setTextAlign("left"), "Mod-Shift-e": () => this.editor.commands.setTextAlign("center"), "Mod-Shift-r": () => this.editor.commands.setTextAlign("right"), "Mod-Shift-j": () => this.editor.commands.setTextAlign("justify") } } }), WOe = jk.create({ name: "textStyle", priority: 101, addOptions() { return { HTMLAttributes: {} } }, parseHTML() { return [{ tag: "span", getAttrs: n => n.hasAttribute("style") ? {} : !1 }] }, renderHTML({ HTMLAttributes: n }) { return ["span", Zr(this.options.HTMLAttributes, n), 0] }, addCommands() { return { removeEmptyTextStyle: () => ({ state: n, commands: e }) => { const t = zR(n, this.type); return Object.entries(t).some(([, i]) => !!i) ? !0 : e.unsetMark(this.name) } } } }), KOe = n => yr({ find: /--$/, replace: n ?? "" }), qOe = n => yr({ find: /\.\.\.$/, replace: n ?? "" }), YOe = n => yr({ find: /(?:^|[\s{[(<'"\u2018\u201C])(")$/, replace: n ?? "" }), ZOe = n => yr({ find: /"$/, replace: n ?? "" }), XOe = n => yr({ find: /(?:^|[\s{[(<'"\u2018\u201C])(')$/, replace: n ?? "" }), JOe = n => yr({ find: /'$/, replace: n ?? "" }), QOe = n => yr({ find: /<-$/, replace: n ?? "" }), eDe = n => yr({ find: /->$/, replace: n ?? "" }), tDe = n => yr({ find: /\(c\)$/, replace: n ?? "" }), nDe = n => yr({ find: /\(tm\)$/, replace: n ?? "" }), rDe = n => yr({ find: /\(sm\)$/, replace: n ?? "" }), iDe = n => yr({ find: /\(r\)$/, replace: n ?? "" }), aDe = n => yr({ find: /(?:^|\s)(1\/2)\s$/, replace: n ?? "" }), oDe = n => yr({ find: /\+\/-$/, replace: n ?? "" }), sDe = n => yr({ find: /!=$/, replace: n ?? "" }), lDe = n => yr({ find: /<<$/, replace: n ?? "" }), cDe = n => yr({ find: />>$/, replace: n ?? "" }), uDe = n => yr({ find: /\d+\s?([*x])\s?\d+$/, replace: n ?? "" }), dDe = n => yr({ find: /\^2$/, replace: n ?? "" }), fDe = n => yr({ find: /\^3$/, replace: n ?? "" }), hDe = n => yr({ find: /(?:^|\s)(1\/4)\s$/, replace: n ?? "" }), pDe = n => yr({ find: /(?:^|\s)(3\/4)\s$/, replace: n ?? "" }), mDe = Bi.create({ name: "typography", addOptions() { return { closeDoubleQuote: "", closeSingleQuote: "", copyright: "", ellipsis: "", emDash: "", laquo: "", leftArrow: "", multiplication: "", notEqual: "", oneHalf: "", oneQuarter: "", openDoubleQuote: "", openSingleQuote: "", plusMinus: "", raquo: "", registeredTrademark: "", rightArrow: "", servicemark: "", superscriptThree: "", superscriptTwo: "", threeQuarters: "", trademark: "" } }, addInputRules() { const n = []; return this.options.emDash !== !1 && n.push(KOe(this.options.emDash)), this.options.ellipsis !== !1 && n.push(qOe(this.options.ellipsis)), this.options.openDoubleQuote !== !1 && n.push(YOe(this.options.openDoubleQuote)), this.options.closeDoubleQuote !== !1 && n.push(ZOe(this.options.closeDoubleQuote)), this.options.openSingleQuote !== !1 && n.push(XOe(this.options.openSingleQuote)), this.options.closeSingleQuote !== !1 && n.push(JOe(this.options.closeSingleQuote)), this.options.leftArrow !== !1 && n.push(QOe(this.options.leftArrow)), this.options.rightArrow !== !1 && n.push(eDe(this.options.rightArrow)), this.options.copyright !== !1 && n.push(tDe(this.options.copyright)), this.options.trademark !== !1 && n.push(nDe(this.options.trademark)), this.options.servicemark !== !1 && n.push(rDe(this.options.servicemark)), this.options.registeredTrademark !== !1 && n.push(iDe(this.options.registeredTrademark)), this.options.oneHalf !== !1 && n.push(aDe(this.options.oneHalf)), this.options.plusMinus !== !1 && n.push(oDe(this.options.plusMinus)), this.options.notEqual !== !1 && n.push(sDe(this.options.notEqual)), this.options.laquo !== !1 && n.push(lDe(this.options.laquo)), this.options.raquo !== !1 && n.push(cDe(this.options.raquo)), this.options.multiplication !== !1 && n.push(uDe(this.options.multiplication)), this.options.superscriptTwo !== !1 && n.push(dDe(this.options.superscriptTwo)), this.options.superscriptThree !== !1 && n.push(fDe(this.options.superscriptThree)), this.options.oneQuarter !== !1 && n.push(hDe(this.options.oneQuarter)), this.options.threeQuarters !== !1 && n.push(pDe(this.options.threeQuarters)), n } }); function zJ(n) { const { state: e, transaction: t } = n; let { selection: r } = t, { doc: i } = t, { storedMarks: a } = t; return { ...e, apply: e.apply.bind(e), applyTransaction: e.applyTransaction.bind(e), plugins: e.plugins, schema: e.schema, reconfigure: e.reconfigure.bind(e), toJSON: e.toJSON.bind(e), get storedMarks() { return a }, get selection() { return r }, get doc() { return i }, get tr() { return r = t.selection, i = t.doc, a = t.storedMarks, t } } } class gDe { constructor(e) { this.editor = e.editor, this.rawCommands = this.editor.extensionManager.commands, this.customState = e.state } get hasCustomState() { return !!this.customState } get state() { return this.customState || this.editor.state } get commands() { const { rawCommands: e, editor: t, state: r } = this, { view: i } = t, { tr: a } = r, o = this.buildProps(a); return Object.fromEntries(Object.entries(e).map(([s, l]) => [s, (...u) => { const d = l(...u)(o); return !a.getMeta("preventDispatch") && !this.hasCustomState && i.dispatch(a), d }])) } get chain() { return () => this.createChain() } get can() { return () => this.createCan() } createChain(e, t = !0) { const { rawCommands: r, editor: i, state: a } = this, { view: o } = i, s = [], l = !!e, c = e || a.tr, u = () => (!l && t && !c.getMeta("preventDispatch") && !this.hasCustomState && o.dispatch(c), s.every(f => f === !0)), d = { ...Object.fromEntries(Object.entries(r).map(([f, h]) => [f, (...m) => { const g = this.buildProps(c, t), y = h(...m)(g); return s.push(y), d }])), run: u }; return d } createCan(e) { const { rawCommands: t, state: r } = this, i = !1, a = e || r.tr, o = this.buildProps(a, i); return { ...Object.fromEntries(Object.entries(t).map(([l, c]) => [l, (...u) => c(...u)({ ...o, dispatch: void 0 })])), chain: () => this.createChain(a, i) } } buildProps(e, t = !0) { const { rawCommands: r, editor: i, state: a } = this, { view: o } = i, s = { tr: e, editor: i, view: o, state: zJ({ state: a, transaction: e }), dispatch: t ? () => { } : void 0, chain: () => this.createChain(e, t), can: () => this.createCan(e), get commands() { return Object.fromEntries(Object.entries(r).map(([l, c]) => [l, (...u) => c(...u)(s)])) } }; return s } } function Di(n, e, t) { return n.config[e] === void 0 && n.parent ? Di(n.parent, e, t) : typeof n.config[e] == "function" ? n.config[e].bind({ ...t, parent: n.parent ? Di(n.parent, e, t) : null }) : n.config[e] } function vDe(n) { const e = n.filter(i => i.type === "extension"), t = n.filter(i => i.type === "node"), r = n.filter(i => i.type === "mark"); return { baseExtensions: e, nodeExtensions: t, markExtensions: r } } function Pi(n, e) { if (typeof n == "string") { if (!e.nodes[n]) throw Error(`There is no node type named '${n}'. Maybe you forgot to add the extension?`); return e.nodes[n] } return n } function ti(...n) { return n.filter(e => !!e).reduce((e, t) => { const r = { ...e }; return Object.entries(t).forEach(([i, a]) => { if (!r[i]) { r[i] = a; return } if (i === "class") { const s = a ? a.split(" ") : [], l = r[i] ? r[i].split(" ") : [], c = s.filter(u => !l.includes(u)); r[i] = [...l, ...c].join(" ") } else if (i === "style") { const s = a ? a.split(";").map(u => u.trim()).filter(Boolean) : [], l = r[i] ? r[i].split(";").map(u => u.trim()).filter(Boolean) : [], c = new Map; l.forEach(u => { const [d, f] = u.split(":").map(h => h.trim()); c.set(d, f) }), s.forEach(u => { const [d, f] = u.split(":").map(h => h.trim()); c.set(d, f) }), r[i] = Array.from(c.entries()).map(([u, d]) => `${u}: ${d}`).join("; ") } else r[i] = a }), r }, {}) } function yDe(n) { return typeof n == "function" } function zr(n, e = void 0, ...t) { return yDe(n) ? e ? n.bind(e)(...t) : n(...t) : n } function _De(n) { return Object.prototype.toString.call(n) === "[object RegExp]" } class $k { constructor(e) { this.find = e.find, this.handler = e.handler } } class bDe { constructor(e) { this.find = e.find, this.handler = e.handler } } function wDe(n) { return Object.prototype.toString.call(n).slice(8, -1) } function sw(n) { return wDe(n) !== "Object" ? !1 : n.constructor === Object && Object.getPrototypeOf(n) === Object.prototype } function Fk(n, e) { const t = { ...n }; return sw(n) && sw(e) && Object.keys(e).forEach(r => { sw(e[r]) && sw(n[r]) ? t[r] = Fk(n[r], e[r]) : t[r] = e[r] }), t } class Ya { constructor(e = {}) { this.type = "extension", this.name = "extension", this.parent = null, this.child = null, this.config = { name: this.name, defaultOptions: {} }, this.config = { ...this.config, ...e }, this.name = this.config.name, e.defaultOptions && Object.keys(e.defaultOptions).length > 0 && console.warn(`[tiptap warn]: BREAKING CHANGE: "defaultOptions" is deprecated. Please use "addOptions" instead. Found in extension: "${this.name}".`), this.options = this.config.defaultOptions, this.config.addOptions && (this.options = zr(Di(this, "addOptions", { name: this.name }))), this.storage = zr(Di(this, "addStorage", { name: this.name, options: this.options })) || {} } static create(e = {}) { return new Ya(e) } configure(e = {}) { const t = this.extend({ ...this.config, addOptions: () => Fk(this.options, e) }); return t.name = this.name, t.parent = this.parent, t } extend(e = {}) { const t = new Ya({ ...this.config, ...e }); return t.parent = this, this.child = t, t.name = e.name ? e.name : t.parent.name, e.defaultOptions && Object.keys(e.defaultOptions).length > 0 && console.warn(`[tiptap warn]: BREAKING CHANGE: "defaultOptions" is deprecated. Please use "addOptions" instead. Found in extension: "${t.name}".`), t.options = zr(Di(t, "addOptions", { name: t.name })), t.storage = zr(Di(t, "addStorage", { name: t.name, options: t.options })), t } } function xDe(n, e, t) {
  const { from: r, to: i } = e, { blockSeparator: a = `

`, textSerializers: o = {} } = t || {}; let s = ""; return n.nodesBetween(r, i, (l, c, u, d) => { var f; l.isBlock && c > r && (s += a); const h = o == null ? void 0 : o[l.type.name]; if (h) return u && (s += h({ node: l, pos: c, parent: u, index: d, range: e })), !1; l.isText && (s += (f = l == null ? void 0 : l.text) === null || f === void 0 ? void 0 : f.slice(Math.max(r, c) - c, i - c)) }), s
} function SDe(n) { return Object.fromEntries(Object.entries(n.nodes).filter(([, e]) => e.spec.toText).map(([e, t]) => [e, t.spec.toText])) } Ya.create({ name: "clipboardTextSerializer", addOptions() { return { blockSeparator: void 0 } }, addProseMirrorPlugins() { return [new wn({ key: new xn("clipboardTextSerializer"), props: { clipboardTextSerializer: () => { const { editor: n } = this, { state: e, schema: t } = n, { doc: r, selection: i } = e, { ranges: a } = i, o = Math.min(...a.map(u => u.$from.pos)), s = Math.max(...a.map(u => u.$to.pos)), l = SDe(t); return xDe(r, { from: o, to: s }, { ...this.options.blockSeparator !== void 0 ? { blockSeparator: this.options.blockSeparator } : {}, textSerializers: l }) } } })] } }); const TDe = () => ({ editor: n, view: e }) => (requestAnimationFrame(() => { var t; n.isDestroyed || (e.dom.blur(), (t = window == null ? void 0 : window.getSelection()) === null || t === void 0 || t.removeAllRanges()) }), !0), kDe = (n = !1) => ({ commands: e }) => e.setContent("", n), CDe = () => ({ state: n, tr: e, dispatch: t }) => { const { selection: r } = e, { ranges: i } = r; return t && i.forEach(({ $from: a, $to: o }) => { n.doc.nodesBetween(a.pos, o.pos, (s, l) => { if (s.type.isText) return; const { doc: c, mapping: u } = e, d = c.resolve(u.map(l)), f = c.resolve(u.map(l + s.nodeSize)), h = d.blockRange(f); if (!h) return; const p = Qh(h); if (s.type.isTextblock) { const { defaultType: m } = d.parent.contentMatchAt(d.index()); e.setNodeMarkup(h.start, m) } (p || p === 0) && e.lift(h, p) }) }), !0 }, ADe = n => e => n(e), EDe = () => ({ state: n, dispatch: e }) => qX(n, e), MDe = (n, e) => ({ editor: t, tr: r }) => { const { state: i } = t, a = i.doc.slice(n.from, n.to); r.deleteRange(n.from, n.to); const o = r.mapping.map(e); return r.insert(o, a.content), r.setSelection(new ht(r.doc.resolve(o - 1))), !0 }, ODe = () => ({ tr: n, dispatch: e }) => { const { selection: t } = n, r = t.$anchor.node(); if (r.content.size > 0) return !1; const i = n.selection.$anchor; for (let a = i.depth; a > 0; a -= 1)if (i.node(a).type === r.type) { if (e) { const s = i.before(a), l = i.after(a); n.delete(s, l).scrollIntoView() } return !0 } return !1 }, DDe = n => ({ tr: e, state: t, dispatch: r }) => { const i = Pi(n, t.schema), a = e.selection.$anchor; for (let o = a.depth; o > 0; o -= 1)if (a.node(o).type === i) { if (r) { const l = a.before(o), c = a.after(o); e.delete(l, c).scrollIntoView() } return !0 } return !1 }, jDe = n => ({ tr: e, dispatch: t }) => { const { from: r, to: i } = n; return t && e.delete(r, i), !0 }, PDe = () => ({ state: n, dispatch: e }) => jX(n, e), IDe = () => ({ commands: n }) => n.keyboardShortcut("Enter"), LDe = () => ({ state: n, dispatch: e }) => KX(n, e); function o2(n, e, t = { strict: !0 }) { const r = Object.keys(e); return r.length ? r.every(i => t.strict ? e[i] === n[i] : _De(e[i]) ? e[i].test(n[i]) : e[i] === n[i]) : !0 } function nP(n, e, t = {}) { return n.find(r => r.type === e && o2(r.attrs, t)) } function RDe(n, e, t = {}) { return !!nP(n, e, t) } function KR(n, e, t = {}) { if (!n || !e) return; let r = n.parent.childAfter(n.parentOffset); if (n.parentOffset === r.offset && r.offset !== 0 && (r = n.parent.childBefore(n.parentOffset)), !r.node) return; const i = nP([...r.node.marks], e, t); if (!i) return; let a = r.index, o = n.start() + r.offset, s = a + 1, l = o + r.node.nodeSize; for (nP([...r.node.marks], e, t); a > 0 && i.isInSet(n.parent.child(a - 1).marks);)a -= 1, o -= n.parent.child(a).nodeSize; for (; s < n.parent.childCount && RDe([...n.parent.child(s).marks], e, t);)l += n.parent.child(s).nodeSize, s += 1; return { from: o, to: l } } function Hd(n, e) { if (typeof n == "string") { if (!e.marks[n]) throw Error(`There is no mark type named '${n}'. Maybe you forgot to add the extension?`); return e.marks[n] } return n } const NDe = (n, e = {}) => ({ tr: t, state: r, dispatch: i }) => { const a = Hd(n, r.schema), { doc: o, selection: s } = t, { $from: l, from: c, to: u } = s; if (i) { const d = KR(l, a, e); if (d && d.from <= c && d.to >= u) { const f = ht.create(o, d.from, d.to); t.setSelection(f) } } return !0 }, BDe = n => e => { const t = typeof n == "function" ? n(e) : n; for (let r = 0; r < t.length; r += 1)if (t[r](e)) return !0; return !1 }; function VJ(n) { return n instanceof ht } function Xf(n = 0, e = 0, t = 0) { return Math.min(Math.max(n, e), t) } function $De(n, e = null) { if (!e) return null; const t = vt.atStart(n), r = vt.atEnd(n); if (e === "start" || e === !0) return t; if (e === "end") return r; const i = t.from, a = r.to; return e === "all" ? ht.create(n, Xf(0, i, a), Xf(n.content.size, i, a)) : ht.create(n, Xf(e, i, a), Xf(e, i, a)) } function qR() { return ["iPad Simulator", "iPhone Simulator", "iPod Simulator", "iPad", "iPhone", "iPod"].includes(navigator.platform) || navigator.userAgent.includes("Mac") && "ontouchend" in document } const FDe = (n = null, e = {}) => ({ editor: t, view: r, tr: i, dispatch: a }) => { e = { scrollIntoView: !0, ...e }; const o = () => { qR() && r.dom.focus(), requestAnimationFrame(() => { t.isDestroyed || (r.focus(), e != null && e.scrollIntoView && t.commands.scrollIntoView()) }) }; if (r.hasFocus() && n === null || n === !1) return !0; if (a && n === null && !VJ(t.state.selection)) return o(), !0; const s = $De(i.doc, n) || t.state.selection, l = t.state.selection.eq(s); return a && (l || i.setSelection(s), l && i.storedMarks && i.setStoredMarks(i.storedMarks), o()), !0 }, zDe = (n, e) => t => n.every((r, i) => e(r, { ...t, index: i })), VDe = (n, e) => ({ tr: t, commands: r }) => r.insertContentAt({ from: t.selection.from, to: t.selection.to }, n, e), HJ = n => { const e = n.childNodes; for (let t = e.length - 1; t >= 0; t -= 1) { const r = e[t]; r.nodeType === 3 && r.nodeValue && /^(\n\s\s|\n)$/.test(r.nodeValue) ? n.removeChild(r) : r.nodeType === 1 && HJ(r) } return n }; function lw(n) { const e = `<body>${n}</body>`, t = new window.DOMParser().parseFromString(e, "text/html").body; return HJ(t) } function s2(n, e, t) { t = { slice: !0, parseOptions: {}, ...t }; const r = typeof n == "object" && n !== null, i = typeof n == "string"; if (r) try { if (Array.isArray(n) && n.length > 0) return Be.fromArray(n.map(s => e.nodeFromJSON(s))); const o = e.nodeFromJSON(n); return t.errorOnInvalidContent && o.check(), o } catch (a) { if (t.errorOnInvalidContent) throw new Error("[tiptap error]: Invalid JSON content", { cause: a }); return console.warn("[tiptap warn]: Invalid content.", "Passed value:", n, "Error:", a), s2("", e, t) } if (i) { if (t.errorOnInvalidContent) { let o = !1, s = ""; const l = new wR({ topNode: e.spec.topNode, marks: e.spec.marks, nodes: e.spec.nodes.append({ __tiptap__private__unknown__catch__all__node: { content: "inline*", group: "block", parseDOM: [{ tag: "*", getAttrs: c => (o = !0, s = typeof c == "string" ? c : c.outerHTML, null) }] } }) }); if (t.slice ? nd.fromSchema(l).parseSlice(lw(n), t.parseOptions) : nd.fromSchema(l).parse(lw(n), t.parseOptions), t.errorOnInvalidContent && o) throw new Error("[tiptap error]: Invalid HTML content", { cause: new Error(`Invalid element found: ${s}`) }) } const a = nd.fromSchema(e); return t.slice ? a.parseSlice(lw(n), t.parseOptions).content : a.parse(lw(n), t.parseOptions) } return s2("", e, t) } function HDe(n, e, t) { const r = n.steps.length - 1; if (r < e) return; const i = n.steps[r]; if (!(i instanceof Br || i instanceof Hr)) return; const a = n.mapping.maps[r]; let o = 0; a.forEach((s, l, c, u) => { o === 0 && (o = u) }), n.setSelection(vt.near(n.doc.resolve(o), t)) } const UDe = n => !("type" in n), GDe = (n, e, t) => ({ tr: r, dispatch: i, editor: a }) => { var o; if (i) { t = { parseOptions: {}, updateSelection: !0, applyInputRules: !1, applyPasteRules: !1, ...t }; let s; try { s = s2(e, a.schema, { parseOptions: { preserveWhitespace: "full", ...t.parseOptions }, errorOnInvalidContent: (o = t.errorOnInvalidContent) !== null && o !== void 0 ? o : a.options.enableContentCheck }) } catch (p) { return a.emit("contentError", { editor: a, error: p, disableCollaboration: () => { console.error("[tiptap error]: Unable to disable collaboration at this point in time") } }), !1 } let { from: l, to: c } = typeof n == "number" ? { from: n, to: n } : { from: n.from, to: n.to }, u = !0, d = !0; if ((UDe(s) ? s : [s]).forEach(p => { p.check(), u = u ? p.isText && p.marks.length === 0 : !1, d = d ? p.isBlock : !1 }), l === c && d) { const { parent: p } = r.doc.resolve(l); p.isTextblock && !p.type.spec.code && !p.childCount && (l -= 1, c += 1) } let h; u ? (Array.isArray(e) ? h = e.map(p => p.text || "").join("") : typeof e == "object" && e && e.text ? h = e.text : h = e, r.insertText(h, l, c)) : (h = s, r.replaceWith(l, c, h)), t.updateSelection && HDe(r, r.steps.length - 1, -1), t.applyInputRules && r.setMeta("applyInputRules", { from: l, text: h }), t.applyPasteRules && r.setMeta("applyPasteRules", { from: l, text: h }) } return !0 }, WDe = () => ({ state: n, dispatch: e }) => VX(n, e), KDe = () => ({ state: n, dispatch: e }) => HX(n, e), qDe = () => ({ state: n, dispatch: e }) => IX(n, e), YDe = () => ({ state: n, dispatch: e }) => FX(n, e), ZDe = () => ({ state: n, dispatch: e, tr: t }) => { try { const r = Hg(n.doc, n.selection.$from.pos, -1); return r == null ? !1 : (t.join(r, 2), e && e(t), !0) } catch { return !1 } }, XDe = () => ({ state: n, dispatch: e, tr: t }) => { try { const r = Hg(n.doc, n.selection.$from.pos, 1); return r == null ? !1 : (t.join(r, 2), e && e(t), !0) } catch { return !1 } }, JDe = () => ({ state: n, dispatch: e }) => LX(n, e), QDe = () => ({ state: n, dispatch: e }) => RX(n, e); function UJ() { return typeof navigator < "u" ? /Mac/.test(navigator.platform) : !1 } function eje(n) { const e = n.split(/-(?!$)/); let t = e[e.length - 1]; t === "Space" && (t = " "); let r, i, a, o; for (let s = 0; s < e.length - 1; s += 1) { const l = e[s]; if (/^(cmd|meta|m)$/i.test(l)) o = !0; else if (/^a(lt)?$/i.test(l)) r = !0; else if (/^(c|ctrl|control)$/i.test(l)) i = !0; else if (/^s(hift)?$/i.test(l)) a = !0; else if (/^mod$/i.test(l)) qR() || UJ() ? o = !0 : i = !0; else throw new Error(`Unrecognized modifier name: ${l}`) } return r && (t = `Alt-${t}`), i && (t = `Ctrl-${t}`), o && (t = `Meta-${t}`), a && (t = `Shift-${t}`), t } const tje = n => ({ editor: e, view: t, tr: r, dispatch: i }) => { const a = eje(n).split(/-(?!$)/), o = a.find(c => !["Alt", "Ctrl", "Meta", "Shift"].includes(c)), s = new KeyboardEvent("keydown", { key: o === "Space" ? " " : o, altKey: a.includes("Alt"), ctrlKey: a.includes("Ctrl"), metaKey: a.includes("Meta"), shiftKey: a.includes("Shift"), bubbles: !0, cancelable: !0 }), l = e.captureTransaction(() => { t.someProp("handleKeyDown", c => c(t, s)) }); return l == null || l.steps.forEach(c => { const u = c.map(r.mapping); u && i && r.maybeStep(u) }), !0 }; function YR(n, e, t = {}) { const { from: r, to: i, empty: a } = n.selection, o = e ? Pi(e, n.schema) : null, s = []; n.doc.nodesBetween(r, i, (d, f) => { if (d.isText) return; const h = Math.max(r, f), p = Math.min(i, f + d.nodeSize); s.push({ node: d, from: h, to: p }) }); const l = i - r, c = s.filter(d => o ? o.name === d.node.type.name : !0).filter(d => o2(d.node.attrs, t, { strict: !1 })); return a ? !!c.length : c.reduce((d, f) => d + f.to - f.from, 0) >= l } const nje = (n, e = {}) => ({ state: t, dispatch: r }) => { const i = Pi(n, t.schema); return YR(t, i, e) ? UX(t, r) : !1 }, rje = () => ({ state: n, dispatch: e }) => YX(n, e), ije = n => ({ state: e, dispatch: t }) => { const r = Pi(n, e.schema); return rJ(r)(e, t) }, aje = () => ({ state: n, dispatch: e }) => GX(n, e); function GJ(n, e) { return e.nodes[n] ? "node" : e.marks[n] ? "mark" : null } function Az(n, e) { const t = typeof e == "string" ? [e] : e; return Object.keys(n).reduce((r, i) => (t.includes(i) || (r[i] = n[i]), r), {}) } const oje = (n, e) => ({ tr: t, state: r, dispatch: i }) => { let a = null, o = null; const s = GJ(typeof n == "string" ? n : n.name, r.schema); return s ? (s === "node" && (a = Pi(n, r.schema)), s === "mark" && (o = Hd(n, r.schema)), i && t.selection.ranges.forEach(l => { r.doc.nodesBetween(l.$from.pos, l.$to.pos, (c, u) => { a && a === c.type && t.setNodeMarkup(u, void 0, Az(c.attrs, e)), o && c.marks.length && c.marks.forEach(d => { o === d.type && t.addMark(u, u + c.nodeSize, o.create(Az(d.attrs, e))) }) }) }), !0) : !1 }, sje = () => ({ tr: n, dispatch: e }) => (e && n.scrollIntoView(), !0), lje = () => ({ tr: n, commands: e }) => e.setTextSelection({ from: 0, to: n.doc.content.size }), cje = () => ({ state: n, dispatch: e }) => BX(n, e), uje = () => ({ state: n, dispatch: e }) => zX(n, e), dje = () => ({ state: n, dispatch: e }) => ZX(n, e), fje = () => ({ state: n, dispatch: e }) => eJ(n, e), hje = () => ({ state: n, dispatch: e }) => QX(n, e); function pje(n, e, t = {}, r = {}) { return s2(n, e, { slice: !1, parseOptions: t, errorOnInvalidContent: r.errorOnInvalidContent }) } const mje = (n, e = !1, t = {}, r = {}) => ({ editor: i, tr: a, dispatch: o, commands: s }) => { var l, c; const { doc: u } = a; if (t.preserveWhitespace !== "full") { const d = pje(n, i.schema, t, { errorOnInvalidContent: (l = r.errorOnInvalidContent) !== null && l !== void 0 ? l : i.options.enableContentCheck }); return o && a.replaceWith(0, u.content.size, d).setMeta("preventUpdate", !e), !0 } return o && a.setMeta("preventUpdate", !e), s.insertContentAt({ from: 0, to: u.content.size }, n, { parseOptions: t, errorOnInvalidContent: (c = r.errorOnInvalidContent) !== null && c !== void 0 ? c : i.options.enableContentCheck }) }; function ZR(n, e) { const t = Hd(e, n.schema), { from: r, to: i, empty: a } = n.selection, o = []; a ? (n.storedMarks && o.push(...n.storedMarks), o.push(...n.selection.$head.marks())) : n.doc.nodesBetween(r, i, l => { o.push(...l.marks) }); const s = o.find(l => l.type.name === t.name); return s ? { ...s.attrs } : {} } function gje(n) { for (let e = 0; e < n.edgeCount; e += 1) { const { type: t } = n.edge(e); if (t.isTextblock && !t.hasRequiredAttrs()) return t } return null } function vje(n, e) { for (let t = n.depth; t > 0; t -= 1) { const r = n.node(t); if (e(r)) return { pos: t > 0 ? n.before(t) : 0, start: n.start(t), depth: t, node: r } } } function XR(n) { return e => vje(e.$from, n) } function WJ(n, e, t) { const r = []; return n === e ? t.resolve(n).marks().forEach(i => { const a = t.resolve(n), o = KR(a, i.type); o && r.push({ mark: i, ...o }) }) : t.nodesBetween(n, e, (i, a) => { !i || (i == null ? void 0 : i.nodeSize) === void 0 || r.push(...i.marks.map(o => ({ from: a, to: a + i.nodeSize, mark: o }))) }), r } function Vx(n, e, t) { return Object.fromEntries(Object.entries(t).filter(([r]) => { const i = n.find(a => a.type === e && a.name === r); return i ? i.attribute.keepOnSplit : !1 })) } function yje(n, e, t = {}) { const { empty: r, ranges: i } = n.selection, a = e ? Hd(e, n.schema) : null; if (r) return !!(n.storedMarks || n.selection.$from.marks()).filter(d => a ? a.name === d.type.name : !0).find(d => o2(d.attrs, t, { strict: !1 })); let o = 0; const s = []; if (i.forEach(({ $from: d, $to: f }) => { const h = d.pos, p = f.pos; n.doc.nodesBetween(h, p, (m, g) => { if (!m.isText && !m.marks.length) return; const y = Math.max(h, g), b = Math.min(p, g + m.nodeSize), w = b - y; o += w, s.push(...m.marks.map(v => ({ mark: v, from: y, to: b }))) }) }), o === 0) return !1; const l = s.filter(d => a ? a.name === d.mark.type.name : !0).filter(d => o2(d.mark.attrs, t, { strict: !1 })).reduce((d, f) => d + f.to - f.from, 0), c = s.filter(d => a ? d.mark.type !== a && d.mark.type.excludes(a) : !0).reduce((d, f) => d + f.to - f.from, 0); return (l > 0 ? l + c : l) >= o } function Ez(n, e) { const { nodeExtensions: t } = vDe(e), r = t.find(o => o.name === n); if (!r) return !1; const i = { name: r.name, options: r.options, storage: r.storage }, a = zr(Di(r, "group", i)); return typeof a != "string" ? !1 : a.split(" ").includes("list") } function KJ(n, { checkChildren: e = !0, ignoreWhitespace: t = !1 } = {}) { var r; if (t) { if (n.type.name === "hardBreak") return !0; if (n.isText) return /^\s*$/m.test((r = n.text) !== null && r !== void 0 ? r : "") } if (n.isText) return !n.text; if (n.isAtom || n.isLeaf) return !1; if (n.content.childCount === 0) return !0; if (e) { let i = !0; return n.content.forEach(a => { i !== !1 && (KJ(a, { ignoreWhitespace: t, checkChildren: e }) || (i = !1)) }), i } return !1 } function _je(n) { return n instanceof _t } function bje(n, e, t) { var r; const { selection: i } = e; let a = null; if (VJ(i) && (a = i.$cursor), a) { const s = (r = n.storedMarks) !== null && r !== void 0 ? r : a.marks(); return !!t.isInSet(s) || !s.some(l => l.type.excludes(t)) } const { ranges: o } = i; return o.some(({ $from: s, $to: l }) => { let c = s.depth === 0 ? n.doc.inlineContent && n.doc.type.allowsMarkType(t) : !1; return n.doc.nodesBetween(s.pos, l.pos, (u, d, f) => { if (c) return !1; if (u.isInline) { const h = !f || f.type.allowsMarkType(t), p = !!t.isInSet(u.marks) || !u.marks.some(m => m.type.excludes(t)); c = h && p } return !c }), c }) } const wje = (n, e = {}) => ({ tr: t, state: r, dispatch: i }) => { const { selection: a } = t, { empty: o, ranges: s } = a, l = Hd(n, r.schema); if (i) if (o) { const c = ZR(r, l); t.addStoredMark(l.create({ ...c, ...e })) } else s.forEach(c => { const u = c.$from.pos, d = c.$to.pos; r.doc.nodesBetween(u, d, (f, h) => { const p = Math.max(h, u), m = Math.min(h + f.nodeSize, d); f.marks.find(y => y.type === l) ? f.marks.forEach(y => { l === y.type && t.addMark(p, m, l.create({ ...y.attrs, ...e })) }) : t.addMark(p, m, l.create(e)) }) }); return bje(r, t, l) }, xje = (n, e) => ({ tr: t }) => (t.setMeta(n, e), !0), Sje = (n, e = {}) => ({ state: t, dispatch: r, chain: i }) => { const a = Pi(n, t.schema); return a.isTextblock ? i().command(({ commands: o }) => t2(a, e)(t) ? !0 : o.clearNodes()).command(({ state: o }) => t2(a, e)(o, r)).run() : (console.warn('[tiptap warn]: Currently "setNode()" only supports text block nodes.'), !1) }, Tje = n => ({ tr: e, dispatch: t }) => { if (t) { const { doc: r } = e, i = Xf(n, 0, r.content.size), a = _t.create(r, i); e.setSelection(a) } return !0 }, kje = n => ({ tr: e, dispatch: t }) => { if (t) { const { doc: r } = e, { from: i, to: a } = typeof n == "number" ? { from: n, to: n } : n, o = ht.atStart(r).from, s = ht.atEnd(r).to, l = Xf(i, o, s), c = Xf(a, o, s), u = ht.create(r, l, c); e.setSelection(u) } return !0 }, Cje = n => ({ state: e, dispatch: t }) => { const r = Pi(n, e.schema); return iJ(r)(e, t) }; function Mz(n, e) { const t = n.storedMarks || n.selection.$to.parentOffset && n.selection.$from.marks(); if (t) { const r = t.filter(i => e == null ? void 0 : e.includes(i.type.name)); n.tr.ensureMarks(r) } } const Aje = ({ keepMarks: n = !0 } = {}) => ({ tr: e, state: t, dispatch: r, editor: i }) => { const { selection: a, doc: o } = e, { $from: s, $to: l } = a, c = i.extensionManager.attributes, u = Vx(c, s.node().type.name, s.node().attrs); if (a instanceof _t && a.node.isBlock) return !s.parentOffset || !hl(o, s.pos) ? !1 : (r && (n && Mz(t, i.extensionManager.splittableMarks), e.split(s.pos).scrollIntoView()), !0); if (!s.parent.isBlock) return !1; const d = l.parentOffset === l.parent.content.size, f = s.depth === 0 ? void 0 : gje(s.node(-1).contentMatchAt(s.indexAfter(-1))); let h = d && f ? [{ type: f, attrs: u }] : void 0, p = hl(e.doc, e.mapping.map(s.pos), 1, h); if (!h && !p && hl(e.doc, e.mapping.map(s.pos), 1, f ? [{ type: f }] : void 0) && (p = !0, h = f ? [{ type: f, attrs: u }] : void 0), r) { if (p && (a instanceof ht && e.deleteSelection(), e.split(e.mapping.map(s.pos), 1, h), f && !d && !s.parentOffset && s.parent.type !== f)) { const m = e.mapping.map(s.before()), g = e.doc.resolve(m); s.node(-1).canReplaceWith(g.index(), g.index() + 1, f) && e.setNodeMarkup(e.mapping.map(s.before()), f) } n && Mz(t, i.extensionManager.splittableMarks), e.scrollIntoView() } return p }, Eje = (n, e = {}) => ({ tr: t, state: r, dispatch: i, editor: a }) => { var o; const s = Pi(n, r.schema), { $from: l, $to: c } = r.selection, u = r.selection.node; if (u && u.isBlock || l.depth < 2 || !l.sameParent(c)) return !1; const d = l.node(-1); if (d.type !== s) return !1; const f = a.extensionManager.attributes; if (l.parent.content.size === 0 && l.node(-1).childCount === l.indexAfter(-1)) { if (l.depth === 2 || l.node(-3).type !== s || l.index(-2) !== l.node(-2).childCount - 1) return !1; if (i) { let y = Be.empty; const b = l.index(-1) ? 1 : l.index(-2) ? 2 : 3; for (let A = l.depth - b; A >= l.depth - 3; A -= 1)y = Be.from(l.node(A).copy(y)); const w = l.indexAfter(-1) < l.node(-2).childCount ? 1 : l.indexAfter(-2) < l.node(-3).childCount ? 2 : 3, v = { ...Vx(f, l.node().type.name, l.node().attrs), ...e }, S = ((o = s.contentMatch.defaultType) === null || o === void 0 ? void 0 : o.createAndFill(v)) || void 0; y = y.append(Be.from(s.createAndFill(null, S) || void 0)); const x = l.before(l.depth - (b - 1)); t.replace(x, l.after(-w), new Qe(y, 4 - b, 0)); let k = -1; t.doc.nodesBetween(x, t.doc.content.size, (A, C) => { if (k > -1) return !1; A.isTextblock && A.content.size === 0 && (k = C + 1) }), k > -1 && t.setSelection(ht.near(t.doc.resolve(k))), t.scrollIntoView() } return !0 } const h = c.pos === l.end() ? d.contentMatchAt(0).defaultType : null, p = { ...Vx(f, d.type.name, d.attrs), ...e }, m = { ...Vx(f, l.node().type.name, l.node().attrs), ...e }; t.delete(l.pos, c.pos); const g = h ? [{ type: s, attrs: p }, { type: h, attrs: m }] : [{ type: s, attrs: p }]; if (!hl(t.doc, l.pos, 2)) return !1; if (i) { const { selection: y, storedMarks: b } = r, { splittableMarks: w } = a.extensionManager, v = b || y.$to.parentOffset && y.$from.marks(); if (t.split(l.pos, 2, g).scrollIntoView(), !v || !i) return !0; const S = v.filter(x => w.includes(x.type.name)); t.ensureMarks(S) } return !0 }, FE = (n, e) => { const t = XR(o => o.type === e)(n.selection); if (!t) return !0; const r = n.doc.resolve(Math.max(0, t.pos - 1)).before(t.depth); if (r === void 0) return !0; const i = n.doc.nodeAt(r); return t.node.type === (i == null ? void 0 : i.type) && Dl(n.doc, t.pos) && n.join(t.pos), !0 }, zE = (n, e) => { const t = XR(o => o.type === e)(n.selection); if (!t) return !0; const r = n.doc.resolve(t.start).after(t.depth); if (r === void 0) return !0; const i = n.doc.nodeAt(r); return t.node.type === (i == null ? void 0 : i.type) && Dl(n.doc, r) && n.join(r), !0 }, Mje = (n, e, t, r = {}) => ({ editor: i, tr: a, state: o, dispatch: s, chain: l, commands: c, can: u }) => { const { extensions: d, splittableMarks: f } = i.extensionManager, h = Pi(n, o.schema), p = Pi(e, o.schema), { selection: m, storedMarks: g } = o, { $from: y, $to: b } = m, w = y.blockRange(b), v = g || m.$to.parentOffset && m.$from.marks(); if (!w) return !1; const S = XR(x => Ez(x.type.name, d))(m); if (w.depth >= 1 && S && w.depth - S.depth <= 1) { if (S.node.type === h) return c.liftListItem(p); if (Ez(S.node.type.name, d) && h.validContent(S.node.content) && s) return l().command(() => (a.setNodeMarkup(S.pos, h), !0)).command(() => FE(a, h)).command(() => zE(a, h)).run() } return !t || !v || !s ? l().command(() => u().wrapInList(h, r) ? !0 : c.clearNodes()).wrapInList(h, r).command(() => FE(a, h)).command(() => zE(a, h)).run() : l().command(() => { const x = u().wrapInList(h, r), k = v.filter(A => f.includes(A.type.name)); return a.ensureMarks(k), x ? !0 : c.clearNodes() }).wrapInList(h, r).command(() => FE(a, h)).command(() => zE(a, h)).run() }, Oje = (n, e = {}, t = {}) => ({ state: r, commands: i }) => { const { extendEmptyMarkRange: a = !1 } = t, o = Hd(n, r.schema); return yje(r, o, e) ? i.unsetMark(o, { extendEmptyMarkRange: a }) : i.setMark(o, e) }, Dje = (n, e, t = {}) => ({ state: r, commands: i }) => { const a = Pi(n, r.schema), o = Pi(e, r.schema), s = YR(r, a, t); let l; return r.selection.$anchor.sameParent(r.selection.$head) && (l = r.selection.$anchor.parent.attrs), s ? i.setNode(o, l) : i.setNode(a, { ...l, ...t }) }, jje = (n, e = {}) => ({ state: t, commands: r }) => { const i = Pi(n, t.schema); return YR(t, i, e) ? r.lift(i) : r.wrapIn(i, e) }, Pje = () => ({ state: n, dispatch: e }) => { const t = n.plugins; for (let r = 0; r < t.length; r += 1) { const i = t[r]; let a; if (i.spec.isInputRules && (a = i.getState(n))) { if (e) { const o = n.tr, s = a.transform; for (let l = s.steps.length - 1; l >= 0; l -= 1)o.step(s.steps[l].invert(s.docs[l])); if (a.text) { const l = o.doc.resolve(a.from).marks(); o.replaceWith(a.from, a.to, n.schema.text(a.text, l)) } else o.delete(a.from, a.to) } return !0 } } return !1 }, Ije = () => ({ tr: n, dispatch: e }) => { const { selection: t } = n, { empty: r, ranges: i } = t; return r || e && i.forEach(a => { n.removeMark(a.$from.pos, a.$to.pos) }), !0 }, Lje = (n, e = {}) => ({ tr: t, state: r, dispatch: i }) => { var a; const { extendEmptyMarkRange: o = !1 } = e, { selection: s } = t, l = Hd(n, r.schema), { $from: c, empty: u, ranges: d } = s; if (!i) return !0; if (u && o) { let { from: f, to: h } = s; const p = (a = c.marks().find(g => g.type === l)) === null || a === void 0 ? void 0 : a.attrs, m = KR(c, l, p); m && (f = m.from, h = m.to), t.removeMark(f, h, l) } else d.forEach(f => { t.removeMark(f.$from.pos, f.$to.pos, l) }); return t.removeStoredMark(l), !0 }, Rje = (n, e = {}) => ({ tr: t, state: r, dispatch: i }) => { let a = null, o = null; const s = GJ(typeof n == "string" ? n : n.name, r.schema); return s ? (s === "node" && (a = Pi(n, r.schema)), s === "mark" && (o = Hd(n, r.schema)), i && t.selection.ranges.forEach(l => { const c = l.$from.pos, u = l.$to.pos; r.doc.nodesBetween(c, u, (d, f) => { a && a === d.type && t.setNodeMarkup(f, void 0, { ...d.attrs, ...e }), o && d.marks.length && d.marks.forEach(h => { if (o === h.type) { const p = Math.max(f, c), m = Math.min(f + d.nodeSize, u); t.addMark(p, m, o.create({ ...h.attrs, ...e })) } }) }) }), !0) : !1 }, Nje = (n, e = {}) => ({ state: t, dispatch: r }) => { const i = Pi(n, t.schema); return tJ(i, e)(t, r) }, Bje = (n, e = {}) => ({ state: t, dispatch: r }) => { const i = Pi(n, t.schema); return nJ(i, e)(t, r) }; var $je = Object.freeze({ __proto__: null, blur: TDe, clearContent: kDe, clearNodes: CDe, command: ADe, createParagraphNear: EDe, cut: MDe, deleteCurrentNode: ODe, deleteNode: DDe, deleteRange: jDe, deleteSelection: PDe, enter: IDe, exitCode: LDe, extendMarkRange: NDe, first: BDe, focus: FDe, forEach: zDe, insertContent: VDe, insertContentAt: GDe, joinBackward: qDe, joinDown: KDe, joinForward: YDe, joinItemBackward: ZDe, joinItemForward: XDe, joinTextblockBackward: JDe, joinTextblockForward: QDe, joinUp: WDe, keyboardShortcut: tje, lift: nje, liftEmptyBlock: rje, liftListItem: ije, newlineInCode: aje, resetAttributes: oje, scrollIntoView: sje, selectAll: lje, selectNodeBackward: cje, selectNodeForward: uje, selectParentNode: dje, selectTextblockEnd: fje, selectTextblockStart: hje, setContent: mje, setMark: wje, setMeta: xje, setNode: Sje, setNodeSelection: Tje, setTextSelection: kje, sinkListItem: Cje, splitBlock: Aje, splitListItem: Eje, toggleList: Mje, toggleMark: Oje, toggleNode: Dje, toggleWrap: jje, undoInputRule: Pje, unsetAllMarks: Ije, unsetMark: Lje, updateAttributes: Rje, wrapIn: Nje, wrapInList: Bje }); Ya.create({ name: "commands", addCommands() { return { ...$je } } }); Ya.create({ name: "editable", addProseMirrorPlugins() { return [new wn({ key: new xn("editable"), props: { editable: () => this.editor.options.editable } })] } }); Ya.create({ name: "focusEvents", addProseMirrorPlugins() { const { editor: n } = this; return [new wn({ key: new xn("focusEvents"), props: { handleDOMEvents: { focus: (e, t) => { n.isFocused = !0; const r = n.state.tr.setMeta("focus", { event: t }).setMeta("addToHistory", !1); return e.dispatch(r), !1 }, blur: (e, t) => { n.isFocused = !1; const r = n.state.tr.setMeta("blur", { event: t }).setMeta("addToHistory", !1); return e.dispatch(r), !1 } } } })] } }); Ya.create({ name: "keymap", addKeyboardShortcuts() { const n = () => this.editor.commands.first(({ commands: o }) => [() => o.undoInputRule(), () => o.command(({ tr: s }) => { const { selection: l, doc: c } = s, { empty: u, $anchor: d } = l, { pos: f, parent: h } = d, p = d.parent.isTextblock && f > 0 ? s.doc.resolve(f - 1) : d, m = p.parent.type.spec.isolating, g = d.pos - d.parentOffset, y = m && p.parent.childCount === 1 ? g === d.pos : vt.atStart(c).from === f; return !u || !h.type.isTextblock || h.textContent.length || !y || y && d.parent.type.name === "paragraph" ? !1 : o.clearNodes() }), () => o.deleteSelection(), () => o.joinBackward(), () => o.selectNodeBackward()]), e = () => this.editor.commands.first(({ commands: o }) => [() => o.deleteSelection(), () => o.deleteCurrentNode(), () => o.joinForward(), () => o.selectNodeForward()]), r = { Enter: () => this.editor.commands.first(({ commands: o }) => [() => o.newlineInCode(), () => o.createParagraphNear(), () => o.liftEmptyBlock(), () => o.splitBlock()]), "Mod-Enter": () => this.editor.commands.exitCode(), Backspace: n, "Mod-Backspace": n, "Shift-Backspace": n, Delete: e, "Mod-Delete": e, "Mod-a": () => this.editor.commands.selectAll() }, i = { ...r }, a = { ...r, "Ctrl-h": n, "Alt-Backspace": n, "Ctrl-d": e, "Ctrl-Alt-Backspace": e, "Alt-Delete": e, "Alt-d": e, "Ctrl-a": () => this.editor.commands.selectTextblockStart(), "Ctrl-e": () => this.editor.commands.selectTextblockEnd() }; return qR() || UJ() ? a : i }, addProseMirrorPlugins() { return [new wn({ key: new xn("clearDocument"), appendTransaction: (n, e, t) => { const r = n.some(m => m.docChanged) && !e.doc.eq(t.doc), i = n.some(m => m.getMeta("preventClearDocument")); if (!r || i) return; const { empty: a, from: o, to: s } = e.selection, l = vt.atStart(e.doc).from, c = vt.atEnd(e.doc).to; if (a || !(o === l && s === c) || !KJ(t.doc)) return; const f = t.tr, h = zJ({ state: t, transaction: f }), { commands: p } = new gDe({ editor: this.editor, state: h }); if (p.clearNodes(), !!f.steps.length) return f } })] } }); Ya.create({ name: "tabindex", addProseMirrorPlugins() { return [new wn({ key: new xn("tabindex"), props: { attributes: () => this.editor.isEditable ? { tabindex: "0" } : {} } })] } }); function bg(n) { return new $k({ find: n.find, handler: ({ state: e, range: t, match: r }) => { const i = zr(n.getAttributes, void 0, r); if (i === !1 || i === null) return null; const { tr: a } = e, o = r[r.length - 1], s = r[0]; if (o) { const l = s.search(/\S/), c = t.from + s.indexOf(o), u = c + o.length; if (WJ(t.from, t.to, e.doc).filter(h => h.mark.type.excluded.find(m => m === n.type && m !== h.mark.type)).filter(h => h.to > c).length) return null; u < t.to && a.delete(u, t.to), c > t.from && a.delete(t.from + l, c); const f = t.from + l + o.length; a.addMark(t.from + l, f, n.type.create(i || {})), a.removeStoredMark(n.type) } } }) } function Fje(n) { return new $k({ find: n.find, handler: ({ state: e, range: t, match: r }) => { const i = zr(n.getAttributes, void 0, r) || {}, { tr: a } = e, o = t.from; let s = t.to; const l = n.type.create(i); if (r[1]) { const c = r[0].lastIndexOf(r[1]); let u = o + c; u > s ? u = s : s = u + r[1].length; const d = r[0][r[0].length - 1]; a.insertText(d, o + r[0].length - 1), a.replaceWith(u, s, l) } else if (r[0]) { const c = n.type.isInline ? o : o - 1; a.insert(c, n.type.create(i)).delete(a.mapping.map(o), a.mapping.map(s)) } a.scrollIntoView() } }) } function rP(n) { return new $k({ find: n.find, handler: ({ state: e, range: t, match: r }) => { const i = e.doc.resolve(t.from), a = zr(n.getAttributes, void 0, r) || {}; if (!i.node(-1).canReplaceWith(i.index(-1), i.indexAfter(-1), n.type)) return null; e.tr.delete(t.from, t.to).setBlockType(t.from, t.from, n.type, a) } }) } function r_(n) { return new $k({ find: n.find, handler: ({ state: e, range: t, match: r, chain: i }) => { const a = zr(n.getAttributes, void 0, r) || {}, o = e.tr.delete(t.from, t.to), l = o.doc.resolve(t.from).blockRange(), c = l && SR(l, n.type, a); if (!c) return null; if (o.wrap(l, c), n.keepMarks && n.editor) { const { selection: d, storedMarks: f } = e, { splittableMarks: h } = n.editor.extensionManager, p = f || d.$to.parentOffset && d.$from.marks(); if (p) { const m = p.filter(g => h.includes(g.type.name)); o.ensureMarks(m) } } if (n.keepAttributes) { const d = n.type.name === "bulletList" || n.type.name === "orderedList" ? "listItem" : "taskList"; i().updateAttributes(d, a).run() } const u = o.doc.resolve(t.from - 1).nodeBefore; u && u.type === n.type && Dl(o.doc, t.from - 1) && (!n.joinPredicate || n.joinPredicate(r, u)) && o.join(t.from - 1) } }) } let Gg = class iP { constructor(e = {}) { this.type = "mark", this.name = "mark", this.parent = null, this.child = null, this.config = { name: this.name, defaultOptions: {} }, this.config = { ...this.config, ...e }, this.name = this.config.name, e.defaultOptions && Object.keys(e.defaultOptions).length > 0 && console.warn(`[tiptap warn]: BREAKING CHANGE: "defaultOptions" is deprecated. Please use "addOptions" instead. Found in extension: "${this.name}".`), this.options = this.config.defaultOptions, this.config.addOptions && (this.options = zr(Di(this, "addOptions", { name: this.name }))), this.storage = zr(Di(this, "addStorage", { name: this.name, options: this.options })) || {} } static create(e = {}) { return new iP(e) } configure(e = {}) { const t = this.extend({ ...this.config, addOptions: () => Fk(this.options, e) }); return t.name = this.name, t.parent = this.parent, t } extend(e = {}) { const t = new iP(e); return t.parent = this, this.child = t, t.name = e.name ? e.name : t.parent.name, e.defaultOptions && Object.keys(e.defaultOptions).length > 0 && console.warn(`[tiptap warn]: BREAKING CHANGE: "defaultOptions" is deprecated. Please use "addOptions" instead. Found in extension: "${t.name}".`), t.options = zr(Di(t, "addOptions", { name: t.name })), t.storage = zr(Di(t, "addStorage", { name: t.name, options: t.options })), t } static handleExit({ editor: e, mark: t }) { const { tr: r } = e.state, i = e.state.selection.$from; if (i.pos === i.end()) { const o = i.marks(); if (!!!o.find(c => (c == null ? void 0 : c.type.name) === t.name)) return !1; const l = o.find(c => (c == null ? void 0 : c.type.name) === t.name); return l && r.removeStoredMark(l), r.insertText(" ", i.pos), e.view.dispatch(r), !0 } return !1 } }, Za = class aP { constructor(e = {}) { this.type = "node", this.name = "node", this.parent = null, this.child = null, this.config = { name: this.name, defaultOptions: {} }, this.config = { ...this.config, ...e }, this.name = this.config.name, e.defaultOptions && Object.keys(e.defaultOptions).length > 0 && console.warn(`[tiptap warn]: BREAKING CHANGE: "defaultOptions" is deprecated. Please use "addOptions" instead. Found in extension: "${this.name}".`), this.options = this.config.defaultOptions, this.config.addOptions && (this.options = zr(Di(this, "addOptions", { name: this.name }))), this.storage = zr(Di(this, "addStorage", { name: this.name, options: this.options })) || {} } static create(e = {}) { return new aP(e) } configure(e = {}) { const t = this.extend({ ...this.config, addOptions: () => Fk(this.options, e) }); return t.name = this.name, t.parent = this.parent, t } extend(e = {}) { const t = new aP(e); return t.parent = this, this.child = t, t.name = e.name ? e.name : t.parent.name, e.defaultOptions && Object.keys(e.defaultOptions).length > 0 && console.warn(`[tiptap warn]: BREAKING CHANGE: "defaultOptions" is deprecated. Please use "addOptions" instead. Found in extension: "${t.name}".`), t.options = zr(Di(t, "addOptions", { name: t.name })), t.storage = zr(Di(t, "addStorage", { name: t.name, options: t.options })), t } }; function wg(n) { return new bDe({ find: n.find, handler: ({ state: e, range: t, match: r, pasteEvent: i }) => { const a = zr(n.getAttributes, void 0, r, i); if (a === !1 || a === null) return null; const { tr: o } = e, s = r[r.length - 1], l = r[0]; let c = t.to; if (s) { const u = l.search(/\S/), d = t.from + l.indexOf(s), f = d + s.length; if (WJ(t.from, t.to, e.doc).filter(p => p.mark.type.excluded.find(g => g === n.type && g !== p.mark.type)).filter(p => p.to > d).length) return null; f < t.to && o.delete(f, t.to), d > t.from && o.delete(t.from + u, d), c = t.from + u + s.length, o.addMark(t.from + u, c, n.type.create(a || {})), o.removeStoredMark(n.type) } } }) } const zje = /^\s*>\s$/, Vje = Za.create({ name: "blockquote", addOptions() { return { HTMLAttributes: {} } }, content: "block+", group: "block", defining: !0, parseHTML() { return [{ tag: "blockquote" }] }, renderHTML({ HTMLAttributes: n }) { return ["blockquote", ti(this.options.HTMLAttributes, n), 0] }, addCommands() { return { setBlockquote: () => ({ commands: n }) => n.wrapIn(this.name), toggleBlockquote: () => ({ commands: n }) => n.toggleWrap(this.name), unsetBlockquote: () => ({ commands: n }) => n.lift(this.name) } }, addKeyboardShortcuts() { return { "Mod-Shift-b": () => this.editor.commands.toggleBlockquote() } }, addInputRules() { return [r_({ find: zje, type: this.type })] } }), Hje = /(?:^|\s)(\*\*(?!\s+\*\*)((?:[^*]+))\*\*(?!\s+\*\*))$/, Uje = /(?:^|\s)(\*\*(?!\s+\*\*)((?:[^*]+))\*\*(?!\s+\*\*))/g, Gje = /(?:^|\s)(__(?!\s+__)((?:[^_]+))__(?!\s+__))$/, Wje = /(?:^|\s)(__(?!\s+__)((?:[^_]+))__(?!\s+__))/g, Kje = Gg.create({ name: "bold", addOptions() { return { HTMLAttributes: {} } }, parseHTML() { return [{ tag: "strong" }, { tag: "b", getAttrs: n => n.style.fontWeight !== "normal" && null }, { style: "font-weight", getAttrs: n => /^(bold(er)?|[5-9]\d{2,})$/.test(n) && null }] }, renderHTML({ HTMLAttributes: n }) { return ["strong", ti(this.options.HTMLAttributes, n), 0] }, addCommands() { return { setBold: () => ({ commands: n }) => n.setMark(this.name), toggleBold: () => ({ commands: n }) => n.toggleMark(this.name), unsetBold: () => ({ commands: n }) => n.unsetMark(this.name) } }, addKeyboardShortcuts() { return { "Mod-b": () => this.editor.commands.toggleBold(), "Mod-B": () => this.editor.commands.toggleBold() } }, addInputRules() { return [bg({ find: Hje, type: this.type }), bg({ find: Gje, type: this.type })] }, addPasteRules() { return [wg({ find: Uje, type: this.type }), wg({ find: Wje, type: this.type })] } }), qje = Za.create({ name: "listItem", addOptions() { return { HTMLAttributes: {}, bulletListTypeName: "bulletList", orderedListTypeName: "orderedList" } }, content: "paragraph block*", defining: !0, parseHTML() { return [{ tag: "li" }] }, renderHTML({ HTMLAttributes: n }) { return ["li", ti(this.options.HTMLAttributes, n), 0] }, addKeyboardShortcuts() { return { Enter: () => this.editor.commands.splitListItem(this.name), Tab: () => this.editor.commands.sinkListItem(this.name), "Shift-Tab": () => this.editor.commands.liftListItem(this.name) } } }), Oz = Gg.create({ name: "textStyle", priority: 101, addOptions() { return { HTMLAttributes: {} } }, parseHTML() { return [{ tag: "span", getAttrs: n => n.hasAttribute("style") ? {} : !1 }] }, renderHTML({ HTMLAttributes: n }) { return ["span", ti(this.options.HTMLAttributes, n), 0] }, addCommands() { return { removeEmptyTextStyle: () => ({ state: n, commands: e }) => { const t = ZR(n, this.type); return Object.entries(t).some(([, i]) => !!i) ? !0 : e.unsetMark(this.name) } } } }), Dz = /^\s*([-+*])\s$/, Yje = Za.create({ name: "bulletList", addOptions() { return { itemTypeName: "listItem", HTMLAttributes: {}, keepMarks: !1, keepAttributes: !1 } }, group: "block list", content() { return `${this.options.itemTypeName}+` }, parseHTML() { return [{ tag: "ul" }] }, renderHTML({ HTMLAttributes: n }) { return ["ul", ti(this.options.HTMLAttributes, n), 0] }, addCommands() { return { toggleBulletList: () => ({ commands: n, chain: e }) => this.options.keepAttributes ? e().toggleList(this.name, this.options.itemTypeName, this.options.keepMarks).updateAttributes(qje.name, this.editor.getAttributes(Oz.name)).run() : n.toggleList(this.name, this.options.itemTypeName, this.options.keepMarks) } }, addKeyboardShortcuts() { return { "Mod-Shift-8": () => this.editor.commands.toggleBulletList() } }, addInputRules() { let n = r_({ find: Dz, type: this.type }); return (this.options.keepMarks || this.options.keepAttributes) && (n = r_({ find: Dz, type: this.type, keepMarks: this.options.keepMarks, keepAttributes: this.options.keepAttributes, getAttributes: () => this.editor.getAttributes(Oz.name), editor: this.editor })), [n] } }), Zje = /(?:^|\s)(`(?!\s+`)((?:[^`]+))`(?!\s+`))$/, Xje = /(?:^|\s)(`(?!\s+`)((?:[^`]+))`(?!\s+`))/g, Jje = Gg.create({ name: "code", addOptions() { return { HTMLAttributes: {} } }, excludes: "_", code: !0, exitable: !0, parseHTML() { return [{ tag: "code" }] }, renderHTML({ HTMLAttributes: n }) { return ["code", ti(this.options.HTMLAttributes, n), 0] }, addCommands() { return { setCode: () => ({ commands: n }) => n.setMark(this.name), toggleCode: () => ({ commands: n }) => n.toggleMark(this.name), unsetCode: () => ({ commands: n }) => n.unsetMark(this.name) } }, addKeyboardShortcuts() { return { "Mod-e": () => this.editor.commands.toggleCode() } }, addInputRules() { return [bg({ find: Zje, type: this.type })] }, addPasteRules() { return [wg({ find: Xje, type: this.type })] } }), Qje = /^```([a-z]+)?[\s\n]$/, ePe = /^~~~([a-z]+)?[\s\n]$/, tPe = Za.create({
  name: "codeBlock", addOptions() { return { languageClassPrefix: "language-", exitOnTripleEnter: !0, exitOnArrowDown: !0, defaultLanguage: null, HTMLAttributes: {} } }, content: "text*", marks: "", group: "block", code: !0, defining: !0, addAttributes() { return { language: { default: this.options.defaultLanguage, parseHTML: n => { var e; const { languageClassPrefix: t } = this.options, a = [...((e = n.firstElementChild) === null || e === void 0 ? void 0 : e.classList) || []].filter(o => o.startsWith(t)).map(o => o.replace(t, ""))[0]; return a || null }, rendered: !1 } } }, parseHTML() { return [{ tag: "pre", preserveWhitespace: "full" }] }, renderHTML({ node: n, HTMLAttributes: e }) { return ["pre", ti(this.options.HTMLAttributes, e), ["code", { class: n.attrs.language ? this.options.languageClassPrefix + n.attrs.language : null }, 0]] }, addCommands() { return { setCodeBlock: n => ({ commands: e }) => e.setNode(this.name, n), toggleCodeBlock: n => ({ commands: e }) => e.toggleNode(this.name, "paragraph", n) } }, addKeyboardShortcuts() {
    return {
      "Mod-Alt-c": () => this.editor.commands.toggleCodeBlock(), Backspace: () => { const { empty: n, $anchor: e } = this.editor.state.selection, t = e.pos === 1; return !n || e.parent.type.name !== this.name ? !1 : t || !e.parent.textContent.length ? this.editor.commands.clearNodes() : !1 }, Enter: ({ editor: n }) => {
        if (!this.options.exitOnTripleEnter) return !1; const { state: e } = n, { selection: t } = e, { $from: r, empty: i } = t; if (!i || r.parent.type !== this.type) return !1; const a = r.parentOffset === r.parent.nodeSize - 2, o = r.parent.textContent.endsWith(`

`); return !a || !o ? !1 : n.chain().command(({ tr: s }) => (s.delete(r.pos - 2, r.pos), !0)).exitCode().run()
      }, ArrowDown: ({ editor: n }) => { if (!this.options.exitOnArrowDown) return !1; const { state: e } = n, { selection: t, doc: r } = e, { $from: i, empty: a } = t; if (!a || i.parent.type !== this.type || !(i.parentOffset === i.parent.nodeSize - 2)) return !1; const s = i.after(); return s === void 0 ? !1 : r.nodeAt(s) ? n.commands.command(({ tr: c }) => (c.setSelection(vt.near(r.resolve(s))), !0)) : n.commands.exitCode() }
    }
  }, addInputRules() { return [rP({ find: Qje, type: this.type, getAttributes: n => ({ language: n[1] }) }), rP({ find: ePe, type: this.type, getAttributes: n => ({ language: n[1] }) })] }, addProseMirrorPlugins() {
    return [new wn({
      key: new xn("codeBlockVSCodeHandler"), props: {
        handlePaste: (n, e) => {
          if (!e.clipboardData || this.editor.isActive(this.type.name)) return !1; const t = e.clipboardData.getData("text/plain"), r = e.clipboardData.getData("vscode-editor-data"), i = r ? JSON.parse(r) : void 0, a = i == null ? void 0 : i.mode; if (!t || !a) return !1; const { tr: o, schema: s } = n.state, l = s.text(t.replace(/\r\n?/g, `
`)); return o.replaceSelectionWith(this.type.create({ language: a }, l)), o.selection.$from.parent.type !== this.type && o.setSelection(ht.near(o.doc.resolve(Math.max(0, o.selection.from - 2)))), o.setMeta("paste", !0), n.dispatch(o), !0
        }
      }
    })]
  }
}), nPe = Za.create({ name: "doc", topNode: !0, content: "block+" }); function rPe(n = {}) { return new wn({ view(e) { return new iPe(e, n) } }) } class iPe { constructor(e, t) { var r; this.editorView = e, this.cursorPos = null, this.element = null, this.timeout = -1, this.width = (r = t.width) !== null && r !== void 0 ? r : 1, this.color = t.color === !1 ? void 0 : t.color || "black", this.class = t.class, this.handlers = ["dragover", "dragend", "drop", "dragleave"].map(i => { let a = o => { this[i](o) }; return e.dom.addEventListener(i, a), { name: i, handler: a } }) } destroy() { this.handlers.forEach(({ name: e, handler: t }) => this.editorView.dom.removeEventListener(e, t)) } update(e, t) { this.cursorPos != null && t.doc != e.state.doc && (this.cursorPos > e.state.doc.content.size ? this.setCursor(null) : this.updateOverlay()) } setCursor(e) { e != this.cursorPos && (this.cursorPos = e, e == null ? (this.element.parentNode.removeChild(this.element), this.element = null) : this.updateOverlay()) } updateOverlay() { let e = this.editorView.state.doc.resolve(this.cursorPos), t = !e.parent.inlineContent, r; if (t) { let s = e.nodeBefore, l = e.nodeAfter; if (s || l) { let c = this.editorView.nodeDOM(this.cursorPos - (s ? s.nodeSize : 0)); if (c) { let u = c.getBoundingClientRect(), d = s ? u.bottom : u.top; s && l && (d = (d + this.editorView.nodeDOM(this.cursorPos).getBoundingClientRect().top) / 2), r = { left: u.left, right: u.right, top: d - this.width / 2, bottom: d + this.width / 2 } } } } if (!r) { let s = this.editorView.coordsAtPos(this.cursorPos); r = { left: s.left - this.width / 2, right: s.left + this.width / 2, top: s.top, bottom: s.bottom } } let i = this.editorView.dom.offsetParent; this.element || (this.element = i.appendChild(document.createElement("div")), this.class && (this.element.className = this.class), this.element.style.cssText = "position: absolute; z-index: 50; pointer-events: none;", this.color && (this.element.style.backgroundColor = this.color)), this.element.classList.toggle("prosemirror-dropcursor-block", t), this.element.classList.toggle("prosemirror-dropcursor-inline", !t); let a, o; if (!i || i == document.body && getComputedStyle(i).position == "static") a = -pageXOffset, o = -pageYOffset; else { let s = i.getBoundingClientRect(); a = s.left - i.scrollLeft, o = s.top - i.scrollTop } this.element.style.left = r.left - a + "px", this.element.style.top = r.top - o + "px", this.element.style.width = r.right - r.left + "px", this.element.style.height = r.bottom - r.top + "px" } scheduleRemoval(e) { clearTimeout(this.timeout), this.timeout = setTimeout(() => this.setCursor(null), e) } dragover(e) { if (!this.editorView.editable) return; let t = this.editorView.posAtCoords({ left: e.clientX, top: e.clientY }), r = t && t.inside >= 0 && this.editorView.state.doc.nodeAt(t.inside), i = r && r.type.spec.disableDropCursor, a = typeof i == "function" ? i(this.editorView, t, e) : i; if (t && !a) { let o = t.pos; if (this.editorView.dragging && this.editorView.dragging.slice) { let s = UZ(this.editorView.state.doc, o, this.editorView.dragging.slice); s != null && (o = s) } this.setCursor(o), this.scheduleRemoval(5e3) } } dragend() { this.scheduleRemoval(20) } drop() { this.scheduleRemoval(20) } dragleave(e) { (e.target == this.editorView.dom || !this.editorView.dom.contains(e.relatedTarget)) && this.setCursor(null) } } const aPe = Ya.create({ name: "dropCursor", addOptions() { return { color: "currentColor", width: 1, class: void 0 } }, addProseMirrorPlugins() { return [rPe(this.options)] } }); class hr extends vt { constructor(e) { super(e, e) } map(e, t) { let r = e.resolve(t.map(this.head)); return hr.valid(r) ? new hr(r) : vt.near(r) } content() { return Qe.empty } eq(e) { return e instanceof hr && e.head == this.head } toJSON() { return { type: "gapcursor", pos: this.head } } static fromJSON(e, t) { if (typeof t.pos != "number") throw new RangeError("Invalid input for GapCursor.fromJSON"); return new hr(e.resolve(t.pos)) } getBookmark() { return new JR(this.anchor) } static valid(e) { let t = e.parent; if (t.isTextblock || !oPe(e) || !sPe(e)) return !1; let r = t.type.spec.allowGapCursor; if (r != null) return r; let i = t.contentMatchAt(e.index()).defaultType; return i && i.isTextblock } static findGapCursorFrom(e, t, r = !1) { e: for (; ;) { if (!r && hr.valid(e)) return e; let i = e.pos, a = null; for (let o = e.depth; ; o--) { let s = e.node(o); if (t > 0 ? e.indexAfter(o) < s.childCount : e.index(o) > 0) { a = s.child(t > 0 ? e.indexAfter(o) : e.index(o) - 1); break } else if (o == 0) return null; i += t; let l = e.doc.resolve(i); if (hr.valid(l)) return l } for (; ;) { let o = t > 0 ? a.firstChild : a.lastChild; if (!o) { if (a.isAtom && !a.isText && !_t.isSelectable(a)) { e = e.doc.resolve(i + a.nodeSize * t), r = !1; continue e } break } a = o, i += t; let s = e.doc.resolve(i); if (hr.valid(s)) return s } return null } } } hr.prototype.visible = !1; hr.findFrom = hr.findGapCursorFrom; vt.jsonID("gapcursor", hr); class JR { constructor(e) { this.pos = e } map(e) { return new JR(e.map(this.pos)) } resolve(e) { let t = e.resolve(this.pos); return hr.valid(t) ? new hr(t) : vt.near(t) } } function oPe(n) { for (let e = n.depth; e >= 0; e--) { let t = n.index(e), r = n.node(e); if (t == 0) { if (r.type.spec.isolating) return !0; continue } for (let i = r.child(t - 1); ; i = i.lastChild) { if (i.childCount == 0 && !i.inlineContent || i.isAtom || i.type.spec.isolating) return !0; if (i.inlineContent) return !1 } } return !0 } function sPe(n) { for (let e = n.depth; e >= 0; e--) { let t = n.indexAfter(e), r = n.node(e); if (t == r.childCount) { if (r.type.spec.isolating) return !0; continue } for (let i = r.child(t); ; i = i.firstChild) { if (i.childCount == 0 && !i.inlineContent || i.isAtom || i.type.spec.isolating) return !0; if (i.inlineContent) return !1 } } return !0 } function lPe() { return new wn({ props: { decorations: fPe, createSelectionBetween(n, e, t) { return e.pos == t.pos && hr.valid(t) ? new hr(t) : null }, handleClick: uPe, handleKeyDown: cPe, handleDOMEvents: { beforeinput: dPe } } }) } const cPe = IR({ ArrowLeft: cw("horiz", -1), ArrowRight: cw("horiz", 1), ArrowUp: cw("vert", -1), ArrowDown: cw("vert", 1) }); function cw(n, e) { const t = n == "vert" ? e > 0 ? "down" : "up" : e > 0 ? "right" : "left"; return function (r, i, a) { let o = r.selection, s = e > 0 ? o.$to : o.$from, l = o.empty; if (o instanceof ht) { if (!a.endOfTextblock(t) || s.depth == 0) return !1; l = !1, s = r.doc.resolve(e > 0 ? s.after() : s.before()) } let c = hr.findGapCursorFrom(s, e, l); return c ? (i && i(r.tr.setSelection(new hr(c))), !0) : !1 } } function uPe(n, e, t) { if (!n || !n.editable) return !1; let r = n.state.doc.resolve(e); if (!hr.valid(r)) return !1; let i = n.posAtCoords({ left: t.clientX, top: t.clientY }); return i && i.inside > -1 && _t.isSelectable(n.state.doc.nodeAt(i.inside)) ? !1 : (n.dispatch(n.state.tr.setSelection(new hr(r))), !0) } function dPe(n, e) { if (e.inputType != "insertCompositionText" || !(n.state.selection instanceof hr)) return !1; let { $from: t } = n.state.selection, r = t.parent.contentMatchAt(t.index()).findWrapping(n.state.schema.nodes.text); if (!r) return !1; let i = Be.empty; for (let o = r.length - 1; o >= 0; o--)i = Be.from(r[o].createAndFill(null, i)); let a = n.state.tr.replace(t.pos, t.pos, new Qe(i, 0, 0)); return a.setSelection(ht.near(a.doc.resolve(t.pos + 1))), n.dispatch(a), !1 } function fPe(n) { if (!(n.selection instanceof hr)) return null; let e = document.createElement("div"); return e.className = "ProseMirror-gapcursor", Xn.create(n.doc, [di.widget(n.selection.head, e, { key: "gapcursor" })]) } const hPe = Ya.create({ name: "gapCursor", addProseMirrorPlugins() { return [lPe()] }, extendNodeSchema(n) { var e; const t = { name: n.name, options: n.options, storage: n.storage }; return { allowGapCursor: (e = zr(Di(n, "allowGapCursor", t))) !== null && e !== void 0 ? e : null } } }), pPe = Za.create({
  name: "hardBreak", addOptions() { return { keepMarks: !0, HTMLAttributes: {} } }, inline: !0, group: "inline", selectable: !1, parseHTML() { return [{ tag: "br" }] }, renderHTML({ HTMLAttributes: n }) { return ["br", ti(this.options.HTMLAttributes, n)] }, renderText() {
    return `
`}, addCommands() { return { setHardBreak: () => ({ commands: n, chain: e, state: t, editor: r }) => n.first([() => n.exitCode(), () => n.command(() => { const { selection: i, storedMarks: a } = t; if (i.$from.parent.type.spec.isolating) return !1; const { keepMarks: o } = this.options, { splittableMarks: s } = r.extensionManager, l = a || i.$to.parentOffset && i.$from.marks(); return e().insertContent({ type: this.name }).command(({ tr: c, dispatch: u }) => { if (u && l && o) { const d = l.filter(f => s.includes(f.type.name)); c.ensureMarks(d) } return !0 }).run() })]) } }, addKeyboardShortcuts() { return { "Mod-Enter": () => this.editor.commands.setHardBreak(), "Shift-Enter": () => this.editor.commands.setHardBreak() } }
}), mPe = Za.create({ name: "heading", addOptions() { return { levels: [1, 2, 3, 4, 5, 6], HTMLAttributes: {} } }, content: "inline*", group: "block", defining: !0, addAttributes() { return { level: { default: 1, rendered: !1 } } }, parseHTML() { return this.options.levels.map(n => ({ tag: `h${n}`, attrs: { level: n } })) }, renderHTML({ node: n, HTMLAttributes: e }) { return [`h${this.options.levels.includes(n.attrs.level) ? n.attrs.level : this.options.levels[0]}`, ti(this.options.HTMLAttributes, e), 0] }, addCommands() { return { setHeading: n => ({ commands: e }) => this.options.levels.includes(n.level) ? e.setNode(this.name, n) : !1, toggleHeading: n => ({ commands: e }) => this.options.levels.includes(n.level) ? e.toggleNode(this.name, "paragraph", n) : !1 } }, addKeyboardShortcuts() { return this.options.levels.reduce((n, e) => ({ ...n, [`Mod-Alt-${e}`]: () => this.editor.commands.toggleHeading({ level: e }) }), {}) }, addInputRules() { return this.options.levels.map(n => rP({ find: new RegExp(`^(#{1,${n}})\\s$`), type: this.type, getAttributes: { level: n } })) } }); var l2 = 200, Qr = function () { }; Qr.prototype.append = function (e) { return e.length ? (e = Qr.from(e), !this.length && e || e.length < l2 && this.leafAppend(e) || this.length < l2 && e.leafPrepend(this) || this.appendInner(e)) : this }; Qr.prototype.prepend = function (e) { return e.length ? Qr.from(e).append(this) : this }; Qr.prototype.appendInner = function (e) { return new gPe(this, e) }; Qr.prototype.slice = function (e, t) { return e === void 0 && (e = 0), t === void 0 && (t = this.length), e >= t ? Qr.empty : this.sliceInner(Math.max(0, e), Math.min(this.length, t)) }; Qr.prototype.get = function (e) { if (!(e < 0 || e >= this.length)) return this.getInner(e) }; Qr.prototype.forEach = function (e, t, r) { t === void 0 && (t = 0), r === void 0 && (r = this.length), t <= r ? this.forEachInner(e, t, r, 0) : this.forEachInvertedInner(e, t, r, 0) }; Qr.prototype.map = function (e, t, r) { t === void 0 && (t = 0), r === void 0 && (r = this.length); var i = []; return this.forEach(function (a, o) { return i.push(e(a, o)) }, t, r), i }; Qr.from = function (e) { return e instanceof Qr ? e : e && e.length ? new qJ(e) : Qr.empty }; var qJ = function (n) { function e(r) { n.call(this), this.values = r } n && (e.__proto__ = n), e.prototype = Object.create(n && n.prototype), e.prototype.constructor = e; var t = { length: { configurable: !0 }, depth: { configurable: !0 } }; return e.prototype.flatten = function () { return this.values }, e.prototype.sliceInner = function (i, a) { return i == 0 && a == this.length ? this : new e(this.values.slice(i, a)) }, e.prototype.getInner = function (i) { return this.values[i] }, e.prototype.forEachInner = function (i, a, o, s) { for (var l = a; l < o; l++)if (i(this.values[l], s + l) === !1) return !1 }, e.prototype.forEachInvertedInner = function (i, a, o, s) { for (var l = a - 1; l >= o; l--)if (i(this.values[l], s + l) === !1) return !1 }, e.prototype.leafAppend = function (i) { if (this.length + i.length <= l2) return new e(this.values.concat(i.flatten())) }, e.prototype.leafPrepend = function (i) { if (this.length + i.length <= l2) return new e(i.flatten().concat(this.values)) }, t.length.get = function () { return this.values.length }, t.depth.get = function () { return 0 }, Object.defineProperties(e.prototype, t), e }(Qr); Qr.empty = new qJ([]); var gPe = function (n) { function e(t, r) { n.call(this), this.left = t, this.right = r, this.length = t.length + r.length, this.depth = Math.max(t.depth, r.depth) + 1 } return n && (e.__proto__ = n), e.prototype = Object.create(n && n.prototype), e.prototype.constructor = e, e.prototype.flatten = function () { return this.left.flatten().concat(this.right.flatten()) }, e.prototype.getInner = function (r) { return r < this.left.length ? this.left.get(r) : this.right.get(r - this.left.length) }, e.prototype.forEachInner = function (r, i, a, o) { var s = this.left.length; if (i < s && this.left.forEachInner(r, i, Math.min(a, s), o) === !1 || a > s && this.right.forEachInner(r, Math.max(i - s, 0), Math.min(this.length, a) - s, o + s) === !1) return !1 }, e.prototype.forEachInvertedInner = function (r, i, a, o) { var s = this.left.length; if (i > s && this.right.forEachInvertedInner(r, i - s, Math.max(a, s) - s, o + s) === !1 || a < s && this.left.forEachInvertedInner(r, Math.min(i, s), a, o) === !1) return !1 }, e.prototype.sliceInner = function (r, i) { if (r == 0 && i == this.length) return this; var a = this.left.length; return i <= a ? this.left.slice(r, i) : r >= a ? this.right.slice(r - a, i - a) : this.left.slice(r, a).append(this.right.slice(0, i - a)) }, e.prototype.leafAppend = function (r) { var i = this.right.leafAppend(r); if (i) return new e(this.left, i) }, e.prototype.leafPrepend = function (r) { var i = this.left.leafPrepend(r); if (i) return new e(i, this.right) }, e.prototype.appendInner = function (r) { return this.left.depth >= Math.max(this.right.depth, r.depth) + 1 ? new e(this.left, new e(this.right, r)) : new e(this, r) }, e }(Qr); const vPe = 500; class ds { constructor(e, t) { this.items = e, this.eventCount = t } popEvent(e, t) { if (this.eventCount == 0) return null; let r = this.items.length; for (; ; r--)if (this.items.get(r - 1).selection) { --r; break } let i, a; t && (i = this.remapping(r, this.items.length), a = i.maps.length); let o = e.tr, s, l, c = [], u = []; return this.items.forEach((d, f) => { if (!d.step) { i || (i = this.remapping(r, f + 1), a = i.maps.length), a--, u.push(d); return } if (i) { u.push(new qs(d.map)); let h = d.step.map(i.slice(a)), p; h && o.maybeStep(h).doc && (p = o.mapping.maps[o.mapping.maps.length - 1], c.push(new qs(p, void 0, void 0, c.length + u.length))), a--, p && i.appendMap(p, a) } else o.maybeStep(d.step); if (d.selection) return s = i ? d.selection.map(i.slice(a)) : d.selection, l = new ds(this.items.slice(0, r).append(u.reverse().concat(c)), this.eventCount - 1), !1 }, this.items.length, 0), { remaining: l, transform: o, selection: s } } addTransform(e, t, r, i) { let a = [], o = this.eventCount, s = this.items, l = !i && s.length ? s.get(s.length - 1) : null; for (let u = 0; u < e.steps.length; u++) { let d = e.steps[u].invert(e.docs[u]), f = new qs(e.mapping.maps[u], d, t), h; (h = l && l.merge(f)) && (f = h, u ? a.pop() : s = s.slice(0, s.length - 1)), a.push(f), t && (o++, t = void 0), i || (l = f) } let c = o - r.depth; return c > _Pe && (s = yPe(s, c), o -= c), new ds(s.append(a), o) } remapping(e, t) { let r = new Um; return this.items.forEach((i, a) => { let o = i.mirrorOffset != null && a - i.mirrorOffset >= e ? r.maps.length - i.mirrorOffset : void 0; r.appendMap(i.map, o) }, e, t), r } addMaps(e) { return this.eventCount == 0 ? this : new ds(this.items.append(e.map(t => new qs(t))), this.eventCount) } rebased(e, t) { if (!this.eventCount) return this; let r = [], i = Math.max(0, this.items.length - t), a = e.mapping, o = e.steps.length, s = this.eventCount; this.items.forEach(f => { f.selection && s-- }, i); let l = t; this.items.forEach(f => { let h = a.getMirror(--l); if (h == null) return; o = Math.min(o, h); let p = a.maps[h]; if (f.step) { let m = e.steps[h].invert(e.docs[h]), g = f.selection && f.selection.map(a.slice(l + 1, h)); g && s++, r.push(new qs(p, m, g)) } else r.push(new qs(p)) }, i); let c = []; for (let f = t; f < o; f++)c.push(new qs(a.maps[f])); let u = this.items.slice(0, i).append(c).append(r), d = new ds(u, s); return d.emptyItemCount() > vPe && (d = d.compress(this.items.length - r.length)), d } emptyItemCount() { let e = 0; return this.items.forEach(t => { t.step || e++ }), e } compress(e = this.items.length) { let t = this.remapping(0, e), r = t.maps.length, i = [], a = 0; return this.items.forEach((o, s) => { if (s >= e) i.push(o), o.selection && a++; else if (o.step) { let l = o.step.map(t.slice(r)), c = l && l.getMap(); if (r--, c && t.appendMap(c, r), l) { let u = o.selection && o.selection.map(t.slice(r)); u && a++; let d = new qs(c.invert(), l, u), f, h = i.length - 1; (f = i.length && i[h].merge(d)) ? i[h] = f : i.push(d) } } else o.map && r-- }, this.items.length, 0), new ds(Qr.from(i.reverse()), a) } } ds.empty = new ds(Qr.empty, 0); function yPe(n, e) { let t; return n.forEach((r, i) => { if (r.selection && e-- == 0) return t = i, !1 }), n.slice(t) } class qs { constructor(e, t, r, i) { this.map = e, this.step = t, this.selection = r, this.mirrorOffset = i } merge(e) { if (this.step && e.step && !e.selection) { let t = e.step.merge(this.step); if (t) return new qs(t.getMap().invert(), t, this.selection) } } } class ku { constructor(e, t, r, i, a) { this.done = e, this.undone = t, this.prevRanges = r, this.prevTime = i, this.prevComposition = a } } const _Pe = 20; function bPe(n, e, t, r) { let i = t.getMeta(yh), a; if (i) return i.historyState; t.getMeta(SPe) && (n = new ku(n.done, n.undone, null, 0, -1)); let o = t.getMeta("appendedTransaction"); if (t.steps.length == 0) return n; if (o && o.getMeta(yh)) return o.getMeta(yh).redo ? new ku(n.done.addTransform(t, void 0, r, Hx(e)), n.undone, jz(t.mapping.maps), n.prevTime, n.prevComposition) : new ku(n.done, n.undone.addTransform(t, void 0, r, Hx(e)), null, n.prevTime, n.prevComposition); if (t.getMeta("addToHistory") !== !1 && !(o && o.getMeta("addToHistory") === !1)) { let s = t.getMeta("composition"), l = n.prevTime == 0 || !o && n.prevComposition != s && (n.prevTime < (t.time || 0) - r.newGroupDelay || !wPe(t, n.prevRanges)), c = o ? VE(n.prevRanges, t.mapping) : jz(t.mapping.maps); return new ku(n.done.addTransform(t, l ? e.selection.getBookmark() : void 0, r, Hx(e)), ds.empty, c, t.time, s ?? n.prevComposition) } else return (a = t.getMeta("rebased")) ? new ku(n.done.rebased(t, a), n.undone.rebased(t, a), VE(n.prevRanges, t.mapping), n.prevTime, n.prevComposition) : new ku(n.done.addMaps(t.mapping.maps), n.undone.addMaps(t.mapping.maps), VE(n.prevRanges, t.mapping), n.prevTime, n.prevComposition) } function wPe(n, e) { if (!e) return !1; if (!n.docChanged) return !0; let t = !1; return n.mapping.maps[0].forEach((r, i) => { for (let a = 0; a < e.length; a += 2)r <= e[a + 1] && i >= e[a] && (t = !0) }), t } function jz(n) { let e = []; for (let t = n.length - 1; t >= 0 && e.length == 0; t--)n[t].forEach((r, i, a, o) => e.push(a, o)); return e } function VE(n, e) { if (!n) return null; let t = []; for (let r = 0; r < n.length; r += 2) { let i = e.map(n[r], 1), a = e.map(n[r + 1], -1); i <= a && t.push(i, a) } return t } function xPe(n, e, t) { let r = Hx(e), i = yh.get(e).spec.config, a = (t ? n.undone : n.done).popEvent(e, r); if (!a) return null; let o = a.selection.resolve(a.transform.doc), s = (t ? n.done : n.undone).addTransform(a.transform, e.selection.getBookmark(), i, r), l = new ku(t ? s : a.remaining, t ? a.remaining : s, null, 0, -1); return a.transform.setSelection(o).setMeta(yh, { redo: t, historyState: l }) } let HE = !1, Pz = null; function Hx(n) { let e = n.plugins; if (Pz != e) { HE = !1, Pz = e; for (let t = 0; t < e.length; t++)if (e[t].spec.historyPreserveItems) { HE = !0; break } } return HE } const yh = new xn("history"), SPe = new xn("closeHistory"); function TPe(n = {}) { return n = { depth: n.depth || 100, newGroupDelay: n.newGroupDelay || 500 }, new wn({ key: yh, state: { init() { return new ku(ds.empty, ds.empty, null, 0, -1) }, apply(e, t, r) { return bPe(t, r, e, n) } }, config: n, props: { handleDOMEvents: { beforeinput(e, t) { let r = t.inputType, i = r == "historyUndo" ? ZJ : r == "historyRedo" ? XJ : null; return i ? (t.preventDefault(), i(e.state, e.dispatch)) : !1 } } } }) } function YJ(n, e) { return (t, r) => { let i = yh.getState(t); if (!i || (n ? i.undone : i.done).eventCount == 0) return !1; if (r) { let a = xPe(i, t, n); a && r(e ? a.scrollIntoView() : a) } return !0 } } const ZJ = YJ(!1, !0), XJ = YJ(!0, !0), kPe = Ya.create({ name: "history", addOptions() { return { depth: 100, newGroupDelay: 500 } }, addCommands() { return { undo: () => ({ state: n, dispatch: e }) => ZJ(n, e), redo: () => ({ state: n, dispatch: e }) => XJ(n, e) } }, addProseMirrorPlugins() { return [TPe(this.options)] }, addKeyboardShortcuts() { return { "Mod-z": () => this.editor.commands.undo(), "Shift-Mod-z": () => this.editor.commands.redo(), "Mod-y": () => this.editor.commands.redo(), "Mod-": () => this.editor.commands.undo(), "Shift-Mod-": () => this.editor.commands.redo() } } }), CPe = Za.create({ name: "horizontalRule", addOptions() { return { HTMLAttributes: {} } }, group: "block", parseHTML() { return [{ tag: "hr" }] }, renderHTML({ HTMLAttributes: n }) { return ["hr", ti(this.options.HTMLAttributes, n)] }, addCommands() { return { setHorizontalRule: () => ({ chain: n, state: e }) => { const { selection: t } = e, { $from: r, $to: i } = t, a = n(); return r.parentOffset === 0 ? a.insertContentAt({ from: Math.max(r.pos - 1, 0), to: i.pos }, { type: this.name }) : _je(t) ? a.insertContentAt(i.pos, { type: this.name }) : a.insertContent({ type: this.name }), a.command(({ tr: o, dispatch: s }) => { var l; if (s) { const { $to: c } = o.selection, u = c.end(); if (c.nodeAfter) c.nodeAfter.isTextblock ? o.setSelection(ht.create(o.doc, c.pos + 1)) : c.nodeAfter.isBlock ? o.setSelection(_t.create(o.doc, c.pos)) : o.setSelection(ht.create(o.doc, c.pos)); else { const d = (l = c.parent.type.contentMatch.defaultType) === null || l === void 0 ? void 0 : l.create(); d && (o.insert(u, d), o.setSelection(ht.create(o.doc, u + 1))) } o.scrollIntoView() } return !0 }).run() } } }, addInputRules() { return [Fje({ find: /^(?:---|-|___\s|\*\*\*\s)$/, type: this.type })] } }), APe = /(?:^|\s)(\*(?!\s+\*)((?:[^*]+))\*(?!\s+\*))$/, EPe = /(?:^|\s)(\*(?!\s+\*)((?:[^*]+))\*(?!\s+\*))/g, MPe = /(?:^|\s)(_(?!\s+_)((?:[^_]+))_(?!\s+_))$/, OPe = /(?:^|\s)(_(?!\s+_)((?:[^_]+))_(?!\s+_))/g, DPe = Gg.create({ name: "italic", addOptions() { return { HTMLAttributes: {} } }, parseHTML() { return [{ tag: "em" }, { tag: "i", getAttrs: n => n.style.fontStyle !== "normal" && null }, { style: "font-style=italic" }] }, renderHTML({ HTMLAttributes: n }) { return ["em", ti(this.options.HTMLAttributes, n), 0] }, addCommands() { return { setItalic: () => ({ commands: n }) => n.setMark(this.name), toggleItalic: () => ({ commands: n }) => n.toggleMark(this.name), unsetItalic: () => ({ commands: n }) => n.unsetMark(this.name) } }, addKeyboardShortcuts() { return { "Mod-i": () => this.editor.commands.toggleItalic(), "Mod-I": () => this.editor.commands.toggleItalic() } }, addInputRules() { return [bg({ find: APe, type: this.type }), bg({ find: MPe, type: this.type })] }, addPasteRules() { return [wg({ find: EPe, type: this.type }), wg({ find: OPe, type: this.type })] } }), jPe = Za.create({ name: "listItem", addOptions() { return { HTMLAttributes: {}, bulletListTypeName: "bulletList", orderedListTypeName: "orderedList" } }, content: "paragraph block*", defining: !0, parseHTML() { return [{ tag: "li" }] }, renderHTML({ HTMLAttributes: n }) { return ["li", ti(this.options.HTMLAttributes, n), 0] }, addKeyboardShortcuts() { return { Enter: () => this.editor.commands.splitListItem(this.name), Tab: () => this.editor.commands.sinkListItem(this.name), "Shift-Tab": () => this.editor.commands.liftListItem(this.name) } } }), PPe = Za.create({ name: "listItem", addOptions() { return { HTMLAttributes: {}, bulletListTypeName: "bulletList", orderedListTypeName: "orderedList" } }, content: "paragraph block*", defining: !0, parseHTML() { return [{ tag: "li" }] }, renderHTML({ HTMLAttributes: n }) { return ["li", ti(this.options.HTMLAttributes, n), 0] }, addKeyboardShortcuts() { return { Enter: () => this.editor.commands.splitListItem(this.name), Tab: () => this.editor.commands.sinkListItem(this.name), "Shift-Tab": () => this.editor.commands.liftListItem(this.name) } } }), Iz = Gg.create({ name: "textStyle", priority: 101, addOptions() { return { HTMLAttributes: {} } }, parseHTML() { return [{ tag: "span", getAttrs: n => n.hasAttribute("style") ? {} : !1 }] }, renderHTML({ HTMLAttributes: n }) { return ["span", ti(this.options.HTMLAttributes, n), 0] }, addCommands() { return { removeEmptyTextStyle: () => ({ state: n, commands: e }) => { const t = ZR(n, this.type); return Object.entries(t).some(([, i]) => !!i) ? !0 : e.unsetMark(this.name) } } } }), Lz = /^(\d+)\.\s$/, IPe = Za.create({ name: "orderedList", addOptions() { return { itemTypeName: "listItem", HTMLAttributes: {}, keepMarks: !1, keepAttributes: !1 } }, group: "block list", content() { return `${this.options.itemTypeName}+` }, addAttributes() { return { start: { default: 1, parseHTML: n => n.hasAttribute("start") ? parseInt(n.getAttribute("start") || "", 10) : 1 }, type: { default: void 0, parseHTML: n => n.getAttribute("type") } } }, parseHTML() { return [{ tag: "ol" }] }, renderHTML({ HTMLAttributes: n }) { const { start: e, ...t } = n; return e === 1 ? ["ol", ti(this.options.HTMLAttributes, t), 0] : ["ol", ti(this.options.HTMLAttributes, n), 0] }, addCommands() { return { toggleOrderedList: () => ({ commands: n, chain: e }) => this.options.keepAttributes ? e().toggleList(this.name, this.options.itemTypeName, this.options.keepMarks).updateAttributes(PPe.name, this.editor.getAttributes(Iz.name)).run() : n.toggleList(this.name, this.options.itemTypeName, this.options.keepMarks) } }, addKeyboardShortcuts() { return { "Mod-Shift-7": () => this.editor.commands.toggleOrderedList() } }, addInputRules() { let n = r_({ find: Lz, type: this.type, getAttributes: e => ({ start: +e[1] }), joinPredicate: (e, t) => t.childCount + t.attrs.start === +e[1] }); return (this.options.keepMarks || this.options.keepAttributes) && (n = r_({ find: Lz, type: this.type, keepMarks: this.options.keepMarks, keepAttributes: this.options.keepAttributes, getAttributes: e => ({ start: +e[1], ...this.editor.getAttributes(Iz.name) }), joinPredicate: (e, t) => t.childCount + t.attrs.start === +e[1], editor: this.editor })), [n] } }), LPe = Za.create({ name: "paragraph", priority: 1e3, addOptions() { return { HTMLAttributes: {} } }, group: "block", content: "inline*", parseHTML() { return [{ tag: "p" }] }, renderHTML({ HTMLAttributes: n }) { return ["p", ti(this.options.HTMLAttributes, n), 0] }, addCommands() { return { setParagraph: () => ({ commands: n }) => n.setNode(this.name) } }, addKeyboardShortcuts() { return { "Mod-Alt-0": () => this.editor.commands.setParagraph() } } }), RPe = /(?:^|\s)(~~(?!\s+~~)((?:[^~]+))~~(?!\s+~~))$/, NPe = /(?:^|\s)(~~(?!\s+~~)((?:[^~]+))~~(?!\s+~~))/g, BPe = Gg.create({ name: "strike", addOptions() { return { HTMLAttributes: {} } }, parseHTML() { return [{ tag: "s" }, { tag: "del" }, { tag: "strike" }, { style: "text-decoration", consuming: !1, getAttrs: n => n.includes("line-through") ? {} : !1 }] }, renderHTML({ HTMLAttributes: n }) { return ["s", ti(this.options.HTMLAttributes, n), 0] }, addCommands() { return { setStrike: () => ({ commands: n }) => n.setMark(this.name), toggleStrike: () => ({ commands: n }) => n.toggleMark(this.name), unsetStrike: () => ({ commands: n }) => n.unsetMark(this.name) } }, addKeyboardShortcuts() { return { "Mod-Shift-s": () => this.editor.commands.toggleStrike() } }, addInputRules() { return [bg({ find: RPe, type: this.type })] }, addPasteRules() { return [wg({ find: NPe, type: this.type })] } }), $Pe = Za.create({ name: "text", group: "inline" }), FPe = Ya.create({ name: "starterKit", addExtensions() { var n, e, t, r, i, a, o, s, l, c, u, d, f, h, p, m, g, y; const b = []; return this.options.bold !== !1 && b.push(Kje.configure((n = this.options) === null || n === void 0 ? void 0 : n.bold)), this.options.blockquote !== !1 && b.push(Vje.configure((e = this.options) === null || e === void 0 ? void 0 : e.blockquote)), this.options.bulletList !== !1 && b.push(Yje.configure((t = this.options) === null || t === void 0 ? void 0 : t.bulletList)), this.options.code !== !1 && b.push(Jje.configure((r = this.options) === null || r === void 0 ? void 0 : r.code)), this.options.codeBlock !== !1 && b.push(tPe.configure((i = this.options) === null || i === void 0 ? void 0 : i.codeBlock)), this.options.document !== !1 && b.push(nPe.configure((a = this.options) === null || a === void 0 ? void 0 : a.document)), this.options.dropcursor !== !1 && b.push(aPe.configure((o = this.options) === null || o === void 0 ? void 0 : o.dropcursor)), this.options.gapcursor !== !1 && b.push(hPe.configure((s = this.options) === null || s === void 0 ? void 0 : s.gapcursor)), this.options.hardBreak !== !1 && b.push(pPe.configure((l = this.options) === null || l === void 0 ? void 0 : l.hardBreak)), this.options.heading !== !1 && b.push(mPe.configure((c = this.options) === null || c === void 0 ? void 0 : c.heading)), this.options.history !== !1 && b.push(kPe.configure((u = this.options) === null || u === void 0 ? void 0 : u.history)), this.options.horizontalRule !== !1 && b.push(CPe.configure((d = this.options) === null || d === void 0 ? void 0 : d.horizontalRule)), this.options.italic !== !1 && b.push(DPe.configure((f = this.options) === null || f === void 0 ? void 0 : f.italic)), this.options.listItem !== !1 && b.push(jPe.configure((h = this.options) === null || h === void 0 ? void 0 : h.listItem)), this.options.orderedList !== !1 && b.push(IPe.configure((p = this.options) === null || p === void 0 ? void 0 : p.orderedList)), this.options.paragraph !== !1 && b.push(LPe.configure((m = this.options) === null || m === void 0 ? void 0 : m.paragraph)), this.options.strike !== !1 && b.push(BPe.configure((g = this.options) === null || g === void 0 ? void 0 : g.strike)), this.options.text !== !1 && b.push($Pe.configure((y = this.options) === null || y === void 0 ? void 0 : y.text)), b } }); var zPe = "tippy-box", JJ = "tippy-content", VPe = "tippy-backdrop", QJ = "tippy-arrow", eQ = "tippy-svg-arrow", Pf = { passive: !0, capture: !0 }, tQ = function () { return document.body }; function UE(n, e, t) { if (Array.isArray(n)) { var r = n[e]; return r ?? (Array.isArray(t) ? t[e] : t) } return n } function QR(n, e) { var t = {}.toString.call(n); return t.indexOf("[object") === 0 && t.indexOf(e + "]") > -1 } function nQ(n, e) { return typeof n == "function" ? n.apply(void 0, e) : n } function Rz(n, e) { if (e === 0) return n; var t; return function (r) { clearTimeout(t), t = setTimeout(function () { n(r) }, e) } } function HPe(n) { return n.split(/\s+/).filter(Boolean) } function vm(n) { return [].concat(n) } function Nz(n, e) { n.indexOf(e) === -1 && n.push(e) } function UPe(n) { return n.filter(function (e, t) { return n.indexOf(e) === t }) } function GPe(n) { return n.split("-")[0] } function c2(n) { return [].slice.call(n) } function Bz(n) { return Object.keys(n).reduce(function (e, t) { return n[t] !== void 0 && (e[t] = n[t]), e }, {}) } function i0() { return document.createElement("div") } function zk(n) { return ["Element", "Fragment"].some(function (e) { return QR(n, e) }) } function WPe(n) { return QR(n, "NodeList") } function KPe(n) { return QR(n, "MouseEvent") } function qPe(n) { return !!(n && n._tippy && n._tippy.reference === n) } function YPe(n) { return zk(n) ? [n] : WPe(n) ? c2(n) : Array.isArray(n) ? n : c2(document.querySelectorAll(n)) } function GE(n, e) { n.forEach(function (t) { t && (t.style.transitionDuration = e + "ms") }) } function $z(n, e) { n.forEach(function (t) { t && t.setAttribute("data-state", e) }) } function ZPe(n) { var e, t = vm(n), r = t[0]; return r != null && (e = r.ownerDocument) != null && e.body ? r.ownerDocument : document } function XPe(n, e) { var t = e.clientX, r = e.clientY; return n.every(function (i) { var a = i.popperRect, o = i.popperState, s = i.props, l = s.interactiveBorder, c = GPe(o.placement), u = o.modifiersData.offset; if (!u) return !0; var d = c === "bottom" ? u.top.y : 0, f = c === "top" ? u.bottom.y : 0, h = c === "right" ? u.left.x : 0, p = c === "left" ? u.right.x : 0, m = a.top - r + d > l, g = r - a.bottom - f > l, y = a.left - t + h > l, b = t - a.right - p > l; return m || g || y || b }) } function WE(n, e, t) { var r = e + "EventListener";["transitionend", "webkitTransitionEnd"].forEach(function (i) { n[r](i, t) }) } function Fz(n, e) { for (var t = e; t;) { var r; if (n.contains(t)) return !0; t = t.getRootNode == null || (r = t.getRootNode()) == null ? void 0 : r.host } return !1 } var el = { isTouch: !1 }, zz = 0; function JPe() { el.isTouch || (el.isTouch = !0, window.performance && document.addEventListener("mousemove", rQ)) } function rQ() { var n = performance.now(); n - zz < 20 && (el.isTouch = !1, document.removeEventListener("mousemove", rQ)), zz = n } function QPe() { var n = document.activeElement; if (qPe(n)) { var e = n._tippy; n.blur && !e.state.isVisible && n.blur() } } function eIe() { document.addEventListener("touchstart", JPe, Pf), window.addEventListener("blur", QPe) } var tIe = typeof window < "u" && typeof document < "u", nIe = tIe ? !!window.msCrypto : !1, rIe = { animateFill: !1, followCursor: !1, inlinePositioning: !1, sticky: !1 }, iIe = { allowHTML: !1, animation: "fade", arrow: !0, content: "", inertia: !1, maxWidth: 350, role: "tooltip", theme: "", zIndex: 9999 }, hs = Object.assign({ appendTo: tQ, aria: { content: "auto", expanded: "auto" }, delay: 0, duration: [300, 250], getReferenceClientRect: null, hideOnClick: !0, ignoreAttributes: !1, interactive: !1, interactiveBorder: 2, interactiveDebounce: 0, moveTransition: "", offset: [0, 10], onAfterUpdate: function () { }, onBeforeUpdate: function () { }, onCreate: function () { }, onDestroy: function () { }, onHidden: function () { }, onHide: function () { }, onMount: function () { }, onShow: function () { }, onShown: function () { }, onTrigger: function () { }, onUntrigger: function () { }, onClickOutside: function () { }, placement: "top", plugins: [], popperOptions: {}, render: null, showOnCreate: !1, touch: !0, trigger: "mouseenter focus", triggerTarget: null }, rIe, iIe), aIe = Object.keys(hs), oIe = function (e) { var t = Object.keys(e); t.forEach(function (r) { hs[r] = e[r] }) }; function iQ(n) { var e = n.plugins || [], t = e.reduce(function (r, i) { var a = i.name, o = i.defaultValue; if (a) { var s; r[a] = n[a] !== void 0 ? n[a] : (s = hs[a]) != null ? s : o } return r }, {}); return Object.assign({}, n, t) } function sIe(n, e) { var t = e ? Object.keys(iQ(Object.assign({}, hs, { plugins: e }))) : aIe, r = t.reduce(function (i, a) { var o = (n.getAttribute("data-tippy-" + a) || "").trim(); if (!o) return i; if (a === "content") i[a] = o; else try { i[a] = JSON.parse(o) } catch { i[a] = o } return i }, {}); return r } function Vz(n, e) { var t = Object.assign({}, e, { content: nQ(e.content, [n]) }, e.ignoreAttributes ? {} : sIe(n, e.plugins)); return t.aria = Object.assign({}, hs.aria, t.aria), t.aria = { expanded: t.aria.expanded === "auto" ? e.interactive : t.aria.expanded, content: t.aria.content === "auto" ? e.interactive ? null : "describedby" : t.aria.content }, t } var lIe = function () { return "innerHTML" }; function oP(n, e) { n[lIe()] = e } function Hz(n) { var e = i0(); return n === !0 ? e.className = QJ : (e.className = eQ, zk(n) ? e.appendChild(n) : oP(e, n)), e } function Uz(n, e) { zk(e.content) ? (oP(n, ""), n.appendChild(e.content)) : typeof e.content != "function" && (e.allowHTML ? oP(n, e.content) : n.textContent = e.content) } function sP(n) { var e = n.firstElementChild, t = c2(e.children); return { box: e, content: t.find(function (r) { return r.classList.contains(JJ) }), arrow: t.find(function (r) { return r.classList.contains(QJ) || r.classList.contains(eQ) }), backdrop: t.find(function (r) { return r.classList.contains(VPe) }) } } function aQ(n) { var e = i0(), t = i0(); t.className = zPe, t.setAttribute("data-state", "hidden"), t.setAttribute("tabindex", "-1"); var r = i0(); r.className = JJ, r.setAttribute("data-state", "hidden"), Uz(r, n.props), e.appendChild(t), t.appendChild(r), i(n.props, n.props); function i(a, o) { var s = sP(e), l = s.box, c = s.content, u = s.arrow; o.theme ? l.setAttribute("data-theme", o.theme) : l.removeAttribute("data-theme"), typeof o.animation == "string" ? l.setAttribute("data-animation", o.animation) : l.removeAttribute("data-animation"), o.inertia ? l.setAttribute("data-inertia", "") : l.removeAttribute("data-inertia"), l.style.maxWidth = typeof o.maxWidth == "number" ? o.maxWidth + "px" : o.maxWidth, o.role ? l.setAttribute("role", o.role) : l.removeAttribute("role"), (a.content !== o.content || a.allowHTML !== o.allowHTML) && Uz(c, n.props), o.arrow ? u ? a.arrow !== o.arrow && (l.removeChild(u), l.appendChild(Hz(o.arrow))) : l.appendChild(Hz(o.arrow)) : u && l.removeChild(u) } return { popper: e, onUpdate: i } } aQ.$$tippy = !0; var cIe = 1, uw = [], KE = []; function uIe(n, e) { var t = Vz(n, Object.assign({}, hs, iQ(Bz(e)))), r, i, a, o = !1, s = !1, l = !1, c = !1, u, d, f, h = [], p = Rz(q, t.interactiveDebounce), m, g = cIe++, y = null, b = UPe(t.plugins), w = { isEnabled: !0, isVisible: !1, isDestroyed: !1, isMounted: !1, isShown: !1 }, v = { id: g, reference: n, popper: i0(), popperInstance: y, props: t, state: w, plugins: b, clearDelayTimeouts: Ee, setProps: ce, setContent: Te, show: Le, hide: st, hideWithInteractivity: jt, enable: ze, disable: Xe, unmount: Dn, destroy: rr }; if (!t.render) return v; var S = t.render(v), x = S.popper, k = S.onUpdate; x.setAttribute("data-tippy-root", ""), x.id = "tippy-" + v.id, v.popper = x, n._tippy = v, x._tippy = v; var A = b.map(function (Ce) { return Ce.fn(v) }), C = n.hasAttribute("aria-expanded"); return _e(), K(), P(), B("onCreate", [v]), t.showOnCreate && Se(), x.addEventListener("mouseenter", function () { v.props.interactive && v.state.isVisible && v.clearDelayTimeouts() }), x.addEventListener("mouseleave", function () { v.props.interactive && v.props.trigger.indexOf("mouseenter") >= 0 && L().addEventListener("mousemove", p) }), v; function E() { var Ce = v.props.touch; return Array.isArray(Ce) ? Ce : [Ce, 0] } function O() { return E()[0] === "hold" } function j() { var Ce; return !!((Ce = v.props.render) != null && Ce.$$tippy) } function I() { return m || n } function L() { var Ce = I().parentNode; return Ce ? ZPe(Ce) : document } function R() { return sP(x) } function D(Ce) { return v.state.isMounted && !v.state.isVisible || el.isTouch || u && u.type === "focus" ? 0 : UE(v.props.delay, Ce ? 0 : 1, hs.delay) } function P(Ce) { Ce === void 0 && (Ce = !1), x.style.pointerEvents = v.props.interactive && !Ce ? "" : "none", x.style.zIndex = "" + v.props.zIndex } function B(Ce, it, ct) { if (ct === void 0 && (ct = !0), A.forEach(function (sn) { sn[Ce] && sn[Ce].apply(sn, it) }), ct) { var $t; ($t = v.props)[Ce].apply($t, it) } } function F() { var Ce = v.props.aria; if (Ce.content) { var it = "aria-" + Ce.content, ct = x.id, $t = vm(v.props.triggerTarget || n); $t.forEach(function (sn) { var ni = sn.getAttribute(it); if (v.state.isVisible) sn.setAttribute(it, ni ? ni + " " + ct : ct); else { var sa = ni && ni.replace(ct, "").trim(); sa ? sn.setAttribute(it, sa) : sn.removeAttribute(it) } }) } } function K() { if (!(C || !v.props.aria.expanded)) { var Ce = vm(v.props.triggerTarget || n); Ce.forEach(function (it) { v.props.interactive ? it.setAttribute("aria-expanded", v.state.isVisible && it === I() ? "true" : "false") : it.removeAttribute("aria-expanded") }) } } function V() { L().removeEventListener("mousemove", p), uw = uw.filter(function (Ce) { return Ce !== p }) } function W(Ce) { if (!(el.isTouch && (l || Ce.type === "mousedown"))) { var it = Ce.composedPath && Ce.composedPath()[0] || Ce.target; if (!(v.props.interactive && Fz(x, it))) { if (vm(v.props.triggerTarget || n).some(function (ct) { return Fz(ct, it) })) { if (el.isTouch || v.state.isVisible && v.props.trigger.indexOf("click") >= 0) return } else B("onClickOutside", [v, Ce]); v.props.hideOnClick === !0 && (v.clearDelayTimeouts(), v.hide(), s = !0, setTimeout(function () { s = !1 }), v.state.isMounted || De()) } } } function J() { l = !0 } function ie() { l = !1 } function le() { var Ce = L(); Ce.addEventListener("mousedown", W, !0), Ce.addEventListener("touchend", W, Pf), Ce.addEventListener("touchstart", ie, Pf), Ce.addEventListener("touchmove", J, Pf) } function De() { var Ce = L(); Ce.removeEventListener("mousedown", W, !0), Ce.removeEventListener("touchend", W, Pf), Ce.removeEventListener("touchstart", ie, Pf), Ce.removeEventListener("touchmove", J, Pf) } function ae(Ce, it) { se(Ce, function () { !v.state.isVisible && x.parentNode && x.parentNode.contains(x) && it() }) } function pe(Ce, it) { se(Ce, it) } function se(Ce, it) { var ct = R().box; function $t(sn) { sn.target === ct && (WE(ct, "remove", $t), it()) } if (Ce === 0) return it(); WE(ct, "remove", d), WE(ct, "add", $t), d = $t } function ge(Ce, it, ct) { ct === void 0 && (ct = !1); var $t = vm(v.props.triggerTarget || n); $t.forEach(function (sn) { sn.addEventListener(Ce, it, ct), h.push({ node: sn, eventType: Ce, handler: it, options: ct }) }) } function _e() { O() && (ge("touchstart", U, { passive: !0 }), ge("touchend", ee, { passive: !0 })), HPe(v.props.trigger).forEach(function (Ce) { if (Ce !== "manual") switch (ge(Ce, U), Ce) { case "mouseenter": ge("mouseleave", ee); break; case "focus": ge(nIe ? "focusout" : "blur", de); break; case "focusin": ge("focusout", de); break } }) } function je() { h.forEach(function (Ce) { var it = Ce.node, ct = Ce.eventType, $t = Ce.handler, sn = Ce.options; it.removeEventListener(ct, $t, sn) }), h = [] } function U(Ce) { var it, ct = !1; if (!(!v.state.isEnabled || me(Ce) || s)) { var $t = ((it = u) == null ? void 0 : it.type) === "focus"; u = Ce, m = Ce.currentTarget, K(), !v.state.isVisible && KPe(Ce) && uw.forEach(function (sn) { return sn(Ce) }), Ce.type === "click" && (v.props.trigger.indexOf("mouseenter") < 0 || o) && v.props.hideOnClick !== !1 && v.state.isVisible ? ct = !0 : Se(Ce), Ce.type === "click" && (o = !ct), ct && !$t && Ke(Ce) } } function q(Ce) { var it = Ce.target, ct = I().contains(it) || x.contains(it); if (!(Ce.type === "mousemove" && ct)) { var $t = ve().concat(x).map(function (sn) { var ni, sa = sn._tippy, Rl = (ni = sa.popperInstance) == null ? void 0 : ni.state; return Rl ? { popperRect: sn.getBoundingClientRect(), popperState: Rl, props: t } : null }).filter(Boolean); XPe($t, Ce) && (V(), Ke(Ce)) } } function ee(Ce) { var it = me(Ce) || v.props.trigger.indexOf("click") >= 0 && o; if (!it) { if (v.props.interactive) { v.hideWithInteractivity(Ce); return } Ke(Ce) } } function de(Ce) { v.props.trigger.indexOf("focusin") < 0 && Ce.target !== I() || v.props.interactive && Ce.relatedTarget && x.contains(Ce.relatedTarget) || Ke(Ce) } function me(Ce) { return el.isTouch ? O() !== Ce.type.indexOf("touch") >= 0 : !1 } function fe() { we(); var Ce = v.props, it = Ce.popperOptions, ct = Ce.placement, $t = Ce.offset, sn = Ce.getReferenceClientRect, ni = Ce.moveTransition, sa = j() ? sP(x).arrow : null, Rl = sn ? { getBoundingClientRect: sn, contextElement: sn.contextElement || I() } : n, dv = { name: "$$tippy", enabled: !0, phase: "beforeWrite", requires: ["computeStyles"], fn: function (hp) { var Gc = hp.state; if (j()) { var zb = R(), hv = zb.box;["placement", "reference-hidden", "escaped"].forEach(function (pp) { pp === "placement" ? hv.setAttribute("data-placement", Gc.placement) : Gc.attributes.popper["data-popper-" + pp] ? hv.setAttribute("data-" + pp, "") : hv.removeAttribute("data-" + pp) }), Gc.attributes.popper = {} } } }, Nl = [{ name: "offset", options: { offset: $t } }, { name: "preventOverflow", options: { padding: { top: 2, bottom: 2, left: 5, right: 5 } } }, { name: "flip", options: { padding: 5 } }, { name: "computeStyles", options: { adaptive: !ni } }, dv]; j() && sa && Nl.push({ name: "arrow", options: { element: sa, padding: 3 } }), Nl.push.apply(Nl, (it == null ? void 0 : it.modifiers) || []), v.popperInstance = pY(Rl, x, Object.assign({}, it, { placement: ct, onFirstUpdate: f, modifiers: Nl })) } function we() { v.popperInstance && (v.popperInstance.destroy(), v.popperInstance = null) } function Oe() { var Ce = v.props.appendTo, it, ct = I(); v.props.interactive && Ce === tQ || Ce === "parent" ? it = ct.parentNode : it = nQ(Ce, [ct]), it.contains(x) || it.appendChild(x), v.state.isMounted = !0, fe() } function ve() { return c2(x.querySelectorAll("[data-tippy-root]")) } function Se(Ce) { v.clearDelayTimeouts(), Ce && B("onTrigger", [v, Ce]), le(); var it = D(!0), ct = E(), $t = ct[0], sn = ct[1]; el.isTouch && $t === "hold" && sn && (it = sn), it ? r = setTimeout(function () { v.show() }, it) : v.show() } function Ke(Ce) { if (v.clearDelayTimeouts(), B("onUntrigger", [v, Ce]), !v.state.isVisible) { De(); return } if (!(v.props.trigger.indexOf("mouseenter") >= 0 && v.props.trigger.indexOf("click") >= 0 && ["mouseleave", "mousemove"].indexOf(Ce.type) >= 0 && o)) { var it = D(!1); it ? i = setTimeout(function () { v.state.isVisible && v.hide() }, it) : a = requestAnimationFrame(function () { v.hide() }) } } function ze() { v.state.isEnabled = !0 } function Xe() { v.hide(), v.state.isEnabled = !1 } function Ee() { clearTimeout(r), clearTimeout(i), cancelAnimationFrame(a) } function ce(Ce) { if (!v.state.isDestroyed) { B("onBeforeUpdate", [v, Ce]), je(); var it = v.props, ct = Vz(n, Object.assign({}, it, Bz(Ce), { ignoreAttributes: !0 })); v.props = ct, _e(), it.interactiveDebounce !== ct.interactiveDebounce && (V(), p = Rz(q, ct.interactiveDebounce)), it.triggerTarget && !ct.triggerTarget ? vm(it.triggerTarget).forEach(function ($t) { $t.removeAttribute("aria-expanded") }) : ct.triggerTarget && n.removeAttribute("aria-expanded"), K(), P(), k && k(it, ct), v.popperInstance && (fe(), ve().forEach(function ($t) { requestAnimationFrame($t._tippy.popperInstance.forceUpdate) })), B("onAfterUpdate", [v, Ce]) } } function Te(Ce) { v.setProps({ content: Ce }) } function Le() { var Ce = v.state.isVisible, it = v.state.isDestroyed, ct = !v.state.isEnabled, $t = el.isTouch && !v.props.touch, sn = UE(v.props.duration, 0, hs.duration); if (!(Ce || it || ct || $t) && !I().hasAttribute("disabled") && (B("onShow", [v], !1), v.props.onShow(v) !== !1)) { if (v.state.isVisible = !0, j() && (x.style.visibility = "visible"), P(), le(), v.state.isMounted || (x.style.transition = "none"), j()) { var ni = R(), sa = ni.box, Rl = ni.content; GE([sa, Rl], 0) } f = function () { var Nl; if (!(!v.state.isVisible || c)) { if (c = !0, x.offsetHeight, x.style.transition = v.props.moveTransition, j() && v.props.animation) { var fv = R(), hp = fv.box, Gc = fv.content; GE([hp, Gc], sn), $z([hp, Gc], "visible") } F(), K(), Nz(KE, v), (Nl = v.popperInstance) == null || Nl.forceUpdate(), B("onMount", [v]), v.props.animation && j() && pe(sn, function () { v.state.isShown = !0, B("onShown", [v]) }) } }, Oe() } } function st() { var Ce = !v.state.isVisible, it = v.state.isDestroyed, ct = !v.state.isEnabled, $t = UE(v.props.duration, 1, hs.duration); if (!(Ce || it || ct) && (B("onHide", [v], !1), v.props.onHide(v) !== !1)) { if (v.state.isVisible = !1, v.state.isShown = !1, c = !1, o = !1, j() && (x.style.visibility = "hidden"), V(), De(), P(!0), j()) { var sn = R(), ni = sn.box, sa = sn.content; v.props.animation && (GE([ni, sa], $t), $z([ni, sa], "hidden")) } F(), K(), v.props.animation ? j() && ae($t, v.unmount) : v.unmount() } } function jt(Ce) { L().addEventListener("mousemove", p), Nz(uw, p), p(Ce) } function Dn() { v.state.isVisible && v.hide(), v.state.isMounted && (we(), ve().forEach(function (Ce) { Ce._tippy.unmount() }), x.parentNode && x.parentNode.removeChild(x), KE = KE.filter(function (Ce) { return Ce !== v }), v.state.isMounted = !1, B("onHidden", [v])) } function rr() { v.state.isDestroyed || (v.clearDelayTimeouts(), v.unmount(), je(), delete n._tippy, v.state.isDestroyed = !0, B("onDestroy", [v])) } } function zc(n, e) { e === void 0 && (e = {}); var t = hs.plugins.concat(e.plugins || []); eIe(); var r = Object.assign({}, e, { plugins: t }), i = YPe(n), a = i.reduce(function (o, s) { var l = s && uIe(s, r); return l && o.push(l), o }, []); return zk(n) ? a[0] : a } zc.defaultProps = hs; zc.setDefaultProps = oIe; zc.currentInput = el; Object.assign({}, oY, { effect: function (e) { var t = e.state, r = { popper: { position: t.options.strategy, left: "0", top: "0", margin: "0" }, arrow: { position: "absolute" }, reference: {} }; Object.assign(t.elements.popper.style, r.popper), t.styles = r, t.elements.arrow && Object.assign(t.elements.arrow.style, r.arrow) } }); zc.setDefaultProps({ render: aQ }); class dIe { constructor({ editor: e, element: t, view: r, tippyOptions: i = {}, updateDelay: a = 250, shouldShow: o }) { this.preventHide = !1, this.shouldShow = ({ view: s, state: l, from: c, to: u }) => { const { doc: d, selection: f } = l, { empty: h } = f, p = !d.textBetween(c, u).length && FR(l.selection), m = this.element.contains(document.activeElement); return !(!(s.hasFocus() || m) || h || p || !this.editor.isEditable) }, this.mousedownHandler = () => { this.preventHide = !0 }, this.dragstartHandler = () => { this.hide() }, this.focusHandler = () => { setTimeout(() => this.update(this.editor.view)) }, this.blurHandler = ({ event: s }) => { var l; if (this.preventHide) { this.preventHide = !1; return } s != null && s.relatedTarget && (!((l = this.element.parentNode) === null || l === void 0) && l.contains(s.relatedTarget)) || this.hide() }, this.tippyBlurHandler = s => { this.blurHandler({ event: s }) }, this.handleDebouncedUpdate = (s, l) => { const c = !(l != null && l.selection.eq(s.state.selection)), u = !(l != null && l.doc.eq(s.state.doc)); !c && !u || (this.updateDebounceTimer && clearTimeout(this.updateDebounceTimer), this.updateDebounceTimer = window.setTimeout(() => { this.updateHandler(s, c, u, l) }, this.updateDelay)) }, this.updateHandler = (s, l, c, u) => { var d, f, h; const { state: p, composing: m } = s, { selection: g } = p; if (m || !l && !c) return; this.createTooltip(); const { ranges: b } = g, w = Math.min(...b.map(x => x.$from.pos)), v = Math.max(...b.map(x => x.$to.pos)); if (!((d = this.shouldShow) === null || d === void 0 ? void 0 : d.call(this, { editor: this.editor, view: s, state: p, oldState: u, from: w, to: v }))) { this.hide(); return } (f = this.tippy) === null || f === void 0 || f.setProps({ getReferenceClientRect: ((h = this.tippyOptions) === null || h === void 0 ? void 0 : h.getReferenceClientRect) || (() => { if (JAe(p.selection)) { let x = s.nodeDOM(w); const k = x.dataset.nodeViewWrapper ? x : x.querySelector("[data-node-view-wrapper]"); if (k && (x = k.firstChild), x) return x.getBoundingClientRect() } return vJ(s, w, v) }) }), this.show() }, this.editor = e, this.element = t, this.view = r, this.updateDelay = a, o && (this.shouldShow = o), this.element.addEventListener("mousedown", this.mousedownHandler, { capture: !0 }), this.view.dom.addEventListener("dragstart", this.dragstartHandler), this.editor.on("focus", this.focusHandler), this.editor.on("blur", this.blurHandler), this.tippyOptions = i, this.element.remove(), this.element.style.visibility = "visible" } createTooltip() { const { element: e } = this.editor.options, t = !!e.parentElement; this.tippy || !t || (this.tippy = zc(e, { duration: 0, getReferenceClientRect: null, content: this.element, interactive: !0, trigger: "manual", placement: "top", hideOnClick: "toggle", ...this.tippyOptions }), this.tippy.popper.firstChild && this.tippy.popper.firstChild.addEventListener("blur", this.tippyBlurHandler)) } update(e, t) { const { state: r } = e, i = r.selection.from !== r.selection.to; if (this.updateDelay > 0 && i) { this.handleDebouncedUpdate(e, t); return } const a = !(t != null && t.selection.eq(e.state.selection)), o = !(t != null && t.doc.eq(e.state.doc)); this.updateHandler(e, a, o, t) } show() { var e; (e = this.tippy) === null || e === void 0 || e.show() } hide() { var e; (e = this.tippy) === null || e === void 0 || e.hide() } destroy() { var e, t; !((e = this.tippy) === null || e === void 0) && e.popper.firstChild && this.tippy.popper.firstChild.removeEventListener("blur", this.tippyBlurHandler), (t = this.tippy) === null || t === void 0 || t.destroy(), this.element.removeEventListener("mousedown", this.mousedownHandler, { capture: !0 }), this.view.dom.removeEventListener("dragstart", this.dragstartHandler), this.editor.off("focus", this.focusHandler), this.editor.off("blur", this.blurHandler) } } const oQ = n => new wn({ key: typeof n.pluginKey == "string" ? new xn(n.pluginKey) : n.pluginKey, view: e => new dIe({ view: e, ...n }) }); Bi.create({ name: "bubbleMenu", addOptions() { return { element: null, tippyOptions: {}, pluginKey: "bubbleMenu", updateDelay: void 0, shouldShow: null } }, addProseMirrorPlugins() { return this.options.element ? [oQ({ pluginKey: this.options.pluginKey, editor: this.editor, element: this.options.element, tippyOptions: this.options.tippyOptions, updateDelay: this.options.updateDelay, shouldShow: this.options.shouldShow })] : [] } }); class fIe { constructor({ editor: e, element: t, view: r, tippyOptions: i = {}, shouldShow: a }) { this.preventHide = !1, this.shouldShow = ({ view: o, state: s }) => { const { selection: l } = s, { $anchor: c, empty: u } = l, d = c.depth === 1, f = c.parent.isTextblock && !c.parent.type.spec.code && !c.parent.textContent; return !(!o.hasFocus() || !u || !d || !f || !this.editor.isEditable) }, this.mousedownHandler = () => { this.preventHide = !0 }, this.focusHandler = () => { setTimeout(() => this.update(this.editor.view)) }, this.blurHandler = ({ event: o }) => { var s; if (this.preventHide) { this.preventHide = !1; return } o != null && o.relatedTarget && (!((s = this.element.parentNode) === null || s === void 0) && s.contains(o.relatedTarget)) || this.hide() }, this.tippyBlurHandler = o => { this.blurHandler({ event: o }) }, this.editor = e, this.element = t, this.view = r, a && (this.shouldShow = a), this.element.addEventListener("mousedown", this.mousedownHandler, { capture: !0 }), this.editor.on("focus", this.focusHandler), this.editor.on("blur", this.blurHandler), this.tippyOptions = i, this.element.remove(), this.element.style.visibility = "visible" } createTooltip() { const { element: e } = this.editor.options, t = !!e.parentElement; this.tippy || !t || (this.tippy = zc(e, { duration: 0, getReferenceClientRect: null, content: this.element, interactive: !0, trigger: "manual", placement: "right", hideOnClick: "toggle", ...this.tippyOptions }), this.tippy.popper.firstChild && this.tippy.popper.firstChild.addEventListener("blur", this.tippyBlurHandler)) } update(e, t) { var r, i, a; const { state: o } = e, { doc: s, selection: l } = o, { from: c, to: u } = l; if (t && t.doc.eq(s) && t.selection.eq(l)) return; if (this.createTooltip(), !((r = this.shouldShow) === null || r === void 0 ? void 0 : r.call(this, { editor: this.editor, view: e, state: o, oldState: t }))) { this.hide(); return } (i = this.tippy) === null || i === void 0 || i.setProps({ getReferenceClientRect: ((a = this.tippyOptions) === null || a === void 0 ? void 0 : a.getReferenceClientRect) || (() => vJ(e, c, u)) }), this.show() } show() { var e; (e = this.tippy) === null || e === void 0 || e.show() } hide() { var e; (e = this.tippy) === null || e === void 0 || e.hide() } destroy() { var e, t; !((e = this.tippy) === null || e === void 0) && e.popper.firstChild && this.tippy.popper.firstChild.removeEventListener("blur", this.tippyBlurHandler), (t = this.tippy) === null || t === void 0 || t.destroy(), this.element.removeEventListener("mousedown", this.mousedownHandler, { capture: !0 }), this.editor.off("focus", this.focusHandler), this.editor.off("blur", this.blurHandler) } } const sQ = n => new wn({ key: typeof n.pluginKey == "string" ? new xn(n.pluginKey) : n.pluginKey, view: e => new fIe({ view: e, ...n }) }); Bi.create({ name: "floatingMenu", addOptions() { return { element: null, tippyOptions: {}, pluginKey: "floatingMenu", shouldShow: null } }, addProseMirrorPlugins() { return this.options.element ? [sQ({ pluginKey: this.options.pluginKey, editor: this.editor, element: this.options.element, tippyOptions: this.options.tippyOptions, shouldShow: this.options.shouldShow })] : [] } }); const hIe = We({ name: "BubbleMenu", props: { pluginKey: { type: [String, Object], default: "bubbleMenu" }, editor: { type: Object, required: !0 }, updateDelay: { type: Number, default: void 0 }, tippyOptions: { type: Object, default: () => ({}) }, shouldShow: { type: Function, default: null } }, setup(n, { slots: e }) { const t = he(null); return un(() => { const { updateDelay: r, editor: i, pluginKey: a, shouldShow: o, tippyOptions: s } = n; i.registerPlugin(oQ({ updateDelay: r, editor: i, element: t.value, pluginKey: a, shouldShow: o, tippyOptions: s })) }), $g(() => { const { pluginKey: r, editor: i } = n; i.unregisterPlugin(r) }), () => { var r; return Gt("div", { ref: t }, (r = e.default) === null || r === void 0 ? void 0 : r.call(e)) } } }); function Gz(n) { return XT((e, t) => ({ get() { return e(), n }, set(r) { n = r, requestAnimationFrame(() => { requestAnimationFrame(() => { t() }) }) } })) } class pIe extends MEe { constructor(e = {}) { return super(e), this.contentComponent = null, this.appContext = null, this.reactiveState = Gz(this.view.state), this.reactiveExtensionStorage = Gz(this.extensionStorage), this.on("beforeTransaction", ({ nextState: t }) => { this.reactiveState.value = t, this.reactiveExtensionStorage.value = this.extensionStorage }), dn(this) } get state() { return this.reactiveState ? this.reactiveState.value : this.view.state } get storage() { return this.reactiveExtensionStorage ? this.reactiveExtensionStorage.value : super.storage } registerPlugin(e, t) { const r = super.registerPlugin(e, t); return this.reactiveState && (this.reactiveState.value = r), r } unregisterPlugin(e) { const t = super.unregisterPlugin(e); return this.reactiveState && t && (this.reactiveState.value = t), t } } const mIe = We({ name: "EditorContent", props: { editor: { default: null, type: Object } }, setup(n) { const e = he(), t = kr(); return Bn(() => { const r = n.editor; r && r.options.element && e.value && Pr(() => { if (!e.value || !r.options.element.firstChild) return; const i = X(e.value); e.value.append(...r.options.element.childNodes), r.contentComponent = t.ctx._, t && (r.appContext = { ...t.appContext, provides: t.provides }), r.setOptions({ element: i }), r.createNodeViews() }) }), $g(() => { const r = n.editor; if (!r || (r.isDestroyed || r.view.setProps({ nodeViews: {} }), r.contentComponent = null, r.appContext = null, !r.options.element.firstChild)) return; const i = document.createElement("div"); i.append(...r.options.element.childNodes), r.setOptions({ element: i }) }), { rootEl: e } }, render() { return Gt("div", { ref: n => { this.rootEl = n } }) } }), gIe = We({ name: "FloatingMenu", props: { pluginKey: { type: null, default: "floatingMenu" }, editor: { type: Object, required: !0 }, tippyOptions: { type: Object, default: () => ({}) }, shouldShow: { type: Function, default: null } }, setup(n, { slots: e }) { const t = he(null); return un(() => { const { pluginKey: r, editor: i, tippyOptions: a, shouldShow: o } = n; i.registerPlugin(sQ({ pluginKey: r, editor: i, element: t.value, tippyOptions: a, shouldShow: o })) }), $g(() => { const { pluginKey: r, editor: i } = n; i.unregisterPlugin(r) }), () => { var r; return Gt("div", { ref: t }, (r = e.default) === null || r === void 0 ? void 0 : r.call(e)) } } }), vIe = We({ name: "NodeViewContent", props: { as: { type: String, default: "div" } }, render() { return Gt(this.as, { style: { whiteSpace: "pre-wrap" }, "data-node-view-content": "" }) } }), lQ = We({ name: "NodeViewWrapper", props: { as: { type: String, default: "div" } }, inject: ["onDragStart", "decorationClasses"], render() { var n, e; return Gt(this.as, { class: this.decorationClasses, style: { whiteSpace: "normal" }, "data-node-view-wrapper": "", onDragstart: this.onDragStart }, (e = (n = this.$slots).default) === null || e === void 0 ? void 0 : e.call(n)) } }); class eN { constructor(e, { props: t = {}, editor: r }) { this.editor = r, this.component = dn(e), this.el = document.createElement("div"), this.props = vr(t), this.renderedComponent = this.renderComponent() } get element() { return this.renderedComponent.el } get ref() { var e, t, r, i; return !((t = (e = this.renderedComponent.vNode) === null || e === void 0 ? void 0 : e.component) === null || t === void 0) && t.exposed ? this.renderedComponent.vNode.component.exposed : (i = (r = this.renderedComponent.vNode) === null || r === void 0 ? void 0 : r.component) === null || i === void 0 ? void 0 : i.proxy } renderComponent() { let e = Gt(this.component, this.props); return this.editor.appContext && (e.appContext = this.editor.appContext), typeof document < "u" && this.el && tj(e, this.el), { vNode: e, destroy: () => { this.el && tj(null, this.el), this.el = null, e = null }, el: this.el ? this.el.firstElementChild : null } } updateProps(e = {}) { Object.entries(e).forEach(([t, r]) => { this.props[t] = r }), this.renderComponent() } destroy() { this.renderedComponent.destroy() } } const cQ = { editor: { type: Object, required: !0 }, node: { type: Object, required: !0 }, decorations: { type: Object, required: !0 }, selected: { type: Boolean, required: !0 }, extension: { type: Object, required: !0 }, getPos: { type: Function, required: !0 }, updateAttributes: { type: Function, required: !0 }, deleteNode: { type: Function, required: !0 } }; class yIe extends DEe { mount() { const e = { editor: this.editor, node: this.node, decorations: this.decorations, innerDecorations: this.innerDecorations, view: this.view, selected: !1, extension: this.extension, HTMLAttributes: this.HTMLAttributes, getPos: () => this.getPos(), updateAttributes: (i = {}) => this.updateAttributes(i), deleteNode: () => this.deleteNode() }, t = this.onDragStart.bind(this); this.decorationClasses = he(this.getDecorationClasses()); const r = We({ extends: { ...this.component }, props: Object.keys(e), template: this.component.template, setup: i => { var a, o; return Or("onDragStart", t), Or("decorationClasses", this.decorationClasses), (o = (a = this.component).setup) === null || o === void 0 ? void 0 : o.call(a, i, { expose: () => { } }) }, __scopeId: this.component.__scopeId, __cssModules: this.component.__cssModules, __name: this.component.__name, __file: this.component.__file }); this.handleSelectionUpdate = this.handleSelectionUpdate.bind(this), this.editor.on("selectionUpdate", this.handleSelectionUpdate), this.renderer = new eN(r, { editor: this.editor, props: e }) } get dom() { if (!this.renderer.element || !this.renderer.element.hasAttribute("data-node-view-wrapper")) throw Error("Please use the NodeViewWrapper component for your node view."); return this.renderer.element } get contentDOM() { return this.node.isLeaf ? null : this.dom.querySelector("[data-node-view-content]") } handleSelectionUpdate() { const { from: e, to: t } = this.editor.state.selection, r = this.getPos(); if (typeof r == "number") if (e <= r && t >= r + this.node.nodeSize) { if (this.renderer.props.selected) return; this.selectNode() } else { if (!this.renderer.props.selected) return; this.deselectNode() } } update(e, t, r) { const i = a => { this.decorationClasses.value = this.getDecorationClasses(), this.renderer.updateProps(a) }; if (typeof this.options.update == "function") { const a = this.node, o = this.decorations, s = this.innerDecorations; return this.node = e, this.decorations = t, this.innerDecorations = r, this.options.update({ oldNode: a, oldDecorations: o, newNode: e, newDecorations: t, oldInnerDecorations: s, innerDecorations: r, updateProps: () => i({ node: e, decorations: t, innerDecorations: r }) }) } return e.type !== this.node.type ? !1 : (e === this.node && this.decorations === t && this.innerDecorations === r || (this.node = e, this.decorations = t, this.innerDecorations = r, i({ node: e, decorations: t, innerDecorations: r })), !0) } selectNode() { this.renderer.updateProps({ selected: !0 }), this.renderer.element && this.renderer.element.classList.add("ProseMirror-selectednode") } deselectNode() { this.renderer.updateProps({ selected: !1 }), this.renderer.element && this.renderer.element.classList.remove("ProseMirror-selectednode") } getDecorationClasses() { return this.decorations.map(e => e.type.attrs.class).flat().join(" ") } destroy() { this.renderer.destroy(), this.editor.off("selectionUpdate", this.handleSelectionUpdate) } } function uQ(n, e) { return t => { if (!t.editor.contentComponent) return {}; const r = typeof n == "function" && "__vccOpts" in n ? n.__vccOpts : n; return new yIe(r, t, e) } } function _Ie(n) { const e = n.regex, t = n.COMMENT("//", "$", { contains: [{ begin: /\\\n/ }] }), r = "decltype\\(auto\\)", i = "[a-zA-Z_]\\w*::", a = "<[^<>]+>", o = "(?!struct)(" + r + "|" + e.optional(i) + "[a-zA-Z_]\\w*" + e.optional(a) + ")", s = { className: "type", begin: "\\b[a-z\\d_]*_t\\b" }, l = "\\\\(x[0-9A-Fa-f]{2}|u[0-9A-Fa-f]{4,8}|[0-7]{3}|\\S)", c = { className: "string", variants: [{ begin: '(u8?|U|L)?"', end: '"', illegal: "\\n", contains: [n.BACKSLASH_ESCAPE] }, { begin: "(u8?|U|L)?'(" + l + "|.)", end: "'", illegal: "." }, n.END_SAME_AS_BEGIN({ begin: /(?:u8?|U|L)?R"([^()\\ ]{0,16})\(/, end: /\)([^()\\ ]{0,16})"/ })] }, u = { className: "number", variants: [{ begin: "[+-]?(?:(?:[0-9](?:'?[0-9])*\\.(?:[0-9](?:'?[0-9])*)?|\\.[0-9](?:'?[0-9])*)(?:[Ee][+-]?[0-9](?:'?[0-9])*)?|[0-9](?:'?[0-9])*[Ee][+-]?[0-9](?:'?[0-9])*|0[Xx](?:[0-9A-Fa-f](?:'?[0-9A-Fa-f])*(?:\\.(?:[0-9A-Fa-f](?:'?[0-9A-Fa-f])*)?)?|\\.[0-9A-Fa-f](?:'?[0-9A-Fa-f])*)[Pp][+-]?[0-9](?:'?[0-9])*)(?:[Ff](?:16|32|64|128)?|(BF|bf)16|[Ll]|)" }, { begin: "[+-]?\\b(?:0[Bb][01](?:'?[01])*|0[Xx][0-9A-Fa-f](?:'?[0-9A-Fa-f])*|0(?:'?[0-7])*|[1-9](?:'?[0-9])*)(?:[Uu](?:LL?|ll?)|[Uu][Zz]?|(?:LL?|ll?)[Uu]?|[Zz][Uu]|)" }], relevance: 0 }, d = { className: "meta", begin: /#\s*[a-z]+\b/, end: /$/, keywords: { keyword: "if else elif endif define undef warning error line pragma _Pragma ifdef ifndef include" }, contains: [{ begin: /\\\n/, relevance: 0 }, n.inherit(c, { className: "string" }), { className: "string", begin: /<.*?>/ }, t, n.C_BLOCK_COMMENT_MODE] }, f = { className: "title", begin: e.optional(i) + n.IDENT_RE, relevance: 0 }, h = e.optional(i) + n.IDENT_RE + "\\s*\\(", p = ["alignas", "alignof", "and", "and_eq", "asm", "atomic_cancel", "atomic_commit", "atomic_noexcept", "auto", "bitand", "bitor", "break", "case", "catch", "class", "co_await", "co_return", "co_yield", "compl", "concept", "const_cast|10", "consteval", "constexpr", "constinit", "continue", "decltype", "default", "delete", "do", "dynamic_cast|10", "else", "enum", "explicit", "export", "extern", "false", "final", "for", "friend", "goto", "if", "import", "inline", "module", "mutable", "namespace", "new", "noexcept", "not", "not_eq", "nullptr", "operator", "or", "or_eq", "override", "private", "protected", "public", "reflexpr", "register", "reinterpret_cast|10", "requires", "return", "sizeof", "static_assert", "static_cast|10", "struct", "switch", "synchronized", "template", "this", "thread_local", "throw", "transaction_safe", "transaction_safe_dynamic", "true", "try", "typedef", "typeid", "typename", "union", "using", "virtual", "volatile", "while", "xor", "xor_eq"], m = ["bool", "char", "char16_t", "char32_t", "char8_t", "double", "float", "int", "long", "short", "void", "wchar_t", "unsigned", "signed", "const", "static"], g = ["any", "auto_ptr", "barrier", "binary_semaphore", "bitset", "complex", "condition_variable", "condition_variable_any", "counting_semaphore", "deque", "false_type", "flat_map", "flat_set", "future", "imaginary", "initializer_list", "istringstream", "jthread", "latch", "lock_guard", "multimap", "multiset", "mutex", "optional", "ostringstream", "packaged_task", "pair", "promise", "priority_queue", "queue", "recursive_mutex", "recursive_timed_mutex", "scoped_lock", "set", "shared_future", "shared_lock", "shared_mutex", "shared_timed_mutex", "shared_ptr", "stack", "string_view", "stringstream", "timed_mutex", "thread", "true_type", "tuple", "unique_lock", "unique_ptr", "unordered_map", "unordered_multimap", "unordered_multiset", "unordered_set", "variant", "vector", "weak_ptr", "wstring", "wstring_view"], y = ["abort", "abs", "acos", "apply", "as_const", "asin", "atan", "atan2", "calloc", "ceil", "cerr", "cin", "clog", "cos", "cosh", "cout", "declval", "endl", "exchange", "exit", "exp", "fabs", "floor", "fmod", "forward", "fprintf", "fputs", "free", "frexp", "fscanf", "future", "invoke", "isalnum", "isalpha", "iscntrl", "isdigit", "isgraph", "islower", "isprint", "ispunct", "isspace", "isupper", "isxdigit", "labs", "launder", "ldexp", "log", "log10", "make_pair", "make_shared", "make_shared_for_overwrite", "make_tuple", "make_unique", "malloc", "memchr", "memcmp", "memcpy", "memset", "modf", "move", "pow", "printf", "putchar", "puts", "realloc", "scanf", "sin", "sinh", "snprintf", "sprintf", "sqrt", "sscanf", "std", "stderr", "stdin", "stdout", "strcat", "strchr", "strcmp", "strcpy", "strcspn", "strlen", "strncat", "strncmp", "strncpy", "strpbrk", "strrchr", "strspn", "strstr", "swap", "tan", "tanh", "terminate", "to_underlying", "tolower", "toupper", "vfprintf", "visit", "vprintf", "vsprintf"], v = { type: m, keyword: p, literal: ["NULL", "false", "nullopt", "nullptr", "true"], built_in: ["_Pragma"], _type_hints: g }, S = { className: "function.dispatch", relevance: 0, keywords: { _hint: y }, begin: e.concat(/\b/, /(?!decltype)/, /(?!if)/, /(?!for)/, /(?!switch)/, /(?!while)/, n.IDENT_RE, e.lookahead(/(<[^<>]+>|)\s*\(/)) }, x = [S, d, s, t, n.C_BLOCK_COMMENT_MODE, u, c], k = { variants: [{ begin: /=/, end: /;/ }, { begin: /\(/, end: /\)/ }, { beginKeywords: "new throw return else", end: /;/ }], keywords: v, contains: x.concat([{ begin: /\(/, end: /\)/, keywords: v, contains: x.concat(["self"]), relevance: 0 }]), relevance: 0 }, A = { className: "function", begin: "(" + o + "[\\*&\\s]+)+" + h, returnBegin: !0, end: /[{;=]/, excludeEnd: !0, keywords: v, illegal: /[^\w\s\*&:<>.]/, contains: [{ begin: r, keywords: v, relevance: 0 }, { begin: h, returnBegin: !0, contains: [f], relevance: 0 }, { begin: /::/, relevance: 0 }, { begin: /:/, endsWithParent: !0, contains: [c, u] }, { relevance: 0, match: /,/ }, { className: "params", begin: /\(/, end: /\)/, keywords: v, relevance: 0, contains: [t, n.C_BLOCK_COMMENT_MODE, c, u, s, { begin: /\(/, end: /\)/, keywords: v, relevance: 0, contains: ["self", t, n.C_BLOCK_COMMENT_MODE, c, u, s] }] }, s, t, n.C_BLOCK_COMMENT_MODE, d] }; return { name: "C++", aliases: ["cc", "c++", "h++", "hpp", "hh", "hxx", "cxx"], keywords: v, illegal: "</", classNameAliases: { "function.dispatch": "built_in" }, contains: [].concat(k, A, S, x, [d, { begin: "\\b(deque|list|queue|priority_queue|pair|stack|vector|map|set|bitset|multiset|multimap|unordered_map|unordered_set|unordered_multiset|unordered_multimap|array|tuple|optional|variant|function|flat_map|flat_set)\\s*<(?!<)", end: ">", keywords: v, contains: ["self", s] }, { begin: n.IDENT_RE + "::", keywords: v }, { match: [/\b(?:enum(?:\s+(?:class|struct))?|class|struct|union)/, /\s+/, /\w+/], className: { 1: "keyword", 3: "title.class" } }]) } } function bIe(n) { const e = { type: ["boolean", "byte", "word", "String"], built_in: ["KeyboardController", "MouseController", "SoftwareSerial", "EthernetServer", "EthernetClient", "LiquidCrystal", "RobotControl", "GSMVoiceCall", "EthernetUDP", "EsploraTFT", "HttpClient", "RobotMotor", "WiFiClient", "GSMScanner", "FileSystem", "Scheduler", "GSMServer", "YunClient", "YunServer", "IPAddress", "GSMClient", "GSMModem", "Keyboard", "Ethernet", "Console", "GSMBand", "Esplora", "Stepper", "Process", "WiFiUDP", "GSM_SMS", "Mailbox", "USBHost", "Firmata", "PImage", "Client", "Server", "GSMPIN", "FileIO", "Bridge", "Serial", "EEPROM", "Stream", "Mouse", "Audio", "Servo", "File", "Task", "GPRS", "WiFi", "Wire", "TFT", "GSM", "SPI", "SD"], _hints: ["setup", "loop", "runShellCommandAsynchronously", "analogWriteResolution", "retrieveCallingNumber", "printFirmwareVersion", "analogReadResolution", "sendDigitalPortPair", "noListenOnLocalhost", "readJoystickButton", "setFirmwareVersion", "readJoystickSwitch", "scrollDisplayRight", "getVoiceCallStatus", "scrollDisplayLeft", "writeMicroseconds", "delayMicroseconds", "beginTransmission", "getSignalStrength", "runAsynchronously", "getAsynchronously", "listenOnLocalhost", "getCurrentCarrier", "readAccelerometer", "messageAvailable", "sendDigitalPorts", "lineFollowConfig", "countryNameWrite", "runShellCommand", "readStringUntil", "rewindDirectory", "readTemperature", "setClockDivider", "readLightSensor", "endTransmission", "analogReference", "detachInterrupt", "countryNameRead", "attachInterrupt", "encryptionType", "readBytesUntil", "robotNameWrite", "readMicrophone", "robotNameRead", "cityNameWrite", "userNameWrite", "readJoystickY", "readJoystickX", "mouseReleased", "openNextFile", "scanNetworks", "noInterrupts", "digitalWrite", "beginSpeaker", "mousePressed", "isActionDone", "mouseDragged", "displayLogos", "noAutoscroll", "addParameter", "remoteNumber", "getModifiers", "keyboardRead", "userNameRead", "waitContinue", "processInput", "parseCommand", "printVersion", "readNetworks", "writeMessage", "blinkVersion", "cityNameRead", "readMessage", "setDataMode", "parsePacket", "isListening", "setBitOrder", "beginPacket", "isDirectory", "motorsWrite", "drawCompass", "digitalRead", "clearScreen", "serialEvent", "rightToLeft", "setTextSize", "leftToRight", "requestFrom", "keyReleased", "compassRead", "analogWrite", "interrupts", "WiFiServer", "disconnect", "playMelody", "parseFloat", "autoscroll", "getPINUsed", "setPINUsed", "setTimeout", "sendAnalog", "readSlider", "analogRead", "beginWrite", "createChar", "motorsStop", "keyPressed", "tempoWrite", "readButton", "subnetMask", "debugPrint", "macAddress", "writeGreen", "randomSeed", "attachGPRS", "readString", "sendString", "remotePort", "releaseAll", "mouseMoved", "background", "getXChange", "getYChange", "answerCall", "getResult", "voiceCall", "endPacket", "constrain", "getSocket", "writeJSON", "getButton", "available", "connected", "findUntil", "readBytes", "exitValue", "readGreen", "writeBlue", "startLoop", "IPAddress", "isPressed", "sendSysex", "pauseMode", "gatewayIP", "setCursor", "getOemKey", "tuneWrite", "noDisplay", "loadImage", "switchPIN", "onRequest", "onReceive", "changePIN", "playFile", "noBuffer", "parseInt", "overflow", "checkPIN", "knobRead", "beginTFT", "bitClear", "updateIR", "bitWrite", "position", "writeRGB", "highByte", "writeRed", "setSpeed", "readBlue", "noStroke", "remoteIP", "transfer", "shutdown", "hangCall", "beginSMS", "endWrite", "attached", "maintain", "noCursor", "checkReg", "checkPUK", "shiftOut", "isValid", "shiftIn", "pulseIn", "connect", "println", "localIP", "pinMode", "getIMEI", "display", "noBlink", "process", "getBand", "running", "beginSD", "drawBMP", "lowByte", "setBand", "release", "bitRead", "prepare", "pointTo", "readRed", "setMode", "noFill", "remove", "listen", "stroke", "detach", "attach", "noTone", "exists", "buffer", "height", "bitSet", "circle", "config", "cursor", "random", "IRread", "setDNS", "endSMS", "getKey", "micros", "millis", "begin", "print", "write", "ready", "flush", "width", "isPIN", "blink", "clear", "press", "mkdir", "rmdir", "close", "point", "yield", "image", "BSSID", "click", "delay", "read", "text", "move", "peek", "beep", "rect", "line", "open", "seek", "fill", "size", "turn", "stop", "home", "find", "step", "tone", "sqrt", "RSSI", "SSID", "end", "bit", "tan", "cos", "sin", "pow", "map", "abs", "max", "min", "get", "run", "put"], literal: ["DIGITAL_MESSAGE", "FIRMATA_STRING", "ANALOG_MESSAGE", "REPORT_DIGITAL", "REPORT_ANALOG", "INPUT_PULLUP", "SET_PIN_MODE", "INTERNAL2V56", "SYSTEM_RESET", "LED_BUILTIN", "INTERNAL1V1", "SYSEX_START", "INTERNAL", "EXTERNAL", "DEFAULT", "OUTPUT", "INPUT", "HIGH", "LOW"] }, t = _Ie(n), r = t.keywords; return r.type = [...r.type, ...e.type], r.literal = [...r.literal, ...e.literal], r.built_in = [...r.built_in, ...e.built_in], r._hints = e._hints, t.name = "Arduino", t.aliases = ["ino"], t.supersetOf = "cpp", t } function wIe(n) { const e = n.regex, t = {}, r = { begin: /\$\{/, end: /\}/, contains: ["self", { begin: /:-/, contains: [t] }] }; Object.assign(t, { className: "variable", variants: [{ begin: e.concat(/\$[\w\d#@][\w\d_]*/, "(?![\\w\\d])(?![$])") }, r] }); const i = { className: "subst", begin: /\$\(/, end: /\)/, contains: [n.BACKSLASH_ESCAPE] }, a = n.inherit(n.COMMENT(), { match: [/(^|\s)/, /#.*$/], scope: { 2: "comment" } }), o = { begin: /<<-?\s*(?=\w+)/, starts: { contains: [n.END_SAME_AS_BEGIN({ begin: /(\w+)/, end: /(\w+)/, className: "string" })] } }, s = { className: "string", begin: /"/, end: /"/, contains: [n.BACKSLASH_ESCAPE, t, i] }; i.contains.push(s); const l = { match: /\\"/ }, c = { className: "string", begin: /'/, end: /'/ }, u = { match: /\\'/ }, d = { begin: /\$?\(\(/, end: /\)\)/, contains: [{ begin: /\d+#[0-9a-f]+/, className: "number" }, n.NUMBER_MODE, t] }, f = ["fish", "bash", "zsh", "sh", "csh", "ksh", "tcsh", "dash", "scsh"], h = n.SHEBANG({ binary: `(${f.join("|")})`, relevance: 10 }), p = { className: "function", begin: /\w[\w\d_]*\s*\(\s*\)\s*\{/, returnBegin: !0, contains: [n.inherit(n.TITLE_MODE, { begin: /\w[\w\d_]*/ })], relevance: 0 }, m = ["if", "then", "else", "elif", "fi", "time", "for", "while", "until", "in", "do", "done", "case", "esac", "coproc", "function", "select"], g = ["true", "false"], y = { match: /(\/[a-z._-]+)+/ }, b = ["break", "cd", "continue", "eval", "exec", "exit", "export", "getopts", "hash", "pwd", "readonly", "return", "shift", "test", "times", "trap", "umask", "unset"], w = ["alias", "bind", "builtin", "caller", "command", "declare", "echo", "enable", "help", "let", "local", "logout", "mapfile", "printf", "read", "readarray", "source", "sudo", "type", "typeset", "ulimit", "unalias"], v = ["autoload", "bg", "bindkey", "bye", "cap", "chdir", "clone", "comparguments", "compcall", "compctl", "compdescribe", "compfiles", "compgroups", "compquote", "comptags", "comptry", "compvalues", "dirs", "disable", "disown", "echotc", "echoti", "emulate", "fc", "fg", "float", "functions", "getcap", "getln", "history", "integer", "jobs", "kill", "limit", "log", "noglob", "popd", "print", "pushd", "pushln", "rehash", "sched", "setcap", "setopt", "stat", "suspend", "ttyctl", "unfunction", "unhash", "unlimit", "unsetopt", "vared", "wait", "whence", "where", "which", "zcompile", "zformat", "zftp", "zle", "zmodload", "zparseopts", "zprof", "zpty", "zregexparse", "zsocket", "zstyle", "ztcp"], S = ["chcon", "chgrp", "chown", "chmod", "cp", "dd", "df", "dir", "dircolors", "ln", "ls", "mkdir", "mkfifo", "mknod", "mktemp", "mv", "realpath", "rm", "rmdir", "shred", "sync", "touch", "truncate", "vdir", "b2sum", "base32", "base64", "cat", "cksum", "comm", "csplit", "cut", "expand", "fmt", "fold", "head", "join", "md5sum", "nl", "numfmt", "od", "paste", "ptx", "pr", "sha1sum", "sha224sum", "sha256sum", "sha384sum", "sha512sum", "shuf", "sort", "split", "sum", "tac", "tail", "tr", "tsort", "unexpand", "uniq", "wc", "arch", "basename", "chroot", "date", "dirname", "du", "echo", "env", "expr", "factor", "groups", "hostid", "id", "link", "logname", "nice", "nohup", "nproc", "pathchk", "pinky", "printenv", "printf", "pwd", "readlink", "runcon", "seq", "sleep", "stat", "stdbuf", "stty", "tee", "test", "timeout", "tty", "uname", "unlink", "uptime", "users", "who", "whoami", "yes"]; return { name: "Bash", aliases: ["sh", "zsh"], keywords: { $pattern: /\b[a-z][a-z0-9._-]+\b/, keyword: m, literal: g, built_in: [...b, ...w, "set", "shopt", ...v, ...S] }, contains: [h, n.SHEBANG(), p, d, a, o, y, s, l, c, u, t] } } function xIe(n) { const e = n.regex, t = n.COMMENT("//", "$", { contains: [{ begin: /\\\n/ }] }), r = "decltype\\(auto\\)", i = "[a-zA-Z_]\\w*::", a = "<[^<>]+>", o = "(" + r + "|" + e.optional(i) + "[a-zA-Z_]\\w*" + e.optional(a) + ")", s = { className: "type", variants: [{ begin: "\\b[a-z\\d_]*_t\\b" }, { match: /\batomic_[a-z]{3,6}\b/ }] }, l = "\\\\(x[0-9A-Fa-f]{2}|u[0-9A-Fa-f]{4,8}|[0-7]{3}|\\S)", c = { className: "string", variants: [{ begin: '(u8?|U|L)?"', end: '"', illegal: "\\n", contains: [n.BACKSLASH_ESCAPE] }, { begin: "(u8?|U|L)?'(" + l + "|.)", end: "'", illegal: "." }, n.END_SAME_AS_BEGIN({ begin: /(?:u8?|U|L)?R"([^()\\ ]{0,16})\(/, end: /\)([^()\\ ]{0,16})"/ })] }, u = { className: "number", variants: [{ match: /\b(0b[01']+)/ }, { match: /(-?)\b([\d']+(\.[\d']*)?|\.[\d']+)((ll|LL|l|L)(u|U)?|(u|U)(ll|LL|l|L)?|f|F|b|B)/ }, { match: /(-?)\b(0[xX][a-fA-F0-9]+(?:'[a-fA-F0-9]+)*(?:\.[a-fA-F0-9]*(?:'[a-fA-F0-9]*)*)?(?:[pP][-+]?[0-9]+)?(l|L)?(u|U)?)/ }, { match: /(-?)\b\d+(?:'\d+)*(?:\.\d*(?:'\d*)*)?(?:[eE][-+]?\d+)?/ }], relevance: 0 }, d = { className: "meta", begin: /#\s*[a-z]+\b/, end: /$/, keywords: { keyword: "if else elif endif define undef warning error line pragma _Pragma ifdef ifndef elifdef elifndef include" }, contains: [{ begin: /\\\n/, relevance: 0 }, n.inherit(c, { className: "string" }), { className: "string", begin: /<.*?>/ }, t, n.C_BLOCK_COMMENT_MODE] }, f = { className: "title", begin: e.optional(i) + n.IDENT_RE, relevance: 0 }, h = e.optional(i) + n.IDENT_RE + "\\s*\\(", g = { keyword: ["asm", "auto", "break", "case", "continue", "default", "do", "else", "enum", "extern", "for", "fortran", "goto", "if", "inline", "register", "restrict", "return", "sizeof", "typeof", "typeof_unqual", "struct", "switch", "typedef", "union", "volatile", "while", "_Alignas", "_Alignof", "_Atomic", "_Generic", "_Noreturn", "_Static_assert", "_Thread_local", "alignas", "alignof", "noreturn", "static_assert", "thread_local", "_Pragma"], type: ["float", "double", "signed", "unsigned", "int", "short", "long", "char", "void", "_Bool", "_BitInt", "_Complex", "_Imaginary", "_Decimal32", "_Decimal64", "_Decimal96", "_Decimal128", "_Decimal64x", "_Decimal128x", "_Float16", "_Float32", "_Float64", "_Float128", "_Float32x", "_Float64x", "_Float128x", "const", "static", "constexpr", "complex", "bool", "imaginary"], literal: "true false NULL", built_in: "std string wstring cin cout cerr clog stdin stdout stderr stringstream istringstream ostringstream auto_ptr deque list queue stack vector map set pair bitset multiset multimap unordered_set unordered_map unordered_multiset unordered_multimap priority_queue make_pair array shared_ptr abort terminate abs acos asin atan2 atan calloc ceil cosh cos exit exp fabs floor fmod fprintf fputs free frexp fscanf future isalnum isalpha iscntrl isdigit isgraph islower isprint ispunct isspace isupper isxdigit tolower toupper labs ldexp log10 log malloc realloc memchr memcmp memcpy memset modf pow printf putchar puts scanf sinh sin snprintf sprintf sqrt sscanf strcat strchr strcmp strcpy strcspn strlen strncat strncmp strncpy strpbrk strrchr strspn strstr tanh tan vfprintf vprintf vsprintf endl initializer_list unique_ptr" }, y = [d, s, t, n.C_BLOCK_COMMENT_MODE, u, c], b = { variants: [{ begin: /=/, end: /;/ }, { begin: /\(/, end: /\)/ }, { beginKeywords: "new throw return else", end: /;/ }], keywords: g, contains: y.concat([{ begin: /\(/, end: /\)/, keywords: g, contains: y.concat(["self"]), relevance: 0 }]), relevance: 0 }, w = { begin: "(" + o + "[\\*&\\s]+)+" + h, returnBegin: !0, end: /[{;=]/, excludeEnd: !0, keywords: g, illegal: /[^\w\s\*&:<>.]/, contains: [{ begin: r, keywords: g, relevance: 0 }, { begin: h, returnBegin: !0, contains: [n.inherit(f, { className: "title.function" })], relevance: 0 }, { relevance: 0, match: /,/ }, { className: "params", begin: /\(/, end: /\)/, keywords: g, relevance: 0, contains: [t, n.C_BLOCK_COMMENT_MODE, c, u, s, { begin: /\(/, end: /\)/, keywords: g, relevance: 0, contains: ["self", t, n.C_BLOCK_COMMENT_MODE, c, u, s] }] }, s, t, n.C_BLOCK_COMMENT_MODE, d] }; return { name: "C", aliases: ["h"], keywords: g, disableAutodetect: !0, illegal: "</", contains: [].concat(b, w, y, [d, { begin: n.IDENT_RE + "::", keywords: g }, { className: "class", beginKeywords: "enum class struct union", end: /[{;:<>=]/, contains: [{ beginKeywords: "final class struct" }, n.TITLE_MODE] }]), exports: { preprocessor: d, strings: c, keywords: g } } } function SIe(n) { const e = n.regex, t = n.COMMENT("//", "$", { contains: [{ begin: /\\\n/ }] }), r = "decltype\\(auto\\)", i = "[a-zA-Z_]\\w*::", a = "<[^<>]+>", o = "(?!struct)(" + r + "|" + e.optional(i) + "[a-zA-Z_]\\w*" + e.optional(a) + ")", s = { className: "type", begin: "\\b[a-z\\d_]*_t\\b" }, l = "\\\\(x[0-9A-Fa-f]{2}|u[0-9A-Fa-f]{4,8}|[0-7]{3}|\\S)", c = { className: "string", variants: [{ begin: '(u8?|U|L)?"', end: '"', illegal: "\\n", contains: [n.BACKSLASH_ESCAPE] }, { begin: "(u8?|U|L)?'(" + l + "|.)", end: "'", illegal: "." }, n.END_SAME_AS_BEGIN({ begin: /(?:u8?|U|L)?R"([^()\\ ]{0,16})\(/, end: /\)([^()\\ ]{0,16})"/ })] }, u = { className: "number", variants: [{ begin: "[+-]?(?:(?:[0-9](?:'?[0-9])*\\.(?:[0-9](?:'?[0-9])*)?|\\.[0-9](?:'?[0-9])*)(?:[Ee][+-]?[0-9](?:'?[0-9])*)?|[0-9](?:'?[0-9])*[Ee][+-]?[0-9](?:'?[0-9])*|0[Xx](?:[0-9A-Fa-f](?:'?[0-9A-Fa-f])*(?:\\.(?:[0-9A-Fa-f](?:'?[0-9A-Fa-f])*)?)?|\\.[0-9A-Fa-f](?:'?[0-9A-Fa-f])*)[Pp][+-]?[0-9](?:'?[0-9])*)(?:[Ff](?:16|32|64|128)?|(BF|bf)16|[Ll]|)" }, { begin: "[+-]?\\b(?:0[Bb][01](?:'?[01])*|0[Xx][0-9A-Fa-f](?:'?[0-9A-Fa-f])*|0(?:'?[0-7])*|[1-9](?:'?[0-9])*)(?:[Uu](?:LL?|ll?)|[Uu][Zz]?|(?:LL?|ll?)[Uu]?|[Zz][Uu]|)" }], relevance: 0 }, d = { className: "meta", begin: /#\s*[a-z]+\b/, end: /$/, keywords: { keyword: "if else elif endif define undef warning error line pragma _Pragma ifdef ifndef include" }, contains: [{ begin: /\\\n/, relevance: 0 }, n.inherit(c, { className: "string" }), { className: "string", begin: /<.*?>/ }, t, n.C_BLOCK_COMMENT_MODE] }, f = { className: "title", begin: e.optional(i) + n.IDENT_RE, relevance: 0 }, h = e.optional(i) + n.IDENT_RE + "\\s*\\(", p = ["alignas", "alignof", "and", "and_eq", "asm", "atomic_cancel", "atomic_commit", "atomic_noexcept", "auto", "bitand", "bitor", "break", "case", "catch", "class", "co_await", "co_return", "co_yield", "compl", "concept", "const_cast|10", "consteval", "constexpr", "constinit", "continue", "decltype", "default", "delete", "do", "dynamic_cast|10", "else", "enum", "explicit", "export", "extern", "false", "final", "for", "friend", "goto", "if", "import", "inline", "module", "mutable", "namespace", "new", "noexcept", "not", "not_eq", "nullptr", "operator", "or", "or_eq", "override", "private", "protected", "public", "reflexpr", "register", "reinterpret_cast|10", "requires", "return", "sizeof", "static_assert", "static_cast|10", "struct", "switch", "synchronized", "template", "this", "thread_local", "throw", "transaction_safe", "transaction_safe_dynamic", "true", "try", "typedef", "typeid", "typename", "union", "using", "virtual", "volatile", "while", "xor", "xor_eq"], m = ["bool", "char", "char16_t", "char32_t", "char8_t", "double", "float", "int", "long", "short", "void", "wchar_t", "unsigned", "signed", "const", "static"], g = ["any", "auto_ptr", "barrier", "binary_semaphore", "bitset", "complex", "condition_variable", "condition_variable_any", "counting_semaphore", "deque", "false_type", "flat_map", "flat_set", "future", "imaginary", "initializer_list", "istringstream", "jthread", "latch", "lock_guard", "multimap", "multiset", "mutex", "optional", "ostringstream", "packaged_task", "pair", "promise", "priority_queue", "queue", "recursive_mutex", "recursive_timed_mutex", "scoped_lock", "set", "shared_future", "shared_lock", "shared_mutex", "shared_timed_mutex", "shared_ptr", "stack", "string_view", "stringstream", "timed_mutex", "thread", "true_type", "tuple", "unique_lock", "unique_ptr", "unordered_map", "unordered_multimap", "unordered_multiset", "unordered_set", "variant", "vector", "weak_ptr", "wstring", "wstring_view"], y = ["abort", "abs", "acos", "apply", "as_const", "asin", "atan", "atan2", "calloc", "ceil", "cerr", "cin", "clog", "cos", "cosh", "cout", "declval", "endl", "exchange", "exit", "exp", "fabs", "floor", "fmod", "forward", "fprintf", "fputs", "free", "frexp", "fscanf", "future", "invoke", "isalnum", "isalpha", "iscntrl", "isdigit", "isgraph", "islower", "isprint", "ispunct", "isspace", "isupper", "isxdigit", "labs", "launder", "ldexp", "log", "log10", "make_pair", "make_shared", "make_shared_for_overwrite", "make_tuple", "make_unique", "malloc", "memchr", "memcmp", "memcpy", "memset", "modf", "move", "pow", "printf", "putchar", "puts", "realloc", "scanf", "sin", "sinh", "snprintf", "sprintf", "sqrt", "sscanf", "std", "stderr", "stdin", "stdout", "strcat", "strchr", "strcmp", "strcpy", "strcspn", "strlen", "strncat", "strncmp", "strncpy", "strpbrk", "strrchr", "strspn", "strstr", "swap", "tan", "tanh", "terminate", "to_underlying", "tolower", "toupper", "vfprintf", "visit", "vprintf", "vsprintf"], v = { type: m, keyword: p, literal: ["NULL", "false", "nullopt", "nullptr", "true"], built_in: ["_Pragma"], _type_hints: g }, S = { className: "function.dispatch", relevance: 0, keywords: { _hint: y }, begin: e.concat(/\b/, /(?!decltype)/, /(?!if)/, /(?!for)/, /(?!switch)/, /(?!while)/, n.IDENT_RE, e.lookahead(/(<[^<>]+>|)\s*\(/)) }, x = [S, d, s, t, n.C_BLOCK_COMMENT_MODE, u, c], k = { variants: [{ begin: /=/, end: /;/ }, { begin: /\(/, end: /\)/ }, { beginKeywords: "new throw return else", end: /;/ }], keywords: v, contains: x.concat([{ begin: /\(/, end: /\)/, keywords: v, contains: x.concat(["self"]), relevance: 0 }]), relevance: 0 }, A = { className: "function", begin: "(" + o + "[\\*&\\s]+)+" + h, returnBegin: !0, end: /[{;=]/, excludeEnd: !0, keywords: v, illegal: /[^\w\s\*&:<>.]/, contains: [{ begin: r, keywords: v, relevance: 0 }, { begin: h, returnBegin: !0, contains: [f], relevance: 0 }, { begin: /::/, relevance: 0 }, { begin: /:/, endsWithParent: !0, contains: [c, u] }, { relevance: 0, match: /,/ }, { className: "params", begin: /\(/, end: /\)/, keywords: v, relevance: 0, contains: [t, n.C_BLOCK_COMMENT_MODE, c, u, s, { begin: /\(/, end: /\)/, keywords: v, relevance: 0, contains: ["self", t, n.C_BLOCK_COMMENT_MODE, c, u, s] }] }, s, t, n.C_BLOCK_COMMENT_MODE, d] }; return { name: "C++", aliases: ["cc", "c++", "h++", "hpp", "hh", "hxx", "cxx"], keywords: v, illegal: "</", classNameAliases: { "function.dispatch": "built_in" }, contains: [].concat(k, A, S, x, [d, { begin: "\\b(deque|list|queue|priority_queue|pair|stack|vector|map|set|bitset|multiset|multimap|unordered_map|unordered_set|unordered_multiset|unordered_multimap|array|tuple|optional|variant|function|flat_map|flat_set)\\s*<(?!<)", end: ">", keywords: v, contains: ["self", s] }, { begin: n.IDENT_RE + "::", keywords: v }, { match: [/\b(?:enum(?:\s+(?:class|struct))?|class|struct|union)/, /\s+/, /\w+/], className: { 1: "keyword", 3: "title.class" } }]) } } function TIe(n) { const e = ["bool", "byte", "char", "decimal", "delegate", "double", "dynamic", "enum", "float", "int", "long", "nint", "nuint", "object", "sbyte", "short", "string", "ulong", "uint", "ushort"], t = ["public", "private", "protected", "static", "internal", "protected", "abstract", "async", "extern", "override", "unsafe", "virtual", "new", "sealed", "partial"], r = ["default", "false", "null", "true"], i = ["abstract", "as", "base", "break", "case", "catch", "class", "const", "continue", "do", "else", "event", "explicit", "extern", "finally", "fixed", "for", "foreach", "goto", "if", "implicit", "in", "interface", "internal", "is", "lock", "namespace", "new", "operator", "out", "override", "params", "private", "protected", "public", "readonly", "record", "ref", "return", "scoped", "sealed", "sizeof", "stackalloc", "static", "struct", "switch", "this", "throw", "try", "typeof", "unchecked", "unsafe", "using", "virtual", "void", "volatile", "while"], a = ["add", "alias", "and", "ascending", "args", "async", "await", "by", "descending", "dynamic", "equals", "file", "from", "get", "global", "group", "init", "into", "join", "let", "nameof", "not", "notnull", "on", "or", "orderby", "partial", "record", "remove", "required", "scoped", "select", "set", "unmanaged", "value|0", "var", "when", "where", "with", "yield"], o = { keyword: i.concat(a), built_in: e, literal: r }, s = n.inherit(n.TITLE_MODE, { begin: "[a-zA-Z](\\.?\\w)*" }), l = { className: "number", variants: [{ begin: "\\b(0b[01']+)" }, { begin: "(-?)\\b([\\d']+(\\.[\\d']*)?|\\.[\\d']+)(u|U|l|L|ul|UL|f|F|b|B)" }, { begin: "(-?)(\\b0[xX][a-fA-F0-9']+|(\\b[\\d']+(\\.[\\d']*)?|\\.[\\d']+)([eE][-+]?[\\d']+)?)" }], relevance: 0 }, c = { className: "string", begin: /"""("*)(?!")(.|\n)*?"""\1/, relevance: 1 }, u = { className: "string", begin: '@"', end: '"', contains: [{ begin: '""' }] }, d = n.inherit(u, { illegal: /\n/ }), f = { className: "subst", begin: /\{/, end: /\}/, keywords: o }, h = n.inherit(f, { illegal: /\n/ }), p = { className: "string", begin: /\$"/, end: '"', illegal: /\n/, contains: [{ begin: /\{\{/ }, { begin: /\}\}/ }, n.BACKSLASH_ESCAPE, h] }, m = { className: "string", begin: /\$@"/, end: '"', contains: [{ begin: /\{\{/ }, { begin: /\}\}/ }, { begin: '""' }, f] }, g = n.inherit(m, { illegal: /\n/, contains: [{ begin: /\{\{/ }, { begin: /\}\}/ }, { begin: '""' }, h] }); f.contains = [m, p, u, n.APOS_STRING_MODE, n.QUOTE_STRING_MODE, l, n.C_BLOCK_COMMENT_MODE], h.contains = [g, p, d, n.APOS_STRING_MODE, n.QUOTE_STRING_MODE, l, n.inherit(n.C_BLOCK_COMMENT_MODE, { illegal: /\n/ })]; const y = { variants: [c, m, p, u, n.APOS_STRING_MODE, n.QUOTE_STRING_MODE] }, b = { begin: "<", end: ">", contains: [{ beginKeywords: "in out" }, s] }, w = n.IDENT_RE + "(<" + n.IDENT_RE + "(\\s*,\\s*" + n.IDENT_RE + ")*>)?(\\[\\])?", v = { begin: "@" + n.IDENT_RE, relevance: 0 }; return { name: "C#", aliases: ["cs", "c#"], keywords: o, illegal: /::/, contains: [n.COMMENT("///", "$", { returnBegin: !0, contains: [{ className: "doctag", variants: [{ begin: "///", relevance: 0 }, { begin: "<!--|-->" }, { begin: "</?", end: ">" }] }] }), n.C_LINE_COMMENT_MODE, n.C_BLOCK_COMMENT_MODE, { className: "meta", begin: "#", end: "$", keywords: { keyword: "if else elif endif define undef warning error line region endregion pragma checksum" } }, y, l, { beginKeywords: "class interface", relevance: 0, end: /[{;=]/, illegal: /[^\s:,]/, contains: [{ beginKeywords: "where class" }, s, b, n.C_LINE_COMMENT_MODE, n.C_BLOCK_COMMENT_MODE] }, { beginKeywords: "namespace", relevance: 0, end: /[{;=]/, illegal: /[^\s:]/, contains: [s, n.C_LINE_COMMENT_MODE, n.C_BLOCK_COMMENT_MODE] }, { beginKeywords: "record", relevance: 0, end: /[{;=]/, illegal: /[^\s:]/, contains: [s, b, n.C_LINE_COMMENT_MODE, n.C_BLOCK_COMMENT_MODE] }, { className: "meta", begin: "^\\s*\\[(?=[\\w])", excludeBegin: !0, end: "\\]", excludeEnd: !0, contains: [{ className: "string", begin: /"/, end: /"/ }] }, { beginKeywords: "new return throw await else", relevance: 0 }, { className: "function", begin: "(" + w + "\\s+)+" + n.IDENT_RE + "\\s*(<[^=]+>\\s*)?\\(", returnBegin: !0, end: /\s*[{;=]/, excludeEnd: !0, keywords: o, contains: [{ beginKeywords: t.join(" "), relevance: 0 }, { begin: n.IDENT_RE + "\\s*(<[^=]+>\\s*)?\\(", returnBegin: !0, contains: [n.TITLE_MODE, b], relevance: 0 }, { match: /\(\)/ }, { className: "params", begin: /\(/, end: /\)/, excludeBegin: !0, excludeEnd: !0, keywords: o, relevance: 0, contains: [y, l, n.C_BLOCK_COMMENT_MODE] }, n.C_LINE_COMMENT_MODE, n.C_BLOCK_COMMENT_MODE] }, v] } } const kIe = n => ({ IMPORTANT: { scope: "meta", begin: "!important" }, BLOCK_COMMENT: n.C_BLOCK_COMMENT_MODE, HEXCOLOR: { scope: "number", begin: /#(([0-9a-fA-F]{3,4})|(([0-9a-fA-F]{2}){3,4}))\b/ }, FUNCTION_DISPATCH: { className: "built_in", begin: /[\w-]+(?=\()/ }, ATTRIBUTE_SELECTOR_MODE: { scope: "selector-attr", begin: /\[/, end: /\]/, illegal: "$", contains: [n.APOS_STRING_MODE, n.QUOTE_STRING_MODE] }, CSS_NUMBER_MODE: { scope: "number", begin: n.NUMBER_RE + "(%|em|ex|ch|rem|vw|vh|vmin|vmax|cm|mm|in|pt|pc|px|deg|grad|rad|turn|s|ms|Hz|kHz|dpi|dpcm|dppx)?", relevance: 0 }, CSS_VARIABLE: { className: "attr", begin: /--[A-Za-z_][A-Za-z0-9_-]*/ } }), CIe = ["a", "abbr", "address", "article", "aside", "audio", "b", "blockquote", "body", "button", "canvas", "caption", "cite", "code", "dd", "del", "details", "dfn", "div", "dl", "dt", "em", "fieldset", "figcaption", "figure", "footer", "form", "h1", "h2", "h3", "h4", "h5", "h6", "header", "hgroup", "html", "i", "iframe", "img", "input", "ins", "kbd", "label", "legend", "li", "main", "mark", "menu", "nav", "object", "ol", "optgroup", "option", "p", "picture", "q", "quote", "samp", "section", "select", "source", "span", "strong", "summary", "sup", "table", "tbody", "td", "textarea", "tfoot", "th", "thead", "time", "tr", "ul", "var", "video"], AIe = ["defs", "g", "marker", "mask", "pattern", "svg", "switch", "symbol", "feBlend", "feColorMatrix", "feComponentTransfer", "feComposite", "feConvolveMatrix", "feDiffuseLighting", "feDisplacementMap", "feFlood", "feGaussianBlur", "feImage", "feMerge", "feMorphology", "feOffset", "feSpecularLighting", "feTile", "feTurbulence", "linearGradient", "radialGradient", "stop", "circle", "ellipse", "image", "line", "path", "polygon", "polyline", "rect", "text", "use", "textPath", "tspan", "foreignObject", "clipPath"], EIe = [...CIe, ...AIe], MIe = ["any-hover", "any-pointer", "aspect-ratio", "color", "color-gamut", "color-index", "device-aspect-ratio", "device-height", "device-width", "display-mode", "forced-colors", "grid", "height", "hover", "inverted-colors", "monochrome", "orientation", "overflow-block", "overflow-inline", "pointer", "prefers-color-scheme", "prefers-contrast", "prefers-reduced-motion", "prefers-reduced-transparency", "resolution", "scan", "scripting", "update", "width", "min-width", "max-width", "min-height", "max-height"].sort().reverse(), OIe = ["active", "any-link", "blank", "checked", "current", "default", "defined", "dir", "disabled", "drop", "empty", "enabled", "first", "first-child", "first-of-type", "fullscreen", "future", "focus", "focus-visible", "focus-within", "has", "host", "host-context", "hover", "indeterminate", "in-range", "invalid", "is", "lang", "last-child", "last-of-type", "left", "link", "local-link", "not", "nth-child", "nth-col", "nth-last-child", "nth-last-col", "nth-last-of-type", "nth-of-type", "only-child", "only-of-type", "optional", "out-of-range", "past", "placeholder-shown", "read-only", "read-write", "required", "right", "root", "scope", "target", "target-within", "user-invalid", "valid", "visited", "where"].sort().reverse(), DIe = ["after", "backdrop", "before", "cue", "cue-region", "first-letter", "first-line", "grammar-error", "marker", "part", "placeholder", "selection", "slotted", "spelling-error"].sort().reverse(), jIe = ["accent-color", "align-content", "align-items", "align-self", "alignment-baseline", "all", "anchor-name", "animation", "animation-composition", "animation-delay", "animation-direction", "animation-duration", "animation-fill-mode", "animation-iteration-count", "animation-name", "animation-play-state", "animation-range", "animation-range-end", "animation-range-start", "animation-timeline", "animation-timing-function", "appearance", "aspect-ratio", "backdrop-filter", "backface-visibility", "background", "background-attachment", "background-blend-mode", "background-clip", "background-color", "background-image", "background-origin", "background-position", "background-position-x", "background-position-y", "background-repeat", "background-size", "baseline-shift", "block-size", "border", "border-block", "border-block-color", "border-block-end", "border-block-end-color", "border-block-end-style", "border-block-end-width", "border-block-start", "border-block-start-color", "border-block-start-style", "border-block-start-width", "border-block-style", "border-block-width", "border-bottom", "border-bottom-color", "border-bottom-left-radius", "border-bottom-right-radius", "border-bottom-style", "border-bottom-width", "border-collapse", "border-color", "border-end-end-radius", "border-end-start-radius", "border-image", "border-image-outset", "border-image-repeat", "border-image-slice", "border-image-source", "border-image-width", "border-inline", "border-inline-color", "border-inline-end", "border-inline-end-color", "border-inline-end-style", "border-inline-end-width", "border-inline-start", "border-inline-start-color", "border-inline-start-style", "border-inline-start-width", "border-inline-style", "border-inline-width", "border-left", "border-left-color", "border-left-style", "border-left-width", "border-radius", "border-right", "border-right-color", "border-right-style", "border-right-width", "border-spacing", "border-start-end-radius", "border-start-start-radius", "border-style", "border-top", "border-top-color", "border-top-left-radius", "border-top-right-radius", "border-top-style", "border-top-width", "border-width", "bottom", "box-align", "box-decoration-break", "box-direction", "box-flex", "box-flex-group", "box-lines", "box-ordinal-group", "box-orient", "box-pack", "box-shadow", "box-sizing", "break-after", "break-before", "break-inside", "caption-side", "caret-color", "clear", "clip", "clip-path", "clip-rule", "color", "color-interpolation", "color-interpolation-filters", "color-profile", "color-rendering", "color-scheme", "column-count", "column-fill", "column-gap", "column-rule", "column-rule-color", "column-rule-style", "column-rule-width", "column-span", "column-width", "columns", "contain", "contain-intrinsic-block-size", "contain-intrinsic-height", "contain-intrinsic-inline-size", "contain-intrinsic-size", "contain-intrinsic-width", "container", "container-name", "container-type", "content", "content-visibility", "counter-increment", "counter-reset", "counter-set", "cue", "cue-after", "cue-before", "cursor", "cx", "cy", "direction", "display", "dominant-baseline", "empty-cells", "enable-background", "field-sizing", "fill", "fill-opacity", "fill-rule", "filter", "flex", "flex-basis", "flex-direction", "flex-flow", "flex-grow", "flex-shrink", "flex-wrap", "float", "flood-color", "flood-opacity", "flow", "font", "font-display", "font-family", "font-feature-settings", "font-kerning", "font-language-override", "font-optical-sizing", "font-palette", "font-size", "font-size-adjust", "font-smooth", "font-smoothing", "font-stretch", "font-style", "font-synthesis", "font-synthesis-position", "font-synthesis-small-caps", "font-synthesis-style", "font-synthesis-weight", "font-variant", "font-variant-alternates", "font-variant-caps", "font-variant-east-asian", "font-variant-emoji", "font-variant-ligatures", "font-variant-numeric", "font-variant-position", "font-variation-settings", "font-weight", "forced-color-adjust", "gap", "glyph-orientation-horizontal", "glyph-orientation-vertical", "grid", "grid-area", "grid-auto-columns", "grid-auto-flow", "grid-auto-rows", "grid-column", "grid-column-end", "grid-column-start", "grid-gap", "grid-row", "grid-row-end", "grid-row-start", "grid-template", "grid-template-areas", "grid-template-columns", "grid-template-rows", "hanging-punctuation", "height", "hyphenate-character", "hyphenate-limit-chars", "hyphens", "icon", "image-orientation", "image-rendering", "image-resolution", "ime-mode", "initial-letter", "initial-letter-align", "inline-size", "inset", "inset-area", "inset-block", "inset-block-end", "inset-block-start", "inset-inline", "inset-inline-end", "inset-inline-start", "isolation", "justify-content", "justify-items", "justify-self", "kerning", "left", "letter-spacing", "lighting-color", "line-break", "line-height", "line-height-step", "list-style", "list-style-image", "list-style-position", "list-style-type", "margin", "margin-block", "margin-block-end", "margin-block-start", "margin-bottom", "margin-inline", "margin-inline-end", "margin-inline-start", "margin-left", "margin-right", "margin-top", "margin-trim", "marker", "marker-end", "marker-mid", "marker-start", "marks", "mask", "mask-border", "mask-border-mode", "mask-border-outset", "mask-border-repeat", "mask-border-slice", "mask-border-source", "mask-border-width", "mask-clip", "mask-composite", "mask-image", "mask-mode", "mask-origin", "mask-position", "mask-repeat", "mask-size", "mask-type", "masonry-auto-flow", "math-depth", "math-shift", "math-style", "max-block-size", "max-height", "max-inline-size", "max-width", "min-block-size", "min-height", "min-inline-size", "min-width", "mix-blend-mode", "nav-down", "nav-index", "nav-left", "nav-right", "nav-up", "none", "normal", "object-fit", "object-position", "offset", "offset-anchor", "offset-distance", "offset-path", "offset-position", "offset-rotate", "opacity", "order", "orphans", "outline", "outline-color", "outline-offset", "outline-style", "outline-width", "overflow", "overflow-anchor", "overflow-block", "overflow-clip-margin", "overflow-inline", "overflow-wrap", "overflow-x", "overflow-y", "overlay", "overscroll-behavior", "overscroll-behavior-block", "overscroll-behavior-inline", "overscroll-behavior-x", "overscroll-behavior-y", "padding", "padding-block", "padding-block-end", "padding-block-start", "padding-bottom", "padding-inline", "padding-inline-end", "padding-inline-start", "padding-left", "padding-right", "padding-top", "page", "page-break-after", "page-break-before", "page-break-inside", "paint-order", "pause", "pause-after", "pause-before", "perspective", "perspective-origin", "place-content", "place-items", "place-self", "pointer-events", "position", "position-anchor", "position-visibility", "print-color-adjust", "quotes", "r", "resize", "rest", "rest-after", "rest-before", "right", "rotate", "row-gap", "ruby-align", "ruby-position", "scale", "scroll-behavior", "scroll-margin", "scroll-margin-block", "scroll-margin-block-end", "scroll-margin-block-start", "scroll-margin-bottom", "scroll-margin-inline", "scroll-margin-inline-end", "scroll-margin-inline-start", "scroll-margin-left", "scroll-margin-right", "scroll-margin-top", "scroll-padding", "scroll-padding-block", "scroll-padding-block-end", "scroll-padding-block-start", "scroll-padding-bottom", "scroll-padding-inline", "scroll-padding-inline-end", "scroll-padding-inline-start", "scroll-padding-left", "scroll-padding-right", "scroll-padding-top", "scroll-snap-align", "scroll-snap-stop", "scroll-snap-type", "scroll-timeline", "scroll-timeline-axis", "scroll-timeline-name", "scrollbar-color", "scrollbar-gutter", "scrollbar-width", "shape-image-threshold", "shape-margin", "shape-outside", "shape-rendering", "speak", "speak-as", "src", "stop-color", "stop-opacity", "stroke", "stroke-dasharray", "stroke-dashoffset", "stroke-linecap", "stroke-linejoin", "stroke-miterlimit", "stroke-opacity", "stroke-width", "tab-size", "table-layout", "text-align", "text-align-all", "text-align-last", "text-anchor", "text-combine-upright", "text-decoration", "text-decoration-color", "text-decoration-line", "text-decoration-skip", "text-decoration-skip-ink", "text-decoration-style", "text-decoration-thickness", "text-emphasis", "text-emphasis-color", "text-emphasis-position", "text-emphasis-style", "text-indent", "text-justify", "text-orientation", "text-overflow", "text-rendering", "text-shadow", "text-size-adjust", "text-transform", "text-underline-offset", "text-underline-position", "text-wrap", "text-wrap-mode", "text-wrap-style", "timeline-scope", "top", "touch-action", "transform", "transform-box", "transform-origin", "transform-style", "transition", "transition-behavior", "transition-delay", "transition-duration", "transition-property", "transition-timing-function", "translate", "unicode-bidi", "user-modify", "user-select", "vector-effect", "vertical-align", "view-timeline", "view-timeline-axis", "view-timeline-inset", "view-timeline-name", "view-transition-name", "visibility", "voice-balance", "voice-duration", "voice-family", "voice-pitch", "voice-range", "voice-rate", "voice-stress", "voice-volume", "white-space", "white-space-collapse", "widows", "width", "will-change", "word-break", "word-spacing", "word-wrap", "writing-mode", "x", "y", "z-index", "zoom"].sort().reverse(); function PIe(n) { const e = n.regex, t = kIe(n), r = { begin: /-(webkit|moz|ms|o)-(?=[a-z])/ }, i = "and or not only", a = /@-?\w[\w]*(-\w+)*/, o = "[a-zA-Z-][a-zA-Z0-9_-]*", s = [n.APOS_STRING_MODE, n.QUOTE_STRING_MODE]; return { name: "CSS", case_insensitive: !0, illegal: /[=|'\$]/, keywords: { keyframePosition: "from to" }, classNameAliases: { keyframePosition: "selector-tag" }, contains: [t.BLOCK_COMMENT, r, t.CSS_NUMBER_MODE, { className: "selector-id", begin: /#[A-Za-z0-9_-]+/, relevance: 0 }, { className: "selector-class", begin: "\\." + o, relevance: 0 }, t.ATTRIBUTE_SELECTOR_MODE, { className: "selector-pseudo", variants: [{ begin: ":(" + OIe.join("|") + ")" }, { begin: ":(:)?(" + DIe.join("|") + ")" }] }, t.CSS_VARIABLE, { className: "attribute", begin: "\\b(" + jIe.join("|") + ")\\b" }, { begin: /:/, end: /[;}{]/, contains: [t.BLOCK_COMMENT, t.HEXCOLOR, t.IMPORTANT, t.CSS_NUMBER_MODE, ...s, { begin: /(url|data-uri)\(/, end: /\)/, relevance: 0, keywords: { built_in: "url data-uri" }, contains: [...s, { className: "string", begin: /[^)]/, endsWithParent: !0, excludeEnd: !0 }] }, t.FUNCTION_DISPATCH] }, { begin: e.lookahead(/@/), end: "[{;]", relevance: 0, illegal: /:/, contains: [{ className: "keyword", begin: a }, { begin: /\s/, endsWithParent: !0, excludeEnd: !0, relevance: 0, keywords: { $pattern: /[a-z-]+/, keyword: i, attribute: MIe.join(" ") }, contains: [{ begin: /[a-z-]+(?=:)/, className: "attribute" }, ...s, t.CSS_NUMBER_MODE] }] }, { className: "selector-tag", begin: "\\b(" + EIe.join("|") + ")\\b" }] } } function IIe(n) { const e = n.regex; return { name: "Diff", aliases: ["patch"], contains: [{ className: "meta", relevance: 10, match: e.either(/^@@ +-\d+,\d+ +\+\d+,\d+ +@@/, /^\*\*\* +\d+,\d+ +\*\*\*\*$/, /^--- +\d+,\d+ +----$/) }, { className: "comment", variants: [{ begin: e.either(/Index: /, /^index/, /={3,}/, /^-{3}/, /^\*{3} /, /^\+{3}/, /^diff --git/), end: /$/ }, { match: /^\*{15}$/ }] }, { className: "addition", begin: /^\+/, end: /$/ }, { className: "deletion", begin: /^-/, end: /$/ }, { className: "addition", begin: /^!/, end: /$/ }] } } function LIe(n) { const a = { keyword: ["break", "case", "chan", "const", "continue", "default", "defer", "else", "fallthrough", "for", "func", "go", "goto", "if", "import", "interface", "map", "package", "range", "return", "select", "struct", "switch", "type", "var"], type: ["bool", "byte", "complex64", "complex128", "error", "float32", "float64", "int8", "int16", "int32", "int64", "string", "uint8", "uint16", "uint32", "uint64", "int", "uint", "uintptr", "rune"], literal: ["true", "false", "iota", "nil"], built_in: ["append", "cap", "close", "complex", "copy", "imag", "len", "make", "new", "panic", "print", "println", "real", "recover", "delete"] }; return { name: "Go", aliases: ["golang"], keywords: a, illegal: "</", contains: [n.C_LINE_COMMENT_MODE, n.C_BLOCK_COMMENT_MODE, { className: "string", variants: [n.QUOTE_STRING_MODE, n.APOS_STRING_MODE, { begin: "`", end: "`" }] }, { className: "number", variants: [{ match: /-?\b0[xX]\.[a-fA-F0-9](_?[a-fA-F0-9])*[pP][+-]?\d(_?\d)*i?/, relevance: 0 }, { match: /-?\b0[xX](_?[a-fA-F0-9])+((\.([a-fA-F0-9](_?[a-fA-F0-9])*)?)?[pP][+-]?\d(_?\d)*)?i?/, relevance: 0 }, { match: /-?\b0[oO](_?[0-7])*i?/, relevance: 0 }, { match: /-?\.\d(_?\d)*([eE][+-]?\d(_?\d)*)?i?/, relevance: 0 }, { match: /-?\b\d(_?\d)*(\.(\d(_?\d)*)?)?([eE][+-]?\d(_?\d)*)?i?/, relevance: 0 }] }, { begin: /:=/ }, { className: "function", beginKeywords: "func", end: "\\s*(\\{|$)", excludeEnd: !0, contains: [n.TITLE_MODE, { className: "params", begin: /\(/, end: /\)/, endsParent: !0, keywords: a, illegal: /["']/ }] }] } } function RIe(n) { const e = n.regex, t = /[_A-Za-z][_0-9A-Za-z]*/; return { name: "GraphQL", aliases: ["gql"], case_insensitive: !0, disableAutodetect: !1, keywords: { keyword: ["query", "mutation", "subscription", "type", "input", "schema", "directive", "interface", "union", "scalar", "fragment", "enum", "on"], literal: ["true", "false", "null"] }, contains: [n.HASH_COMMENT_MODE, n.QUOTE_STRING_MODE, n.NUMBER_MODE, { scope: "punctuation", match: /[.]{3}/, relevance: 0 }, { scope: "punctuation", begin: /[\!\(\)\:\=\[\]\{\|\}]{1}/, relevance: 0 }, { scope: "variable", begin: /\$/, end: /\W/, excludeEnd: !0, relevance: 0 }, { scope: "meta", match: /@\w+/, excludeEnd: !0 }, { scope: "symbol", begin: e.concat(t, e.lookahead(/\s*:/)), relevance: 0 }], illegal: [/[;<']/, /BEGIN/] } } function NIe(n) { const e = n.regex, t = { className: "number", relevance: 0, variants: [{ begin: /([+-]+)?[\d]+_[\d_]+/ }, { begin: n.NUMBER_RE }] }, r = n.COMMENT(); r.variants = [{ begin: /;/, end: /$/ }, { begin: /#/, end: /$/ }]; const i = { className: "variable", variants: [{ begin: /\$[\w\d"][\w\d_]*/ }, { begin: /\$\{(.*?)\}/ }] }, a = { className: "literal", begin: /\bon|off|true|false|yes|no\b/ }, o = { className: "string", contains: [n.BACKSLASH_ESCAPE], variants: [{ begin: "'''", end: "'''", relevance: 10 }, { begin: '"""', end: '"""', relevance: 10 }, { begin: '"', end: '"' }, { begin: "'", end: "'" }] }, s = { begin: /\[/, end: /\]/, contains: [r, a, i, o, t, "self"], relevance: 0 }, l = /[A-Za-z0-9_-]+/, c = /"(\\"|[^"])*"/, u = /'[^']*'/, d = e.either(l, c, u), f = e.concat(d, "(\\s*\\.\\s*", d, ")*", e.lookahead(/\s*=\s*[^#\s]/)); return { name: "TOML, also INI", aliases: ["toml"], case_insensitive: !0, illegal: /\S/, contains: [r, { className: "section", begin: /\[+/, end: /\]+/ }, { begin: f, className: "attr", starts: { end: /$/, contains: [r, s, a, i, o, t] } }] } } var ym = "[0-9](_*[0-9])*", dw = `\\.(${ym})`, fw = "[0-9a-fA-F](_*[0-9a-fA-F])*", Wz = { className: "number", variants: [{ begin: `(\\b(${ym})((${dw})|\\.)?|(${dw}))[eE][+-]?(${ym})[fFdD]?\\b` }, { begin: `\\b(${ym})((${dw})[fFdD]?\\b|\\.([fFdD]\\b)?)` }, { begin: `(${dw})[fFdD]?\\b` }, { begin: `\\b(${ym})[fFdD]\\b` }, { begin: `\\b0[xX]((${fw})\\.?|(${fw})?\\.(${fw}))[pP][+-]?(${ym})[fFdD]?\\b` }, { begin: "\\b(0|[1-9](_*[0-9])*)[lL]?\\b" }, { begin: `\\b0[xX](${fw})[lL]?\\b` }, { begin: "\\b0(_*[0-7])*[lL]?\\b" }, { begin: "\\b0[bB][01](_*[01])*[lL]?\\b" }], relevance: 0 }; function dQ(n, e, t) { return t === -1 ? "" : n.replace(e, r => dQ(n, e, t - 1)) } function BIe(n) { const e = n.regex, t = "[-a-zA-Z_$][-a-zA-Z_$0-9]*", r = t + dQ("(?:<" + t + "~~~(?:\\s*,\\s*" + t + "~~~)*>)?", /~~~/g, 2), l = { keyword: ["synchronized", "abstract", "private", "var", "static", "if", "const ", "for", "while", "strictfp", "finally", "protected", "import", "native", "final", "void", "enum", "else", "break", "transient", "catch", "instanceof", "volatile", "case", "assert", "package", "default", "public", "try", "switch", "continue", "throws", "protected", "public", "private", "module", "requires", "exports", "do", "sealed", "yield", "permits", "goto", "when"], literal: ["false", "true", "null"], type: ["char", "boolean", "long", "float", "int", "byte", "short", "double"], built_in: ["super", "this"] }, c = { className: "meta", begin: "@" + t, contains: [{ begin: /\(/, end: /\)/, contains: ["self"] }] }, u = { className: "params", begin: /\(/, end: /\)/, keywords: l, relevance: 0, contains: [n.C_BLOCK_COMMENT_MODE], endsParent: !0 }; return { name: "Java", aliases: ["jsp"], keywords: l, illegal: /<\/|#/, contains: [n.COMMENT("/\\*\\*", "\\*/", { relevance: 0, contains: [{ begin: /\w+@/, relevance: 0 }, { className: "doctag", begin: "@[A-Za-z]+" }] }), { begin: /import java\.[a-z]+\./, keywords: "import", relevance: 2 }, n.C_LINE_COMMENT_MODE, n.C_BLOCK_COMMENT_MODE, { begin: /"""/, end: /"""/, className: "string", contains: [n.BACKSLASH_ESCAPE] }, n.APOS_STRING_MODE, n.QUOTE_STRING_MODE, { match: [/\b(?:class|interface|enum|extends|implements|new)/, /\s+/, t], className: { 1: "keyword", 3: "title.class" } }, { match: /non-sealed/, scope: "keyword" }, { begin: [e.concat(/(?!else)/, t), /\s+/, t, /\s+/, /=(?!=)/], className: { 1: "type", 3: "variable", 5: "operator" } }, { begin: [/record/, /\s+/, t], className: { 1: "keyword", 3: "title.class" }, contains: [u, n.C_LINE_COMMENT_MODE, n.C_BLOCK_COMMENT_MODE] }, { beginKeywords: "new throw return else", relevance: 0 }, { begin: ["(?:" + r + "\\s+)", n.UNDERSCORE_IDENT_RE, /\s*(?=\()/], className: { 2: "title.function" }, keywords: l, contains: [{ className: "params", begin: /\(/, end: /\)/, keywords: l, relevance: 0, contains: [c, n.APOS_STRING_MODE, n.QUOTE_STRING_MODE, Wz, n.C_BLOCK_COMMENT_MODE] }, n.C_LINE_COMMENT_MODE, n.C_BLOCK_COMMENT_MODE] }, Wz, c] } } const Kz = "[A-Za-z$_][0-9A-Za-z$_]*", $Ie = ["as", "in", "of", "if", "for", "while", "finally", "var", "new", "function", "do", "return", "void", "else", "break", "catch", "instanceof", "with", "throw", "case", "default", "try", "switch", "continue", "typeof", "delete", "let", "yield", "const", "class", "debugger", "async", "await", "static", "import", "from", "export", "extends", "using"], FIe = ["true", "false", "null", "undefined", "NaN", "Infinity"], fQ = ["Object", "Function", "Boolean", "Symbol", "Math", "Date", "Number", "BigInt", "String", "RegExp", "Array", "Float32Array", "Float64Array", "Int8Array", "Uint8Array", "Uint8ClampedArray", "Int16Array", "Int32Array", "Uint16Array", "Uint32Array", "BigInt64Array", "BigUint64Array", "Set", "Map", "WeakSet", "WeakMap", "ArrayBuffer", "SharedArrayBuffer", "Atomics", "DataView", "JSON", "Promise", "Generator", "GeneratorFunction", "AsyncFunction", "Reflect", "Proxy", "Intl", "WebAssembly"], hQ = ["Error", "EvalError", "InternalError", "RangeError", "ReferenceError", "SyntaxError", "TypeError", "URIError"], pQ = ["setInterval", "setTimeout", "clearInterval", "clearTimeout", "require", "exports", "eval", "isFinite", "isNaN", "parseFloat", "parseInt", "decodeURI", "decodeURIComponent", "encodeURI", "encodeURIComponent", "escape", "unescape"], zIe = ["arguments", "this", "super", "console", "window", "document", "localStorage", "sessionStorage", "module", "global"], VIe = [].concat(pQ, fQ, hQ); function HIe(n) { const e = n.regex, t = (B, { after: F }) => { const K = "</" + B[0].slice(1); return B.input.indexOf(K, F) !== -1 }, r = Kz, i = { begin: "<>", end: "</>" }, a = /<[A-Za-z0-9\\._:-]+\s*\/>/, o = { begin: /<[A-Za-z0-9\\._:-]+/, end: /\/[A-Za-z0-9\\._:-]+>|\/>/, isTrulyOpeningTag: (B, F) => { const K = B[0].length + B.index, V = B.input[K]; if (V === "<" || V === ",") { F.ignoreMatch(); return } V === ">" && (t(B, { after: K }) || F.ignoreMatch()); let W; const J = B.input.substring(K); if (W = J.match(/^\s*=/)) { F.ignoreMatch(); return } if ((W = J.match(/^\s+extends\s+/)) && W.index === 0) { F.ignoreMatch(); return } } }, s = { $pattern: Kz, keyword: $Ie, literal: FIe, built_in: VIe, "variable.language": zIe }, l = "[0-9](_?[0-9])*", c = `\\.(${l})`, u = "0|[1-9](_?[0-9])*|0[0-7]*[89][0-9]*", d = { className: "number", variants: [{ begin: `(\\b(${u})((${c})|\\.)?|(${c}))[eE][+-]?(${l})\\b` }, { begin: `\\b(${u})\\b((${c})\\b|\\.)?|(${c})\\b` }, { begin: "\\b(0|[1-9](_?[0-9])*)n\\b" }, { begin: "\\b0[xX][0-9a-fA-F](_?[0-9a-fA-F])*n?\\b" }, { begin: "\\b0[bB][0-1](_?[0-1])*n?\\b" }, { begin: "\\b0[oO][0-7](_?[0-7])*n?\\b" }, { begin: "\\b0[0-7]+n?\\b" }], relevance: 0 }, f = { className: "subst", begin: "\\$\\{", end: "\\}", keywords: s, contains: [] }, h = { begin: ".?html`", end: "", starts: { end: "`", returnEnd: !1, contains: [n.BACKSLASH_ESCAPE, f], subLanguage: "xml" } }, p = { begin: ".?css`", end: "", starts: { end: "`", returnEnd: !1, contains: [n.BACKSLASH_ESCAPE, f], subLanguage: "css" } }, m = { begin: ".?gql`", end: "", starts: { end: "`", returnEnd: !1, contains: [n.BACKSLASH_ESCAPE, f], subLanguage: "graphql" } }, g = { className: "string", begin: "`", end: "`", contains: [n.BACKSLASH_ESCAPE, f] }, b = { className: "comment", variants: [n.COMMENT(/\/\*\*(?!\/)/, "\\*/", { relevance: 0, contains: [{ begin: "(?=@[A-Za-z]+)", relevance: 0, contains: [{ className: "doctag", begin: "@[A-Za-z]+" }, { className: "type", begin: "\\{", end: "\\}", excludeEnd: !0, excludeBegin: !0, relevance: 0 }, { className: "variable", begin: r + "(?=\\s*(-)|$)", endsParent: !0, relevance: 0 }, { begin: /(?=[^\n])\s/, relevance: 0 }] }] }), n.C_BLOCK_COMMENT_MODE, n.C_LINE_COMMENT_MODE] }, w = [n.APOS_STRING_MODE, n.QUOTE_STRING_MODE, h, p, m, g, { match: /\$\d+/ }, d]; f.contains = w.concat({ begin: /\{/, end: /\}/, keywords: s, contains: ["self"].concat(w) }); const v = [].concat(b, f.contains), S = v.concat([{ begin: /(\s*)\(/, end: /\)/, keywords: s, contains: ["self"].concat(v) }]), x = { className: "params", begin: /(\s*)\(/, end: /\)/, excludeBegin: !0, excludeEnd: !0, keywords: s, contains: S }, k = { variants: [{ match: [/class/, /\s+/, r, /\s+/, /extends/, /\s+/, e.concat(r, "(", e.concat(/\./, r), ")*")], scope: { 1: "keyword", 3: "title.class", 5: "keyword", 7: "title.class.inherited" } }, { match: [/class/, /\s+/, r], scope: { 1: "keyword", 3: "title.class" } }] }, A = { relevance: 0, match: e.either(/\bJSON/, /\b[A-Z][a-z]+([A-Z][a-z]*|\d)*/, /\b[A-Z]{2,}([A-Z][a-z]+|\d)+([A-Z][a-z]*)*/, /\b[A-Z]{2,}[a-z]+([A-Z][a-z]+|\d)*([A-Z][a-z]*)*/), className: "title.class", keywords: { _: [...fQ, ...hQ] } }, C = { label: "use_strict", className: "meta", relevance: 10, begin: /^\s*['"]use (strict|asm)['"]/ }, E = { variants: [{ match: [/function/, /\s+/, r, /(?=\s*\()/] }, { match: [/function/, /\s*(?=\()/] }], className: { 1: "keyword", 3: "title.function" }, label: "func.def", contains: [x], illegal: /%/ }, O = { relevance: 0, match: /\b[A-Z][A-Z_0-9]+\b/, className: "variable.constant" }; function j(B) { return e.concat("(?!", B.join("|"), ")") } const I = { match: e.concat(/\b/, j([...pQ, "super", "import"].map(B => `${B}\\s*\\(`)), r, e.lookahead(/\s*\(/)), className: "title.function", relevance: 0 }, L = { begin: e.concat(/\./, e.lookahead(e.concat(r, /(?![0-9A-Za-z$_(])/))), end: r, excludeBegin: !0, keywords: "prototype", className: "property", relevance: 0 }, R = { match: [/get|set/, /\s+/, r, /(?=\()/], className: { 1: "keyword", 3: "title.function" }, contains: [{ begin: /\(\)/ }, x] }, D = "(\\([^()]*(\\([^()]*(\\([^()]*\\)[^()]*)*\\)[^()]*)*\\)|" + n.UNDERSCORE_IDENT_RE + ")\\s*=>", P = { match: [/const|var|let/, /\s+/, r, /\s*/, /=\s*/, /(async\s*)?/, e.lookahead(D)], keywords: "async", className: { 1: "keyword", 3: "title.function" }, contains: [x] }; return { name: "JavaScript", aliases: ["js", "jsx", "mjs", "cjs"], keywords: s, exports: { PARAMS_CONTAINS: S, CLASS_REFERENCE: A }, illegal: /#(?![$_A-z])/, contains: [n.SHEBANG({ label: "shebang", binary: "node", relevance: 5 }), C, n.APOS_STRING_MODE, n.QUOTE_STRING_MODE, h, p, m, g, b, { match: /\$\d+/ }, d, A, { scope: "attr", match: r + e.lookahead(":"), relevance: 0 }, P, { begin: "(" + n.RE_STARTERS_RE + "|\\b(case|return|throw)\\b)\\s*", keywords: "return throw case", relevance: 0, contains: [b, n.REGEXP_MODE, { className: "function", begin: D, returnBegin: !0, end: "\\s*=>", contains: [{ className: "params", variants: [{ begin: n.UNDERSCORE_IDENT_RE, relevance: 0 }, { className: null, begin: /\(\s*\)/, skip: !0 }, { begin: /(\s*)\(/, end: /\)/, excludeBegin: !0, excludeEnd: !0, keywords: s, contains: S }] }] }, { begin: /,/, relevance: 0 }, { match: /\s+/, relevance: 0 }, { variants: [{ begin: i.begin, end: i.end }, { match: a }, { begin: o.begin, "on:begin": o.isTrulyOpeningTag, end: o.end }], subLanguage: "xml", contains: [{ begin: o.begin, end: o.end, skip: !0, contains: ["self"] }] }] }, E, { beginKeywords: "while if switch catch for" }, { begin: "\\b(?!function)" + n.UNDERSCORE_IDENT_RE + "\\([^()]*(\\([^()]*(\\([^()]*\\)[^()]*)*\\)[^()]*)*\\)\\s*\\{", returnBegin: !0, label: "func.def", contains: [x, n.inherit(n.TITLE_MODE, { begin: r, className: "title.function" })] }, { match: /\.\.\./, relevance: 0 }, L, { match: "\\$" + r, relevance: 0 }, { match: [/\bconstructor(?=\s*\()/], className: { 1: "title.function" }, contains: [x] }, I, O, k, R, { match: /\$[(.]/ }] } } function UIe(n) { const e = { className: "attr", begin: /"(\\.|[^\\"\r\n])*"(?=\s*:)/, relevance: 1.01 }, t = { match: /[{}[\],:]/, className: "punctuation", relevance: 0 }, r = ["true", "false", "null"], i = { scope: "literal", beginKeywords: r.join(" ") }; return { name: "JSON", aliases: ["jsonc"], keywords: { literal: r }, contains: [e, t, n.QUOTE_STRING_MODE, i, n.C_NUMBER_MODE, n.C_LINE_COMMENT_MODE, n.C_BLOCK_COMMENT_MODE], illegal: "\\S" } } var _m = "[0-9](_*[0-9])*", hw = `\\.(${_m})`, pw = "[0-9a-fA-F](_*[0-9a-fA-F])*", GIe = { className: "number", variants: [{ begin: `(\\b(${_m})((${hw})|\\.)?|(${hw}))[eE][+-]?(${_m})[fFdD]?\\b` }, { begin: `\\b(${_m})((${hw})[fFdD]?\\b|\\.([fFdD]\\b)?)` }, { begin: `(${hw})[fFdD]?\\b` }, { begin: `\\b(${_m})[fFdD]\\b` }, { begin: `\\b0[xX]((${pw})\\.?|(${pw})?\\.(${pw}))[pP][+-]?(${_m})[fFdD]?\\b` }, { begin: "\\b(0|[1-9](_*[0-9])*)[lL]?\\b" }, { begin: `\\b0[xX](${pw})[lL]?\\b` }, { begin: "\\b0(_*[0-7])*[lL]?\\b" }, { begin: "\\b0[bB][01](_*[01])*[lL]?\\b" }], relevance: 0 }; function WIe(n) {
  const e = { keyword: "abstract as val var vararg get set class object open private protected public noinline crossinline dynamic final enum if else do while for when throw try catch finally import package is in fun override companion reified inline lateinit init interface annotation data sealed internal infix operator out by constructor super tailrec where const inner suspend typealias external expect actual", built_in: "Byte Short Char Int Long Boolean Float Double Void Unit Nothing", literal: "true false null" }, t = { className: "keyword", begin: /\b(break|continue|return|this)\b/, starts: { contains: [{ className: "symbol", begin: /@\w+/ }] } }, r = { className: "symbol", begin: n.UNDERSCORE_IDENT_RE + "@" }, i = { className: "subst", begin: /\$\{/, end: /\}/, contains: [n.C_NUMBER_MODE] }, a = { className: "variable", begin: "\\$" + n.UNDERSCORE_IDENT_RE }, o = { className: "string", variants: [{ begin: '"""', end: '"""(?=[^"])', contains: [a, i] }, { begin: "'", end: "'", illegal: /\n/, contains: [n.BACKSLASH_ESCAPE] }, { begin: '"', end: '"', illegal: /\n/, contains: [n.BACKSLASH_ESCAPE, a, i] }] }; i.contains.push(o); const s = { className: "meta", begin: "@(?:file|property|field|get|set|receiver|param|setparam|delegate)\\s*:(?:\\s*" + n.UNDERSCORE_IDENT_RE + ")?" }, l = { className: "meta", begin: "@" + n.UNDERSCORE_IDENT_RE, contains: [{ begin: /\(/, end: /\)/, contains: [n.inherit(o, { className: "string" }), "self"] }] }, c = GIe, u = n.COMMENT("/\\*", "\\*/", { contains: [n.C_BLOCK_COMMENT_MODE] }), d = { variants: [{ className: "type", begin: n.UNDERSCORE_IDENT_RE }, { begin: /\(/, end: /\)/, contains: [] }] }, f = d; return f.variants[1].contains = [d], d.variants[1].contains = [f], {
    name: "Kotlin", aliases: ["kt", "kts"], keywords: e, contains: [n.COMMENT("/\\*\\*", "\\*/", { relevance: 0, contains: [{ className: "doctag", begin: "@[A-Za-z]+" }] }), n.C_LINE_COMMENT_MODE, u, t, r, s, l, { className: "function", beginKeywords: "fun", end: "[(]|$", returnBegin: !0, excludeEnd: !0, keywords: e, relevance: 5, contains: [{ begin: n.UNDERSCORE_IDENT_RE + "\\s*\\(", returnBegin: !0, relevance: 0, contains: [n.UNDERSCORE_TITLE_MODE] }, { className: "type", begin: /</, end: />/, keywords: "reified", relevance: 0 }, { className: "params", begin: /\(/, end: /\)/, endsParent: !0, keywords: e, relevance: 0, contains: [{ begin: /:/, end: /[=,\/]/, endsWithParent: !0, contains: [d, n.C_LINE_COMMENT_MODE, u], relevance: 0 }, n.C_LINE_COMMENT_MODE, u, s, l, o, n.C_NUMBER_MODE] }, u] }, { begin: [/class|interface|trait/, /\s+/, n.UNDERSCORE_IDENT_RE], beginScope: { 3: "title.class" }, keywords: "class interface trait", end: /[:\{(]|$/, excludeEnd: !0, illegal: "extends implements", contains: [{ beginKeywords: "public protected internal private constructor" }, n.UNDERSCORE_TITLE_MODE, { className: "type", begin: /</, end: />/, excludeBegin: !0, excludeEnd: !0, relevance: 0 }, { className: "type", begin: /[,:]\s*/, end: /[<\(,){\s]|$/, excludeBegin: !0, returnEnd: !0 }, s, l] }, o, {
      className: "meta", begin: "^#!/usr/bin/env", end: "$", illegal: `
`}, c]
  }
} const KIe = n => ({ IMPORTANT: { scope: "meta", begin: "!important" }, BLOCK_COMMENT: n.C_BLOCK_COMMENT_MODE, HEXCOLOR: { scope: "number", begin: /#(([0-9a-fA-F]{3,4})|(([0-9a-fA-F]{2}){3,4}))\b/ }, FUNCTION_DISPATCH: { className: "built_in", begin: /[\w-]+(?=\()/ }, ATTRIBUTE_SELECTOR_MODE: { scope: "selector-attr", begin: /\[/, end: /\]/, illegal: "$", contains: [n.APOS_STRING_MODE, n.QUOTE_STRING_MODE] }, CSS_NUMBER_MODE: { scope: "number", begin: n.NUMBER_RE + "(%|em|ex|ch|rem|vw|vh|vmin|vmax|cm|mm|in|pt|pc|px|deg|grad|rad|turn|s|ms|Hz|kHz|dpi|dpcm|dppx)?", relevance: 0 }, CSS_VARIABLE: { className: "attr", begin: /--[A-Za-z_][A-Za-z0-9_-]*/ } }), qIe = ["a", "abbr", "address", "article", "aside", "audio", "b", "blockquote", "body", "button", "canvas", "caption", "cite", "code", "dd", "del", "details", "dfn", "div", "dl", "dt", "em", "fieldset", "figcaption", "figure", "footer", "form", "h1", "h2", "h3", "h4", "h5", "h6", "header", "hgroup", "html", "i", "iframe", "img", "input", "ins", "kbd", "label", "legend", "li", "main", "mark", "menu", "nav", "object", "ol", "optgroup", "option", "p", "picture", "q", "quote", "samp", "section", "select", "source", "span", "strong", "summary", "sup", "table", "tbody", "td", "textarea", "tfoot", "th", "thead", "time", "tr", "ul", "var", "video"], YIe = ["defs", "g", "marker", "mask", "pattern", "svg", "switch", "symbol", "feBlend", "feColorMatrix", "feComponentTransfer", "feComposite", "feConvolveMatrix", "feDiffuseLighting", "feDisplacementMap", "feFlood", "feGaussianBlur", "feImage", "feMerge", "feMorphology", "feOffset", "feSpecularLighting", "feTile", "feTurbulence", "linearGradient", "radialGradient", "stop", "circle", "ellipse", "image", "line", "path", "polygon", "polyline", "rect", "text", "use", "textPath", "tspan", "foreignObject", "clipPath"], ZIe = [...qIe, ...YIe], XIe = ["any-hover", "any-pointer", "aspect-ratio", "color", "color-gamut", "color-index", "device-aspect-ratio", "device-height", "device-width", "display-mode", "forced-colors", "grid", "height", "hover", "inverted-colors", "monochrome", "orientation", "overflow-block", "overflow-inline", "pointer", "prefers-color-scheme", "prefers-contrast", "prefers-reduced-motion", "prefers-reduced-transparency", "resolution", "scan", "scripting", "update", "width", "min-width", "max-width", "min-height", "max-height"].sort().reverse(), mQ = ["active", "any-link", "blank", "checked", "current", "default", "defined", "dir", "disabled", "drop", "empty", "enabled", "first", "first-child", "first-of-type", "fullscreen", "future", "focus", "focus-visible", "focus-within", "has", "host", "host-context", "hover", "indeterminate", "in-range", "invalid", "is", "lang", "last-child", "last-of-type", "left", "link", "local-link", "not", "nth-child", "nth-col", "nth-last-child", "nth-last-col", "nth-last-of-type", "nth-of-type", "only-child", "only-of-type", "optional", "out-of-range", "past", "placeholder-shown", "read-only", "read-write", "required", "right", "root", "scope", "target", "target-within", "user-invalid", "valid", "visited", "where"].sort().reverse(), gQ = ["after", "backdrop", "before", "cue", "cue-region", "first-letter", "first-line", "grammar-error", "marker", "part", "placeholder", "selection", "slotted", "spelling-error"].sort().reverse(), JIe = ["accent-color", "align-content", "align-items", "align-self", "alignment-baseline", "all", "anchor-name", "animation", "animation-composition", "animation-delay", "animation-direction", "animation-duration", "animation-fill-mode", "animation-iteration-count", "animation-name", "animation-play-state", "animation-range", "animation-range-end", "animation-range-start", "animation-timeline", "animation-timing-function", "appearance", "aspect-ratio", "backdrop-filter", "backface-visibility", "background", "background-attachment", "background-blend-mode", "background-clip", "background-color", "background-image", "background-origin", "background-position", "background-position-x", "background-position-y", "background-repeat", "background-size", "baseline-shift", "block-size", "border", "border-block", "border-block-color", "border-block-end", "border-block-end-color", "border-block-end-style", "border-block-end-width", "border-block-start", "border-block-start-color", "border-block-start-style", "border-block-start-width", "border-block-style", "border-block-width", "border-bottom", "border-bottom-color", "border-bottom-left-radius", "border-bottom-right-radius", "border-bottom-style", "border-bottom-width", "border-collapse", "border-color", "border-end-end-radius", "border-end-start-radius", "border-image", "border-image-outset", "border-image-repeat", "border-image-slice", "border-image-source", "border-image-width", "border-inline", "border-inline-color", "border-inline-end", "border-inline-end-color", "border-inline-end-style", "border-inline-end-width", "border-inline-start", "border-inline-start-color", "border-inline-start-style", "border-inline-start-width", "border-inline-style", "border-inline-width", "border-left", "border-left-color", "border-left-style", "border-left-width", "border-radius", "border-right", "border-right-color", "border-right-style", "border-right-width", "border-spacing", "border-start-end-radius", "border-start-start-radius", "border-style", "border-top", "border-top-color", "border-top-left-radius", "border-top-right-radius", "border-top-style", "border-top-width", "border-width", "bottom", "box-align", "box-decoration-break", "box-direction", "box-flex", "box-flex-group", "box-lines", "box-ordinal-group", "box-orient", "box-pack", "box-shadow", "box-sizing", "break-after", "break-before", "break-inside", "caption-side", "caret-color", "clear", "clip", "clip-path", "clip-rule", "color", "color-interpolation", "color-interpolation-filters", "color-profile", "color-rendering", "color-scheme", "column-count", "column-fill", "column-gap", "column-rule", "column-rule-color", "column-rule-style", "column-rule-width", "column-span", "column-width", "columns", "contain", "contain-intrinsic-block-size", "contain-intrinsic-height", "contain-intrinsic-inline-size", "contain-intrinsic-size", "contain-intrinsic-width", "container", "container-name", "container-type", "content", "content-visibility", "counter-increment", "counter-reset", "counter-set", "cue", "cue-after", "cue-before", "cursor", "cx", "cy", "direction", "display", "dominant-baseline", "empty-cells", "enable-background", "field-sizing", "fill", "fill-opacity", "fill-rule", "filter", "flex", "flex-basis", "flex-direction", "flex-flow", "flex-grow", "flex-shrink", "flex-wrap", "float", "flood-color", "flood-opacity", "flow", "font", "font-display", "font-family", "font-feature-settings", "font-kerning", "font-language-override", "font-optical-sizing", "font-palette", "font-size", "font-size-adjust", "font-smooth", "font-smoothing", "font-stretch", "font-style", "font-synthesis", "font-synthesis-position", "font-synthesis-small-caps", "font-synthesis-style", "font-synthesis-weight", "font-variant", "font-variant-alternates", "font-variant-caps", "font-variant-east-asian", "font-variant-emoji", "font-variant-ligatures", "font-variant-numeric", "font-variant-position", "font-variation-settings", "font-weight", "forced-color-adjust", "gap", "glyph-orientation-horizontal", "glyph-orientation-vertical", "grid", "grid-area", "grid-auto-columns", "grid-auto-flow", "grid-auto-rows", "grid-column", "grid-column-end", "grid-column-start", "grid-gap", "grid-row", "grid-row-end", "grid-row-start", "grid-template", "grid-template-areas", "grid-template-columns", "grid-template-rows", "hanging-punctuation", "height", "hyphenate-character", "hyphenate-limit-chars", "hyphens", "icon", "image-orientation", "image-rendering", "image-resolution", "ime-mode", "initial-letter", "initial-letter-align", "inline-size", "inset", "inset-area", "inset-block", "inset-block-end", "inset-block-start", "inset-inline", "inset-inline-end", "inset-inline-start", "isolation", "justify-content", "justify-items", "justify-self", "kerning", "left", "letter-spacing", "lighting-color", "line-break", "line-height", "line-height-step", "list-style", "list-style-image", "list-style-position", "list-style-type", "margin", "margin-block", "margin-block-end", "margin-block-start", "margin-bottom", "margin-inline", "margin-inline-end", "margin-inline-start", "margin-left", "margin-right", "margin-top", "margin-trim", "marker", "marker-end", "marker-mid", "marker-start", "marks", "mask", "mask-border", "mask-border-mode", "mask-border-outset", "mask-border-repeat", "mask-border-slice", "mask-border-source", "mask-border-width", "mask-clip", "mask-composite", "mask-image", "mask-mode", "mask-origin", "mask-position", "mask-repeat", "mask-size", "mask-type", "masonry-auto-flow", "math-depth", "math-shift", "math-style", "max-block-size", "max-height", "max-inline-size", "max-width", "min-block-size", "min-height", "min-inline-size", "min-width", "mix-blend-mode", "nav-down", "nav-index", "nav-left", "nav-right", "nav-up", "none", "normal", "object-fit", "object-position", "offset", "offset-anchor", "offset-distance", "offset-path", "offset-position", "offset-rotate", "opacity", "order", "orphans", "outline", "outline-color", "outline-offset", "outline-style", "outline-width", "overflow", "overflow-anchor", "overflow-block", "overflow-clip-margin", "overflow-inline", "overflow-wrap", "overflow-x", "overflow-y", "overlay", "overscroll-behavior", "overscroll-behavior-block", "overscroll-behavior-inline", "overscroll-behavior-x", "overscroll-behavior-y", "padding", "padding-block", "padding-block-end", "padding-block-start", "padding-bottom", "padding-inline", "padding-inline-end", "padding-inline-start", "padding-left", "padding-right", "padding-top", "page", "page-break-after", "page-break-before", "page-break-inside", "paint-order", "pause", "pause-after", "pause-before", "perspective", "perspective-origin", "place-content", "place-items", "place-self", "pointer-events", "position", "position-anchor", "position-visibility", "print-color-adjust", "quotes", "r", "resize", "rest", "rest-after", "rest-before", "right", "rotate", "row-gap", "ruby-align", "ruby-position", "scale", "scroll-behavior", "scroll-margin", "scroll-margin-block", "scroll-margin-block-end", "scroll-margin-block-start", "scroll-margin-bottom", "scroll-margin-inline", "scroll-margin-inline-end", "scroll-margin-inline-start", "scroll-margin-left", "scroll-margin-right", "scroll-margin-top", "scroll-padding", "scroll-padding-block", "scroll-padding-block-end", "scroll-padding-block-start", "scroll-padding-bottom", "scroll-padding-inline", "scroll-padding-inline-end", "scroll-padding-inline-start", "scroll-padding-left", "scroll-padding-right", "scroll-padding-top", "scroll-snap-align", "scroll-snap-stop", "scroll-snap-type", "scroll-timeline", "scroll-timeline-axis", "scroll-timeline-name", "scrollbar-color", "scrollbar-gutter", "scrollbar-width", "shape-image-threshold", "shape-margin", "shape-outside", "shape-rendering", "speak", "speak-as", "src", "stop-color", "stop-opacity", "stroke", "stroke-dasharray", "stroke-dashoffset", "stroke-linecap", "stroke-linejoin", "stroke-miterlimit", "stroke-opacity", "stroke-width", "tab-size", "table-layout", "text-align", "text-align-all", "text-align-last", "text-anchor", "text-combine-upright", "text-decoration", "text-decoration-color", "text-decoration-line", "text-decoration-skip", "text-decoration-skip-ink", "text-decoration-style", "text-decoration-thickness", "text-emphasis", "text-emphasis-color", "text-emphasis-position", "text-emphasis-style", "text-indent", "text-justify", "text-orientation", "text-overflow", "text-rendering", "text-shadow", "text-size-adjust", "text-transform", "text-underline-offset", "text-underline-position", "text-wrap", "text-wrap-mode", "text-wrap-style", "timeline-scope", "top", "touch-action", "transform", "transform-box", "transform-origin", "transform-style", "transition", "transition-behavior", "transition-delay", "transition-duration", "transition-property", "transition-timing-function", "translate", "unicode-bidi", "user-modify", "user-select", "vector-effect", "vertical-align", "view-timeline", "view-timeline-axis", "view-timeline-inset", "view-timeline-name", "view-transition-name", "visibility", "voice-balance", "voice-duration", "voice-family", "voice-pitch", "voice-range", "voice-rate", "voice-stress", "voice-volume", "white-space", "white-space-collapse", "widows", "width", "will-change", "word-break", "word-spacing", "word-wrap", "writing-mode", "x", "y", "z-index", "zoom"].sort().reverse(), QIe = mQ.concat(gQ).sort().reverse(); function eLe(n) { const e = KIe(n), t = QIe, r = "and or not only", i = "[\\w-]+", a = "(" + i + "|@\\{" + i + "\\})", o = [], s = [], l = function (w) { return { className: "string", begin: "~?" + w + ".*?" + w } }, c = function (w, v, S) { return { className: w, begin: v, relevance: S } }, u = { $pattern: /[a-z-]+/, keyword: r, attribute: XIe.join(" ") }, d = { begin: "\\(", end: "\\)", contains: s, keywords: u, relevance: 0 }; s.push(n.C_LINE_COMMENT_MODE, n.C_BLOCK_COMMENT_MODE, l("'"), l('"'), e.CSS_NUMBER_MODE, { begin: "(url|data-uri)\\(", starts: { className: "string", end: "[\\)\\n]", excludeEnd: !0 } }, e.HEXCOLOR, d, c("variable", "@@?" + i, 10), c("variable", "@\\{" + i + "\\}"), c("built_in", "~?`[^`]*?`"), { className: "attribute", begin: i + "\\s*:", end: ":", returnBegin: !0, excludeEnd: !0 }, e.IMPORTANT, { beginKeywords: "and not" }, e.FUNCTION_DISPATCH); const f = s.concat({ begin: /\{/, end: /\}/, contains: o }), h = { beginKeywords: "when", endsWithParent: !0, contains: [{ beginKeywords: "and not" }].concat(s) }, p = { begin: a + "\\s*:", returnBegin: !0, end: /[;}]/, relevance: 0, contains: [{ begin: /-(webkit|moz|ms|o)-/ }, e.CSS_VARIABLE, { className: "attribute", begin: "\\b(" + JIe.join("|") + ")\\b", end: /(?=:)/, starts: { endsWithParent: !0, illegal: "[<=$]", relevance: 0, contains: s } }] }, m = { className: "keyword", begin: "@(import|media|charset|font-face|(-[a-z]+-)?keyframes|supports|document|namespace|page|viewport|host)\\b", starts: { end: "[;{}]", keywords: u, returnEnd: !0, contains: s, relevance: 0 } }, g = { className: "variable", variants: [{ begin: "@" + i + "\\s*:", relevance: 15 }, { begin: "@" + i }], starts: { end: "[;}]", returnEnd: !0, contains: f } }, y = { variants: [{ begin: "[\\.#:&\\[>]", end: "[;{}]" }, { begin: a, end: /\{/ }], returnBegin: !0, returnEnd: !0, illegal: `[<='$"]`, relevance: 0, contains: [n.C_LINE_COMMENT_MODE, n.C_BLOCK_COMMENT_MODE, h, c("keyword", "all\\b"), c("variable", "@\\{" + i + "\\}"), { begin: "\\b(" + ZIe.join("|") + ")\\b", className: "selector-tag" }, e.CSS_NUMBER_MODE, c("selector-tag", a, 0), c("selector-id", "#" + a), c("selector-class", "\\." + a, 0), c("selector-tag", "&", 0), e.ATTRIBUTE_SELECTOR_MODE, { className: "selector-pseudo", begin: ":(" + mQ.join("|") + ")" }, { className: "selector-pseudo", begin: ":(:)?(" + gQ.join("|") + ")" }, { begin: /\(/, end: /\)/, relevance: 0, contains: f }, { begin: "!important" }, e.FUNCTION_DISPATCH] }, b = { begin: i + `:(:)?(${t.join("|")})`, returnBegin: !0, contains: [y] }; return o.push(n.C_LINE_COMMENT_MODE, n.C_BLOCK_COMMENT_MODE, m, g, b, p, y, h, e.FUNCTION_DISPATCH), { name: "Less", case_insensitive: !0, illegal: `[=>'/<($"]`, contains: o } } function tLe(n) { const e = "\\[=*\\[", t = "\\]=*\\]", r = { begin: e, end: t, contains: ["self"] }, i = [n.COMMENT("--(?!" + e + ")", "$"), n.COMMENT("--" + e, t, { contains: [r], relevance: 10 })]; return { name: "Lua", aliases: ["pluto"], keywords: { $pattern: n.UNDERSCORE_IDENT_RE, literal: "true false nil", keyword: "and break do else elseif end for goto if in local not or repeat return then until while", built_in: "_G _ENV _VERSION __index __newindex __mode __call __metatable __tostring __len __gc __add __sub __mul __div __mod __pow __concat __unm __eq __lt __le assert collectgarbage dofile error getfenv getmetatable ipairs load loadfile loadstring module next pairs pcall print rawequal rawget rawset require select setfenv setmetatable tonumber tostring type unpack xpcall arg self coroutine resume yield status wrap create running debug getupvalue debug sethook getmetatable gethook setmetatable setlocal traceback setfenv getinfo setupvalue getlocal getregistry getfenv io lines write close flush open output type read stderr stdin input stdout popen tmpfile math log max acos huge ldexp pi cos tanh pow deg tan cosh sinh random randomseed frexp ceil floor rad abs sqrt modf asin min mod fmod log10 atan2 exp sin atan os exit setlocale date getenv difftime remove time clock tmpname rename execute package preload loadlib loaded loaders cpath config path seeall string sub upper len gfind rep find match char dump gmatch reverse byte format gsub lower table setn insert getn foreachi maxn foreach concat sort remove" }, contains: i.concat([{ className: "function", beginKeywords: "function", end: "\\)", contains: [n.inherit(n.TITLE_MODE, { begin: "([_a-zA-Z]\\w*\\.)*([_a-zA-Z]\\w*:)?[_a-zA-Z]\\w*" }), { className: "params", begin: "\\(", endsWithParent: !0, contains: i }].concat(i) }, n.C_NUMBER_MODE, n.APOS_STRING_MODE, n.QUOTE_STRING_MODE, { className: "string", begin: e, end: t, contains: [r], relevance: 5 }]) } } function nLe(n) { const e = { className: "variable", variants: [{ begin: "\\$\\(" + n.UNDERSCORE_IDENT_RE + "\\)", contains: [n.BACKSLASH_ESCAPE] }, { begin: /\$[@%<?\^\+\*]/ }] }, t = { className: "string", begin: /"/, end: /"/, contains: [n.BACKSLASH_ESCAPE, e] }, r = { className: "variable", begin: /\$\([\w-]+\s/, end: /\)/, keywords: { built_in: "subst patsubst strip findstring filter filter-out sort word wordlist firstword lastword dir notdir suffix basename addsuffix addprefix join wildcard realpath abspath error warning shell origin flavor foreach if or and call eval file value" }, contains: [e, t] }, i = { begin: "^" + n.UNDERSCORE_IDENT_RE + "\\s*(?=[:+?]?=)" }, a = { className: "meta", begin: /^\.PHONY:/, end: /$/, keywords: { $pattern: /[\.\w]+/, keyword: ".PHONY" } }, o = { className: "section", begin: /^[^\s]+:/, end: /$/, contains: [e] }; return { name: "Makefile", aliases: ["mk", "mak", "make"], keywords: { $pattern: /[\w-]+/, keyword: "define endef undefine ifdef ifndef ifeq ifneq else endif include -include sinclude override export unexport private vpath" }, contains: [n.HASH_COMMENT_MODE, e, t, r, i, a, o] } } function rLe(n) { const e = n.regex, t = { begin: /<\/?[A-Za-z_]/, end: ">", subLanguage: "xml", relevance: 0 }, r = { begin: "^[-\\*]{3,}", end: "$" }, i = { className: "code", variants: [{ begin: "(`{3,})[^`](.|\\n)*?\\1`*[ ]*" }, { begin: "(~{3,})[^~](.|\\n)*?\\1~*[ ]*" }, { begin: "```", end: "```+[ ]*$" }, { begin: "~~~", end: "~~~+[ ]*$" }, { begin: "`.+?`" }, { begin: "(?=^( {4}|\\t))", contains: [{ begin: "^( {4}|\\t)", end: "(\\n)$" }], relevance: 0 }] }, a = { className: "bullet", begin: "^[ 	]*([*+-]|(\\d+\\.))(?=\\s+)", end: "\\s+", excludeEnd: !0 }, o = { begin: /^\[[^\n]+\]:/, returnBegin: !0, contains: [{ className: "symbol", begin: /\[/, end: /\]/, excludeBegin: !0, excludeEnd: !0 }, { className: "link", begin: /:\s*/, end: /$/, excludeBegin: !0 }] }, s = /[A-Za-z][A-Za-z0-9+.-]*/, l = { variants: [{ begin: /\[.+?\]\[.*?\]/, relevance: 0 }, { begin: /\[.+?\]\(((data|javascript|mailto):|(?:http|ftp)s?:\/\/).*?\)/, relevance: 2 }, { begin: e.concat(/\[.+?\]\(/, s, /:\/\/.*?\)/), relevance: 2 }, { begin: /\[.+?\]\([./?&#].*?\)/, relevance: 1 }, { begin: /\[.*?\]\(.*?\)/, relevance: 0 }], returnBegin: !0, contains: [{ match: /\[(?=\])/ }, { className: "string", relevance: 0, begin: "\\[", end: "\\]", excludeBegin: !0, returnEnd: !0 }, { className: "link", relevance: 0, begin: "\\]\\(", end: "\\)", excludeBegin: !0, excludeEnd: !0 }, { className: "symbol", relevance: 0, begin: "\\]\\[", end: "\\]", excludeBegin: !0, excludeEnd: !0 }] }, c = { className: "strong", contains: [], variants: [{ begin: /_{2}(?!\s)/, end: /_{2}/ }, { begin: /\*{2}(?!\s)/, end: /\*{2}/ }] }, u = { className: "emphasis", contains: [], variants: [{ begin: /\*(?![*\s])/, end: /\*/ }, { begin: /_(?![_\s])/, end: /_/, relevance: 0 }] }, d = n.inherit(c, { contains: [] }), f = n.inherit(u, { contains: [] }); c.contains.push(f), u.contains.push(d); let h = [t, l]; return [c, u, d, f].forEach(y => { y.contains = y.contains.concat(h) }), h = h.concat(c, u), { name: "Markdown", aliases: ["md", "mkdown", "mkd"], contains: [{ className: "section", variants: [{ begin: "^#{1,6}", end: "$", contains: h }, { begin: "(?=^.+?\\n[=-]{2,}$)", contains: [{ begin: "^[=-]*$" }, { begin: "^", end: "\\n", contains: h }] }] }, t, a, c, u, { className: "quote", begin: "^>\\s+", contains: h, end: "$" }, i, r, l, o, { scope: "literal", match: /&([a-zA-Z0-9]+|#[0-9]{1,7}|#[Xx][0-9a-fA-F]{1,6});/ }] } } function iLe(n) { const e = { className: "built_in", begin: "\\b(AV|CA|CF|CG|CI|CL|CM|CN|CT|MK|MP|MTK|MTL|NS|SCN|SK|UI|WK|XC)\\w+" }, t = /[a-zA-Z@][a-zA-Z0-9_]*/, s = { "variable.language": ["this", "super"], $pattern: t, keyword: ["while", "export", "sizeof", "typedef", "const", "struct", "for", "union", "volatile", "static", "mutable", "if", "do", "return", "goto", "enum", "else", "break", "extern", "asm", "case", "default", "register", "explicit", "typename", "switch", "continue", "inline", "readonly", "assign", "readwrite", "self", "@synchronized", "id", "typeof", "nonatomic", "IBOutlet", "IBAction", "strong", "weak", "copy", "in", "out", "inout", "bycopy", "byref", "oneway", "__strong", "__weak", "__block", "__autoreleasing", "@private", "@protected", "@public", "@try", "@property", "@end", "@throw", "@catch", "@finally", "@autoreleasepool", "@synthesize", "@dynamic", "@selector", "@optional", "@required", "@encode", "@package", "@import", "@defs", "@compatibility_alias", "__bridge", "__bridge_transfer", "__bridge_retained", "__bridge_retain", "__covariant", "__contravariant", "__kindof", "_Nonnull", "_Nullable", "_Null_unspecified", "__FUNCTION__", "__PRETTY_FUNCTION__", "__attribute__", "getter", "setter", "retain", "unsafe_unretained", "nonnull", "nullable", "null_unspecified", "null_resettable", "class", "instancetype", "NS_DESIGNATED_INITIALIZER", "NS_UNAVAILABLE", "NS_REQUIRES_SUPER", "NS_RETURNS_INNER_POINTER", "NS_INLINE", "NS_AVAILABLE", "NS_DEPRECATED", "NS_ENUM", "NS_OPTIONS", "NS_SWIFT_UNAVAILABLE", "NS_ASSUME_NONNULL_BEGIN", "NS_ASSUME_NONNULL_END", "NS_REFINED_FOR_SWIFT", "NS_SWIFT_NAME", "NS_SWIFT_NOTHROW", "NS_DURING", "NS_HANDLER", "NS_ENDHANDLER", "NS_VALUERETURN", "NS_VOIDRETURN"], literal: ["false", "true", "FALSE", "TRUE", "nil", "YES", "NO", "NULL"], built_in: ["dispatch_once_t", "dispatch_queue_t", "dispatch_sync", "dispatch_async", "dispatch_once"], type: ["int", "float", "char", "unsigned", "signed", "short", "long", "double", "wchar_t", "unichar", "void", "bool", "BOOL", "id|0", "_Bool"] }, l = { $pattern: t, keyword: ["@interface", "@class", "@protocol", "@implementation"] }; return { name: "Objective-C", aliases: ["mm", "objc", "obj-c", "obj-c++", "objective-c++"], keywords: s, illegal: "</", contains: [e, n.C_LINE_COMMENT_MODE, n.C_BLOCK_COMMENT_MODE, n.C_NUMBER_MODE, n.QUOTE_STRING_MODE, n.APOS_STRING_MODE, { className: "string", variants: [{ begin: '@"', end: '"', illegal: "\\n", contains: [n.BACKSLASH_ESCAPE] }] }, { className: "meta", begin: /#\s*[a-z]+\b/, end: /$/, keywords: { keyword: "if else elif endif define undef warning error line pragma ifdef ifndef include" }, contains: [{ begin: /\\\n/, relevance: 0 }, n.inherit(n.QUOTE_STRING_MODE, { className: "string" }), { className: "string", begin: /<.*?>/, end: /$/, illegal: "\\n" }, n.C_LINE_COMMENT_MODE, n.C_BLOCK_COMMENT_MODE] }, { className: "class", begin: "(" + l.keyword.join("|") + ")\\b", end: /(\{|$)/, excludeEnd: !0, keywords: l, contains: [n.UNDERSCORE_TITLE_MODE] }, { begin: "\\." + n.UNDERSCORE_IDENT_RE, relevance: 0 }] } } function aLe(n) { const e = n.regex, t = ["abs", "accept", "alarm", "and", "atan2", "bind", "binmode", "bless", "break", "caller", "chdir", "chmod", "chomp", "chop", "chown", "chr", "chroot", "class", "close", "closedir", "connect", "continue", "cos", "crypt", "dbmclose", "dbmopen", "defined", "delete", "die", "do", "dump", "each", "else", "elsif", "endgrent", "endhostent", "endnetent", "endprotoent", "endpwent", "endservent", "eof", "eval", "exec", "exists", "exit", "exp", "fcntl", "field", "fileno", "flock", "for", "foreach", "fork", "format", "formline", "getc", "getgrent", "getgrgid", "getgrnam", "gethostbyaddr", "gethostbyname", "gethostent", "getlogin", "getnetbyaddr", "getnetbyname", "getnetent", "getpeername", "getpgrp", "getpriority", "getprotobyname", "getprotobynumber", "getprotoent", "getpwent", "getpwnam", "getpwuid", "getservbyname", "getservbyport", "getservent", "getsockname", "getsockopt", "given", "glob", "gmtime", "goto", "grep", "gt", "hex", "if", "index", "int", "ioctl", "join", "keys", "kill", "last", "lc", "lcfirst", "length", "link", "listen", "local", "localtime", "log", "lstat", "lt", "ma", "map", "method", "mkdir", "msgctl", "msgget", "msgrcv", "msgsnd", "my", "ne", "next", "no", "not", "oct", "open", "opendir", "or", "ord", "our", "pack", "package", "pipe", "pop", "pos", "print", "printf", "prototype", "push", "q|0", "qq", "quotemeta", "qw", "qx", "rand", "read", "readdir", "readline", "readlink", "readpipe", "recv", "redo", "ref", "rename", "require", "reset", "return", "reverse", "rewinddir", "rindex", "rmdir", "say", "scalar", "seek", "seekdir", "select", "semctl", "semget", "semop", "send", "setgrent", "sethostent", "setnetent", "setpgrp", "setpriority", "setprotoent", "setpwent", "setservent", "setsockopt", "shift", "shmctl", "shmget", "shmread", "shmwrite", "shutdown", "sin", "sleep", "socket", "socketpair", "sort", "splice", "split", "sprintf", "sqrt", "srand", "stat", "state", "study", "sub", "substr", "symlink", "syscall", "sysopen", "sysread", "sysseek", "system", "syswrite", "tell", "telldir", "tie", "tied", "time", "times", "tr", "truncate", "uc", "ucfirst", "umask", "undef", "unless", "unlink", "unpack", "unshift", "untie", "until", "use", "utime", "values", "vec", "wait", "waitpid", "wantarray", "warn", "when", "while", "write", "x|0", "xor", "y|0"], r = /[dualxmsipngr]{0,12}/, i = { $pattern: /[\w.]+/, keyword: t.join(" ") }, a = { className: "subst", begin: "[$@]\\{", end: "\\}", keywords: i }, o = { begin: /->\{/, end: /\}/ }, s = { scope: "attr", match: /\s+:\s*\w+(\s*\(.*?\))?/ }, l = { scope: "variable", variants: [{ begin: /\$\d/ }, { begin: e.concat(/[$%@](?!")(\^\w\b|#\w+(::\w+)*|\{\w+\}|\w+(::\w*)*)/, "(?![A-Za-z])(?![@$%])") }, { begin: /[$%@](?!")[^\s\w{=]|\$=/, relevance: 0 }], contains: [s] }, c = { className: "number", variants: [{ match: /0?\.[0-9][0-9_]+\b/ }, { match: /\bv?(0|[1-9][0-9_]*(\.[0-9_]+)?|[1-9][0-9_]*)\b/ }, { match: /\b0[0-7][0-7_]*\b/ }, { match: /\b0x[0-9a-fA-F][0-9a-fA-F_]*\b/ }, { match: /\b0b[0-1][0-1_]*\b/ }], relevance: 0 }, u = [n.BACKSLASH_ESCAPE, a, l], d = [/!/, /\//, /\|/, /\?/, /'/, /"/, /#/], f = (m, g, y = "\\1") => { const b = y === "\\1" ? y : e.concat(y, g); return e.concat(e.concat("(?:", m, ")"), g, /(?:\\.|[^\\\/])*?/, b, /(?:\\.|[^\\\/])*?/, y, r) }, h = (m, g, y) => e.concat(e.concat("(?:", m, ")"), g, /(?:\\.|[^\\\/])*?/, y, r), p = [l, n.HASH_COMMENT_MODE, n.COMMENT(/^=\w/, /=cut/, { endsWithParent: !0 }), o, { className: "string", contains: u, variants: [{ begin: "q[qwxr]?\\s*\\(", end: "\\)", relevance: 5 }, { begin: "q[qwxr]?\\s*\\[", end: "\\]", relevance: 5 }, { begin: "q[qwxr]?\\s*\\{", end: "\\}", relevance: 5 }, { begin: "q[qwxr]?\\s*\\|", end: "\\|", relevance: 5 }, { begin: "q[qwxr]?\\s*<", end: ">", relevance: 5 }, { begin: "qw\\s+q", end: "q", relevance: 5 }, { begin: "'", end: "'", contains: [n.BACKSLASH_ESCAPE] }, { begin: '"', end: '"' }, { begin: "`", end: "`", contains: [n.BACKSLASH_ESCAPE] }, { begin: /\{\w+\}/, relevance: 0 }, { begin: "-?\\w+\\s*=>", relevance: 0 }] }, c, { begin: "(\\/\\/|" + n.RE_STARTERS_RE + "|\\b(split|return|print|reverse|grep)\\b)\\s*", keywords: "split return print reverse grep", relevance: 0, contains: [n.HASH_COMMENT_MODE, { className: "regexp", variants: [{ begin: f("s|tr|y", e.either(...d, { capture: !0 })) }, { begin: f("s|tr|y", "\\(", "\\)") }, { begin: f("s|tr|y", "\\[", "\\]") }, { begin: f("s|tr|y", "\\{", "\\}") }], relevance: 2 }, { className: "regexp", variants: [{ begin: /(m|qr)\/\//, relevance: 0 }, { begin: h("(?:m|qr)?", /\//, /\//) }, { begin: h("m|qr", e.either(...d, { capture: !0 }), /\1/) }, { begin: h("m|qr", /\(/, /\)/) }, { begin: h("m|qr", /\[/, /\]/) }, { begin: h("m|qr", /\{/, /\}/) }] }] }, { className: "function", beginKeywords: "sub method", end: "(\\s*\\(.*?\\))?[;{]", excludeEnd: !0, relevance: 5, contains: [n.TITLE_MODE, s] }, { className: "class", beginKeywords: "class", end: "[;{]", excludeEnd: !0, relevance: 5, contains: [n.TITLE_MODE, s, c] }, { begin: "-\\w\\b", relevance: 0 }, { begin: "^__DATA__$", end: "^__END__$", subLanguage: "mojolicious", contains: [{ begin: "^@@.*", end: "$", className: "comment" }] }]; return a.contains = p, o.contains = p, { name: "Perl", aliases: ["pl", "pm"], keywords: i, contains: p } } function oLe(n) {
  const e = n.regex, t = /(?![A-Za-z0-9])(?![$])/, r = e.concat(/[a-zA-Z_\x7f-\xff][a-zA-Z0-9_\x7f-\xff]*/, t), i = e.concat(/(\\?[A-Z][a-z0-9_\x7f-\xff]+|\\?[A-Z]+(?=[A-Z][a-z0-9_\x7f-\xff])){1,}/, t), a = e.concat(/[A-Z]+/, t), o = { scope: "variable", match: "\\$+" + r }, s = { scope: "meta", variants: [{ begin: /<\?php/, relevance: 10 }, { begin: /<\?=/ }, { begin: /<\?/, relevance: .1 }, { begin: /\?>/ }] }, l = { scope: "subst", variants: [{ begin: /\$\w+/ }, { begin: /\{\$/, end: /\}/ }] }, c = n.inherit(n.APOS_STRING_MODE, { illegal: null }), u = n.inherit(n.QUOTE_STRING_MODE, { illegal: null, contains: n.QUOTE_STRING_MODE.contains.concat(l) }), d = { begin: /<<<[ \t]*(?:(\w+)|"(\w+)")\n/, end: /[ \t]*(\w+)\b/, contains: n.QUOTE_STRING_MODE.contains.concat(l), "on:begin": (L, R) => { R.data._beginMatch = L[1] || L[2] }, "on:end": (L, R) => { R.data._beginMatch !== L[1] && R.ignoreMatch() } }, f = n.END_SAME_AS_BEGIN({ begin: /<<<[ \t]*'(\w+)'\n/, end: /[ \t]*(\w+)\b/ }), h = `[ 	
]`, p = { scope: "string", variants: [u, c, d, f] }, m = { scope: "number", variants: [{ begin: "\\b0[bB][01]+(?:_[01]+)*\\b" }, { begin: "\\b0[oO][0-7]+(?:_[0-7]+)*\\b" }, { begin: "\\b0[xX][\\da-fA-F]+(?:_[\\da-fA-F]+)*\\b" }, { begin: "(?:\\b\\d+(?:_\\d+)*(\\.(?:\\d+(?:_\\d+)*))?|\\B\\.\\d+)(?:[eE][+-]?\\d+)?" }], relevance: 0 }, g = ["false", "null", "true"], y = ["__CLASS__", "__DIR__", "__FILE__", "__FUNCTION__", "__COMPILER_HALT_OFFSET__", "__LINE__", "__METHOD__", "__NAMESPACE__", "__TRAIT__", "die", "echo", "exit", "include", "include_once", "print", "require", "require_once", "array", "abstract", "and", "as", "binary", "bool", "boolean", "break", "callable", "case", "catch", "class", "clone", "const", "continue", "declare", "default", "do", "double", "else", "elseif", "empty", "enddeclare", "endfor", "endforeach", "endif", "endswitch", "endwhile", "enum", "eval", "extends", "final", "finally", "float", "for", "foreach", "from", "global", "goto", "if", "implements", "instanceof", "insteadof", "int", "integer", "interface", "isset", "iterable", "list", "match|0", "mixed", "new", "never", "object", "or", "private", "protected", "public", "readonly", "real", "return", "string", "switch", "throw", "trait", "try", "unset", "use", "var", "void", "while", "xor", "yield"], b = ["Error|0", "AppendIterator", "ArgumentCountError", "ArithmeticError", "ArrayIterator", "ArrayObject", "AssertionError", "BadFunctionCallException", "BadMethodCallException", "CachingIterator", "CallbackFilterIterator", "CompileError", "Countable", "DirectoryIterator", "DivisionByZeroError", "DomainException", "EmptyIterator", "ErrorException", "Exception", "FilesystemIterator", "FilterIterator", "GlobIterator", "InfiniteIterator", "InvalidArgumentException", "IteratorIterator", "LengthException", "LimitIterator", "LogicException", "MultipleIterator", "NoRewindIterator", "OutOfBoundsException", "OutOfRangeException", "OuterIterator", "OverflowException", "ParentIterator", "ParseError", "RangeException", "RecursiveArrayIterator", "RecursiveCachingIterator", "RecursiveCallbackFilterIterator", "RecursiveDirectoryIterator", "RecursiveFilterIterator", "RecursiveIterator", "RecursiveIteratorIterator", "RecursiveRegexIterator", "RecursiveTreeIterator", "RegexIterator", "RuntimeException", "SeekableIterator", "SplDoublyLinkedList", "SplFileInfo", "SplFileObject", "SplFixedArray", "SplHeap", "SplMaxHeap", "SplMinHeap", "SplObjectStorage", "SplObserver", "SplPriorityQueue", "SplQueue", "SplStack", "SplSubject", "SplTempFileObject", "TypeError", "UnderflowException", "UnexpectedValueException", "UnhandledMatchError", "ArrayAccess", "BackedEnum", "Closure", "Fiber", "Generator", "Iterator", "IteratorAggregate", "Serializable", "Stringable", "Throwable", "Traversable", "UnitEnum", "WeakReference", "WeakMap", "Directory", "__PHP_Incomplete_Class", "parent", "php_user_filter", "self", "static", "stdClass"], v = { keyword: y, literal: (L => { const R = []; return L.forEach(D => { R.push(D), D.toLowerCase() === D ? R.push(D.toUpperCase()) : R.push(D.toLowerCase()) }), R })(g), built_in: b }, S = L => L.map(R => R.replace(/\|\d+$/, "")), x = { variants: [{ match: [/new/, e.concat(h, "+"), e.concat("(?!", S(b).join("\\b|"), "\\b)"), i], scope: { 1: "keyword", 4: "title.class" } }] }, k = e.concat(r, "\\b(?!\\()"), A = { variants: [{ match: [e.concat(/::/, e.lookahead(/(?!class\b)/)), k], scope: { 2: "variable.constant" } }, { match: [/::/, /class/], scope: { 2: "variable.language" } }, { match: [i, e.concat(/::/, e.lookahead(/(?!class\b)/)), k], scope: { 1: "title.class", 3: "variable.constant" } }, { match: [i, e.concat("::", e.lookahead(/(?!class\b)/))], scope: { 1: "title.class" } }, { match: [i, /::/, /class/], scope: { 1: "title.class", 3: "variable.language" } }] }, C = { scope: "attr", match: e.concat(r, e.lookahead(":"), e.lookahead(/(?!::)/)) }, E = { relevance: 0, begin: /\(/, end: /\)/, keywords: v, contains: [C, o, A, n.C_BLOCK_COMMENT_MODE, p, m, x] }, O = { relevance: 0, match: [/\b/, e.concat("(?!fn\\b|function\\b|", S(y).join("\\b|"), "|", S(b).join("\\b|"), "\\b)"), r, e.concat(h, "*"), e.lookahead(/(?=\()/)], scope: { 3: "title.function.invoke" }, contains: [E] }; E.contains.push(O); const j = [C, A, n.C_BLOCK_COMMENT_MODE, p, m, x], I = { begin: e.concat(/#\[\s*\\?/, e.either(i, a)), beginScope: "meta", end: /]/, endScope: "meta", keywords: { literal: g, keyword: ["new", "array"] }, contains: [{ begin: /\[/, end: /]/, keywords: { literal: g, keyword: ["new", "array"] }, contains: ["self", ...j] }, ...j, { scope: "meta", variants: [{ match: i }, { match: a }] }] }; return { case_insensitive: !1, keywords: v, contains: [I, n.HASH_COMMENT_MODE, n.COMMENT("//", "$"), n.COMMENT("/\\*", "\\*/", { contains: [{ scope: "doctag", match: "@[A-Za-z]+" }] }), { match: /__halt_compiler\(\);/, keywords: "__halt_compiler", starts: { scope: "comment", end: n.MATCH_NOTHING_RE, contains: [{ match: /\?>/, scope: "meta", endsParent: !0 }] } }, s, { scope: "variable.language", match: /\$this\b/ }, o, O, A, { match: [/const/, /\s/, r], scope: { 1: "keyword", 3: "variable.constant" } }, x, { scope: "function", relevance: 0, beginKeywords: "fn function", end: /[;{]/, excludeEnd: !0, illegal: "[$%\\[]", contains: [{ beginKeywords: "use" }, n.UNDERSCORE_TITLE_MODE, { begin: "=>", endsParent: !0 }, { scope: "params", begin: "\\(", end: "\\)", excludeBegin: !0, excludeEnd: !0, keywords: v, contains: ["self", I, o, A, n.C_BLOCK_COMMENT_MODE, p, m] }] }, { scope: "class", variants: [{ beginKeywords: "enum", illegal: /[($"]/ }, { beginKeywords: "class interface trait", illegal: /[:($"]/ }], relevance: 0, end: /\{/, excludeEnd: !0, contains: [{ beginKeywords: "extends implements" }, n.UNDERSCORE_TITLE_MODE] }, { beginKeywords: "namespace", relevance: 0, end: ";", illegal: /[.']/, contains: [n.inherit(n.UNDERSCORE_TITLE_MODE, { scope: "title.class" })] }, { beginKeywords: "use", relevance: 0, end: ";", contains: [{ match: /\b(as|const|function)\b/, scope: "keyword" }, n.UNDERSCORE_TITLE_MODE] }, p, m] }
} function sLe(n) { return { name: "PHP template", subLanguage: "xml", contains: [{ begin: /<\?(php|=)?/, end: /\?>/, subLanguage: "php", contains: [{ begin: "/\\*", end: "\\*/", skip: !0 }, { begin: 'b"', end: '"', skip: !0 }, { begin: "b'", end: "'", skip: !0 }, n.inherit(n.APOS_STRING_MODE, { illegal: null, className: null, contains: null, skip: !0 }), n.inherit(n.QUOTE_STRING_MODE, { illegal: null, className: null, contains: null, skip: !0 })] }] } } function lLe(n) { return { name: "Plain text", aliases: ["text", "txt"], disableAutodetect: !0 } } function cLe(n) { const e = n.regex, t = /[\p{XID_Start}_]\p{XID_Continue}*/u, r = ["and", "as", "assert", "async", "await", "break", "case", "class", "continue", "def", "del", "elif", "else", "except", "finally", "for", "from", "global", "if", "import", "in", "is", "lambda", "match", "nonlocal|10", "not", "or", "pass", "raise", "return", "try", "while", "with", "yield"], s = { $pattern: /[A-Za-z]\w+|__\w+__/, keyword: r, built_in: ["__import__", "abs", "all", "any", "ascii", "bin", "bool", "breakpoint", "bytearray", "bytes", "callable", "chr", "classmethod", "compile", "complex", "delattr", "dict", "dir", "divmod", "enumerate", "eval", "exec", "filter", "float", "format", "frozenset", "getattr", "globals", "hasattr", "hash", "help", "hex", "id", "input", "int", "isinstance", "issubclass", "iter", "len", "list", "locals", "map", "max", "memoryview", "min", "next", "object", "oct", "open", "ord", "pow", "print", "property", "range", "repr", "reversed", "round", "set", "setattr", "slice", "sorted", "staticmethod", "str", "sum", "super", "tuple", "type", "vars", "zip"], literal: ["__debug__", "Ellipsis", "False", "None", "NotImplemented", "True"], type: ["Any", "Callable", "Coroutine", "Dict", "List", "Literal", "Generic", "Optional", "Sequence", "Set", "Tuple", "Type", "Union"] }, l = { className: "meta", begin: /^(>>>|\.\.\.) / }, c = { className: "subst", begin: /\{/, end: /\}/, keywords: s, illegal: /#/ }, u = { begin: /\{\{/, relevance: 0 }, d = { className: "string", contains: [n.BACKSLASH_ESCAPE], variants: [{ begin: /([uU]|[bB]|[rR]|[bB][rR]|[rR][bB])?'''/, end: /'''/, contains: [n.BACKSLASH_ESCAPE, l], relevance: 10 }, { begin: /([uU]|[bB]|[rR]|[bB][rR]|[rR][bB])?"""/, end: /"""/, contains: [n.BACKSLASH_ESCAPE, l], relevance: 10 }, { begin: /([fF][rR]|[rR][fF]|[fF])'''/, end: /'''/, contains: [n.BACKSLASH_ESCAPE, l, u, c] }, { begin: /([fF][rR]|[rR][fF]|[fF])"""/, end: /"""/, contains: [n.BACKSLASH_ESCAPE, l, u, c] }, { begin: /([uU]|[rR])'/, end: /'/, relevance: 10 }, { begin: /([uU]|[rR])"/, end: /"/, relevance: 10 }, { begin: /([bB]|[bB][rR]|[rR][bB])'/, end: /'/ }, { begin: /([bB]|[bB][rR]|[rR][bB])"/, end: /"/ }, { begin: /([fF][rR]|[rR][fF]|[fF])'/, end: /'/, contains: [n.BACKSLASH_ESCAPE, u, c] }, { begin: /([fF][rR]|[rR][fF]|[fF])"/, end: /"/, contains: [n.BACKSLASH_ESCAPE, u, c] }, n.APOS_STRING_MODE, n.QUOTE_STRING_MODE] }, f = "[0-9](_?[0-9])*", h = `(\\b(${f}))?\\.(${f})|\\b(${f})\\.`, p = `\\b|${r.join("|")}`, m = { className: "number", relevance: 0, variants: [{ begin: `(\\b(${f})|(${h}))[eE][+-]?(${f})[jJ]?(?=${p})` }, { begin: `(${h})[jJ]?` }, { begin: `\\b([1-9](_?[0-9])*|0+(_?0)*)[lLjJ]?(?=${p})` }, { begin: `\\b0[bB](_?[01])+[lL]?(?=${p})` }, { begin: `\\b0[oO](_?[0-7])+[lL]?(?=${p})` }, { begin: `\\b0[xX](_?[0-9a-fA-F])+[lL]?(?=${p})` }, { begin: `\\b(${f})[jJ](?=${p})` }] }, g = { className: "comment", begin: e.lookahead(/# type:/), end: /$/, keywords: s, contains: [{ begin: /# type:/ }, { begin: /#/, end: /\b\B/, endsWithParent: !0 }] }, y = { className: "params", variants: [{ className: "", begin: /\(\s*\)/, skip: !0 }, { begin: /\(/, end: /\)/, excludeBegin: !0, excludeEnd: !0, keywords: s, contains: ["self", l, m, d, n.HASH_COMMENT_MODE] }] }; return c.contains = [d, m, l], { name: "Python", aliases: ["py", "gyp", "ipython"], unicodeRegex: !0, keywords: s, illegal: /(<\/|\?)|=>/, contains: [l, m, { scope: "variable.language", match: /\bself\b/ }, { beginKeywords: "if", relevance: 0 }, { match: /\bor\b/, scope: "keyword" }, d, g, n.HASH_COMMENT_MODE, { match: [/\bdef/, /\s+/, t], scope: { 1: "keyword", 3: "title.function" }, contains: [y] }, { variants: [{ match: [/\bclass/, /\s+/, t, /\s*/, /\(\s*/, t, /\s*\)/] }, { match: [/\bclass/, /\s+/, t] }], scope: { 1: "keyword", 3: "title.class", 6: "title.class.inherited" } }, { className: "meta", begin: /^[\t ]*@/, end: /(?=#)|$/, contains: [m, y, d] }] } } function uLe(n) { return { aliases: ["pycon"], contains: [{ className: "meta.prompt", starts: { end: / |$/, starts: { end: "$", subLanguage: "python" } }, variants: [{ begin: /^>>>(?=[ ]|$)/ }, { begin: /^\.\.\.(?=[ ]|$)/ }] }] } } function dLe(n) { const e = n.regex, t = /(?:(?:[a-zA-Z]|\.[._a-zA-Z])[._a-zA-Z0-9]*)|\.(?!\d)/, r = e.either(/0[xX][0-9a-fA-F]+\.[0-9a-fA-F]*[pP][+-]?\d+i?/, /0[xX][0-9a-fA-F]+(?:[pP][+-]?\d+)?[Li]?/, /(?:\d+(?:\.\d*)?|\.\d+)(?:[eE][+-]?\d+)?[Li]?/), i = /[=!<>:]=|\|\||&&|:::?|<-|<<-|->>|->|\|>|[-+*\/?!$&|:<=>@^~]|\*\*/, a = e.either(/[()]/, /[{}]/, /\[\[/, /[[\]]/, /\\/, /,/); return { name: "R", keywords: { $pattern: t, keyword: "function if in break next repeat else for while", literal: "NULL NA TRUE FALSE Inf NaN NA_integer_|10 NA_real_|10 NA_character_|10 NA_complex_|10", built_in: "LETTERS letters month.abb month.name pi T F abs acos acosh all any anyNA Arg as.call as.character as.complex as.double as.environment as.integer as.logical as.null.default as.numeric as.raw asin asinh atan atanh attr attributes baseenv browser c call ceiling class Conj cos cosh cospi cummax cummin cumprod cumsum digamma dim dimnames emptyenv exp expression floor forceAndCall gamma gc.time globalenv Im interactive invisible is.array is.atomic is.call is.character is.complex is.double is.environment is.expression is.finite is.function is.infinite is.integer is.language is.list is.logical is.matrix is.na is.name is.nan is.null is.numeric is.object is.pairlist is.raw is.recursive is.single is.symbol lazyLoadDBfetch length lgamma list log max min missing Mod names nargs nzchar oldClass on.exit pos.to.env proc.time prod quote range Re rep retracemem return round seq_along seq_len seq.int sign signif sin sinh sinpi sqrt standardGeneric substitute sum switch tan tanh tanpi tracemem trigamma trunc unclass untracemem UseMethod xtfrm" }, contains: [n.COMMENT(/#'/, /$/, { contains: [{ scope: "doctag", match: /@examples/, starts: { end: e.lookahead(e.either(/\n^#'\s*(?=@[a-zA-Z]+)/, /\n^(?!#')/)), endsParent: !0 } }, { scope: "doctag", begin: "@param", end: /$/, contains: [{ scope: "variable", variants: [{ match: t }, { match: /`(?:\\.|[^`\\])+`/ }], endsParent: !0 }] }, { scope: "doctag", match: /@[a-zA-Z]+/ }, { scope: "keyword", match: /\\[a-zA-Z]+/ }] }), n.HASH_COMMENT_MODE, { scope: "string", contains: [n.BACKSLASH_ESCAPE], variants: [n.END_SAME_AS_BEGIN({ begin: /[rR]"(-*)\(/, end: /\)(-*)"/ }), n.END_SAME_AS_BEGIN({ begin: /[rR]"(-*)\{/, end: /\}(-*)"/ }), n.END_SAME_AS_BEGIN({ begin: /[rR]"(-*)\[/, end: /\](-*)"/ }), n.END_SAME_AS_BEGIN({ begin: /[rR]'(-*)\(/, end: /\)(-*)'/ }), n.END_SAME_AS_BEGIN({ begin: /[rR]'(-*)\{/, end: /\}(-*)'/ }), n.END_SAME_AS_BEGIN({ begin: /[rR]'(-*)\[/, end: /\](-*)'/ }), { begin: '"', end: '"', relevance: 0 }, { begin: "'", end: "'", relevance: 0 }] }, { relevance: 0, variants: [{ scope: { 1: "operator", 2: "number" }, match: [i, r] }, { scope: { 1: "operator", 2: "number" }, match: [/%[^%]*%/, r] }, { scope: { 1: "punctuation", 2: "number" }, match: [a, r] }, { scope: { 2: "number" }, match: [/[^a-zA-Z0-9._]|^/, r] }] }, { scope: { 3: "operator" }, match: [t, /\s+/, /<-/, /\s+/] }, { scope: "operator", relevance: 0, variants: [{ match: i }, { match: /%[^%]*%/ }] }, { scope: "punctuation", relevance: 0, match: a }, { begin: "`", end: "`", contains: [{ begin: /\\./ }] }] } } function fLe(n) { const e = n.regex, t = "([a-zA-Z_]\\w*[!?=]?|[-+~]@|<<|>>|=~|===?|<=>|[<>]=?|\\*\\*|[-/+%^&*~`|]|\\[\\]=?)", r = e.either(/\b([A-Z]+[a-z0-9]+)+/, /\b([A-Z]+[a-z0-9]+)+[A-Z]+/), i = e.concat(r, /(::\w+)*/), o = { "variable.constant": ["__FILE__", "__LINE__", "__ENCODING__"], "variable.language": ["self", "super"], keyword: ["alias", "and", "begin", "BEGIN", "break", "case", "class", "defined", "do", "else", "elsif", "end", "END", "ensure", "for", "if", "in", "module", "next", "not", "or", "redo", "require", "rescue", "retry", "return", "then", "undef", "unless", "until", "when", "while", "yield", ...["include", "extend", "prepend", "public", "private", "protected", "raise", "throw"]], built_in: ["proc", "lambda", "attr_accessor", "attr_reader", "attr_writer", "define_method", "private_constant", "module_function"], literal: ["true", "false", "nil"] }, s = { className: "doctag", begin: "@[A-Za-z]+" }, l = { begin: "#<", end: ">" }, c = [n.COMMENT("#", "$", { contains: [s] }), n.COMMENT("^=begin", "^=end", { contains: [s], relevance: 10 }), n.COMMENT("^__END__", n.MATCH_NOTHING_RE)], u = { className: "subst", begin: /#\{/, end: /\}/, keywords: o }, d = { className: "string", contains: [n.BACKSLASH_ESCAPE, u], variants: [{ begin: /'/, end: /'/ }, { begin: /"/, end: /"/ }, { begin: /`/, end: /`/ }, { begin: /%[qQwWx]?\(/, end: /\)/ }, { begin: /%[qQwWx]?\[/, end: /\]/ }, { begin: /%[qQwWx]?\{/, end: /\}/ }, { begin: /%[qQwWx]?</, end: />/ }, { begin: /%[qQwWx]?\//, end: /\// }, { begin: /%[qQwWx]?%/, end: /%/ }, { begin: /%[qQwWx]?-/, end: /-/ }, { begin: /%[qQwWx]?\|/, end: /\|/ }, { begin: /\B\?(\\\d{1,3})/ }, { begin: /\B\?(\\x[A-Fa-f0-9]{1,2})/ }, { begin: /\B\?(\\u\{?[A-Fa-f0-9]{1,6}\}?)/ }, { begin: /\B\?(\\M-\\C-|\\M-\\c|\\c\\M-|\\M-|\\C-\\M-)[\x20-\x7e]/ }, { begin: /\B\?\\(c|C-)[\x20-\x7e]/ }, { begin: /\B\?\\?\S/ }, { begin: e.concat(/<<[-~]?'?/, e.lookahead(/(\w+)(?=\W)[^\n]*\n(?:[^\n]*\n)*?\s*\1\b/)), contains: [n.END_SAME_AS_BEGIN({ begin: /(\w+)/, end: /(\w+)/, contains: [n.BACKSLASH_ESCAPE, u] })] }] }, f = "[1-9](_?[0-9])*|0", h = "[0-9](_?[0-9])*", p = { className: "number", relevance: 0, variants: [{ begin: `\\b(${f})(\\.(${h}))?([eE][+-]?(${h})|r)?i?\\b` }, { begin: "\\b0[dD][0-9](_?[0-9])*r?i?\\b" }, { begin: "\\b0[bB][0-1](_?[0-1])*r?i?\\b" }, { begin: "\\b0[oO][0-7](_?[0-7])*r?i?\\b" }, { begin: "\\b0[xX][0-9a-fA-F](_?[0-9a-fA-F])*r?i?\\b" }, { begin: "\\b0(_?[0-7])+r?i?\\b" }] }, m = { variants: [{ match: /\(\)/ }, { className: "params", begin: /\(/, end: /(?=\))/, excludeBegin: !0, endsParent: !0, keywords: o }] }, x = [d, { variants: [{ match: [/class\s+/, i, /\s+<\s+/, i] }, { match: [/\b(class|module)\s+/, i] }], scope: { 2: "title.class", 4: "title.class.inherited" }, keywords: o }, { match: [/(include|extend)\s+/, i], scope: { 2: "title.class" }, keywords: o }, { relevance: 0, match: [i, /\.new[. (]/], scope: { 1: "title.class" } }, { relevance: 0, match: /\b[A-Z][A-Z_0-9]+\b/, className: "variable.constant" }, { relevance: 0, match: r, scope: "title.class" }, { match: [/def/, /\s+/, t], scope: { 1: "keyword", 3: "title.function" }, contains: [m] }, { begin: n.IDENT_RE + "::" }, { className: "symbol", begin: n.UNDERSCORE_IDENT_RE + "(!|\\?)?:", relevance: 0 }, { className: "symbol", begin: ":(?!\\s)", contains: [d, { begin: t }], relevance: 0 }, p, { className: "variable", begin: "(\\$\\W)|((\\$|@@?)(\\w+))(?=[^@$?])(?![A-Za-z])(?![@$?'])" }, { className: "params", begin: /\|(?!=)/, end: /\|/, excludeBegin: !0, excludeEnd: !0, relevance: 0, keywords: o }, { begin: "(" + n.RE_STARTERS_RE + "|unless)\\s*", keywords: "unless", contains: [{ className: "regexp", contains: [n.BACKSLASH_ESCAPE, u], illegal: /\n/, variants: [{ begin: "/", end: "/[a-z]*" }, { begin: /%r\{/, end: /\}[a-z]*/ }, { begin: "%r\\(", end: "\\)[a-z]*" }, { begin: "%r!", end: "![a-z]*" }, { begin: "%r\\[", end: "\\][a-z]*" }] }].concat(l, c), relevance: 0 }].concat(l, c); u.contains = x, m.contains = x; const k = "[>?]>", A = "[\\w#]+\\(\\w+\\):\\d+:\\d+[>*]", C = "(\\w+-)?\\d+\\.\\d+\\.\\d+(p\\d+)?[^\\d][^>]+>", E = [{ begin: /^\s*=>/, starts: { end: "$", contains: x } }, { className: "meta.prompt", begin: "^(" + k + "|" + A + "|" + C + ")(?=[ ])", starts: { end: "$", keywords: o, contains: x } }]; return c.unshift(l), { name: "Ruby", aliases: ["rb", "gemspec", "podspec", "thor", "irb"], keywords: o, illegal: /\/\*/, contains: [n.SHEBANG({ binary: "ruby" })].concat(E).concat(c).concat(x) } } function hLe(n) { const e = n.regex, t = /(r#)?/, r = e.concat(t, n.UNDERSCORE_IDENT_RE), i = e.concat(t, n.IDENT_RE), a = { className: "title.function.invoke", relevance: 0, begin: e.concat(/\b/, /(?!let|for|while|if|else|match\b)/, i, e.lookahead(/\s*\(/)) }, o = "([ui](8|16|32|64|128|size)|f(32|64))?", s = ["abstract", "as", "async", "await", "become", "box", "break", "const", "continue", "crate", "do", "dyn", "else", "enum", "extern", "false", "final", "fn", "for", "if", "impl", "in", "let", "loop", "macro", "match", "mod", "move", "mut", "override", "priv", "pub", "ref", "return", "self", "Self", "static", "struct", "super", "trait", "true", "try", "type", "typeof", "union", "unsafe", "unsized", "use", "virtual", "where", "while", "yield"], l = ["true", "false", "Some", "None", "Ok", "Err"], c = ["drop ", "Copy", "Send", "Sized", "Sync", "Drop", "Fn", "FnMut", "FnOnce", "ToOwned", "Clone", "Debug", "PartialEq", "PartialOrd", "Eq", "Ord", "AsRef", "AsMut", "Into", "From", "Default", "Iterator", "Extend", "IntoIterator", "DoubleEndedIterator", "ExactSizeIterator", "SliceConcatExt", "ToString", "assert!", "assert_eq!", "bitflags!", "bytes!", "cfg!", "col!", "concat!", "concat_idents!", "debug_assert!", "debug_assert_eq!", "env!", "eprintln!", "panic!", "file!", "format!", "format_args!", "include_bytes!", "include_str!", "line!", "local_data_key!", "module_path!", "option_env!", "print!", "println!", "select!", "stringify!", "try!", "unimplemented!", "unreachable!", "vec!", "write!", "writeln!", "macro_rules!", "assert_ne!", "debug_assert_ne!"], u = ["i8", "i16", "i32", "i64", "i128", "isize", "u8", "u16", "u32", "u64", "u128", "usize", "f32", "f64", "str", "char", "bool", "Box", "Option", "Result", "String", "Vec"]; return { name: "Rust", aliases: ["rs"], keywords: { $pattern: n.IDENT_RE + "!?", type: u, keyword: s, literal: l, built_in: c }, illegal: "</", contains: [n.C_LINE_COMMENT_MODE, n.COMMENT("/\\*", "\\*/", { contains: ["self"] }), n.inherit(n.QUOTE_STRING_MODE, { begin: /b?"/, illegal: null }), { className: "symbol", begin: /'[a-zA-Z_][a-zA-Z0-9_]*(?!')/ }, { scope: "string", variants: [{ begin: /b?r(#*)"(.|\n)*?"\1(?!#)/ }, { begin: /b?'/, end: /'/, contains: [{ scope: "char.escape", match: /\\('|\w|x\w{2}|u\w{4}|U\w{8})/ }] }] }, { className: "number", variants: [{ begin: "\\b0b([01_]+)" + o }, { begin: "\\b0o([0-7_]+)" + o }, { begin: "\\b0x([A-Fa-f0-9_]+)" + o }, { begin: "\\b(\\d[\\d_]*(\\.[0-9_]+)?([eE][+-]?[0-9_]+)?)" + o }], relevance: 0 }, { begin: [/fn/, /\s+/, r], className: { 1: "keyword", 3: "title.function" } }, { className: "meta", begin: "#!?\\[", end: "\\]", contains: [{ className: "string", begin: /"/, end: /"/, contains: [n.BACKSLASH_ESCAPE] }] }, { begin: [/let/, /\s+/, /(?:mut\s+)?/, r], className: { 1: "keyword", 3: "keyword", 4: "variable" } }, { begin: [/for/, /\s+/, r, /\s+/, /in/], className: { 1: "keyword", 3: "variable", 5: "keyword" } }, { begin: [/type/, /\s+/, r], className: { 1: "keyword", 3: "title.class" } }, { begin: [/(?:trait|enum|struct|union|impl|for)/, /\s+/, r], className: { 1: "keyword", 3: "title.class" } }, { begin: n.IDENT_RE + "::", keywords: { keyword: "Self", built_in: c, type: u } }, { className: "punctuation", begin: "->" }, a] } } const pLe = n => ({ IMPORTANT: { scope: "meta", begin: "!important" }, BLOCK_COMMENT: n.C_BLOCK_COMMENT_MODE, HEXCOLOR: { scope: "number", begin: /#(([0-9a-fA-F]{3,4})|(([0-9a-fA-F]{2}){3,4}))\b/ }, FUNCTION_DISPATCH: { className: "built_in", begin: /[\w-]+(?=\()/ }, ATTRIBUTE_SELECTOR_MODE: { scope: "selector-attr", begin: /\[/, end: /\]/, illegal: "$", contains: [n.APOS_STRING_MODE, n.QUOTE_STRING_MODE] }, CSS_NUMBER_MODE: { scope: "number", begin: n.NUMBER_RE + "(%|em|ex|ch|rem|vw|vh|vmin|vmax|cm|mm|in|pt|pc|px|deg|grad|rad|turn|s|ms|Hz|kHz|dpi|dpcm|dppx)?", relevance: 0 }, CSS_VARIABLE: { className: "attr", begin: /--[A-Za-z_][A-Za-z0-9_-]*/ } }), mLe = ["a", "abbr", "address", "article", "aside", "audio", "b", "blockquote", "body", "button", "canvas", "caption", "cite", "code", "dd", "del", "details", "dfn", "div", "dl", "dt", "em", "fieldset", "figcaption", "figure", "footer", "form", "h1", "h2", "h3", "h4", "h5", "h6", "header", "hgroup", "html", "i", "iframe", "img", "input", "ins", "kbd", "label", "legend", "li", "main", "mark", "menu", "nav", "object", "ol", "optgroup", "option", "p", "picture", "q", "quote", "samp", "section", "select", "source", "span", "strong", "summary", "sup", "table", "tbody", "td", "textarea", "tfoot", "th", "thead", "time", "tr", "ul", "var", "video"], gLe = ["defs", "g", "marker", "mask", "pattern", "svg", "switch", "symbol", "feBlend", "feColorMatrix", "feComponentTransfer", "feComposite", "feConvolveMatrix", "feDiffuseLighting", "feDisplacementMap", "feFlood", "feGaussianBlur", "feImage", "feMerge", "feMorphology", "feOffset", "feSpecularLighting", "feTile", "feTurbulence", "linearGradient", "radialGradient", "stop", "circle", "ellipse", "image", "line", "path", "polygon", "polyline", "rect", "text", "use", "textPath", "tspan", "foreignObject", "clipPath"], vLe = [...mLe, ...gLe], yLe = ["any-hover", "any-pointer", "aspect-ratio", "color", "color-gamut", "color-index", "device-aspect-ratio", "device-height", "device-width", "display-mode", "forced-colors", "grid", "height", "hover", "inverted-colors", "monochrome", "orientation", "overflow-block", "overflow-inline", "pointer", "prefers-color-scheme", "prefers-contrast", "prefers-reduced-motion", "prefers-reduced-transparency", "resolution", "scan", "scripting", "update", "width", "min-width", "max-width", "min-height", "max-height"].sort().reverse(), _Le = ["active", "any-link", "blank", "checked", "current", "default", "defined", "dir", "disabled", "drop", "empty", "enabled", "first", "first-child", "first-of-type", "fullscreen", "future", "focus", "focus-visible", "focus-within", "has", "host", "host-context", "hover", "indeterminate", "in-range", "invalid", "is", "lang", "last-child", "last-of-type", "left", "link", "local-link", "not", "nth-child", "nth-col", "nth-last-child", "nth-last-col", "nth-last-of-type", "nth-of-type", "only-child", "only-of-type", "optional", "out-of-range", "past", "placeholder-shown", "read-only", "read-write", "required", "right", "root", "scope", "target", "target-within", "user-invalid", "valid", "visited", "where"].sort().reverse(), bLe = ["after", "backdrop", "before", "cue", "cue-region", "first-letter", "first-line", "grammar-error", "marker", "part", "placeholder", "selection", "slotted", "spelling-error"].sort().reverse(), wLe = ["accent-color", "align-content", "align-items", "align-self", "alignment-baseline", "all", "anchor-name", "animation", "animation-composition", "animation-delay", "animation-direction", "animation-duration", "animation-fill-mode", "animation-iteration-count", "animation-name", "animation-play-state", "animation-range", "animation-range-end", "animation-range-start", "animation-timeline", "animation-timing-function", "appearance", "aspect-ratio", "backdrop-filter", "backface-visibility", "background", "background-attachment", "background-blend-mode", "background-clip", "background-color", "background-image", "background-origin", "background-position", "background-position-x", "background-position-y", "background-repeat", "background-size", "baseline-shift", "block-size", "border", "border-block", "border-block-color", "border-block-end", "border-block-end-color", "border-block-end-style", "border-block-end-width", "border-block-start", "border-block-start-color", "border-block-start-style", "border-block-start-width", "border-block-style", "border-block-width", "border-bottom", "border-bottom-color", "border-bottom-left-radius", "border-bottom-right-radius", "border-bottom-style", "border-bottom-width", "border-collapse", "border-color", "border-end-end-radius", "border-end-start-radius", "border-image", "border-image-outset", "border-image-repeat", "border-image-slice", "border-image-source", "border-image-width", "border-inline", "border-inline-color", "border-inline-end", "border-inline-end-color", "border-inline-end-style", "border-inline-end-width", "border-inline-start", "border-inline-start-color", "border-inline-start-style", "border-inline-start-width", "border-inline-style", "border-inline-width", "border-left", "border-left-color", "border-left-style", "border-left-width", "border-radius", "border-right", "border-right-color", "border-right-style", "border-right-width", "border-spacing", "border-start-end-radius", "border-start-start-radius", "border-style", "border-top", "border-top-color", "border-top-left-radius", "border-top-right-radius", "border-top-style", "border-top-width", "border-width", "bottom", "box-align", "box-decoration-break", "box-direction", "box-flex", "box-flex-group", "box-lines", "box-ordinal-group", "box-orient", "box-pack", "box-shadow", "box-sizing", "break-after", "break-before", "break-inside", "caption-side", "caret-color", "clear", "clip", "clip-path", "clip-rule", "color", "color-interpolation", "color-interpolation-filters", "color-profile", "color-rendering", "color-scheme", "column-count", "column-fill", "column-gap", "column-rule", "column-rule-color", "column-rule-style", "column-rule-width", "column-span", "column-width", "columns", "contain", "contain-intrinsic-block-size", "contain-intrinsic-height", "contain-intrinsic-inline-size", "contain-intrinsic-size", "contain-intrinsic-width", "container", "container-name", "container-type", "content", "content-visibility", "counter-increment", "counter-reset", "counter-set", "cue", "cue-after", "cue-before", "cursor", "cx", "cy", "direction", "display", "dominant-baseline", "empty-cells", "enable-background", "field-sizing", "fill", "fill-opacity", "fill-rule", "filter", "flex", "flex-basis", "flex-direction", "flex-flow", "flex-grow", "flex-shrink", "flex-wrap", "float", "flood-color", "flood-opacity", "flow", "font", "font-display", "font-family", "font-feature-settings", "font-kerning", "font-language-override", "font-optical-sizing", "font-palette", "font-size", "font-size-adjust", "font-smooth", "font-smoothing", "font-stretch", "font-style", "font-synthesis", "font-synthesis-position", "font-synthesis-small-caps", "font-synthesis-style", "font-synthesis-weight", "font-variant", "font-variant-alternates", "font-variant-caps", "font-variant-east-asian", "font-variant-emoji", "font-variant-ligatures", "font-variant-numeric", "font-variant-position", "font-variation-settings", "font-weight", "forced-color-adjust", "gap", "glyph-orientation-horizontal", "glyph-orientation-vertical", "grid", "grid-area", "grid-auto-columns", "grid-auto-flow", "grid-auto-rows", "grid-column", "grid-column-end", "grid-column-start", "grid-gap", "grid-row", "grid-row-end", "grid-row-start", "grid-template", "grid-template-areas", "grid-template-columns", "grid-template-rows", "hanging-punctuation", "height", "hyphenate-character", "hyphenate-limit-chars", "hyphens", "icon", "image-orientation", "image-rendering", "image-resolution", "ime-mode", "initial-letter", "initial-letter-align", "inline-size", "inset", "inset-area", "inset-block", "inset-block-end", "inset-block-start", "inset-inline", "inset-inline-end", "inset-inline-start", "isolation", "justify-content", "justify-items", "justify-self", "kerning", "left", "letter-spacing", "lighting-color", "line-break", "line-height", "line-height-step", "list-style", "list-style-image", "list-style-position", "list-style-type", "margin", "margin-block", "margin-block-end", "margin-block-start", "margin-bottom", "margin-inline", "margin-inline-end", "margin-inline-start", "margin-left", "margin-right", "margin-top", "margin-trim", "marker", "marker-end", "marker-mid", "marker-start", "marks", "mask", "mask-border", "mask-border-mode", "mask-border-outset", "mask-border-repeat", "mask-border-slice", "mask-border-source", "mask-border-width", "mask-clip", "mask-composite", "mask-image", "mask-mode", "mask-origin", "mask-position", "mask-repeat", "mask-size", "mask-type", "masonry-auto-flow", "math-depth", "math-shift", "math-style", "max-block-size", "max-height", "max-inline-size", "max-width", "min-block-size", "min-height", "min-inline-size", "min-width", "mix-blend-mode", "nav-down", "nav-index", "nav-left", "nav-right", "nav-up", "none", "normal", "object-fit", "object-position", "offset", "offset-anchor", "offset-distance", "offset-path", "offset-position", "offset-rotate", "opacity", "order", "orphans", "outline", "outline-color", "outline-offset", "outline-style", "outline-width", "overflow", "overflow-anchor", "overflow-block", "overflow-clip-margin", "overflow-inline", "overflow-wrap", "overflow-x", "overflow-y", "overlay", "overscroll-behavior", "overscroll-behavior-block", "overscroll-behavior-inline", "overscroll-behavior-x", "overscroll-behavior-y", "padding", "padding-block", "padding-block-end", "padding-block-start", "padding-bottom", "padding-inline", "padding-inline-end", "padding-inline-start", "padding-left", "padding-right", "padding-top", "page", "page-break-after", "page-break-before", "page-break-inside", "paint-order", "pause", "pause-after", "pause-before", "perspective", "perspective-origin", "place-content", "place-items", "place-self", "pointer-events", "position", "position-anchor", "position-visibility", "print-color-adjust", "quotes", "r", "resize", "rest", "rest-after", "rest-before", "right", "rotate", "row-gap", "ruby-align", "ruby-position", "scale", "scroll-behavior", "scroll-margin", "scroll-margin-block", "scroll-margin-block-end", "scroll-margin-block-start", "scroll-margin-bottom", "scroll-margin-inline", "scroll-margin-inline-end", "scroll-margin-inline-start", "scroll-margin-left", "scroll-margin-right", "scroll-margin-top", "scroll-padding", "scroll-padding-block", "scroll-padding-block-end", "scroll-padding-block-start", "scroll-padding-bottom", "scroll-padding-inline", "scroll-padding-inline-end", "scroll-padding-inline-start", "scroll-padding-left", "scroll-padding-right", "scroll-padding-top", "scroll-snap-align", "scroll-snap-stop", "scroll-snap-type", "scroll-timeline", "scroll-timeline-axis", "scroll-timeline-name", "scrollbar-color", "scrollbar-gutter", "scrollbar-width", "shape-image-threshold", "shape-margin", "shape-outside", "shape-rendering", "speak", "speak-as", "src", "stop-color", "stop-opacity", "stroke", "stroke-dasharray", "stroke-dashoffset", "stroke-linecap", "stroke-linejoin", "stroke-miterlimit", "stroke-opacity", "stroke-width", "tab-size", "table-layout", "text-align", "text-align-all", "text-align-last", "text-anchor", "text-combine-upright", "text-decoration", "text-decoration-color", "text-decoration-line", "text-decoration-skip", "text-decoration-skip-ink", "text-decoration-style", "text-decoration-thickness", "text-emphasis", "text-emphasis-color", "text-emphasis-position", "text-emphasis-style", "text-indent", "text-justify", "text-orientation", "text-overflow", "text-rendering", "text-shadow", "text-size-adjust", "text-transform", "text-underline-offset", "text-underline-position", "text-wrap", "text-wrap-mode", "text-wrap-style", "timeline-scope", "top", "touch-action", "transform", "transform-box", "transform-origin", "transform-style", "transition", "transition-behavior", "transition-delay", "transition-duration", "transition-property", "transition-timing-function", "translate", "unicode-bidi", "user-modify", "user-select", "vector-effect", "vertical-align", "view-timeline", "view-timeline-axis", "view-timeline-inset", "view-timeline-name", "view-transition-name", "visibility", "voice-balance", "voice-duration", "voice-family", "voice-pitch", "voice-range", "voice-rate", "voice-stress", "voice-volume", "white-space", "white-space-collapse", "widows", "width", "will-change", "word-break", "word-spacing", "word-wrap", "writing-mode", "x", "y", "z-index", "zoom"].sort().reverse(); function xLe(n) { const e = pLe(n), t = bLe, r = _Le, i = "@[a-z-]+", a = "and or not only", s = { className: "variable", begin: "(\\$" + "[a-zA-Z-][a-zA-Z0-9_-]*" + ")\\b", relevance: 0 }; return { name: "SCSS", case_insensitive: !0, illegal: "[=/|']", contains: [n.C_LINE_COMMENT_MODE, n.C_BLOCK_COMMENT_MODE, e.CSS_NUMBER_MODE, { className: "selector-id", begin: "#[A-Za-z0-9_-]+", relevance: 0 }, { className: "selector-class", begin: "\\.[A-Za-z0-9_-]+", relevance: 0 }, e.ATTRIBUTE_SELECTOR_MODE, { className: "selector-tag", begin: "\\b(" + vLe.join("|") + ")\\b", relevance: 0 }, { className: "selector-pseudo", begin: ":(" + r.join("|") + ")" }, { className: "selector-pseudo", begin: ":(:)?(" + t.join("|") + ")" }, s, { begin: /\(/, end: /\)/, contains: [e.CSS_NUMBER_MODE] }, e.CSS_VARIABLE, { className: "attribute", begin: "\\b(" + wLe.join("|") + ")\\b" }, { begin: "\\b(whitespace|wait|w-resize|visible|vertical-text|vertical-ideographic|uppercase|upper-roman|upper-alpha|underline|transparent|top|thin|thick|text|text-top|text-bottom|tb-rl|table-header-group|table-footer-group|sw-resize|super|strict|static|square|solid|small-caps|separate|se-resize|scroll|s-resize|rtl|row-resize|ridge|right|repeat|repeat-y|repeat-x|relative|progress|pointer|overline|outside|outset|oblique|nowrap|not-allowed|normal|none|nw-resize|no-repeat|no-drop|newspaper|ne-resize|n-resize|move|middle|medium|ltr|lr-tb|lowercase|lower-roman|lower-alpha|loose|list-item|line|line-through|line-edge|lighter|left|keep-all|justify|italic|inter-word|inter-ideograph|inside|inset|inline|inline-block|inherit|inactive|ideograph-space|ideograph-parenthesis|ideograph-numeric|ideograph-alpha|horizontal|hidden|help|hand|groove|fixed|ellipsis|e-resize|double|dotted|distribute|distribute-space|distribute-letter|distribute-all-lines|disc|disabled|default|decimal|dashed|crosshair|collapse|col-resize|circle|char|center|capitalize|break-word|break-all|bottom|both|bolder|bold|block|bidi-override|below|baseline|auto|always|all-scroll|absolute|table|table-cell)\\b" }, { begin: /:/, end: /[;}{]/, relevance: 0, contains: [e.BLOCK_COMMENT, s, e.HEXCOLOR, e.CSS_NUMBER_MODE, n.QUOTE_STRING_MODE, n.APOS_STRING_MODE, e.IMPORTANT, e.FUNCTION_DISPATCH] }, { begin: "@(page|font-face)", keywords: { $pattern: i, keyword: "@page @font-face" } }, { begin: "@", end: "[{;]", returnBegin: !0, keywords: { $pattern: /[a-z-]+/, keyword: a, attribute: yLe.join(" ") }, contains: [{ begin: i, className: "keyword" }, { begin: /[a-z-]+(?=:)/, className: "attribute" }, s, n.QUOTE_STRING_MODE, n.APOS_STRING_MODE, e.HEXCOLOR, e.CSS_NUMBER_MODE] }, e.FUNCTION_DISPATCH] } } function SLe(n) { return { name: "Shell Session", aliases: ["console", "shellsession"], contains: [{ className: "meta.prompt", begin: /^\s{0,3}[/~\w\d[\]()@-]*[>%$#][ ]?/, starts: { end: /[^\\](?=\s*$)/, subLanguage: "bash" } }] } } function TLe(n) { const e = n.regex, t = n.COMMENT("--", "$"), r = { scope: "string", variants: [{ begin: /'/, end: /'/, contains: [{ match: /''/ }] }] }, i = { begin: /"/, end: /"/, contains: [{ match: /""/ }] }, a = ["true", "false", "unknown"], o = ["double precision", "large object", "with timezone", "without timezone"], s = ["bigint", "binary", "blob", "boolean", "char", "character", "clob", "date", "dec", "decfloat", "decimal", "float", "int", "integer", "interval", "nchar", "nclob", "national", "numeric", "real", "row", "smallint", "time", "timestamp", "varchar", "varying", "varbinary"], l = ["add", "asc", "collation", "desc", "final", "first", "last", "view"], c = ["abs", "acos", "all", "allocate", "alter", "and", "any", "are", "array", "array_agg", "array_max_cardinality", "as", "asensitive", "asin", "asymmetric", "at", "atan", "atomic", "authorization", "avg", "begin", "begin_frame", "begin_partition", "between", "bigint", "binary", "blob", "boolean", "both", "by", "call", "called", "cardinality", "cascaded", "case", "cast", "ceil", "ceiling", "char", "char_length", "character", "character_length", "check", "classifier", "clob", "close", "coalesce", "collate", "collect", "column", "commit", "condition", "connect", "constraint", "contains", "convert", "copy", "corr", "corresponding", "cos", "cosh", "count", "covar_pop", "covar_samp", "create", "cross", "cube", "cume_dist", "current", "current_catalog", "current_date", "current_default_transform_group", "current_path", "current_role", "current_row", "current_schema", "current_time", "current_timestamp", "current_path", "current_role", "current_transform_group_for_type", "current_user", "cursor", "cycle", "date", "day", "deallocate", "dec", "decimal", "decfloat", "declare", "default", "define", "delete", "dense_rank", "deref", "describe", "deterministic", "disconnect", "distinct", "double", "drop", "dynamic", "each", "element", "else", "empty", "end", "end_frame", "end_partition", "end-exec", "equals", "escape", "every", "except", "exec", "execute", "exists", "exp", "external", "extract", "false", "fetch", "filter", "first_value", "float", "floor", "for", "foreign", "frame_row", "free", "from", "full", "function", "fusion", "get", "global", "grant", "group", "grouping", "groups", "having", "hold", "hour", "identity", "in", "indicator", "initial", "inner", "inout", "insensitive", "insert", "int", "integer", "intersect", "intersection", "interval", "into", "is", "join", "json_array", "json_arrayagg", "json_exists", "json_object", "json_objectagg", "json_query", "json_table", "json_table_primitive", "json_value", "lag", "language", "large", "last_value", "lateral", "lead", "leading", "left", "like", "like_regex", "listagg", "ln", "local", "localtime", "localtimestamp", "log", "log10", "lower", "match", "match_number", "match_recognize", "matches", "max", "member", "merge", "method", "min", "minute", "mod", "modifies", "module", "month", "multiset", "national", "natural", "nchar", "nclob", "new", "no", "none", "normalize", "not", "nth_value", "ntile", "null", "nullif", "numeric", "octet_length", "occurrences_regex", "of", "offset", "old", "omit", "on", "one", "only", "open", "or", "order", "out", "outer", "over", "overlaps", "overlay", "parameter", "partition", "pattern", "per", "percent", "percent_rank", "percentile_cont", "percentile_disc", "period", "portion", "position", "position_regex", "power", "precedes", "precision", "prepare", "primary", "procedure", "ptf", "range", "rank", "reads", "real", "recursive", "ref", "references", "referencing", "regr_avgx", "regr_avgy", "regr_count", "regr_intercept", "regr_r2", "regr_slope", "regr_sxx", "regr_sxy", "regr_syy", "release", "result", "return", "returns", "revoke", "right", "rollback", "rollup", "row", "row_number", "rows", "running", "savepoint", "scope", "scroll", "search", "second", "seek", "select", "sensitive", "session_user", "set", "show", "similar", "sin", "sinh", "skip", "smallint", "some", "specific", "specifictype", "sql", "sqlexception", "sqlstate", "sqlwarning", "sqrt", "start", "static", "stddev_pop", "stddev_samp", "submultiset", "subset", "substring", "substring_regex", "succeeds", "sum", "symmetric", "system", "system_time", "system_user", "table", "tablesample", "tan", "tanh", "then", "time", "timestamp", "timezone_hour", "timezone_minute", "to", "trailing", "translate", "translate_regex", "translation", "treat", "trigger", "trim", "trim_array", "true", "truncate", "uescape", "union", "unique", "unknown", "unnest", "update", "upper", "user", "using", "value", "values", "value_of", "var_pop", "var_samp", "varbinary", "varchar", "varying", "versioning", "when", "whenever", "where", "width_bucket", "window", "with", "within", "without", "year"], u = ["abs", "acos", "array_agg", "asin", "atan", "avg", "cast", "ceil", "ceiling", "coalesce", "corr", "cos", "cosh", "count", "covar_pop", "covar_samp", "cume_dist", "dense_rank", "deref", "element", "exp", "extract", "first_value", "floor", "json_array", "json_arrayagg", "json_exists", "json_object", "json_objectagg", "json_query", "json_table", "json_table_primitive", "json_value", "lag", "last_value", "lead", "listagg", "ln", "log", "log10", "lower", "max", "min", "mod", "nth_value", "ntile", "nullif", "percent_rank", "percentile_cont", "percentile_disc", "position", "position_regex", "power", "rank", "regr_avgx", "regr_avgy", "regr_count", "regr_intercept", "regr_r2", "regr_slope", "regr_sxx", "regr_sxy", "regr_syy", "row_number", "sin", "sinh", "sqrt", "stddev_pop", "stddev_samp", "substring", "substring_regex", "sum", "tan", "tanh", "translate", "translate_regex", "treat", "trim", "trim_array", "unnest", "upper", "value_of", "var_pop", "var_samp", "width_bucket"], d = ["current_catalog", "current_date", "current_default_transform_group", "current_path", "current_role", "current_schema", "current_transform_group_for_type", "current_user", "session_user", "system_time", "system_user", "current_time", "localtime", "current_timestamp", "localtimestamp"], f = ["create table", "insert into", "primary key", "foreign key", "not null", "alter table", "add constraint", "grouping sets", "on overflow", "character set", "respect nulls", "ignore nulls", "nulls first", "nulls last", "depth first", "breadth first"], h = u, p = [...c, ...l].filter(S => !u.includes(S)), m = { scope: "variable", match: /@[a-z0-9][a-z0-9_]*/ }, g = { scope: "operator", match: /[-+*/=%^~]|&&?|\|\|?|!=?|<(?:=>?|<|>)?|>[>=]?/, relevance: 0 }, y = { match: e.concat(/\b/, e.either(...h), /\s*\(/), relevance: 0, keywords: { built_in: h } }; function b(S) { return e.concat(/\b/, e.either(...S.map(x => x.replace(/\s+/, "\\s+"))), /\b/) } const w = { scope: "keyword", match: b(f), relevance: 0 }; function v(S, { exceptions: x, when: k } = {}) { const A = k; return x = x || [], S.map(C => C.match(/\|\d+$/) || x.includes(C) ? C : A(C) ? `${C}|0` : C) } return { name: "SQL", case_insensitive: !0, illegal: /[{}]|<\//, keywords: { $pattern: /\b[\w\.]+/, keyword: v(p, { when: S => S.length < 3 }), literal: a, type: s, built_in: d }, contains: [{ scope: "type", match: b(o) }, w, y, m, r, i, n.C_NUMBER_MODE, n.C_BLOCK_COMMENT_MODE, t, g] } } function vQ(n) { return n ? typeof n == "string" ? n : n.source : null } function $v(n) { return Fn("(?=", n, ")") } function Fn(...n) { return n.map(t => vQ(t)).join("") } function kLe(n) { const e = n[n.length - 1]; return typeof e == "object" && e.constructor === Object ? (n.splice(n.length - 1, 1), e) : {} } function Gi(...n) { return "(" + (kLe(n).capture ? "" : "?:") + n.map(r => vQ(r)).join("|") + ")" } const tN = n => Fn(/\b/, n, /\w$/.test(n) ? /\b/ : /\B/), CLe = ["Protocol", "Type"].map(tN), qz = ["init", "self"].map(tN), ALe = ["Any", "Self"], qE = ["actor", "any", "associatedtype", "async", "await", /as\?/, /as!/, "as", "borrowing", "break", "case", "catch", "class", "consume", "consuming", "continue", "convenience", "copy", "default", "defer", "deinit", "didSet", "distributed", "do", "dynamic", "each", "else", "enum", "extension", "fallthrough", /fileprivate\(set\)/, "fileprivate", "final", "for", "func", "get", "guard", "if", "import", "indirect", "infix", /init\?/, /init!/, "inout", /internal\(set\)/, "internal", "in", "is", "isolated", "nonisolated", "lazy", "let", "macro", "mutating", "nonmutating", /open\(set\)/, "open", "operator", "optional", "override", "package", "postfix", "precedencegroup", "prefix", /private\(set\)/, "private", "protocol", /public\(set\)/, "public", "repeat", "required", "rethrows", "return", "set", "some", "static", "struct", "subscript", "super", "switch", "throws", "throw", /try\?/, /try!/, "try", "typealias", /unowned\(safe\)/, /unowned\(unsafe\)/, "unowned", "var", "weak", "where", "while", "willSet"], Yz = ["false", "nil", "true"], ELe = ["assignment", "associativity", "higherThan", "left", "lowerThan", "none", "right"], MLe = ["#colorLiteral", "#column", "#dsohandle", "#else", "#elseif", "#endif", "#error", "#file", "#fileID", "#fileLiteral", "#filePath", "#function", "#if", "#imageLiteral", "#keyPath", "#line", "#selector", "#sourceLocation", "#warning"], Zz = ["abs", "all", "any", "assert", "assertionFailure", "debugPrint", "dump", "fatalError", "getVaList", "isKnownUniquelyReferenced", "max", "min", "numericCast", "pointwiseMax", "pointwiseMin", "precondition", "preconditionFailure", "print", "readLine", "repeatElement", "sequence", "stride", "swap", "swift_unboxFromSwiftValueWithType", "transcode", "type", "unsafeBitCast", "unsafeDowncast", "withExtendedLifetime", "withUnsafeMutablePointer", "withUnsafePointer", "withVaList", "withoutActuallyEscaping", "zip"], yQ = Gi(/[/=\-+!*%<>&|^~?]/, /[\u00A1-\u00A7]/, /[\u00A9\u00AB]/, /[\u00AC\u00AE]/, /[\u00B0\u00B1]/, /[\u00B6\u00BB\u00BF\u00D7\u00F7]/, /[\u2016-\u2017]/, /[\u2020-\u2027]/, /[\u2030-\u203E]/, /[\u2041-\u2053]/, /[\u2055-\u205E]/, /[\u2190-\u23FF]/, /[\u2500-\u2775]/, /[\u2794-\u2BFF]/, /[\u2E00-\u2E7F]/, /[\u3001-\u3003]/, /[\u3008-\u3020]/, /[\u3030]/), _Q = Gi(yQ, /[\u0300-\u036F]/, /[\u1DC0-\u1DFF]/, /[\u20D0-\u20FF]/, /[\uFE00-\uFE0F]/, /[\uFE20-\uFE2F]/), YE = Fn(yQ, _Q, "*"), bQ = Gi(/[a-zA-Z_]/, /[\u00A8\u00AA\u00AD\u00AF\u00B2-\u00B5\u00B7-\u00BA]/, /[\u00BC-\u00BE\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u00FF]/, /[\u0100-\u02FF\u0370-\u167F\u1681-\u180D\u180F-\u1DBF]/, /[\u1E00-\u1FFF]/, /[\u200B-\u200D\u202A-\u202E\u203F-\u2040\u2054\u2060-\u206F]/, /[\u2070-\u20CF\u2100-\u218F\u2460-\u24FF\u2776-\u2793]/, /[\u2C00-\u2DFF\u2E80-\u2FFF]/, /[\u3004-\u3007\u3021-\u302F\u3031-\u303F\u3040-\uD7FF]/, /[\uF900-\uFD3D\uFD40-\uFDCF\uFDF0-\uFE1F\uFE30-\uFE44]/, /[\uFE47-\uFEFE\uFF00-\uFFFD]/), u2 = Gi(bQ, /\d/, /[\u0300-\u036F\u1DC0-\u1DFF\u20D0-\u20FF\uFE20-\uFE2F]/), Hs = Fn(bQ, u2, "*"), mw = Fn(/[A-Z]/, u2, "*"), OLe = ["attached", "autoclosure", Fn(/convention\(/, Gi("swift", "block", "c"), /\)/), "discardableResult", "dynamicCallable", "dynamicMemberLookup", "escaping", "freestanding", "frozen", "GKInspectable", "IBAction", "IBDesignable", "IBInspectable", "IBOutlet", "IBSegueAction", "inlinable", "main", "nonobjc", "NSApplicationMain", "NSCopying", "NSManaged", Fn(/objc\(/, Hs, /\)/), "objc", "objcMembers", "propertyWrapper", "requires_stored_property_inits", "resultBuilder", "Sendable", "testable", "UIApplicationMain", "unchecked", "unknown", "usableFromInline", "warn_unqualified_access"], DLe = ["iOS", "iOSApplicationExtension", "macOS", "macOSApplicationExtension", "macCatalyst", "macCatalystApplicationExtension", "watchOS", "watchOSApplicationExtension", "tvOS", "tvOSApplicationExtension", "swift"]; function jLe(n) { const e = { match: /\s+/, relevance: 0 }, t = n.COMMENT("/\\*", "\\*/", { contains: ["self"] }), r = [n.C_LINE_COMMENT_MODE, t], i = { match: [/\./, Gi(...CLe, ...qz)], className: { 2: "keyword" } }, a = { match: Fn(/\./, Gi(...qE)), relevance: 0 }, o = qE.filter(de => typeof de == "string").concat(["_|0"]), s = qE.filter(de => typeof de != "string").concat(ALe).map(tN), l = { variants: [{ className: "keyword", match: Gi(...s, ...qz) }] }, c = { $pattern: Gi(/\b\w+/, /#\w+/), keyword: o.concat(MLe), literal: Yz }, u = [i, a, l], d = { match: Fn(/\./, Gi(...Zz)), relevance: 0 }, f = { className: "built_in", match: Fn(/\b/, Gi(...Zz), /(?=\()/) }, h = [d, f], p = { match: /->/, relevance: 0 }, m = { className: "operator", relevance: 0, variants: [{ match: YE }, { match: `\\.(\\.|${_Q})+` }] }, g = [p, m], y = "([0-9]_*)+", b = "([0-9a-fA-F]_*)+", w = { className: "number", relevance: 0, variants: [{ match: `\\b(${y})(\\.(${y}))?([eE][+-]?(${y}))?\\b` }, { match: `\\b0x(${b})(\\.(${b}))?([pP][+-]?(${y}))?\\b` }, { match: /\b0o([0-7]_*)+\b/ }, { match: /\b0b([01]_*)+\b/ }] }, v = (de = "") => ({ className: "subst", variants: [{ match: Fn(/\\/, de, /[0\\tnr"']/) }, { match: Fn(/\\/, de, /u\{[0-9a-fA-F]{1,8}\}/) }] }), S = (de = "") => ({ className: "subst", match: Fn(/\\/, de, /[\t ]*(?:[\r\n]|\r\n)/) }), x = (de = "") => ({ className: "subst", label: "interpol", begin: Fn(/\\/, de, /\(/), end: /\)/ }), k = (de = "") => ({ begin: Fn(de, /"""/), end: Fn(/"""/, de), contains: [v(de), S(de), x(de)] }), A = (de = "") => ({ begin: Fn(de, /"/), end: Fn(/"/, de), contains: [v(de), x(de)] }), C = { className: "string", variants: [k(), k("#"), k("##"), k("###"), A(), A("#"), A("##"), A("###")] }, E = [n.BACKSLASH_ESCAPE, { begin: /\[/, end: /\]/, relevance: 0, contains: [n.BACKSLASH_ESCAPE] }], O = { begin: /\/[^\s](?=[^/\n]*\/)/, end: /\//, contains: E }, j = de => { const me = Fn(de, /\//), fe = Fn(/\//, de); return { begin: me, end: fe, contains: [...E, { scope: "comment", begin: `#(?!.*${fe})`, end: /$/ }] } }, I = { scope: "regexp", variants: [j("###"), j("##"), j("#"), O] }, L = { match: Fn(/`/, Hs, /`/) }, R = { className: "variable", match: /\$\d+/ }, D = { className: "variable", match: `\\$${u2}+` }, P = [L, R, D], B = { match: /(@|#(un)?)available/, scope: "keyword", starts: { contains: [{ begin: /\(/, end: /\)/, keywords: DLe, contains: [...g, w, C] }] } }, F = { scope: "keyword", match: Fn(/@/, Gi(...OLe), $v(Gi(/\(/, /\s+/))) }, K = { scope: "meta", match: Fn(/@/, Hs) }, V = [B, F, K], W = { match: $v(/\b[A-Z]/), relevance: 0, contains: [{ className: "type", match: Fn(/(AV|CA|CF|CG|CI|CL|CM|CN|CT|MK|MP|MTK|MTL|NS|SCN|SK|UI|WK|XC)/, u2, "+") }, { className: "type", match: mw, relevance: 0 }, { match: /[?!]+/, relevance: 0 }, { match: /\.\.\./, relevance: 0 }, { match: Fn(/\s+&\s+/, $v(mw)), relevance: 0 }] }, J = { begin: /</, end: />/, keywords: c, contains: [...r, ...u, ...V, p, W] }; W.contains.push(J); const ie = { match: Fn(Hs, /\s*:/), keywords: "_|0", relevance: 0 }, le = { begin: /\(/, end: /\)/, relevance: 0, keywords: c, contains: ["self", ie, ...r, I, ...u, ...h, ...g, w, C, ...P, ...V, W] }, De = { begin: /</, end: />/, keywords: "repeat each", contains: [...r, W] }, ae = { begin: Gi($v(Fn(Hs, /\s*:/)), $v(Fn(Hs, /\s+/, Hs, /\s*:/))), end: /:/, relevance: 0, contains: [{ className: "keyword", match: /\b_\b/ }, { className: "params", match: Hs }] }, pe = { begin: /\(/, end: /\)/, keywords: c, contains: [ae, ...r, ...u, ...g, w, C, ...V, W, le], endsParent: !0, illegal: /["']/ }, se = { match: [/(func|macro)/, /\s+/, Gi(L.match, Hs, YE)], className: { 1: "keyword", 3: "title.function" }, contains: [De, pe, e], illegal: [/\[/, /%/] }, ge = { match: [/\b(?:subscript|init[?!]?)/, /\s*(?=[<(])/], className: { 1: "keyword" }, contains: [De, pe, e], illegal: /\[|%/ }, _e = { match: [/operator/, /\s+/, YE], className: { 1: "keyword", 3: "title" } }, je = { begin: [/precedencegroup/, /\s+/, mw], className: { 1: "keyword", 3: "title" }, contains: [W], keywords: [...ELe, ...Yz], end: /}/ }, U = { match: [/class\b/, /\s+/, /func\b/, /\s+/, /\b[A-Za-z_][A-Za-z0-9_]*\b/], scope: { 1: "keyword", 3: "keyword", 5: "title.function" } }, q = { match: [/class\b/, /\s+/, /var\b/], scope: { 1: "keyword", 3: "keyword" } }, ee = { begin: [/(struct|protocol|class|extension|enum|actor)/, /\s+/, Hs, /\s*/], beginScope: { 1: "keyword", 3: "title.class" }, keywords: c, contains: [De, ...u, { begin: /:/, end: /\{/, keywords: c, contains: [{ scope: "title.class.inherited", match: mw }, ...u], relevance: 0 }] }; for (const de of C.variants) { const me = de.contains.find(we => we.label === "interpol"); me.keywords = c; const fe = [...u, ...h, ...g, w, C, ...P]; me.contains = [...fe, { begin: /\(/, end: /\)/, contains: ["self", ...fe] }] } return { name: "Swift", keywords: c, contains: [...r, se, ge, U, q, ee, _e, je, { beginKeywords: "import", end: /$/, contains: [...r], relevance: 0 }, I, ...u, ...h, ...g, w, C, ...P, ...V, W, le] } } const d2 = "[A-Za-z$_][0-9A-Za-z$_]*", wQ = ["as", "in", "of", "if", "for", "while", "finally", "var", "new", "function", "do", "return", "void", "else", "break", "catch", "instanceof", "with", "throw", "case", "default", "try", "switch", "continue", "typeof", "delete", "let", "yield", "const", "class", "debugger", "async", "await", "static", "import", "from", "export", "extends", "using"], xQ = ["true", "false", "null", "undefined", "NaN", "Infinity"], SQ = ["Object", "Function", "Boolean", "Symbol", "Math", "Date", "Number", "BigInt", "String", "RegExp", "Array", "Float32Array", "Float64Array", "Int8Array", "Uint8Array", "Uint8ClampedArray", "Int16Array", "Int32Array", "Uint16Array", "Uint32Array", "BigInt64Array", "BigUint64Array", "Set", "Map", "WeakSet", "WeakMap", "ArrayBuffer", "SharedArrayBuffer", "Atomics", "DataView", "JSON", "Promise", "Generator", "GeneratorFunction", "AsyncFunction", "Reflect", "Proxy", "Intl", "WebAssembly"], TQ = ["Error", "EvalError", "InternalError", "RangeError", "ReferenceError", "SyntaxError", "TypeError", "URIError"], kQ = ["setInterval", "setTimeout", "clearInterval", "clearTimeout", "require", "exports", "eval", "isFinite", "isNaN", "parseFloat", "parseInt", "decodeURI", "decodeURIComponent", "encodeURI", "encodeURIComponent", "escape", "unescape"], CQ = ["arguments", "this", "super", "console", "window", "document", "localStorage", "sessionStorage", "module", "global"], AQ = [].concat(kQ, SQ, TQ); function PLe(n) { const e = n.regex, t = (B, { after: F }) => { const K = "</" + B[0].slice(1); return B.input.indexOf(K, F) !== -1 }, r = d2, i = { begin: "<>", end: "</>" }, a = /<[A-Za-z0-9\\._:-]+\s*\/>/, o = { begin: /<[A-Za-z0-9\\._:-]+/, end: /\/[A-Za-z0-9\\._:-]+>|\/>/, isTrulyOpeningTag: (B, F) => { const K = B[0].length + B.index, V = B.input[K]; if (V === "<" || V === ",") { F.ignoreMatch(); return } V === ">" && (t(B, { after: K }) || F.ignoreMatch()); let W; const J = B.input.substring(K); if (W = J.match(/^\s*=/)) { F.ignoreMatch(); return } if ((W = J.match(/^\s+extends\s+/)) && W.index === 0) { F.ignoreMatch(); return } } }, s = { $pattern: d2, keyword: wQ, literal: xQ, built_in: AQ, "variable.language": CQ }, l = "[0-9](_?[0-9])*", c = `\\.(${l})`, u = "0|[1-9](_?[0-9])*|0[0-7]*[89][0-9]*", d = { className: "number", variants: [{ begin: `(\\b(${u})((${c})|\\.)?|(${c}))[eE][+-]?(${l})\\b` }, { begin: `\\b(${u})\\b((${c})\\b|\\.)?|(${c})\\b` }, { begin: "\\b(0|[1-9](_?[0-9])*)n\\b" }, { begin: "\\b0[xX][0-9a-fA-F](_?[0-9a-fA-F])*n?\\b" }, { begin: "\\b0[bB][0-1](_?[0-1])*n?\\b" }, { begin: "\\b0[oO][0-7](_?[0-7])*n?\\b" }, { begin: "\\b0[0-7]+n?\\b" }], relevance: 0 }, f = { className: "subst", begin: "\\$\\{", end: "\\}", keywords: s, contains: [] }, h = { begin: ".?html`", end: "", starts: { end: "`", returnEnd: !1, contains: [n.BACKSLASH_ESCAPE, f], subLanguage: "xml" } }, p = { begin: ".?css`", end: "", starts: { end: "`", returnEnd: !1, contains: [n.BACKSLASH_ESCAPE, f], subLanguage: "css" } }, m = { begin: ".?gql`", end: "", starts: { end: "`", returnEnd: !1, contains: [n.BACKSLASH_ESCAPE, f], subLanguage: "graphql" } }, g = { className: "string", begin: "`", end: "`", contains: [n.BACKSLASH_ESCAPE, f] }, b = { className: "comment", variants: [n.COMMENT(/\/\*\*(?!\/)/, "\\*/", { relevance: 0, contains: [{ begin: "(?=@[A-Za-z]+)", relevance: 0, contains: [{ className: "doctag", begin: "@[A-Za-z]+" }, { className: "type", begin: "\\{", end: "\\}", excludeEnd: !0, excludeBegin: !0, relevance: 0 }, { className: "variable", begin: r + "(?=\\s*(-)|$)", endsParent: !0, relevance: 0 }, { begin: /(?=[^\n])\s/, relevance: 0 }] }] }), n.C_BLOCK_COMMENT_MODE, n.C_LINE_COMMENT_MODE] }, w = [n.APOS_STRING_MODE, n.QUOTE_STRING_MODE, h, p, m, g, { match: /\$\d+/ }, d]; f.contains = w.concat({ begin: /\{/, end: /\}/, keywords: s, contains: ["self"].concat(w) }); const v = [].concat(b, f.contains), S = v.concat([{ begin: /(\s*)\(/, end: /\)/, keywords: s, contains: ["self"].concat(v) }]), x = { className: "params", begin: /(\s*)\(/, end: /\)/, excludeBegin: !0, excludeEnd: !0, keywords: s, contains: S }, k = { variants: [{ match: [/class/, /\s+/, r, /\s+/, /extends/, /\s+/, e.concat(r, "(", e.concat(/\./, r), ")*")], scope: { 1: "keyword", 3: "title.class", 5: "keyword", 7: "title.class.inherited" } }, { match: [/class/, /\s+/, r], scope: { 1: "keyword", 3: "title.class" } }] }, A = { relevance: 0, match: e.either(/\bJSON/, /\b[A-Z][a-z]+([A-Z][a-z]*|\d)*/, /\b[A-Z]{2,}([A-Z][a-z]+|\d)+([A-Z][a-z]*)*/, /\b[A-Z]{2,}[a-z]+([A-Z][a-z]+|\d)*([A-Z][a-z]*)*/), className: "title.class", keywords: { _: [...SQ, ...TQ] } }, C = { label: "use_strict", className: "meta", relevance: 10, begin: /^\s*['"]use (strict|asm)['"]/ }, E = { variants: [{ match: [/function/, /\s+/, r, /(?=\s*\()/] }, { match: [/function/, /\s*(?=\()/] }], className: { 1: "keyword", 3: "title.function" }, label: "func.def", contains: [x], illegal: /%/ }, O = { relevance: 0, match: /\b[A-Z][A-Z_0-9]+\b/, className: "variable.constant" }; function j(B) { return e.concat("(?!", B.join("|"), ")") } const I = { match: e.concat(/\b/, j([...kQ, "super", "import"].map(B => `${B}\\s*\\(`)), r, e.lookahead(/\s*\(/)), className: "title.function", relevance: 0 }, L = { begin: e.concat(/\./, e.lookahead(e.concat(r, /(?![0-9A-Za-z$_(])/))), end: r, excludeBegin: !0, keywords: "prototype", className: "property", relevance: 0 }, R = { match: [/get|set/, /\s+/, r, /(?=\()/], className: { 1: "keyword", 3: "title.function" }, contains: [{ begin: /\(\)/ }, x] }, D = "(\\([^()]*(\\([^()]*(\\([^()]*\\)[^()]*)*\\)[^()]*)*\\)|" + n.UNDERSCORE_IDENT_RE + ")\\s*=>", P = { match: [/const|var|let/, /\s+/, r, /\s*/, /=\s*/, /(async\s*)?/, e.lookahead(D)], keywords: "async", className: { 1: "keyword", 3: "title.function" }, contains: [x] }; return { name: "JavaScript", aliases: ["js", "jsx", "mjs", "cjs"], keywords: s, exports: { PARAMS_CONTAINS: S, CLASS_REFERENCE: A }, illegal: /#(?![$_A-z])/, contains: [n.SHEBANG({ label: "shebang", binary: "node", relevance: 5 }), C, n.APOS_STRING_MODE, n.QUOTE_STRING_MODE, h, p, m, g, b, { match: /\$\d+/ }, d, A, { scope: "attr", match: r + e.lookahead(":"), relevance: 0 }, P, { begin: "(" + n.RE_STARTERS_RE + "|\\b(case|return|throw)\\b)\\s*", keywords: "return throw case", relevance: 0, contains: [b, n.REGEXP_MODE, { className: "function", begin: D, returnBegin: !0, end: "\\s*=>", contains: [{ className: "params", variants: [{ begin: n.UNDERSCORE_IDENT_RE, relevance: 0 }, { className: null, begin: /\(\s*\)/, skip: !0 }, { begin: /(\s*)\(/, end: /\)/, excludeBegin: !0, excludeEnd: !0, keywords: s, contains: S }] }] }, { begin: /,/, relevance: 0 }, { match: /\s+/, relevance: 0 }, { variants: [{ begin: i.begin, end: i.end }, { match: a }, { begin: o.begin, "on:begin": o.isTrulyOpeningTag, end: o.end }], subLanguage: "xml", contains: [{ begin: o.begin, end: o.end, skip: !0, contains: ["self"] }] }] }, E, { beginKeywords: "while if switch catch for" }, { begin: "\\b(?!function)" + n.UNDERSCORE_IDENT_RE + "\\([^()]*(\\([^()]*(\\([^()]*\\)[^()]*)*\\)[^()]*)*\\)\\s*\\{", returnBegin: !0, label: "func.def", contains: [x, n.inherit(n.TITLE_MODE, { begin: r, className: "title.function" })] }, { match: /\.\.\./, relevance: 0 }, L, { match: "\\$" + r, relevance: 0 }, { match: [/\bconstructor(?=\s*\()/], className: { 1: "title.function" }, contains: [x] }, I, O, k, R, { match: /\$[(.]/ }] } } function ILe(n) { const e = n.regex, t = PLe(n), r = d2, i = ["any", "void", "number", "boolean", "string", "object", "never", "symbol", "bigint", "unknown"], a = { begin: [/namespace/, /\s+/, n.IDENT_RE], beginScope: { 1: "keyword", 3: "title.class" } }, o = { beginKeywords: "interface", end: /\{/, excludeEnd: !0, keywords: { keyword: "interface extends", built_in: i }, contains: [t.exports.CLASS_REFERENCE] }, s = { className: "meta", relevance: 10, begin: /^\s*['"]use strict['"]/ }, l = ["type", "interface", "public", "private", "protected", "implements", "declare", "abstract", "readonly", "enum", "override", "satisfies"], c = { $pattern: d2, keyword: wQ.concat(l), literal: xQ, built_in: AQ.concat(i), "variable.language": CQ }, u = { className: "meta", begin: "@" + r }, d = (m, g, y) => { const b = m.contains.findIndex(w => w.label === g); if (b === -1) throw new Error("can not find mode to replace"); m.contains.splice(b, 1, y) }; Object.assign(t.keywords, c), t.exports.PARAMS_CONTAINS.push(u); const f = t.contains.find(m => m.scope === "attr"), h = Object.assign({}, f, { match: e.concat(r, e.lookahead(/\s*\?:/)) }); t.exports.PARAMS_CONTAINS.push([t.exports.CLASS_REFERENCE, f, h]), t.contains = t.contains.concat([u, a, o, h]), d(t, "shebang", n.SHEBANG()), d(t, "use_strict", s); const p = t.contains.find(m => m.label === "func.def"); return p.relevance = 0, Object.assign(t, { name: "TypeScript", aliases: ["ts", "tsx", "mts", "cts"] }), t } function LLe(n) { const e = n.regex, t = { className: "string", begin: /"(""|[^/n])"C\b/ }, r = { className: "string", begin: /"/, end: /"/, illegal: /\n/, contains: [{ begin: /""/ }] }, i = /\d{1,2}\/\d{1,2}\/\d{4}/, a = /\d{4}-\d{1,2}-\d{1,2}/, o = /(\d|1[012])(:\d+){0,2} *(AM|PM)/, s = /\d{1,2}(:\d{1,2}){1,2}/, l = { className: "literal", variants: [{ begin: e.concat(/# */, e.either(a, i), / *#/) }, { begin: e.concat(/# */, s, / *#/) }, { begin: e.concat(/# */, o, / *#/) }, { begin: e.concat(/# */, e.either(a, i), / +/, e.either(o, s), / *#/) }] }, c = { className: "number", relevance: 0, variants: [{ begin: /\b\d[\d_]*((\.[\d_]+(E[+-]?[\d_]+)?)|(E[+-]?[\d_]+))[RFD@!#]?/ }, { begin: /\b\d[\d_]*((U?[SIL])|[%&])?/ }, { begin: /&H[\dA-F_]+((U?[SIL])|[%&])?/ }, { begin: /&O[0-7_]+((U?[SIL])|[%&])?/ }, { begin: /&B[01_]+((U?[SIL])|[%&])?/ }] }, u = { className: "label", begin: /^\w+:/ }, d = n.COMMENT(/'''/, /$/, { contains: [{ className: "doctag", begin: /<\/?/, end: />/ }] }), f = n.COMMENT(null, /$/, { variants: [{ begin: /'/ }, { begin: /([\t ]|^)REM(?=\s)/ }] }); return { name: "Visual Basic .NET", aliases: ["vb"], case_insensitive: !0, classNameAliases: { label: "symbol" }, keywords: { keyword: "addhandler alias aggregate ansi as async assembly auto binary by byref byval call case catch class compare const continue custom declare default delegate dim distinct do each equals else elseif end enum erase error event exit explicit finally for friend from function get global goto group handles if implements imports in inherits interface into iterator join key let lib loop me mid module mustinherit mustoverride mybase myclass namespace narrowing new next notinheritable notoverridable of off on operator option optional order overloads overridable overrides paramarray partial preserve private property protected public raiseevent readonly redim removehandler resume return select set shadows shared skip static step stop structure strict sub synclock take text then throw to try unicode until using when where while widening with withevents writeonly yield", built_in: "addressof and andalso await directcast gettype getxmlnamespace is isfalse isnot istrue like mod nameof new not or orelse trycast typeof xor cbool cbyte cchar cdate cdbl cdec cint clng cobj csbyte cshort csng cstr cuint culng cushort", type: "boolean byte char date decimal double integer long object sbyte short single string uinteger ulong ushort", literal: "true false nothing" }, illegal: "//|\\{|\\}|endif|gosub|variant|wend|^\\$ ", contains: [t, r, l, c, u, d, f, { className: "meta", begin: /[\t ]*#(const|disable|else|elseif|enable|end|externalsource|if|region)\b/, end: /$/, keywords: { keyword: "const disable else elseif enable end externalsource if region then" }, contains: [f] }] } } function RLe(n) { n.regex; const e = n.COMMENT(/\(;/, /;\)/); e.contains.push("self"); const t = n.COMMENT(/;;/, /$/), r = ["anyfunc", "block", "br", "br_if", "br_table", "call", "call_indirect", "data", "drop", "elem", "else", "end", "export", "func", "global.get", "global.set", "local.get", "local.set", "local.tee", "get_global", "get_local", "global", "if", "import", "local", "loop", "memory", "memory.grow", "memory.size", "module", "mut", "nop", "offset", "param", "result", "return", "select", "set_global", "set_local", "start", "table", "tee_local", "then", "type", "unreachable"], i = { begin: [/(?:func|call|call_indirect)/, /\s+/, /\$[^\s)]+/], className: { 1: "keyword", 3: "title.function" } }, a = { className: "variable", begin: /\$[\w_]+/ }, o = { match: /(\((?!;)|\))+/, className: "punctuation", relevance: 0 }, s = { className: "number", relevance: 0, match: /[+-]?\b(?:\d(?:_?\d)*(?:\.\d(?:_?\d)*)?(?:[eE][+-]?\d(?:_?\d)*)?|0x[\da-fA-F](?:_?[\da-fA-F])*(?:\.[\da-fA-F](?:_?[\da-fA-D])*)?(?:[pP][+-]?\d(?:_?\d)*)?)\b|\binf\b|\bnan(?::0x[\da-fA-F](?:_?[\da-fA-D])*)?\b/ }, l = { match: /(i32|i64|f32|f64)(?!\.)/, className: "type" }, c = { className: "keyword", match: /\b(f32|f64|i32|i64)(?:\.(?:abs|add|and|ceil|clz|const|convert_[su]\/i(?:32|64)|copysign|ctz|demote\/f64|div(?:_[su])?|eqz?|extend_[su]\/i32|floor|ge(?:_[su])?|gt(?:_[su])?|le(?:_[su])?|load(?:(?:8|16|32)_[su])?|lt(?:_[su])?|max|min|mul|nearest|neg?|or|popcnt|promote\/f32|reinterpret\/[fi](?:32|64)|rem_[su]|rot[lr]|shl|shr_[su]|store(?:8|16|32)?|sqrt|sub|trunc(?:_[su]\/f(?:32|64))?|wrap\/i64|xor))\b/ }; return { name: "WebAssembly", keywords: { $pattern: /[\w.]+/, keyword: r }, contains: [t, e, { match: [/(?:offset|align)/, /\s*/, /=/], className: { 1: "keyword", 3: "operator" } }, a, o, i, n.QUOTE_STRING_MODE, l, c, s] } } function NLe(n) { const e = n.regex, t = e.concat(/[\p{L}_]/u, e.optional(/[\p{L}0-9_.-]*:/u), /[\p{L}0-9_.-]*/u), r = /[\p{L}0-9._:-]+/u, i = { className: "symbol", begin: /&[a-z]+;|&#[0-9]+;|&#x[a-f0-9]+;/ }, a = { begin: /\s/, contains: [{ className: "keyword", begin: /#?[a-z_][a-z1-9_-]+/, illegal: /\n/ }] }, o = n.inherit(a, { begin: /\(/, end: /\)/ }), s = n.inherit(n.APOS_STRING_MODE, { className: "string" }), l = n.inherit(n.QUOTE_STRING_MODE, { className: "string" }), c = { endsWithParent: !0, illegal: /</, relevance: 0, contains: [{ className: "attr", begin: r, relevance: 0 }, { begin: /=\s*/, relevance: 0, contains: [{ className: "string", endsParent: !0, variants: [{ begin: /"/, end: /"/, contains: [i] }, { begin: /'/, end: /'/, contains: [i] }, { begin: /[^\s"'=<>`]+/ }] }] }] }; return { name: "HTML, XML", aliases: ["html", "xhtml", "rss", "atom", "xjb", "xsd", "xsl", "plist", "wsf", "svg"], case_insensitive: !0, unicodeRegex: !0, contains: [{ className: "meta", begin: /<![a-z]/, end: />/, relevance: 10, contains: [a, l, s, o, { begin: /\[/, end: /\]/, contains: [{ className: "meta", begin: /<![a-z]/, end: />/, contains: [a, o, l, s] }] }] }, n.COMMENT(/<!--/, /-->/, { relevance: 10 }), { begin: /<!\[CDATA\[/, end: /\]\]>/, relevance: 10 }, i, { className: "meta", end: /\?>/, variants: [{ begin: /<\?xml/, relevance: 10, contains: [l] }, { begin: /<\?[a-z][a-z0-9]+/ }] }, { className: "tag", begin: /<style(?=\s|>)/, end: />/, keywords: { name: "style" }, contains: [c], starts: { end: /<\/style>/, returnEnd: !0, subLanguage: ["css", "xml"] } }, { className: "tag", begin: /<script(?=\s|>)/, end: />/, keywords: { name: "script" }, contains: [c], starts: { end: /<\/script>/, returnEnd: !0, subLanguage: ["javascript", "handlebars", "xml"] } }, { className: "tag", begin: /<>|<\/>/ }, { className: "tag", begin: e.concat(/</, e.lookahead(e.concat(t, e.either(/\/>/, />/, /\s/)))), end: /\/?>/, contains: [{ className: "name", begin: t, relevance: 0, starts: c }] }, { className: "tag", begin: e.concat(/<\//, e.lookahead(e.concat(t, />/))), contains: [{ className: "name", begin: t, relevance: 0 }, { begin: />/, relevance: 0, endsParent: !0 }] }] } } function BLe(n) { const e = "true false yes no null", t = "[\\w#;/?:@&=+$,.~*'()[\\]]+", r = { className: "attr", variants: [{ begin: /[\w*@][\w*@ :()\./-]*:(?=[ \t]|$)/ }, { begin: /"[\w*@][\w*@ :()\./-]*":(?=[ \t]|$)/ }, { begin: /'[\w*@][\w*@ :()\./-]*':(?=[ \t]|$)/ }] }, i = { className: "template-variable", variants: [{ begin: /\{\{/, end: /\}\}/ }, { begin: /%\{/, end: /\}/ }] }, a = { className: "string", relevance: 0, begin: /'/, end: /'/, contains: [{ match: /''/, scope: "char.escape", relevance: 0 }] }, o = { className: "string", relevance: 0, variants: [{ begin: /"/, end: /"/ }, { begin: /\S+/ }], contains: [n.BACKSLASH_ESCAPE, i] }, s = n.inherit(o, { variants: [{ begin: /'/, end: /'/, contains: [{ begin: /''/, relevance: 0 }] }, { begin: /"/, end: /"/ }, { begin: /[^\s,{}[\]]+/ }] }), l = "[0-9]{4}(-[0-9][0-9]){0,2}", c = "([Tt \\t][0-9][0-9]?(:[0-9][0-9]){2})?", u = "(\\.[0-9]*)?", d = "([ \\t])*(Z|[-+][0-9][0-9]?(:[0-9][0-9])?)?", f = { className: "number", begin: "\\b" + l + c + u + d + "\\b" }, h = { end: ",", endsWithParent: !0, excludeEnd: !0, keywords: e, relevance: 0 }, p = { begin: /\{/, end: /\}/, contains: [h], illegal: "\\n", relevance: 0 }, m = { begin: "\\[", end: "\\]", contains: [h], illegal: "\\n", relevance: 0 }, g = [r, { className: "meta", begin: "^---\\s*$", relevance: 10 }, { className: "string", begin: "[\\|>]([1-9]?[+-])?[ ]*\\n( +)[^ ][^\\n]*\\n(\\2[^\\n]+\\n?)*" }, { begin: "<%[%=-]?", end: "[%-]?%>", subLanguage: "ruby", excludeBegin: !0, excludeEnd: !0, relevance: 0 }, { className: "type", begin: "!\\w+!" + t }, { className: "type", begin: "!<" + t + ">" }, { className: "type", begin: "!" + t }, { className: "type", begin: "!!" + t }, { className: "meta", begin: "&" + n.UNDERSCORE_IDENT_RE + "$" }, { className: "meta", begin: "\\*" + n.UNDERSCORE_IDENT_RE + "$" }, { className: "bullet", begin: "-(?=[ ]|$)", relevance: 0 }, n.HASH_COMMENT_MODE, { beginKeywords: e, keywords: { literal: e } }, f, { className: "number", begin: n.C_NUMBER_RE + "\\b", relevance: 0 }, p, m, a, o], y = [...g]; return y.pop(), y.push(s), h.contains = y, { name: "YAML", case_insensitive: !0, aliases: ["yml"], contains: g } } const $Le = { arduino: bIe, bash: wIe, c: xIe, cpp: SIe, csharp: TIe, css: PIe, diff: IIe, go: LIe, graphql: RIe, ini: NIe, java: BIe, javascript: HIe, json: UIe, kotlin: WIe, less: eLe, lua: tLe, makefile: nLe, markdown: rLe, objectivec: iLe, perl: aLe, php: oLe, "php-template": sLe, plaintext: lLe, python: cLe, "python-repl": uLe, r: dLe, ruby: fLe, rust: hLe, scss: xLe, shell: SLe, sql: TLe, swift: jLe, typescript: ILe, vbnet: LLe, wasm: RLe, xml: NLe, yaml: BLe }; function EQ(n) { return n instanceof Map ? n.clear = n.delete = n.set = function () { throw new Error("map is read-only") } : n instanceof Set && (n.add = n.clear = n.delete = function () { throw new Error("set is read-only") }), Object.freeze(n), Object.getOwnPropertyNames(n).forEach(e => { const t = n[e], r = typeof t; (r === "object" || r === "function") && !Object.isFrozen(t) && EQ(t) }), n } class Xz { constructor(e) { e.data === void 0 && (e.data = {}), this.data = e.data, this.isMatchIgnored = !1 } ignoreMatch() { this.isMatchIgnored = !0 } } function MQ(n) { return n.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&#x27;") } function Vu(n, ...e) { const t = Object.create(null); for (const r in n) t[r] = n[r]; return e.forEach(function (r) { for (const i in r) t[i] = r[i] }), t } const FLe = "</span>", Jz = n => !!n.scope, zLe = (n, { prefix: e }) => { if (n.startsWith("language:")) return n.replace("language:", "language-"); if (n.includes(".")) { const t = n.split("."); return [`${e}${t.shift()}`, ...t.map((r, i) => `${r}${"_".repeat(i + 1)}`)].join(" ") } return `${e}${n}` }; class VLe { constructor(e, t) { this.buffer = "", this.classPrefix = t.classPrefix, e.walk(this) } addText(e) { this.buffer += MQ(e) } openNode(e) { if (!Jz(e)) return; const t = zLe(e.scope, { prefix: this.classPrefix }); this.span(t) } closeNode(e) { Jz(e) && (this.buffer += FLe) } value() { return this.buffer } span(e) { this.buffer += `<span class="${e}">` } } const Qz = (n = {}) => { const e = { children: [] }; return Object.assign(e, n), e }; class nN { constructor() { this.rootNode = Qz(), this.stack = [this.rootNode] } get top() { return this.stack[this.stack.length - 1] } get root() { return this.rootNode } add(e) { this.top.children.push(e) } openNode(e) { const t = Qz({ scope: e }); this.add(t), this.stack.push(t) } closeNode() { if (this.stack.length > 1) return this.stack.pop() } closeAllNodes() { for (; this.closeNode();); } toJSON() { return JSON.stringify(this.rootNode, null, 4) } walk(e) { return this.constructor._walk(e, this.rootNode) } static _walk(e, t) { return typeof t == "string" ? e.addText(t) : t.children && (e.openNode(t), t.children.forEach(r => this._walk(e, r)), e.closeNode(t)), e } static _collapse(e) { typeof e != "string" && e.children && (e.children.every(t => typeof t == "string") ? e.children = [e.children.join("")] : e.children.forEach(t => { nN._collapse(t) })) } } class HLe extends nN { constructor(e) { super(), this.options = e } addText(e) { e !== "" && this.add(e) } startScope(e) { this.openNode(e) } endScope() { this.closeNode() } __addSublanguage(e, t) { const r = e.root; t && (r.scope = `language:${t}`), this.add(r) } toHTML() { return new VLe(this, this.options).value() } finalize() { return this.closeAllNodes(), !0 } } function i_(n) { return n ? typeof n == "string" ? n : n.source : null } function OQ(n) { return tp("(?=", n, ")") } function ULe(n) { return tp("(?:", n, ")*") } function GLe(n) { return tp("(?:", n, ")?") } function tp(...n) { return n.map(t => i_(t)).join("") } function WLe(n) { const e = n[n.length - 1]; return typeof e == "object" && e.constructor === Object ? (n.splice(n.length - 1, 1), e) : {} } function rN(...n) { return "(" + (WLe(n).capture ? "" : "?:") + n.map(r => i_(r)).join("|") + ")" } function DQ(n) { return new RegExp(n.toString() + "|").exec("").length - 1 } function KLe(n, e) { const t = n && n.exec(e); return t && t.index === 0 } const qLe = /\[(?:[^\\\]]|\\.)*\]|\(\??|\\([1-9][0-9]*)|\\./; function iN(n, { joinWith: e }) { let t = 0; return n.map(r => { t += 1; const i = t; let a = i_(r), o = ""; for (; a.length > 0;) { const s = qLe.exec(a); if (!s) { o += a; break } o += a.substring(0, s.index), a = a.substring(s.index + s[0].length), s[0][0] === "\\" && s[1] ? o += "\\" + String(Number(s[1]) + i) : (o += s[0], s[0] === "(" && t++) } return o }).map(r => `(${r})`).join(e) } const YLe = /\b\B/, jQ = "[a-zA-Z]\\w*", aN = "[a-zA-Z_]\\w*", PQ = "\\b\\d+(\\.\\d+)?", IQ = "(-?)(\\b0[xX][a-fA-F0-9]+|(\\b\\d+(\\.\\d*)?|\\.\\d+)([eE][-+]?\\d+)?)", LQ = "\\b(0b[01]+)", ZLe = "!|!=|!==|%|%=|&|&&|&=|\\*|\\*=|\\+|\\+=|,|-|-=|/=|/|:|;|<<|<<=|<=|<|===|==|=|>>>=|>>=|>=|>>>|>>|>|\\?|\\[|\\{|\\(|\\^|\\^=|\\||\\|=|\\|\\||~", XLe = (n = {}) => { const e = /^#![ ]*\//; return n.binary && (n.begin = tp(e, /.*\b/, n.binary, /\b.*/)), Vu({ scope: "meta", begin: e, end: /$/, relevance: 0, "on:begin": (t, r) => { t.index !== 0 && r.ignoreMatch() } }, n) }, a_ = { begin: "\\\\[\\s\\S]", relevance: 0 }, JLe = { scope: "string", begin: "'", end: "'", illegal: "\\n", contains: [a_] }, QLe = { scope: "string", begin: '"', end: '"', illegal: "\\n", contains: [a_] }, eRe = { begin: /\b(a|an|the|are|I'm|isn't|don't|doesn't|won't|but|just|should|pretty|simply|enough|gonna|going|wtf|so|such|will|you|your|they|like|more)\b/ }, Vk = function (n, e, t = {}) { const r = Vu({ scope: "comment", begin: n, end: e, contains: [] }, t); r.contains.push({ scope: "doctag", begin: "[ ]*(?=(TODO|FIXME|NOTE|BUG|OPTIMIZE|HACK|XXX):)", end: /(TODO|FIXME|NOTE|BUG|OPTIMIZE|HACK|XXX):/, excludeBegin: !0, relevance: 0 }); const i = rN("I", "a", "is", "so", "us", "to", "at", "if", "in", "it", "on", /[A-Za-z]+['](d|ve|re|ll|t|s|n)/, /[A-Za-z]+[-][a-z]+/, /[A-Za-z][a-z]{2,}/); return r.contains.push({ begin: tp(/[ ]+/, "(", i, /[.]?[:]?([.][ ]|[ ])/, "){3}") }), r }, tRe = Vk("//", "$"), nRe = Vk("/\\*", "\\*/"), rRe = Vk("#", "$"), iRe = { scope: "number", begin: PQ, relevance: 0 }, aRe = { scope: "number", begin: IQ, relevance: 0 }, oRe = { scope: "number", begin: LQ, relevance: 0 }, sRe = { scope: "regexp", begin: /\/(?=[^/\n]*\/)/, end: /\/[gimuy]*/, contains: [a_, { begin: /\[/, end: /\]/, relevance: 0, contains: [a_] }] }, lRe = { scope: "title", begin: jQ, relevance: 0 }, cRe = { scope: "title", begin: aN, relevance: 0 }, uRe = { begin: "\\.\\s*" + aN, relevance: 0 }, dRe = function (n) { return Object.assign(n, { "on:begin": (e, t) => { t.data._beginMatch = e[1] }, "on:end": (e, t) => { t.data._beginMatch !== e[1] && t.ignoreMatch() } }) }; var gw = Object.freeze({ __proto__: null, APOS_STRING_MODE: JLe, BACKSLASH_ESCAPE: a_, BINARY_NUMBER_MODE: oRe, BINARY_NUMBER_RE: LQ, COMMENT: Vk, C_BLOCK_COMMENT_MODE: nRe, C_LINE_COMMENT_MODE: tRe, C_NUMBER_MODE: aRe, C_NUMBER_RE: IQ, END_SAME_AS_BEGIN: dRe, HASH_COMMENT_MODE: rRe, IDENT_RE: jQ, MATCH_NOTHING_RE: YLe, METHOD_GUARD: uRe, NUMBER_MODE: iRe, NUMBER_RE: PQ, PHRASAL_WORDS_MODE: eRe, QUOTE_STRING_MODE: QLe, REGEXP_MODE: sRe, RE_STARTERS_RE: ZLe, SHEBANG: XLe, TITLE_MODE: lRe, UNDERSCORE_IDENT_RE: aN, UNDERSCORE_TITLE_MODE: cRe }); function fRe(n, e) { n.input[n.index - 1] === "." && e.ignoreMatch() } function hRe(n, e) { n.className !== void 0 && (n.scope = n.className, delete n.className) } function pRe(n, e) { e && n.beginKeywords && (n.begin = "\\b(" + n.beginKeywords.split(" ").join("|") + ")(?!\\.)(?=\\b|\\s)", n.__beforeBegin = fRe, n.keywords = n.keywords || n.beginKeywords, delete n.beginKeywords, n.relevance === void 0 && (n.relevance = 0)) } function mRe(n, e) { Array.isArray(n.illegal) && (n.illegal = rN(...n.illegal)) } function gRe(n, e) { if (n.match) { if (n.begin || n.end) throw new Error("begin & end are not supported with match"); n.begin = n.match, delete n.match } } function vRe(n, e) { n.relevance === void 0 && (n.relevance = 1) } const yRe = (n, e) => { if (!n.beforeMatch) return; if (n.starts) throw new Error("beforeMatch cannot be used with starts"); const t = Object.assign({}, n); Object.keys(n).forEach(r => { delete n[r] }), n.keywords = t.keywords, n.begin = tp(t.beforeMatch, OQ(t.begin)), n.starts = { relevance: 0, contains: [Object.assign(t, { endsParent: !0 })] }, n.relevance = 0, delete t.beforeMatch }, _Re = ["of", "and", "for", "in", "not", "or", "if", "then", "parent", "list", "value"], bRe = "keyword"; function RQ(n, e, t = bRe) { const r = Object.create(null); return typeof n == "string" ? i(t, n.split(" ")) : Array.isArray(n) ? i(t, n) : Object.keys(n).forEach(function (a) { Object.assign(r, RQ(n[a], e, a)) }), r; function i(a, o) { e && (o = o.map(s => s.toLowerCase())), o.forEach(function (s) { const l = s.split("|"); r[l[0]] = [a, wRe(l[0], l[1])] }) } } function wRe(n, e) { return e ? Number(e) : xRe(n) ? 0 : 1 } function xRe(n) { return _Re.includes(n.toLowerCase()) } const e6 = {}, _h = n => { console.error(n) }, t6 = (n, ...e) => { console.log(`WARN: ${n}`, ...e) }, Bp = (n, e) => { e6[`${n}/${e}`] || (console.log(`Deprecated as of ${n}. ${e}`), e6[`${n}/${e}`] = !0) }, f2 = new Error; function NQ(n, e, { key: t }) { let r = 0; const i = n[t], a = {}, o = {}; for (let s = 1; s <= e.length; s++)o[s + r] = i[s], a[s + r] = !0, r += DQ(e[s - 1]); n[t] = o, n[t]._emit = a, n[t]._multi = !0 } function SRe(n) { if (Array.isArray(n.begin)) { if (n.skip || n.excludeBegin || n.returnBegin) throw _h("skip, excludeBegin, returnBegin not compatible with beginScope: {}"), f2; if (typeof n.beginScope != "object" || n.beginScope === null) throw _h("beginScope must be object"), f2; NQ(n, n.begin, { key: "beginScope" }), n.begin = iN(n.begin, { joinWith: "" }) } } function TRe(n) { if (Array.isArray(n.end)) { if (n.skip || n.excludeEnd || n.returnEnd) throw _h("skip, excludeEnd, returnEnd not compatible with endScope: {}"), f2; if (typeof n.endScope != "object" || n.endScope === null) throw _h("endScope must be object"), f2; NQ(n, n.end, { key: "endScope" }), n.end = iN(n.end, { joinWith: "" }) } } function kRe(n) { n.scope && typeof n.scope == "object" && n.scope !== null && (n.beginScope = n.scope, delete n.scope) } function CRe(n) { kRe(n), typeof n.beginScope == "string" && (n.beginScope = { _wrap: n.beginScope }), typeof n.endScope == "string" && (n.endScope = { _wrap: n.endScope }), SRe(n), TRe(n) } function ARe(n) { function e(o, s) { return new RegExp(i_(o), "m" + (n.case_insensitive ? "i" : "") + (n.unicodeRegex ? "u" : "") + (s ? "g" : "")) } class t { constructor() { this.matchIndexes = {}, this.regexes = [], this.matchAt = 1, this.position = 0 } addRule(s, l) { l.position = this.position++, this.matchIndexes[this.matchAt] = l, this.regexes.push([l, s]), this.matchAt += DQ(s) + 1 } compile() { this.regexes.length === 0 && (this.exec = () => null); const s = this.regexes.map(l => l[1]); this.matcherRe = e(iN(s, { joinWith: "|" }), !0), this.lastIndex = 0 } exec(s) { this.matcherRe.lastIndex = this.lastIndex; const l = this.matcherRe.exec(s); if (!l) return null; const c = l.findIndex((d, f) => f > 0 && d !== void 0), u = this.matchIndexes[c]; return l.splice(0, c), Object.assign(l, u) } } class r { constructor() { this.rules = [], this.multiRegexes = [], this.count = 0, this.lastIndex = 0, this.regexIndex = 0 } getMatcher(s) { if (this.multiRegexes[s]) return this.multiRegexes[s]; const l = new t; return this.rules.slice(s).forEach(([c, u]) => l.addRule(c, u)), l.compile(), this.multiRegexes[s] = l, l } resumingScanAtSamePosition() { return this.regexIndex !== 0 } considerAll() { this.regexIndex = 0 } addRule(s, l) { this.rules.push([s, l]), l.type === "begin" && this.count++ } exec(s) { const l = this.getMatcher(this.regexIndex); l.lastIndex = this.lastIndex; let c = l.exec(s); if (this.resumingScanAtSamePosition() && !(c && c.index === this.lastIndex)) { const u = this.getMatcher(0); u.lastIndex = this.lastIndex + 1, c = u.exec(s) } return c && (this.regexIndex += c.position + 1, this.regexIndex === this.count && this.considerAll()), c } } function i(o) { const s = new r; return o.contains.forEach(l => s.addRule(l.begin, { rule: l, type: "begin" })), o.terminatorEnd && s.addRule(o.terminatorEnd, { type: "end" }), o.illegal && s.addRule(o.illegal, { type: "illegal" }), s } function a(o, s) { const l = o; if (o.isCompiled) return l;[hRe, gRe, CRe, yRe].forEach(u => u(o, s)), n.compilerExtensions.forEach(u => u(o, s)), o.__beforeBegin = null, [pRe, mRe, vRe].forEach(u => u(o, s)), o.isCompiled = !0; let c = null; return typeof o.keywords == "object" && o.keywords.$pattern && (o.keywords = Object.assign({}, o.keywords), c = o.keywords.$pattern, delete o.keywords.$pattern), c = c || /\w+/, o.keywords && (o.keywords = RQ(o.keywords, n.case_insensitive)), l.keywordPatternRe = e(c, !0), s && (o.begin || (o.begin = /\B|\b/), l.beginRe = e(l.begin), !o.end && !o.endsWithParent && (o.end = /\B|\b/), o.end && (l.endRe = e(l.end)), l.terminatorEnd = i_(l.end) || "", o.endsWithParent && s.terminatorEnd && (l.terminatorEnd += (o.end ? "|" : "") + s.terminatorEnd)), o.illegal && (l.illegalRe = e(o.illegal)), o.contains || (o.contains = []), o.contains = [].concat(...o.contains.map(function (u) { return ERe(u === "self" ? o : u) })), o.contains.forEach(function (u) { a(u, l) }), o.starts && a(o.starts, s), l.matcher = i(l), l } if (n.compilerExtensions || (n.compilerExtensions = []), n.contains && n.contains.includes("self")) throw new Error("ERR: contains `self` is not supported at the top-level of a language.  See documentation."); return n.classNameAliases = Vu(n.classNameAliases || {}), a(n) } function BQ(n) { return n ? n.endsWithParent || BQ(n.starts) : !1 } function ERe(n) { return n.variants && !n.cachedVariants && (n.cachedVariants = n.variants.map(function (e) { return Vu(n, { variants: null }, e) })), n.cachedVariants ? n.cachedVariants : BQ(n) ? Vu(n, { starts: n.starts ? Vu(n.starts) : null }) : Object.isFrozen(n) ? Vu(n) : n } var MRe = "11.11.1"; class ORe extends Error { constructor(e, t) { super(e), this.name = "HTMLInjectionError", this.html = t } } const ZE = MQ, n6 = Vu, r6 = Symbol("nomatch"), DRe = 7, $Q = function (n) {
  const e = Object.create(null), t = Object.create(null), r = []; let i = !0; const a = "Could not find the language '{}', did you forget to load/include a language module?", o = { disableAutodetect: !0, name: "Plain text", contains: [] }; let s = { ignoreUnescapedHTML: !1, throwUnescapedHTML: !1, noHighlightRe: /^(no-?highlight)$/i, languageDetectRe: /\blang(?:uage)?-([\w-]+)\b/i, classPrefix: "hljs-", cssSelector: "pre code", languages: null, __emitter: HLe }; function l(D) { return s.noHighlightRe.test(D) } function c(D) { let P = D.className + " "; P += D.parentNode ? D.parentNode.className : ""; const B = s.languageDetectRe.exec(P); if (B) { const F = A(B[1]); return F || (t6(a.replace("{}", B[1])), t6("Falling back to no-highlight mode for this block.", D)), F ? B[1] : "no-highlight" } return P.split(/\s+/).find(F => l(F) || A(F)) } function u(D, P, B) {
    let F = "", K = ""; typeof P == "object" ? (F = D, B = P.ignoreIllegals, K = P.language) : (Bp("10.7.0", "highlight(lang, code, ...args) has been deprecated."), Bp("10.7.0", `Please use highlight(code, options) instead.
https://github.com/highlightjs/highlight.js/issues/2277`), K = D, F = P), B === void 0 && (B = !0); const V = { code: F, language: K }; L("before:highlight", V); const W = V.result ? V.result : d(V.language, V.code, B); return W.code = V.code, L("after:highlight", W), W
  } function d(D, P, B, F) {
    const K = Object.create(null); function V(Ee, ce) { return Ee.keywords[ce] } function W() { if (!fe.keywords) { Oe.addText(ve); return } let Ee = 0; fe.keywordPatternRe.lastIndex = 0; let ce = fe.keywordPatternRe.exec(ve), Te = ""; for (; ce;) { Te += ve.substring(Ee, ce.index); const Le = ee.case_insensitive ? ce[0].toLowerCase() : ce[0], st = V(fe, Le); if (st) { const [jt, Dn] = st; if (Oe.addText(Te), Te = "", K[Le] = (K[Le] || 0) + 1, K[Le] <= DRe && (Se += Dn), jt.startsWith("_")) Te += ce[0]; else { const rr = ee.classNameAliases[jt] || jt; le(ce[0], rr) } } else Te += ce[0]; Ee = fe.keywordPatternRe.lastIndex, ce = fe.keywordPatternRe.exec(ve) } Te += ve.substring(Ee), Oe.addText(Te) } function J() { if (ve === "") return; let Ee = null; if (typeof fe.subLanguage == "string") { if (!e[fe.subLanguage]) { Oe.addText(ve); return } Ee = d(fe.subLanguage, ve, !0, we[fe.subLanguage]), we[fe.subLanguage] = Ee._top } else Ee = h(ve, fe.subLanguage.length ? fe.subLanguage : null); fe.relevance > 0 && (Se += Ee.relevance), Oe.__addSublanguage(Ee._emitter, Ee.language) } function ie() { fe.subLanguage != null ? J() : W(), ve = "" } function le(Ee, ce) { Ee !== "" && (Oe.startScope(ce), Oe.addText(Ee), Oe.endScope()) } function De(Ee, ce) { let Te = 1; const Le = ce.length - 1; for (; Te <= Le;) { if (!Ee._emit[Te]) { Te++; continue } const st = ee.classNameAliases[Ee[Te]] || Ee[Te], jt = ce[Te]; st ? le(jt, st) : (ve = jt, W(), ve = ""), Te++ } } function ae(Ee, ce) { return Ee.scope && typeof Ee.scope == "string" && Oe.openNode(ee.classNameAliases[Ee.scope] || Ee.scope), Ee.beginScope && (Ee.beginScope._wrap ? (le(ve, ee.classNameAliases[Ee.beginScope._wrap] || Ee.beginScope._wrap), ve = "") : Ee.beginScope._multi && (De(Ee.beginScope, ce), ve = "")), fe = Object.create(Ee, { parent: { value: fe } }), fe } function pe(Ee, ce, Te) { let Le = KLe(Ee.endRe, Te); if (Le) { if (Ee["on:end"]) { const st = new Xz(Ee); Ee["on:end"](ce, st), st.isMatchIgnored && (Le = !1) } if (Le) { for (; Ee.endsParent && Ee.parent;)Ee = Ee.parent; return Ee } } if (Ee.endsWithParent) return pe(Ee.parent, ce, Te) } function se(Ee) { return fe.matcher.regexIndex === 0 ? (ve += Ee[0], 1) : (Xe = !0, 0) } function ge(Ee) { const ce = Ee[0], Te = Ee.rule, Le = new Xz(Te), st = [Te.__beforeBegin, Te["on:begin"]]; for (const jt of st) if (jt && (jt(Ee, Le), Le.isMatchIgnored)) return se(ce); return Te.skip ? ve += ce : (Te.excludeBegin && (ve += ce), ie(), !Te.returnBegin && !Te.excludeBegin && (ve = ce)), ae(Te, Ee), Te.returnBegin ? 0 : ce.length } function _e(Ee) { const ce = Ee[0], Te = P.substring(Ee.index), Le = pe(fe, Ee, Te); if (!Le) return r6; const st = fe; fe.endScope && fe.endScope._wrap ? (ie(), le(ce, fe.endScope._wrap)) : fe.endScope && fe.endScope._multi ? (ie(), De(fe.endScope, Ee)) : st.skip ? ve += ce : (st.returnEnd || st.excludeEnd || (ve += ce), ie(), st.excludeEnd && (ve = ce)); do fe.scope && Oe.closeNode(), !fe.skip && !fe.subLanguage && (Se += fe.relevance), fe = fe.parent; while (fe !== Le.parent); return Le.starts && ae(Le.starts, Ee), st.returnEnd ? 0 : ce.length } function je() { const Ee = []; for (let ce = fe; ce !== ee; ce = ce.parent)ce.scope && Ee.unshift(ce.scope); Ee.forEach(ce => Oe.openNode(ce)) } let U = {}; function q(Ee, ce) {
      const Te = ce && ce[0]; if (ve += Ee, Te == null) return ie(), 0; if (U.type === "begin" && ce.type === "end" && U.index === ce.index && Te === "") { if (ve += P.slice(ce.index, ce.index + 1), !i) { const Le = new Error(`0 width match regex (${D})`); throw Le.languageName = D, Le.badRule = U.rule, Le } return 1 } if (U = ce, ce.type === "begin") return ge(ce); if (ce.type === "illegal" && !B) { const Le = new Error('Illegal lexeme "' + Te + '" for mode "' + (fe.scope || "<unnamed>") + '"'); throw Le.mode = fe, Le } else if (ce.type === "end") { const Le = _e(ce); if (Le !== r6) return Le } if (ce.type === "illegal" && Te === "") return ve += `
`, 1; if (ze > 1e5 && ze > ce.index * 3) throw new Error("potential infinite loop, way more iterations than matches"); return ve += Te, Te.length
    } const ee = A(D); if (!ee) throw _h(a.replace("{}", D)), new Error('Unknown language: "' + D + '"'); const de = ARe(ee); let me = "", fe = F || de; const we = {}, Oe = new s.__emitter(s); je(); let ve = "", Se = 0, Ke = 0, ze = 0, Xe = !1; try { if (ee.__emitTokens) ee.__emitTokens(P, Oe); else { for (fe.matcher.considerAll(); ;) { ze++, Xe ? Xe = !1 : fe.matcher.considerAll(), fe.matcher.lastIndex = Ke; const Ee = fe.matcher.exec(P); if (!Ee) break; const ce = P.substring(Ke, Ee.index), Te = q(ce, Ee); Ke = Ee.index + Te } q(P.substring(Ke)) } return Oe.finalize(), me = Oe.toHTML(), { language: D, value: me, relevance: Se, illegal: !1, _emitter: Oe, _top: fe } } catch (Ee) { if (Ee.message && Ee.message.includes("Illegal")) return { language: D, value: ZE(P), illegal: !0, relevance: 0, _illegalBy: { message: Ee.message, index: Ke, context: P.slice(Ke - 100, Ke + 100), mode: Ee.mode, resultSoFar: me }, _emitter: Oe }; if (i) return { language: D, value: ZE(P), illegal: !1, relevance: 0, errorRaised: Ee, _emitter: Oe, _top: fe }; throw Ee }
  } function f(D) { const P = { value: ZE(D), illegal: !1, relevance: 0, _top: o, _emitter: new s.__emitter(s) }; return P._emitter.addText(D), P } function h(D, P) { P = P || s.languages || Object.keys(e); const B = f(D), F = P.filter(A).filter(E).map(ie => d(ie, D, !1)); F.unshift(B); const K = F.sort((ie, le) => { if (ie.relevance !== le.relevance) return le.relevance - ie.relevance; if (ie.language && le.language) { if (A(ie.language).supersetOf === le.language) return 1; if (A(le.language).supersetOf === ie.language) return -1 } return 0 }), [V, W] = K, J = V; return J.secondBest = W, J } function p(D, P, B) { const F = P && t[P] || B; D.classList.add("hljs"), D.classList.add(`language-${F}`) } function m(D) { let P = null; const B = c(D); if (l(B)) return; if (L("before:highlightElement", { el: D, language: B }), D.dataset.highlighted) { console.log("Element previously highlighted. To highlight again, first unset `dataset.highlighted`.", D); return } if (D.children.length > 0 && (s.ignoreUnescapedHTML || (console.warn("One of your code blocks includes unescaped HTML. This is a potentially serious security risk."), console.warn("https://github.com/highlightjs/highlight.js/wiki/security"), console.warn("The element with unescaped HTML:"), console.warn(D)), s.throwUnescapedHTML)) throw new ORe("One of your code blocks includes unescaped HTML.", D.innerHTML); P = D; const F = P.textContent, K = B ? u(F, { language: B, ignoreIllegals: !0 }) : h(F); D.innerHTML = K.value, D.dataset.highlighted = "yes", p(D, B, K.language), D.result = { language: K.language, re: K.relevance, relevance: K.relevance }, K.secondBest && (D.secondBest = { language: K.secondBest.language, relevance: K.secondBest.relevance }), L("after:highlightElement", { el: D, result: K, text: F }) } function g(D) { s = n6(s, D) } const y = () => { v(), Bp("10.6.0", "initHighlighting() deprecated.  Use highlightAll() now.") }; function b() { v(), Bp("10.6.0", "initHighlightingOnLoad() deprecated.  Use highlightAll() now.") } let w = !1; function v() { function D() { v() } if (document.readyState === "loading") { w || window.addEventListener("DOMContentLoaded", D, !1), w = !0; return } document.querySelectorAll(s.cssSelector).forEach(m) } function S(D, P) { let B = null; try { B = P(n) } catch (F) { if (_h("Language definition for '{}' could not be registered.".replace("{}", D)), i) _h(F); else throw F; B = o } B.name || (B.name = D), e[D] = B, B.rawDefinition = P.bind(null, n), B.aliases && C(B.aliases, { languageName: D }) } function x(D) { delete e[D]; for (const P of Object.keys(t)) t[P] === D && delete t[P] } function k() { return Object.keys(e) } function A(D) { return D = (D || "").toLowerCase(), e[D] || e[t[D]] } function C(D, { languageName: P }) { typeof D == "string" && (D = [D]), D.forEach(B => { t[B.toLowerCase()] = P }) } function E(D) { const P = A(D); return P && !P.disableAutodetect } function O(D) { D["before:highlightBlock"] && !D["before:highlightElement"] && (D["before:highlightElement"] = P => { D["before:highlightBlock"](Object.assign({ block: P.el }, P)) }), D["after:highlightBlock"] && !D["after:highlightElement"] && (D["after:highlightElement"] = P => { D["after:highlightBlock"](Object.assign({ block: P.el }, P)) }) } function j(D) { O(D), r.push(D) } function I(D) { const P = r.indexOf(D); P !== -1 && r.splice(P, 1) } function L(D, P) { const B = D; r.forEach(function (F) { F[B] && F[B](P) }) } function R(D) { return Bp("10.7.0", "highlightBlock will be removed entirely in v12.0"), Bp("10.7.0", "Please use highlightElement now."), m(D) } Object.assign(n, { highlight: u, highlightAuto: h, highlightAll: v, highlightElement: m, highlightBlock: R, configure: g, initHighlighting: y, initHighlightingOnLoad: b, registerLanguage: S, unregisterLanguage: x, listLanguages: k, getLanguage: A, registerAliases: C, autoDetection: E, inherit: n6, addPlugin: j, removePlugin: I }), n.debugMode = function () { i = !1 }, n.safeMode = function () { i = !0 }, n.versionString = MRe, n.regex = { concat: tp, lookahead: OQ, either: rN, optional: GLe, anyNumberOfTimes: ULe }; for (const D in gw) typeof gw[D] == "object" && EQ(gw[D]); return Object.assign(n, gw), n
}, xg = $Q({}); xg.newInstance = () => $Q({}); var jRe = xg; xg.HighlightJS = xg; xg.default = xg; const PRe = ck(jRe), i6 = {}, IRe = "hljs-"; function LRe(n) { const e = PRe.newInstance(); return n && a(n), { highlight: t, highlightAuto: r, listLanguages: i, register: a, registerAlias: o, registered: s }; function t(l, c, u) { const d = u || i6, f = typeof d.prefix == "string" ? d.prefix : IRe; if (!e.getLanguage(l)) throw new Error("Unknown language: `" + l + "` is not registered"); e.configure({ __emitter: RRe, classPrefix: f }); const h = e.highlight(c, { ignoreIllegals: !0, language: l }); if (h.errorRaised) throw new Error("Could not highlight with `Highlight.js`", { cause: h.errorRaised }); const p = h._emitter.root, m = p.data; return m.language = h.language, m.relevance = h.relevance, p } function r(l, c) { const d = (c || i6).subset || i(); let f = -1, h = 0, p; for (; ++f < d.length;) { const m = d[f]; if (!e.getLanguage(m)) continue; const g = t(m, l, c); g.data && g.data.relevance !== void 0 && g.data.relevance > h && (h = g.data.relevance, p = g) } return p || { type: "root", children: [], data: { language: void 0, relevance: h } } } function i() { return e.listLanguages() } function a(l, c) { if (typeof l == "string") e.registerLanguage(l, c); else { let u; for (u in l) Object.hasOwn(l, u) && e.registerLanguage(u, l[u]) } } function o(l, c) { if (typeof l == "string") e.registerAliases(typeof c == "string" ? c : [...c], { languageName: l }); else { let u; for (u in l) if (Object.hasOwn(l, u)) { const d = l[u]; e.registerAliases(typeof d == "string" ? d : [...d], { languageName: u }) } } } function s(l) { return !!e.getLanguage(l) } } class RRe { constructor(e) { this.options = e, this.root = { type: "root", children: [], data: { language: void 0, relevance: 0 } }, this.stack = [this.root] } addText(e) { if (e === "") return; const t = this.stack[this.stack.length - 1], r = t.children[t.children.length - 1]; r && r.type === "text" ? r.value += e : t.children.push({ type: "text", value: e }) } startScope(e) { this.openNode(String(e)) } endScope() { this.closeNode() } __addSublanguage(e, t) { const r = this.stack[this.stack.length - 1], i = e.root.children; t ? r.children.push({ type: "element", tagName: "span", properties: { className: [t] }, children: i }) : r.children.push(...i) } openNode(e) { const t = this, r = e.split(".").map(function (o, s) { return s ? o + "_".repeat(s) : t.options.classPrefix + o }), i = this.stack[this.stack.length - 1], a = { type: "element", tagName: "span", properties: { className: r }, children: [] }; i.children.push(a), this.stack.push(a) } closeNode() { this.stack.pop() } finalize() { } toHTML() { return "" } } function FQ(n, e, t) { for (let r = 0; ; r++) { if (r == n.childCount || r == e.childCount) return n.childCount == e.childCount ? null : t; let i = n.child(r), a = e.child(r); if (i == a) { t += i.nodeSize; continue } if (!i.sameMarkup(a)) return t; if (i.isText && i.text != a.text) { for (let o = 0; i.text[o] == a.text[o]; o++)t++; return t } if (i.content.size || a.content.size) { let o = FQ(i.content, a.content, t + 1); if (o != null) return o } t += i.nodeSize } } function zQ(n, e, t, r) { for (let i = n.childCount, a = e.childCount; ;) { if (i == 0 || a == 0) return i == a ? null : { a: t, b: r }; let o = n.child(--i), s = e.child(--a), l = o.nodeSize; if (o == s) { t -= l, r -= l; continue } if (!o.sameMarkup(s)) return { a: t, b: r }; if (o.isText && o.text != s.text) { let c = 0, u = Math.min(o.text.length, s.text.length); for (; c < u && o.text[o.text.length - c - 1] == s.text[s.text.length - c - 1];)c++, t--, r--; return { a: t, b: r } } if (o.content.size || s.content.size) { let c = zQ(o.content, s.content, t - 1, r - 1); if (c) return c } t -= l, r -= l } } class dr { constructor(e, t) { if (this.content = e, this.size = t || 0, t == null) for (let r = 0; r < e.length; r++)this.size += e[r].nodeSize } nodesBetween(e, t, r, i = 0, a) { for (let o = 0, s = 0; s < t; o++) { let l = this.content[o], c = s + l.nodeSize; if (c > e && r(l, i + s, a || null, o) !== !1 && l.content.size) { let u = s + 1; l.nodesBetween(Math.max(0, e - u), Math.min(l.content.size, t - u), r, i + u) } s = c } } descendants(e) { this.nodesBetween(0, this.size, e) } textBetween(e, t, r, i) { let a = "", o = !0; return this.nodesBetween(e, t, (s, l) => { let c = s.isText ? s.text.slice(Math.max(e, l) - l, t - l) : s.isLeaf ? i ? typeof i == "function" ? i(s) : i : s.type.spec.leafText ? s.type.spec.leafText(s) : "" : ""; s.isBlock && (s.isLeaf && c || s.isTextblock) && r && (o ? o = !1 : a += r), a += c }, 0), a } append(e) { if (!e.size) return this; if (!this.size) return e; let t = this.lastChild, r = e.firstChild, i = this.content.slice(), a = 0; for (t.isText && t.sameMarkup(r) && (i[i.length - 1] = t.withText(t.text + r.text), a = 1); a < e.content.length; a++)i.push(e.content[a]); return new dr(i, this.size + e.size) } cut(e, t = this.size) { if (e == 0 && t == this.size) return this; let r = [], i = 0; if (t > e) for (let a = 0, o = 0; o < t; a++) { let s = this.content[a], l = o + s.nodeSize; l > e && ((o < e || l > t) && (s.isText ? s = s.cut(Math.max(0, e - o), Math.min(s.text.length, t - o)) : s = s.cut(Math.max(0, e - o - 1), Math.min(s.content.size, t - o - 1))), r.push(s), i += s.nodeSize), o = l } return new dr(r, i) } cutByIndex(e, t) { return e == t ? dr.empty : e == 0 && t == this.content.length ? this : new dr(this.content.slice(e, t)) } replaceChild(e, t) { let r = this.content[e]; if (r == t) return this; let i = this.content.slice(), a = this.size + t.nodeSize - r.nodeSize; return i[e] = t, new dr(i, a) } addToStart(e) { return new dr([e].concat(this.content), this.size + e.nodeSize) } addToEnd(e) { return new dr(this.content.concat(e), this.size + e.nodeSize) } eq(e) { if (this.content.length != e.content.length) return !1; for (let t = 0; t < this.content.length; t++)if (!this.content[t].eq(e.content[t])) return !1; return !0 } get firstChild() { return this.content.length ? this.content[0] : null } get lastChild() { return this.content.length ? this.content[this.content.length - 1] : null } get childCount() { return this.content.length } child(e) { let t = this.content[e]; if (!t) throw new RangeError("Index " + e + " out of range for " + this); return t } maybeChild(e) { return this.content[e] || null } forEach(e) { for (let t = 0, r = 0; t < this.content.length; t++) { let i = this.content[t]; e(i, r, t), r += i.nodeSize } } findDiffStart(e, t = 0) { return FQ(this, e, t) } findDiffEnd(e, t = this.size, r = e.size) { return zQ(this, e, t, r) } findIndex(e, t = -1) { if (e == 0) return vw(0, e); if (e == this.size) return vw(this.content.length, e); if (e > this.size || e < 0) throw new RangeError(`Position ${e} outside of fragment (${this})`); for (let r = 0, i = 0; ; r++) { let a = this.child(r), o = i + a.nodeSize; if (o >= e) return o == e || t > 0 ? vw(r + 1, o) : vw(r, i); i = o } } toString() { return "<" + this.toStringInner() + ">" } toStringInner() { return this.content.join(", ") } toJSON() { return this.content.length ? this.content.map(e => e.toJSON()) : null } static fromJSON(e, t) { if (!t) return dr.empty; if (!Array.isArray(t)) throw new RangeError("Invalid input for Fragment.fromJSON"); return new dr(t.map(e.nodeFromJSON)) } static fromArray(e) { if (!e.length) return dr.empty; let t, r = 0; for (let i = 0; i < e.length; i++) { let a = e[i]; r += a.nodeSize, i && a.isText && e[i - 1].sameMarkup(a) ? (t || (t = e.slice(0, i)), t[t.length - 1] = a.withText(t[t.length - 1].text + a.text)) : t && t.push(a) } return new dr(t || e, r) } static from(e) { if (!e) return dr.empty; if (e instanceof dr) return e; if (Array.isArray(e)) return this.fromArray(e); if (e.attrs) return new dr([e], e.nodeSize); throw new RangeError("Can not convert " + e + " to a Fragment" + (e.nodesBetween ? " (looks like multiple versions of prosemirror-model were loaded)" : "")) } } dr.empty = new dr([], 0); const XE = { index: 0, offset: 0 }; function vw(n, e) { return XE.index = n, XE.offset = e, XE } function lP(n, e) { if (n === e) return !0; if (!(n && typeof n == "object") || !(e && typeof e == "object")) return !1; let t = Array.isArray(n); if (Array.isArray(e) != t) return !1; if (t) { if (n.length != e.length) return !1; for (let r = 0; r < n.length; r++)if (!lP(n[r], e[r])) return !1 } else { for (let r in n) if (!(r in e) || !lP(n[r], e[r])) return !1; for (let r in e) if (!(r in n)) return !1 } return !0 } class ko { constructor(e, t) { this.type = e, this.attrs = t } addToSet(e) { let t, r = !1; for (let i = 0; i < e.length; i++) { let a = e[i]; if (this.eq(a)) return e; if (this.type.excludes(a.type)) t || (t = e.slice(0, i)); else { if (a.type.excludes(this.type)) return e; !r && a.type.rank > this.type.rank && (t || (t = e.slice(0, i)), t.push(this), r = !0), t && t.push(a) } } return t || (t = e.slice()), r || t.push(this), t } removeFromSet(e) { for (let t = 0; t < e.length; t++)if (this.eq(e[t])) return e.slice(0, t).concat(e.slice(t + 1)); return e } isInSet(e) { for (let t = 0; t < e.length; t++)if (this.eq(e[t])) return !0; return !1 } eq(e) { return this == e || this.type == e.type && lP(this.attrs, e.attrs) } toJSON() { let e = { type: this.type.name }; for (let t in this.attrs) { e.attrs = this.attrs; break } return e } static fromJSON(e, t) { if (!t) throw new RangeError("Invalid input for Mark.fromJSON"); let r = e.marks[t.type]; if (!r) throw new RangeError(`There is no mark type ${t.type} in this schema`); let i = r.create(t.attrs); return r.checkAttrs(i.attrs), i } static sameSet(e, t) { if (e == t) return !0; if (e.length != t.length) return !1; for (let r = 0; r < e.length; r++)if (!e[r].eq(t[r])) return !1; return !0 } static setFrom(e) { if (!e || Array.isArray(e) && e.length == 0) return ko.none; if (e instanceof ko) return [e]; let t = e.slice(); return t.sort((r, i) => r.type.rank - i.type.rank), t } } ko.none = []; class fc { constructor(e, t, r) { this.content = e, this.openStart = t, this.openEnd = r } get size() { return this.content.size - this.openStart - this.openEnd } insertAt(e, t) { let r = HQ(this.content, e + this.openStart, t); return r && new fc(r, this.openStart, this.openEnd) } removeBetween(e, t) { return new fc(VQ(this.content, e + this.openStart, t + this.openStart), this.openStart, this.openEnd) } eq(e) { return this.content.eq(e.content) && this.openStart == e.openStart && this.openEnd == e.openEnd } toString() { return this.content + "(" + this.openStart + "," + this.openEnd + ")" } toJSON() { if (!this.content.size) return null; let e = { content: this.content.toJSON() }; return this.openStart > 0 && (e.openStart = this.openStart), this.openEnd > 0 && (e.openEnd = this.openEnd), e } static fromJSON(e, t) { if (!t) return fc.empty; let r = t.openStart || 0, i = t.openEnd || 0; if (typeof r != "number" || typeof i != "number") throw new RangeError("Invalid input for Slice.fromJSON"); return new fc(dr.fromJSON(e, t.content), r, i) } static maxOpen(e, t = !0) { let r = 0, i = 0; for (let a = e.firstChild; a && !a.isLeaf && (t || !a.type.spec.isolating); a = a.firstChild)r++; for (let a = e.lastChild; a && !a.isLeaf && (t || !a.type.spec.isolating); a = a.lastChild)i++; return new fc(e, r, i) } } fc.empty = new fc(dr.empty, 0, 0); function VQ(n, e, t) { let { index: r, offset: i } = n.findIndex(e), a = n.maybeChild(r), { index: o, offset: s } = n.findIndex(t); if (i == e || a.isText) { if (s != t && !n.child(o).isText) throw new RangeError("Removing non-flat range"); return n.cut(0, e).append(n.cut(t)) } if (r != o) throw new RangeError("Removing non-flat range"); return n.replaceChild(r, a.copy(VQ(a.content, e - i - 1, t - i - 1))) } function HQ(n, e, t, r) { let { index: i, offset: a } = n.findIndex(e), o = n.maybeChild(i); if (a == e || o.isText) return r && !r.canReplace(i, i, t) ? null : n.cut(0, e).append(t).append(n.cut(e)); let s = HQ(o.content, e - a - 1, t); return s && n.replaceChild(i, o.copy(s)) } function NRe(n) { return n.tag != null } function BRe(n) { return n.style != null } let $Re = class cP { constructor(e, t) { this.schema = e, this.rules = t, this.tags = [], this.styles = []; let r = this.matchedStyles = []; t.forEach(i => { if (NRe(i)) this.tags.push(i); else if (BRe(i)) { let a = /[^=]*/.exec(i.style)[0]; r.indexOf(a) < 0 && r.push(a), this.styles.push(i) } }), this.normalizeLists = !this.tags.some(i => { if (!/^(ul|ol)\b/.test(i.tag) || !i.node) return !1; let a = e.nodes[i.node]; return a.contentMatch.matchType(a) }) } parse(e, t = {}) { let r = new o6(this, t, !1); return r.addAll(e, ko.none, t.from, t.to), r.finish() } parseSlice(e, t = {}) { let r = new o6(this, t, !0); return r.addAll(e, ko.none, t.from, t.to), fc.maxOpen(r.finish()) } matchTag(e, t, r) { for (let i = r ? this.tags.indexOf(r) + 1 : 0; i < this.tags.length; i++) { let a = this.tags[i]; if (VRe(e, a.tag) && (a.namespace === void 0 || e.namespaceURI == a.namespace) && (!a.context || t.matchesContext(a.context))) { if (a.getAttrs) { let o = a.getAttrs(e); if (o === !1) continue; a.attrs = o || void 0 } return a } } } matchStyle(e, t, r, i) { for (let a = i ? this.styles.indexOf(i) + 1 : 0; a < this.styles.length; a++) { let o = this.styles[a], s = o.style; if (!(s.indexOf(e) != 0 || o.context && !r.matchesContext(o.context) || s.length > e.length && (s.charCodeAt(e.length) != 61 || s.slice(e.length + 1) != t))) { if (o.getAttrs) { let l = o.getAttrs(t); if (l === !1) continue; o.attrs = l || void 0 } return o } } } static schemaRules(e) { let t = []; function r(i) { let a = i.priority == null ? 50 : i.priority, o = 0; for (; o < t.length; o++) { let s = t[o]; if ((s.priority == null ? 50 : s.priority) < a) break } t.splice(o, 0, i) } for (let i in e.marks) { let a = e.marks[i].spec.parseDOM; a && a.forEach(o => { r(o = s6(o)), o.mark || o.ignore || o.clearMark || (o.mark = i) }) } for (let i in e.nodes) { let a = e.nodes[i].spec.parseDOM; a && a.forEach(o => { r(o = s6(o)), o.node || o.ignore || o.mark || (o.node = i) }) } return t } static fromSchema(e) { return e.cached.domParser || (e.cached.domParser = new cP(e, cP.schemaRules(e))) } }; const UQ = { address: !0, article: !0, aside: !0, blockquote: !0, canvas: !0, dd: !0, div: !0, dl: !0, fieldset: !0, figcaption: !0, figure: !0, footer: !0, form: !0, h1: !0, h2: !0, h3: !0, h4: !0, h5: !0, h6: !0, header: !0, hgroup: !0, hr: !0, li: !0, noscript: !0, ol: !0, output: !0, p: !0, pre: !0, section: !0, table: !0, tfoot: !0, ul: !0 }, FRe = { head: !0, noscript: !0, object: !0, script: !0, style: !0, title: !0 }, GQ = { ol: !0, ul: !0 }, o_ = 1, uP = 2, a0 = 4; function a6(n, e, t) { return e != null ? (e ? o_ : 0) | (e === "full" ? uP : 0) : n && n.whitespace == "pre" ? o_ | uP : t & ~a0 } class yw { constructor(e, t, r, i, a, o) { this.type = e, this.attrs = t, this.marks = r, this.solid = i, this.options = o, this.content = [], this.activeMarks = ko.none, this.match = a || (o & a0 ? null : e.contentMatch) } findWrapping(e) { if (!this.match) { if (!this.type) return []; let t = this.type.contentMatch.fillBefore(dr.from(e)); if (t) this.match = this.type.contentMatch.matchFragment(t); else { let r = this.type.contentMatch, i; return (i = r.findWrapping(e.type)) ? (this.match = r, i) : null } } return this.match.findWrapping(e.type) } finish(e) { if (!(this.options & o_)) { let r = this.content[this.content.length - 1], i; if (r && r.isText && (i = /[ \t\r\n\u000c]+$/.exec(r.text))) { let a = r; r.text.length == i[0].length ? this.content.pop() : this.content[this.content.length - 1] = a.withText(a.text.slice(0, a.text.length - i[0].length)) } } let t = dr.from(this.content); return !e && this.match && (t = t.append(this.match.fillBefore(dr.empty, !0))), this.type ? this.type.create(this.attrs, t, this.marks) : t } inlineContext(e) { return this.type ? this.type.inlineContent : this.content.length ? this.content[0].isInline : e.parentNode && !UQ.hasOwnProperty(e.parentNode.nodeName.toLowerCase()) } } class o6 {
  constructor(e, t, r) { this.parser = e, this.options = t, this.isOpen = r, this.open = 0, this.localPreserveWS = !1; let i = t.topNode, a, o = a6(null, t.preserveWhitespace, 0) | (r ? a0 : 0); i ? a = new yw(i.type, i.attrs, ko.none, !0, t.topMatch || i.type.contentMatch, o) : r ? a = new yw(null, null, ko.none, !0, null, o) : a = new yw(e.schema.topNodeType, null, ko.none, !0, null, o), this.nodes = [a], this.find = t.findPositions, this.needsBlock = !1 } get top() { return this.nodes[this.open] } addDOM(e, t) { e.nodeType == 3 ? this.addTextNode(e, t) : e.nodeType == 1 && this.addElement(e, t) } addTextNode(e, t) {
    let r = e.nodeValue, i = this.top, a = i.options & uP ? "full" : this.localPreserveWS || (i.options & o_) > 0; if (a === "full" || i.inlineContext(e) || /[^ \t\r\n\u000c]/.test(r)) {
      if (a) a !== "full" ? r = r.replace(/\r?\n|\r/g, " ") : r = r.replace(/\r\n?/g, `
`); else if (r = r.replace(/[ \t\r\n\u000c]+/g, " "), /^[ \t\r\n\u000c]/.test(r) && this.open == this.nodes.length - 1) { let o = i.content[i.content.length - 1], s = e.previousSibling; (!o || s && s.nodeName == "BR" || o.isText && /[ \t\r\n\u000c]$/.test(o.text)) && (r = r.slice(1)) } r && this.insertNode(this.parser.schema.text(r), t, !/\S/.test(r)), this.findInText(e)
    } else this.findInside(e)
  } addElement(e, t, r) { let i = this.localPreserveWS, a = this.top; (e.tagName == "PRE" || /pre/.test(e.style && e.style.whiteSpace)) && (this.localPreserveWS = !0); let o = e.nodeName.toLowerCase(), s; GQ.hasOwnProperty(o) && this.parser.normalizeLists && zRe(e); let l = this.options.ruleFromNode && this.options.ruleFromNode(e) || (s = this.parser.matchTag(e, this, r)); e: if (l ? l.ignore : FRe.hasOwnProperty(o)) this.findInside(e), this.ignoreFallback(e, t); else if (!l || l.skip || l.closeParent) { l && l.closeParent ? this.open = Math.max(0, this.open - 1) : l && l.skip.nodeType && (e = l.skip); let c, u = this.needsBlock; if (UQ.hasOwnProperty(o)) a.content.length && a.content[0].isInline && this.open && (this.open--, a = this.top), c = !0, a.type || (this.needsBlock = !0); else if (!e.firstChild) { this.leafFallback(e, t); break e } let d = l && l.skip ? t : this.readStyles(e, t); d && this.addAll(e, d), c && this.sync(a), this.needsBlock = u } else { let c = this.readStyles(e, t); c && this.addElementByRule(e, l, c, l.consuming === !1 ? s : void 0) } this.localPreserveWS = i } leafFallback(e, t) {
    e.nodeName == "BR" && this.top.type && this.top.type.inlineContent && this.addTextNode(e.ownerDocument.createTextNode(`
`), t)
  } ignoreFallback(e, t) { e.nodeName == "BR" && (!this.top.type || !this.top.type.inlineContent) && this.findPlace(this.parser.schema.text("-"), t, !0) } readStyles(e, t) { let r = e.style; if (r && r.length) for (let i = 0; i < this.parser.matchedStyles.length; i++) { let a = this.parser.matchedStyles[i], o = r.getPropertyValue(a); if (o) for (let s = void 0; ;) { let l = this.parser.matchStyle(a, o, this, s); if (!l) break; if (l.ignore) return null; if (l.clearMark ? t = t.filter(c => !l.clearMark(c)) : t = t.concat(this.parser.schema.marks[l.mark].create(l.attrs)), l.consuming === !1) s = l; else break } } return t } addElementByRule(e, t, r, i) { let a, o; if (t.node) if (o = this.parser.schema.nodes[t.node], o.isLeaf) this.insertNode(o.create(t.attrs), r, e.nodeName == "BR") || this.leafFallback(e, r); else { let l = this.enter(o, t.attrs || null, r, t.preserveWhitespace); l && (a = !0, r = l) } else { let l = this.parser.schema.marks[t.mark]; r = r.concat(l.create(t.attrs)) } let s = this.top; if (o && o.isLeaf) this.findInside(e); else if (i) this.addElement(e, r, i); else if (t.getContent) this.findInside(e), t.getContent(e, this.parser.schema).forEach(l => this.insertNode(l, r, !1)); else { let l = e; typeof t.contentElement == "string" ? l = e.querySelector(t.contentElement) : typeof t.contentElement == "function" ? l = t.contentElement(e) : t.contentElement && (l = t.contentElement), this.findAround(e, l, !0), this.addAll(l, r), this.findAround(e, l, !1) } a && this.sync(s) && this.open-- } addAll(e, t, r, i) { let a = r || 0; for (let o = r ? e.childNodes[r] : e.firstChild, s = i == null ? null : e.childNodes[i]; o != s; o = o.nextSibling, ++a)this.findAtPoint(e, a), this.addDOM(o, t); this.findAtPoint(e, a) } findPlace(e, t, r) { let i, a; for (let o = this.open, s = 0; o >= 0; o--) { let l = this.nodes[o], c = l.findWrapping(e); if (c && (!i || i.length > c.length + s) && (i = c, a = l, !c.length)) break; if (l.solid) { if (r) break; s += 2 } } if (!i) return null; this.sync(a); for (let o = 0; o < i.length; o++)t = this.enterInner(i[o], null, t, !1); return t } insertNode(e, t, r) { if (e.isInline && this.needsBlock && !this.top.type) { let a = this.textblockFromContext(); a && (t = this.enterInner(a, null, t)) } let i = this.findPlace(e, t, r); if (i) { this.closeExtra(); let a = this.top; a.match && (a.match = a.match.matchType(e.type)); let o = ko.none; for (let s of i.concat(e.marks)) (a.type ? a.type.allowsMarkType(s.type) : l6(s.type, e.type)) && (o = s.addToSet(o)); return a.content.push(e.mark(o)), !0 } return !1 } enter(e, t, r, i) { let a = this.findPlace(e.create(t), r, !1); return a && (a = this.enterInner(e, t, r, !0, i)), a } enterInner(e, t, r, i = !1, a) { this.closeExtra(); let o = this.top; o.match = o.match && o.match.matchType(e); let s = a6(e, a, o.options); o.options & a0 && o.content.length == 0 && (s |= a0); let l = ko.none; return r = r.filter(c => (o.type ? o.type.allowsMarkType(c.type) : l6(c.type, e)) ? (l = c.addToSet(l), !1) : !0), this.nodes.push(new yw(e, t, l, i, null, s)), this.open++, r } closeExtra(e = !1) { let t = this.nodes.length - 1; if (t > this.open) { for (; t > this.open; t--)this.nodes[t - 1].content.push(this.nodes[t].finish(e)); this.nodes.length = this.open + 1 } } finish() { return this.open = 0, this.closeExtra(this.isOpen), this.nodes[0].finish(!!(this.isOpen || this.options.topOpen)) } sync(e) { for (let t = this.open; t >= 0; t--) { if (this.nodes[t] == e) return this.open = t, !0; this.localPreserveWS && (this.nodes[t].options |= o_) } return !1 } get currentPos() { this.closeExtra(); let e = 0; for (let t = this.open; t >= 0; t--) { let r = this.nodes[t].content; for (let i = r.length - 1; i >= 0; i--)e += r[i].nodeSize; t && e++ } return e } findAtPoint(e, t) { if (this.find) for (let r = 0; r < this.find.length; r++)this.find[r].node == e && this.find[r].offset == t && (this.find[r].pos = this.currentPos) } findInside(e) { if (this.find) for (let t = 0; t < this.find.length; t++)this.find[t].pos == null && e.nodeType == 1 && e.contains(this.find[t].node) && (this.find[t].pos = this.currentPos) } findAround(e, t, r) { if (e != t && this.find) for (let i = 0; i < this.find.length; i++)this.find[i].pos == null && e.nodeType == 1 && e.contains(this.find[i].node) && t.compareDocumentPosition(this.find[i].node) & (r ? 2 : 4) && (this.find[i].pos = this.currentPos) } findInText(e) { if (this.find) for (let t = 0; t < this.find.length; t++)this.find[t].node == e && (this.find[t].pos = this.currentPos - (e.nodeValue.length - this.find[t].offset)) } matchesContext(e) { if (e.indexOf("|") > -1) return e.split(/\s*\|\s*/).some(this.matchesContext, this); let t = e.split("/"), r = this.options.context, i = !this.isOpen && (!r || r.parent.type == this.nodes[0].type), a = -(r ? r.depth + 1 : 0) + (i ? 0 : 1), o = (s, l) => { for (; s >= 0; s--) { let c = t[s]; if (c == "") { if (s == t.length - 1 || s == 0) continue; for (; l >= a; l--)if (o(s - 1, l)) return !0; return !1 } else { let u = l > 0 || l == 0 && i ? this.nodes[l].type : r && l >= a ? r.node(l - a).type : null; if (!u || u.name != c && !u.isInGroup(c)) return !1; l-- } } return !0 }; return o(t.length - 1, this.open) } textblockFromContext() { let e = this.options.context; if (e) for (let t = e.depth; t >= 0; t--) { let r = e.node(t).contentMatchAt(e.indexAfter(t)).defaultType; if (r && r.isTextblock && r.defaultAttrs) return r } for (let t in this.parser.schema.nodes) { let r = this.parser.schema.nodes[t]; if (r.isTextblock && r.defaultAttrs) return r } }
} function zRe(n) { for (let e = n.firstChild, t = null; e; e = e.nextSibling) { let r = e.nodeType == 1 ? e.nodeName.toLowerCase() : null; r && GQ.hasOwnProperty(r) && t ? (t.appendChild(e), e = t) : r == "li" ? t = e : r && (t = null) } } function VRe(n, e) { return (n.matches || n.msMatchesSelector || n.webkitMatchesSelector || n.mozMatchesSelector).call(n, e) } function s6(n) { let e = {}; for (let t in n) e[t] = n[t]; return e } function l6(n, e) { let t = e.schema.nodes; for (let r in t) { let i = t[r]; if (!i.allowsMarkType(n)) continue; let a = [], o = s => { a.push(s); for (let l = 0; l < s.edgeCount; l++) { let { type: c, next: u } = s.edge(l); if (c == e || a.indexOf(u) < 0 && o(u)) return !0 } }; if (o(i.contentMatch)) return !0 } } var WQ = { exports: {} }; (function (n) {
  (function () {
    function e(v) { var S = { omitExtraWLInCodeBlocks: { defaultValue: !1, describe: "Omit the default extra whiteline added to code blocks", type: "boolean" }, noHeaderId: { defaultValue: !1, describe: "Turn on/off generated header id", type: "boolean" }, prefixHeaderId: { defaultValue: !1, describe: "Add a prefix to the generated header ids. Passing a string will prefix that string to the header id. Setting to true will add a generic 'section-' prefix", type: "string" }, rawPrefixHeaderId: { defaultValue: !1, describe: 'Setting this option to true will prevent showdown from modifying the prefix. This might result in malformed IDs (if, for instance, the " char is used in the prefix)', type: "boolean" }, ghCompatibleHeaderId: { defaultValue: !1, describe: "Generate header ids compatible with github style (spaces are replaced with dashes, a bunch of non alphanumeric chars are removed)", type: "boolean" }, rawHeaderId: { defaultValue: !1, describe: `Remove only spaces, ' and " from generated header ids (including prefixes), replacing them with dashes (-). WARNING: This might result in malformed ids`, type: "boolean" }, headerLevelStart: { defaultValue: !1, describe: "The header blocks level start", type: "integer" }, parseImgDimensions: { defaultValue: !1, describe: "Turn on/off image dimension parsing", type: "boolean" }, simplifiedAutoLink: { defaultValue: !1, describe: "Turn on/off GFM autolink style", type: "boolean" }, excludeTrailingPunctuationFromURLs: { defaultValue: !1, describe: "Excludes trailing punctuation from links generated with autoLinking", type: "boolean" }, literalMidWordUnderscores: { defaultValue: !1, describe: "Parse midword underscores as literal underscores", type: "boolean" }, literalMidWordAsterisks: { defaultValue: !1, describe: "Parse midword asterisks as literal asterisks", type: "boolean" }, strikethrough: { defaultValue: !1, describe: "Turn on/off strikethrough support", type: "boolean" }, tables: { defaultValue: !1, describe: "Turn on/off tables support", type: "boolean" }, tablesHeaderId: { defaultValue: !1, describe: "Add an id to table headers", type: "boolean" }, ghCodeBlocks: { defaultValue: !0, describe: "Turn on/off GFM fenced code blocks support", type: "boolean" }, tasklists: { defaultValue: !1, describe: "Turn on/off GFM tasklist support", type: "boolean" }, smoothLivePreview: { defaultValue: !1, describe: "Prevents weird effects in live previews due to incomplete input", type: "boolean" }, smartIndentationFix: { defaultValue: !1, describe: "Tries to smartly fix indentation in es6 strings", type: "boolean" }, disableForced4SpacesIndentedSublists: { defaultValue: !1, describe: "Disables the requirement of indenting nested sublists by 4 spaces", type: "boolean" }, simpleLineBreaks: { defaultValue: !1, describe: "Parses simple line breaks as <br> (GFM Style)", type: "boolean" }, requireSpaceBeforeHeadingText: { defaultValue: !1, describe: "Makes adding a space between `#` and the header text mandatory (GFM Style)", type: "boolean" }, ghMentions: { defaultValue: !1, describe: "Enables github @mentions", type: "boolean" }, ghMentionsLink: { defaultValue: "https://github.com/{u}", describe: "Changes the link generated by @mentions. Only applies if ghMentions option is enabled.", type: "string" }, encodeEmails: { defaultValue: !0, describe: "Encode e-mail addresses through the use of Character Entities, transforming ASCII e-mail addresses into its equivalent decimal entities", type: "boolean" }, openLinksInNewWindow: { defaultValue: !1, describe: "Open all links in new windows", type: "boolean" }, backslashEscapesHTMLTags: { defaultValue: !1, describe: "Support for HTML Tag escaping. ex: <div>foo</div>", type: "boolean" }, emoji: { defaultValue: !1, describe: "Enable emoji support. Ex: `this is a :smile: emoji`", type: "boolean" }, underline: { defaultValue: !1, describe: "Enable support for underline. Syntax is double or triple underscores: `__underline word__`. With this option enabled, underscores no longer parses into `<em>` and `<strong>`", type: "boolean" }, ellipsis: { defaultValue: !0, describe: "Replaces three dots with the ellipsis unicode character", type: "boolean" }, completeHTMLDocument: { defaultValue: !1, describe: "Outputs a complete html document, including `<html>`, `<head>` and `<body>` tags", type: "boolean" }, metadata: { defaultValue: !1, describe: "Enable support for document metadata (defined at the top of the document between `` and `` or between `---` and `---`).", type: "boolean" }, splitAdjacentBlockquotes: { defaultValue: !1, describe: "Split adjacent blockquote blocks", type: "boolean" } }; if (v === !1) return JSON.parse(JSON.stringify(S)); var x = {}; for (var k in S) S.hasOwnProperty(k) && (x[k] = S[k].defaultValue); return x } function t() { var v = e(!0), S = {}; for (var x in v) v.hasOwnProperty(x) && (S[x] = !0); return S } var r = {}, i = {}, a = {}, o = e(!0), s = "vanilla", l = { github: { omitExtraWLInCodeBlocks: !0, simplifiedAutoLink: !0, excludeTrailingPunctuationFromURLs: !0, literalMidWordUnderscores: !0, strikethrough: !0, tables: !0, tablesHeaderId: !0, ghCodeBlocks: !0, tasklists: !0, disableForced4SpacesIndentedSublists: !0, simpleLineBreaks: !0, requireSpaceBeforeHeadingText: !0, ghCompatibleHeaderId: !0, ghMentions: !0, backslashEscapesHTMLTags: !0, emoji: !0, splitAdjacentBlockquotes: !0 }, original: { noHeaderId: !0, ghCodeBlocks: !1 }, ghost: { omitExtraWLInCodeBlocks: !0, parseImgDimensions: !0, simplifiedAutoLink: !0, excludeTrailingPunctuationFromURLs: !0, literalMidWordUnderscores: !0, strikethrough: !0, tables: !0, tablesHeaderId: !0, ghCodeBlocks: !0, tasklists: !0, smoothLivePreview: !0, simpleLineBreaks: !0, requireSpaceBeforeHeadingText: !0, ghMentions: !1, encodeEmails: !0 }, vanilla: e(!0), allOn: t() }; r.helper = {}, r.extensions = {}, r.setOption = function (v, S) { return o[v] = S, this }, r.getOption = function (v) { return o[v] }, r.getOptions = function () { return o }, r.resetOptions = function () { o = e(!0) }, r.setFlavor = function (v) { if (!l.hasOwnProperty(v)) throw Error(v + " flavor was not found"); r.resetOptions(); var S = l[v]; s = v; for (var x in S) S.hasOwnProperty(x) && (o[x] = S[x]) }, r.getFlavor = function () { return s }, r.getFlavorOptions = function (v) { if (l.hasOwnProperty(v)) return l[v] }, r.getDefaultOptions = function (v) { return e(v) }, r.subParser = function (v, S) { if (r.helper.isString(v)) if (typeof S < "u") i[v] = S; else { if (i.hasOwnProperty(v)) return i[v]; throw Error("SubParser named " + v + " not registered!") } }, r.extension = function (v, S) { if (!r.helper.isString(v)) throw Error("Extension 'name' must be a string"); if (v = r.helper.stdExtName(v), r.helper.isUndefined(S)) { if (!a.hasOwnProperty(v)) throw Error("Extension named " + v + " is not registered!"); return a[v] } else { typeof S == "function" && (S = S()), r.helper.isArray(S) || (S = [S]); var x = c(S, v); if (x.valid) a[v] = S; else throw Error(x.error) } }, r.getAllExtensions = function () { return a }, r.removeExtension = function (v) { delete a[v] }, r.resetExtensions = function () { a = {} }; function c(v, S) { var x = S ? "Error in " + S + " extension->" : "Error in unnamed extension", k = { valid: !0, error: "" }; r.helper.isArray(v) || (v = [v]); for (var A = 0; A < v.length; ++A) { var C = x + " sub-extension " + A + ": ", E = v[A]; if (typeof E != "object") return k.valid = !1, k.error = C + "must be an object, but " + typeof E + " given", k; if (!r.helper.isString(E.type)) return k.valid = !1, k.error = C + 'property "type" must be a string, but ' + typeof E.type + " given", k; var O = E.type = E.type.toLowerCase(); if (O === "language" && (O = E.type = "lang"), O === "html" && (O = E.type = "output"), O !== "lang" && O !== "output" && O !== "listener") return k.valid = !1, k.error = C + "type " + O + ' is not recognized. Valid values: "lang/language", "output/html" or "listener"', k; if (O === "listener") { if (r.helper.isUndefined(E.listeners)) return k.valid = !1, k.error = C + '. Extensions of type "listener" must have a property called "listeners"', k } else if (r.helper.isUndefined(E.filter) && r.helper.isUndefined(E.regex)) return k.valid = !1, k.error = C + O + ' extensions must define either a "regex" property or a "filter" method', k; if (E.listeners) { if (typeof E.listeners != "object") return k.valid = !1, k.error = C + '"listeners" property must be an object but ' + typeof E.listeners + " given", k; for (var j in E.listeners) if (E.listeners.hasOwnProperty(j) && typeof E.listeners[j] != "function") return k.valid = !1, k.error = C + '"listeners" property must be an hash of [event name]: [callback]. listeners.' + j + " must be a function but " + typeof E.listeners[j] + " given", k } if (E.filter) { if (typeof E.filter != "function") return k.valid = !1, k.error = C + '"filter" must be a function, but ' + typeof E.filter + " given", k } else if (E.regex) { if (r.helper.isString(E.regex) && (E.regex = new RegExp(E.regex, "g")), !(E.regex instanceof RegExp)) return k.valid = !1, k.error = C + '"regex" property must either be a string or a RegExp object, but ' + typeof E.regex + " given", k; if (r.helper.isUndefined(E.replace)) return k.valid = !1, k.error = C + '"regex" extensions must implement a replace string or function', k } } return k } r.validateExtension = function (v) { var S = c(v, null); return S.valid ? !0 : (console.warn(S.error), !1) }, r.hasOwnProperty("helper") || (r.helper = {}), r.helper.isString = function (v) { return typeof v == "string" || v instanceof String }, r.helper.isFunction = function (v) { var S = {}; return v && S.toString.call(v) === "[object Function]" }, r.helper.isArray = function (v) { return Array.isArray(v) }, r.helper.isUndefined = function (v) { return typeof v > "u" }, r.helper.forEach = function (v, S) { if (r.helper.isUndefined(v)) throw new Error("obj param is required"); if (r.helper.isUndefined(S)) throw new Error("callback param is required"); if (!r.helper.isFunction(S)) throw new Error("callback param must be a function/closure"); if (typeof v.forEach == "function") v.forEach(S); else if (r.helper.isArray(v)) for (var x = 0; x < v.length; x++)S(v[x], x, v); else if (typeof v == "object") for (var k in v) v.hasOwnProperty(k) && S(v[k], k, v); else throw new Error("obj does not seem to be an array or an iterable object") }, r.helper.stdExtName = function (v) { return v.replace(/[_?*+\/\\.^-]/g, "").replace(/\s/g, "").toLowerCase() }; function u(v, S) { var x = S.charCodeAt(0); return "E" + x + "E" } r.helper.escapeCharactersCallback = u, r.helper.escapeCharacters = function (v, S, x) { var k = "([" + S.replace(/([\[\]\\])/g, "\\$1") + "])"; x && (k = "\\\\" + k); var A = new RegExp(k, "g"); return v = v.replace(A, u), v }, r.helper.unescapeHTMLEntities = function (v) { return v.replace(/&quot;/g, '"').replace(/&lt;/g, "<").replace(/&gt;/g, ">").replace(/&amp;/g, "&") }; var d = function (v, S, x, k) { var A = k || "", C = A.indexOf("g") > -1, E = new RegExp(S + "|" + x, "g" + A.replace(/g/g, "")), O = new RegExp(S, A.replace(/g/g, "")), j = [], I, L, R, D, P; do for (I = 0; R = E.exec(v);)if (O.test(R[0])) I++ || (L = E.lastIndex, D = L - R[0].length); else if (I && !--I) { P = R.index + R[0].length; var B = { left: { start: D, end: L }, match: { start: L, end: R.index }, right: { start: R.index, end: P }, wholeMatch: { start: D, end: P } }; if (j.push(B), !C) return j } while (I && (E.lastIndex = L)); return j }; r.helper.matchRecursiveRegExp = function (v, S, x, k) { for (var A = d(v, S, x, k), C = [], E = 0; E < A.length; ++E)C.push([v.slice(A[E].wholeMatch.start, A[E].wholeMatch.end), v.slice(A[E].match.start, A[E].match.end), v.slice(A[E].left.start, A[E].left.end), v.slice(A[E].right.start, A[E].right.end)]); return C }, r.helper.replaceRecursiveRegExp = function (v, S, x, k, A) { if (!r.helper.isFunction(S)) { var C = S; S = function () { return C } } var E = d(v, x, k, A), O = v, j = E.length; if (j > 0) { var I = []; E[0].wholeMatch.start !== 0 && I.push(v.slice(0, E[0].wholeMatch.start)); for (var L = 0; L < j; ++L)I.push(S(v.slice(E[L].wholeMatch.start, E[L].wholeMatch.end), v.slice(E[L].match.start, E[L].match.end), v.slice(E[L].left.start, E[L].left.end), v.slice(E[L].right.start, E[L].right.end))), L < j - 1 && I.push(v.slice(E[L].wholeMatch.end, E[L + 1].wholeMatch.start)); E[j - 1].wholeMatch.end < v.length && I.push(v.slice(E[j - 1].wholeMatch.end)), O = I.join("") } return O }, r.helper.regexIndexOf = function (v, S, x) { if (!r.helper.isString(v)) throw "InvalidArgumentError: first parameter of showdown.helper.regexIndexOf function must be a string"; if (!(S instanceof RegExp)) throw "InvalidArgumentError: second parameter of showdown.helper.regexIndexOf function must be an instance of RegExp"; var k = v.substring(x || 0).search(S); return k >= 0 ? k + (x || 0) : k }, r.helper.splitAtIndex = function (v, S) { if (!r.helper.isString(v)) throw "InvalidArgumentError: first parameter of showdown.helper.regexIndexOf function must be a string"; return [v.substring(0, S), v.substring(S)] }, r.helper.encodeEmailAddress = function (v) { var S = [function (x) { return "&#" + x.charCodeAt(0) + ";" }, function (x) { return "&#x" + x.charCodeAt(0).toString(16) + ";" }, function (x) { return x }]; return v = v.replace(/./g, function (x) { if (x === "@") x = S[Math.floor(Math.random() * 2)](x); else { var k = Math.random(); x = k > .9 ? S[2](x) : k > .45 ? S[1](x) : S[0](x) } return x }), v }, r.helper.padEnd = function (S, x, k) { return x = x >> 0, k = String(k || " "), S.length > x ? String(S) : (x = x - S.length, x > k.length && (k += k.repeat(x / k.length)), String(S) + k.slice(0, x)) }, typeof console > "u" && (console = { warn: function (v) { alert(v) }, log: function (v) { alert(v) }, error: function (v) { throw v } }), r.helper.regexes = { asteriskDashAndColon: /([*_:~])/g }, r.helper.emojis = { "+1": "", "-1": "", 100: "", 1234: "", "1st_place_medal": "", "2nd_place_medal": "", "3rd_place_medal": "", "8ball": "", a: "", ab: "", abc: "", abcd: "", accept: "", aerial_tramway: "", airplane: "", alarm_clock: "", alembic: "", alien: "", ambulance: "", amphora: "", anchor: "", angel: "", anger: "", angry: "", anguished: "", ant: "", apple: "", aquarius: "", aries: "", arrow_backward: "", arrow_double_down: "", arrow_double_up: "", arrow_down: "", arrow_down_small: "", arrow_forward: "", arrow_heading_down: "", arrow_heading_up: "", arrow_left: "", arrow_lower_left: "", arrow_lower_right: "", arrow_right: "", arrow_right_hook: "", arrow_up: "", arrow_up_down: "", arrow_up_small: "", arrow_upper_left: "", arrow_upper_right: "", arrows_clockwise: "", arrows_counterclockwise: "", art: "", articulated_lorry: "", artificial_satellite: "", astonished: "", athletic_shoe: "", atm: "", atom_symbol: "", avocado: "", b: "", baby: "", baby_bottle: "", baby_chick: "", baby_symbol: "", back: "", bacon: "", badminton: "", baggage_claim: "", baguette_bread: "", balance_scale: "", balloon: "", ballot_box: "", ballot_box_with_check: "", bamboo: "", banana: "", bangbang: "", bank: "", bar_chart: "", barber: "", baseball: "", basketball: "", basketball_man: "", basketball_woman: "&zwj;", bat: "", bath: "", bathtub: "", battery: "", beach_umbrella: "", bear: "", bed: "", bee: "", beer: "", beers: "", beetle: "", beginner: "", bell: "", bellhop_bell: "", bento: "", biking_man: "", bike: "", biking_woman: "&zwj;", bikini: "", biohazard: "", bird: "", birthday: "", black_circle: "", black_flag: "", black_heart: "", black_joker: "", black_large_square: "", black_medium_small_square: "", black_medium_square: "", black_nib: "", black_small_square: "", black_square_button: "", blonde_man: "", blonde_woman: "&zwj;", blossom: "", blowfish: "", blue_book: "", blue_car: "", blue_heart: "", blush: "", boar: "", boat: "", bomb: "", book: "", bookmark: "", bookmark_tabs: "", books: "", boom: "", boot: "", bouquet: "", bowing_man: "", bow_and_arrow: "", bowing_woman: "&zwj;", bowling: "", boxing_glove: "", boy: "", bread: "", bride_with_veil: "", bridge_at_night: "", briefcase: "", broken_heart: "", bug: "", building_construction: "", bulb: "", bullettrain_front: "", bullettrain_side: "", burrito: "", bus: "", business_suit_levitating: "", busstop: "", bust_in_silhouette: "", busts_in_silhouette: "", butterfly: "", cactus: "", cake: "", calendar: "", call_me_hand: "", calling: "", camel: "", camera: "", camera_flash: "", camping: "", cancer: "", candle: "", candy: "", canoe: "", capital_abcd: "", capricorn: "", car: "", card_file_box: "", card_index: "", card_index_dividers: "", carousel_horse: "", carrot: "", cat: "", cat2: "", cd: "", chains: "", champagne: "", chart: "", chart_with_downwards_trend: "", chart_with_upwards_trend: "", checkered_flag: "", cheese: "", cherries: "", cherry_blossom: "", chestnut: "", chicken: "", children_crossing: "", chipmunk: "", chocolate_bar: "", christmas_tree: "", church: "", cinema: "", circus_tent: "", city_sunrise: "", city_sunset: "", cityscape: "", cl: "", clamp: "", clap: "", clapper: "", classical_building: "", clinking_glasses: "", clipboard: "", clock1: "", clock10: "", clock1030: "", clock11: "", clock1130: "", clock12: "", clock1230: "", clock130: "", clock2: "", clock230: "", clock3: "", clock330: "", clock4: "", clock430: "", clock5: "", clock530: "", clock6: "", clock630: "", clock7: "", clock730: "", clock8: "", clock830: "", clock9: "", clock930: "", closed_book: "", closed_lock_with_key: "", closed_umbrella: "", cloud: "", cloud_with_lightning: "", cloud_with_lightning_and_rain: "", cloud_with_rain: "", cloud_with_snow: "", clown_face: "", clubs: "", cocktail: "", coffee: "", coffin: "", cold_sweat: "", comet: "", computer: "", computer_mouse: "", confetti_ball: "", confounded: "", confused: "", congratulations: "", construction: "", construction_worker_man: "", construction_worker_woman: "&zwj;", control_knobs: "", convenience_store: "", cookie: "", cool: "", policeman: "", copyright: "", corn: "", couch_and_lamp: "", couple: "", couple_with_heart_woman_man: "", couple_with_heart_man_man: "&zwj;&zwj;", couple_with_heart_woman_woman: "&zwj;&zwj;", couplekiss_man_man: "&zwj;&zwj;&zwj;", couplekiss_man_woman: "", couplekiss_woman_woman: "&zwj;&zwj;&zwj;", cow: "", cow2: "", cowboy_hat_face: "", crab: "", crayon: "", credit_card: "", crescent_moon: "", cricket: "", crocodile: "", croissant: "", crossed_fingers: "", crossed_flags: "", crossed_swords: "", crown: "", cry: "", crying_cat_face: "", crystal_ball: "", cucumber: "", cupid: "", curly_loop: "", currency_exchange: "", curry: "", custard: "", customs: "", cyclone: "", dagger: "", dancer: "", dancing_women: "", dancing_men: "&zwj;", dango: "", dark_sunglasses: "", dart: "", dash: "", date: "", deciduous_tree: "", deer: "", department_store: "", derelict_house: "", desert: "", desert_island: "", desktop_computer: "", male_detective: "", diamond_shape_with_a_dot_inside: "", diamonds: "", disappointed: "", disappointed_relieved: "", dizzy: "", dizzy_face: "", do_not_litter: "", dog: "", dog2: "", dollar: "", dolls: "", dolphin: "", door: "", doughnut: "", dove: "", dragon: "", dragon_face: "", dress: "", dromedary_camel: "", drooling_face: "", droplet: "", drum: "", duck: "", dvd: "", "e-mail": "", eagle: "", ear: "", ear_of_rice: "", earth_africa: "", earth_americas: "", earth_asia: "", egg: "", eggplant: "", eight_pointed_black_star: "", eight_spoked_asterisk: "", electric_plug: "", elephant: "", email: "", end: "", envelope_with_arrow: "", euro: "", european_castle: "", european_post_office: "", evergreen_tree: "", exclamation: "", expressionless: "", eye: "", eye_speech_bubble: "&zwj;", eyeglasses: "", eyes: "", face_with_head_bandage: "", face_with_thermometer: "", fist_oncoming: "", factory: "", fallen_leaf: "", family_man_woman_boy: "", family_man_boy: "&zwj;", family_man_boy_boy: "&zwj;&zwj;", family_man_girl: "&zwj;", family_man_girl_boy: "&zwj;&zwj;", family_man_girl_girl: "&zwj;&zwj;", family_man_man_boy: "&zwj;&zwj;", family_man_man_boy_boy: "&zwj;&zwj;&zwj;", family_man_man_girl: "&zwj;&zwj;", family_man_man_girl_boy: "&zwj;&zwj;&zwj;", family_man_man_girl_girl: "&zwj;&zwj;&zwj;", family_man_woman_boy_boy: "&zwj;&zwj;&zwj;", family_man_woman_girl: "&zwj;&zwj;", family_man_woman_girl_boy: "&zwj;&zwj;&zwj;", family_man_woman_girl_girl: "&zwj;&zwj;&zwj;", family_woman_boy: "&zwj;", family_woman_boy_boy: "&zwj;&zwj;", family_woman_girl: "&zwj;", family_woman_girl_boy: "&zwj;&zwj;", family_woman_girl_girl: "&zwj;&zwj;", family_woman_woman_boy: "&zwj;&zwj;", family_woman_woman_boy_boy: "&zwj;&zwj;&zwj;", family_woman_woman_girl: "&zwj;&zwj;", family_woman_woman_girl_boy: "&zwj;&zwj;&zwj;", family_woman_woman_girl_girl: "&zwj;&zwj;&zwj;", fast_forward: "", fax: "", fearful: "", feet: "", female_detective: "&zwj;", ferris_wheel: "", ferry: "", field_hockey: "", file_cabinet: "", file_folder: "", film_projector: "", film_strip: "", fire: "", fire_engine: "", fireworks: "", first_quarter_moon: "", first_quarter_moon_with_face: "", fish: "", fish_cake: "", fishing_pole_and_fish: "", fist_raised: "", fist_left: "", fist_right: "", flags: "", flashlight: "", fleur_de_lis: "", flight_arrival: "", flight_departure: "", floppy_disk: "", flower_playing_cards: "", flushed: "", fog: "", foggy: "", football: "", footprints: "", fork_and_knife: "", fountain: "", fountain_pen: "", four_leaf_clover: "", fox_face: "", framed_picture: "", free: "", fried_egg: "", fried_shrimp: "", fries: "", frog: "", frowning: "", frowning_face: "", frowning_man: "&zwj;", frowning_woman: "", middle_finger: "", fuelpump: "", full_moon: "", full_moon_with_face: "", funeral_urn: "", game_die: "", gear: "", gem: "", gemini: "", ghost: "", gift: "", gift_heart: "", girl: "", globe_with_meridians: "", goal_net: "", goat: "", golf: "", golfing_man: "", golfing_woman: "&zwj;", gorilla: "", grapes: "", green_apple: "", green_book: "", green_heart: "", green_salad: "", grey_exclamation: "", grey_question: "", grimacing: "", grin: "", grinning: "", guardsman: "", guardswoman: "&zwj;", guitar: "", gun: "", haircut_woman: "", haircut_man: "&zwj;", hamburger: "", hammer: "", hammer_and_pick: "", hammer_and_wrench: "", hamster: "", hand: "", handbag: "", handshake: "", hankey: "", hatched_chick: "", hatching_chick: "", headphones: "", hear_no_evil: "", heart: "", heart_decoration: "", heart_eyes: "", heart_eyes_cat: "", heartbeat: "", heartpulse: "", hearts: "", heavy_check_mark: "", heavy_division_sign: "", heavy_dollar_sign: "", heavy_heart_exclamation: "", heavy_minus_sign: "", heavy_multiplication_x: "", heavy_plus_sign: "", helicopter: "", herb: "", hibiscus: "", high_brightness: "", high_heel: "", hocho: "", hole: "", honey_pot: "", horse: "", horse_racing: "", hospital: "", hot_pepper: "", hotdog: "", hotel: "", hotsprings: "", hourglass: "", hourglass_flowing_sand: "", house: "", house_with_garden: "", houses: "", hugs: "", hushed: "", ice_cream: "", ice_hockey: "", ice_skate: "", icecream: "", id: "", ideograph_advantage: "", imp: "", inbox_tray: "", incoming_envelope: "", tipping_hand_woman: "", information_source: "", innocent: "", interrobang: "", iphone: "", izakaya_lantern: "", jack_o_lantern: "", japan: "", japanese_castle: "", japanese_goblin: "", japanese_ogre: "", jeans: "", joy: "", joy_cat: "", joystick: "", kaaba: "", key: "", keyboard: "", keycap_ten: "", kick_scooter: "", kimono: "", kiss: "", kissing: "", kissing_cat: "", kissing_closed_eyes: "", kissing_heart: "", kissing_smiling_eyes: "", kiwi_fruit: "", koala: "", koko: "", label: "", large_blue_circle: "", large_blue_diamond: "", large_orange_diamond: "", last_quarter_moon: "", last_quarter_moon_with_face: "", latin_cross: "", laughing: "", leaves: "", ledger: "", left_luggage: "", left_right_arrow: "", leftwards_arrow_with_hook: "", lemon: "", leo: "", leopard: "", level_slider: "", libra: "", light_rail: "", link: "", lion: "", lips: "", lipstick: "", lizard: "", lock: "", lock_with_ink_pen: "", lollipop: "", loop: "", loud_sound: "", loudspeaker: "", love_hotel: "", love_letter: "", low_brightness: "", lying_face: "", m: "", mag: "", mag_right: "", mahjong: "", mailbox: "", mailbox_closed: "", mailbox_with_mail: "", mailbox_with_no_mail: "", man: "", man_artist: "&zwj;", man_astronaut: "&zwj;", man_cartwheeling: "&zwj;", man_cook: "&zwj;", man_dancing: "", man_facepalming: "&zwj;", man_factory_worker: "&zwj;", man_farmer: "&zwj;", man_firefighter: "&zwj;", man_health_worker: "&zwj;", man_in_tuxedo: "", man_judge: "&zwj;", man_juggling: "&zwj;", man_mechanic: "&zwj;", man_office_worker: "&zwj;", man_pilot: "&zwj;", man_playing_handball: "&zwj;", man_playing_water_polo: "&zwj;", man_scientist: "&zwj;", man_shrugging: "&zwj;", man_singer: "&zwj;", man_student: "&zwj;", man_teacher: "&zwj;", man_technologist: "&zwj;", man_with_gua_pi_mao: "", man_with_turban: "", tangerine: "", mans_shoe: "", mantelpiece_clock: "", maple_leaf: "", martial_arts_uniform: "", mask: "", massage_woman: "", massage_man: "&zwj;", meat_on_bone: "", medal_military: "", medal_sports: "", mega: "", melon: "", memo: "", men_wrestling: "&zwj;", menorah: "", mens: "", metal: "", metro: "", microphone: "", microscope: "", milk_glass: "", milky_way: "", minibus: "", minidisc: "", mobile_phone_off: "", money_mouth_face: "", money_with_wings: "", moneybag: "", monkey: "", monkey_face: "", monorail: "", moon: "", mortar_board: "", mosque: "", motor_boat: "", motor_scooter: "", motorcycle: "", motorway: "", mount_fuji: "", mountain: "", mountain_biking_man: "", mountain_biking_woman: "&zwj;", mountain_cableway: "", mountain_railway: "", mountain_snow: "", mouse: "", mouse2: "", movie_camera: "", moyai: "", mrs_claus: "", muscle: "", mushroom: "", musical_keyboard: "", musical_note: "", musical_score: "", mute: "", nail_care: "", name_badge: "", national_park: "", nauseated_face: "", necktie: "", negative_squared_cross_mark: "", nerd_face: "", neutral_face: "", new: "", new_moon: "", new_moon_with_face: "", newspaper: "", newspaper_roll: "", next_track_button: "", ng: "", no_good_man: "&zwj;", no_good_woman: "", night_with_stars: "", no_bell: "", no_bicycles: "", no_entry: "", no_entry_sign: "", no_mobile_phones: "", no_mouth: "", no_pedestrians: "", no_smoking: "", "non-potable_water": "", nose: "", notebook: "", notebook_with_decorative_cover: "", notes: "", nut_and_bolt: "", o: "", o2: "", ocean: "", octopus: "", oden: "", office: "", oil_drum: "", ok: "", ok_hand: "", ok_man: "&zwj;", ok_woman: "", old_key: "", older_man: "", older_woman: "", om: "", on: "", oncoming_automobile: "", oncoming_bus: "", oncoming_police_car: "", oncoming_taxi: "", open_file_folder: "", open_hands: "", open_mouth: "", open_umbrella: "", ophiuchus: "", orange_book: "", orthodox_cross: "", outbox_tray: "", owl: "", ox: "", package: "", page_facing_up: "", page_with_curl: "", pager: "", paintbrush: "", palm_tree: "", pancakes: "", panda_face: "", paperclip: "", paperclips: "", parasol_on_ground: "", parking: "", part_alternation_mark: "", partly_sunny: "", passenger_ship: "", passport_control: "", pause_button: "", peace_symbol: "", peach: "", peanuts: "", pear: "", pen: "", pencil2: "", penguin: "", pensive: "", performing_arts: "", persevere: "", person_fencing: "", pouting_woman: "", phone: "", pick: "", pig: "", pig2: "", pig_nose: "", pill: "", pineapple: "", ping_pong: "", pisces: "", pizza: "", place_of_worship: "", plate_with_cutlery: "", play_or_pause_button: "", point_down: "", point_left: "", point_right: "", point_up: "", point_up_2: "", police_car: "", policewoman: "&zwj;", poodle: "", popcorn: "", post_office: "", postal_horn: "", postbox: "", potable_water: "", potato: "", pouch: "", poultry_leg: "", pound: "", rage: "", pouting_cat: "", pouting_man: "&zwj;", pray: "", prayer_beads: "", pregnant_woman: "", previous_track_button: "", prince: "", princess: "", printer: "", purple_heart: "", purse: "", pushpin: "", put_litter_in_its_place: "", question: "", rabbit: "", rabbit2: "", racehorse: "", racing_car: "", radio: "", radio_button: "", radioactive: "", railway_car: "", railway_track: "", rainbow: "", rainbow_flag: "&zwj;", raised_back_of_hand: "", raised_hand_with_fingers_splayed: "", raised_hands: "", raising_hand_woman: "", raising_hand_man: "&zwj;", ram: "", ramen: "", rat: "", record_button: "", recycle: "", red_circle: "", registered: "", relaxed: "", relieved: "", reminder_ribbon: "", repeat: "", repeat_one: "", rescue_worker_helmet: "", restroom: "", revolving_hearts: "", rewind: "", rhinoceros: "", ribbon: "", rice: "", rice_ball: "", rice_cracker: "", rice_scene: "", right_anger_bubble: "", ring: "", robot: "", rocket: "", rofl: "", roll_eyes: "", roller_coaster: "", rooster: "", rose: "", rosette: "", rotating_light: "", round_pushpin: "", rowing_man: "", rowing_woman: "&zwj;", rugby_football: "", running_man: "", running_shirt_with_sash: "", running_woman: "&zwj;", sa: "", sagittarius: "", sake: "", sandal: "", santa: "", satellite: "", saxophone: "", school: "", school_satchel: "", scissors: "", scorpion: "", scorpius: "", scream: "", scream_cat: "", scroll: "", seat: "", secret: "", see_no_evil: "", seedling: "", selfie: "", shallow_pan_of_food: "", shamrock: "", shark: "", shaved_ice: "", sheep: "", shell: "", shield: "", shinto_shrine: "", ship: "", shirt: "", shopping: "", shopping_cart: "", shower: "", shrimp: "", signal_strength: "", six_pointed_star: "", ski: "", skier: "", skull: "", skull_and_crossbones: "", sleeping: "", sleeping_bed: "", sleepy: "", slightly_frowning_face: "", slightly_smiling_face: "", slot_machine: "", small_airplane: "", small_blue_diamond: "", small_orange_diamond: "", small_red_triangle: "", small_red_triangle_down: "", smile: "", smile_cat: "", smiley: "", smiley_cat: "", smiling_imp: "", smirk: "", smirk_cat: "", smoking: "", snail: "", snake: "", sneezing_face: "", snowboarder: "", snowflake: "", snowman: "", snowman_with_snow: "", sob: "", soccer: "", soon: "", sos: "", sound: "", space_invader: "", spades: "", spaghetti: "", sparkle: "", sparkler: "", sparkles: "", sparkling_heart: "", speak_no_evil: "", speaker: "", speaking_head: "", speech_balloon: "", speedboat: "", spider: "", spider_web: "", spiral_calendar: "", spiral_notepad: "", spoon: "", squid: "", stadium: "", star: "", star2: "", star_and_crescent: "", star_of_david: "", stars: "", station: "", statue_of_liberty: "", steam_locomotive: "", stew: "", stop_button: "", stop_sign: "", stopwatch: "", straight_ruler: "", strawberry: "", stuck_out_tongue: "", stuck_out_tongue_closed_eyes: "", stuck_out_tongue_winking_eye: "", studio_microphone: "", stuffed_flatbread: "", sun_behind_large_cloud: "", sun_behind_rain_cloud: "", sun_behind_small_cloud: "", sun_with_face: "", sunflower: "", sunglasses: "", sunny: "", sunrise: "", sunrise_over_mountains: "", surfing_man: "", surfing_woman: "&zwj;", sushi: "", suspension_railway: "", sweat: "", sweat_drops: "", sweat_smile: "", sweet_potato: "", swimming_man: "", swimming_woman: "&zwj;", symbols: "", synagogue: "", syringe: "", taco: "", tada: "", tanabata_tree: "", taurus: "", taxi: "", tea: "", telephone_receiver: "", telescope: "", tennis: "", tent: "", thermometer: "", thinking: "", thought_balloon: "", ticket: "", tickets: "", tiger: "", tiger2: "", timer_clock: "", tipping_hand_man: "&zwj;", tired_face: "", tm: "", toilet: "", tokyo_tower: "", tomato: "", tongue: "", top: "", tophat: "", tornado: "", trackball: "", tractor: "", traffic_light: "", train: "", train2: "", tram: "", triangular_flag_on_post: "", triangular_ruler: "", trident: "", triumph: "", trolleybus: "", trophy: "", tropical_drink: "", tropical_fish: "", truck: "", trumpet: "", tulip: "", tumbler_glass: "", turkey: "", turtle: "", tv: "", twisted_rightwards_arrows: "", two_hearts: "", two_men_holding_hands: "", two_women_holding_hands: "", u5272: "", u5408: "", u55b6: "", u6307: "", u6708: "", u6709: "", u6e80: "", u7121: "", u7533: "", u7981: "", u7a7a: "", umbrella: "", unamused: "", underage: "", unicorn: "", unlock: "", up: "", upside_down_face: "", v: "", vertical_traffic_light: "", vhs: "", vibration_mode: "", video_camera: "", video_game: "", violin: "", virgo: "", volcano: "", volleyball: "", vs: "", vulcan_salute: "", walking_man: "", walking_woman: "&zwj;", waning_crescent_moon: "", waning_gibbous_moon: "", warning: "", wastebasket: "", watch: "", water_buffalo: "", watermelon: "", wave: "", wavy_dash: "", waxing_crescent_moon: "", wc: "", weary: "", wedding: "", weight_lifting_man: "", weight_lifting_woman: "&zwj;", whale: "", whale2: "", wheel_of_dharma: "", wheelchair: "", white_check_mark: "", white_circle: "", white_flag: "", white_flower: "", white_large_square: "", white_medium_small_square: "", white_medium_square: "", white_small_square: "", white_square_button: "", wilted_flower: "", wind_chime: "", wind_face: "", wine_glass: "", wink: "", wolf: "", woman: "", woman_artist: "&zwj;", woman_astronaut: "&zwj;", woman_cartwheeling: "&zwj;", woman_cook: "&zwj;", woman_facepalming: "&zwj;", woman_factory_worker: "&zwj;", woman_farmer: "&zwj;", woman_firefighter: "&zwj;", woman_health_worker: "&zwj;", woman_judge: "&zwj;", woman_juggling: "&zwj;", woman_mechanic: "&zwj;", woman_office_worker: "&zwj;", woman_pilot: "&zwj;", woman_playing_handball: "&zwj;", woman_playing_water_polo: "&zwj;", woman_scientist: "&zwj;", woman_shrugging: "&zwj;", woman_singer: "&zwj;", woman_student: "&zwj;", woman_teacher: "&zwj;", woman_technologist: "&zwj;", woman_with_turban: "&zwj;", womans_clothes: "", womans_hat: "", women_wrestling: "&zwj;", womens: "", world_map: "", worried: "", wrench: "", writing_hand: "", x: "", yellow_heart: "", yen: "", yin_yang: "", yum: "", zap: "", zipper_mouth_face: "", zzz: "", octocat: '<img alt=":octocat:" height="20" width="20" align="absmiddle" src="https://assets-cdn.github.com/images/icons/emoji/octocat.png">', showdown: `<span style="font-family: 'Anonymous Pro', monospace; text-decoration: underline; text-decoration-style: dashed; text-decoration-color: #3e8b8a;text-underline-position: under;">S</span>` }, r.Converter = function (v) {
      var S = {}, x = [], k = [], A = {}, C = s, E = { parsed: {}, raw: "", format: "" }; O(); function O() { v = v || {}; for (var D in o) o.hasOwnProperty(D) && (S[D] = o[D]); if (typeof v == "object") for (var P in v) v.hasOwnProperty(P) && (S[P] = v[P]); else throw Error("Converter expects the passed parameter to be an object, but " + typeof v + " was passed instead."); S.extensions && r.helper.forEach(S.extensions, j) } function j(D, P) { if (P = P || null, r.helper.isString(D)) if (D = r.helper.stdExtName(D), P = D, r.extensions[D]) { console.warn("DEPRECATION WARNING: " + D + " is an old extension that uses a deprecated loading method.Please inform the developer that the extension should be updated!"), I(r.extensions[D], D); return } else if (!r.helper.isUndefined(a[D])) D = a[D]; else throw Error('Extension "' + D + '" could not be loaded. It was either not found or is not a valid extension.'); typeof D == "function" && (D = D()), r.helper.isArray(D) || (D = [D]); var B = c(D, P); if (!B.valid) throw Error(B.error); for (var F = 0; F < D.length; ++F) { switch (D[F].type) { case "lang": x.push(D[F]); break; case "output": k.push(D[F]); break }if (D[F].hasOwnProperty("listeners")) for (var K in D[F].listeners) D[F].listeners.hasOwnProperty(K) && L(K, D[F].listeners[K]) } } function I(D, P) { typeof D == "function" && (D = D(new r.Converter)), r.helper.isArray(D) || (D = [D]); var B = c(D, P); if (!B.valid) throw Error(B.error); for (var F = 0; F < D.length; ++F)switch (D[F].type) { case "lang": x.push(D[F]); break; case "output": k.push(D[F]); break; default: throw Error("Extension loader error: Type unrecognized!!!") } } function L(D, P) { if (!r.helper.isString(D)) throw Error("Invalid argument in converter.listen() method: name must be a string, but " + typeof D + " given"); if (typeof P != "function") throw Error("Invalid argument in converter.listen() method: callback must be a function, but " + typeof P + " given"); A.hasOwnProperty(D) || (A[D] = []), A[D].push(P) } function R(D) { var P = D.match(/^\s*/)[0].length, B = new RegExp("^\\s{0," + P + "}", "gm"); return D.replace(B, "") } this._dispatch = function (P, B, F, K) { if (A.hasOwnProperty(P)) for (var V = 0; V < A[P].length; ++V) { var W = A[P][V](P, B, this, F, K); W && typeof W < "u" && (B = W) } return B }, this.listen = function (D, P) { return L(D, P), this }, this.makeHtml = function (D) {
        if (!D) return D; var P = { gHtmlBlocks: [], gHtmlMdBlocks: [], gHtmlSpans: [], gUrls: {}, gTitles: {}, gDimensions: {}, gListLevel: 0, hashLinkCounts: {}, langExtensions: x, outputModifiers: k, converter: this, ghCodeBlocks: [], metadata: { parsed: {}, raw: "", format: "" } }; return D = D.replace(//g, "T"), D = D.replace(/\$/g, "D"), D = D.replace(/\r\n/g, `
`), D = D.replace(/\r/g, `
`), D = D.replace(/\u00A0/g, "&nbsp;"), S.smartIndentationFix && (D = R(D)), D = `

`+ D + `

`, D = r.subParser("detab")(D, S, P), D = D.replace(/^[ \t]+$/mg, ""), r.helper.forEach(x, function (B) { D = r.subParser("runExtension")(B, D, S, P) }), D = r.subParser("metadata")(D, S, P), D = r.subParser("hashPreCodeTags")(D, S, P), D = r.subParser("githubCodeBlocks")(D, S, P), D = r.subParser("hashHTMLBlocks")(D, S, P), D = r.subParser("hashCodeTags")(D, S, P), D = r.subParser("stripLinkDefinitions")(D, S, P), D = r.subParser("blockGamut")(D, S, P), D = r.subParser("unhashHTMLSpans")(D, S, P), D = r.subParser("unescapeSpecialChars")(D, S, P), D = D.replace(/D/g, "$$"), D = D.replace(/T/g, ""), D = r.subParser("completeHTMLDocument")(D, S, P), r.helper.forEach(k, function (B) { D = r.subParser("runExtension")(B, D, S, P) }), E = P.metadata, D
      }, this.makeMarkdown = this.makeMd = function (D, P) {
        if (D = D.replace(/\r\n/g, `
`), D = D.replace(/\r/g, `
`), D = D.replace(/>[ \t]+</, ">NBSP;<"), !P) if (window && window.document) P = window.document; else throw new Error("HTMLParser is undefined. If in a webworker or nodejs environment, you need to provide a WHATWG DOM and HTML such as JSDOM"); var B = P.createElement("div"); B.innerHTML = D; var F = { preList: ie(B) }; J(B); for (var K = B.childNodes, V = "", W = 0; W < K.length; W++)V += r.subParser("makeMarkdown.node")(K[W], F); function J(le) {
          for (var De = 0; De < le.childNodes.length; ++De) {
            var ae = le.childNodes[De]; ae.nodeType === 3 ? !/\S/.test(ae.nodeValue) && !/^[ ]+$/.test(ae.nodeValue) ? (le.removeChild(ae), --De) : (ae.nodeValue = ae.nodeValue.split(`
`).join(" "), ae.nodeValue = ae.nodeValue.replace(/(\s)+/g, "$1")) : ae.nodeType === 1 && J(ae)
          }
        } function ie(le) { for (var De = le.querySelectorAll("pre"), ae = [], pe = 0; pe < De.length; ++pe)if (De[pe].childElementCount === 1 && De[pe].firstChild.tagName.toLowerCase() === "code") { var se = De[pe].firstChild.innerHTML.trim(), ge = De[pe].firstChild.getAttribute("data-language") || ""; if (ge === "") for (var _e = De[pe].firstChild.className.split(" "), je = 0; je < _e.length; ++je) { var U = _e[je].match(/^language-(.+)$/); if (U !== null) { ge = U[1]; break } } se = r.helper.unescapeHTMLEntities(se), ae.push(se), De[pe].outerHTML = '<precode language="' + ge + '" precodenum="' + pe.toString() + '"></precode>' } else ae.push(De[pe].innerHTML), De[pe].innerHTML = "", De[pe].setAttribute("prenum", pe.toString()); return ae } return V
      }, this.setOption = function (D, P) { S[D] = P }, this.getOption = function (D) { return S[D] }, this.getOptions = function () { return S }, this.addExtension = function (D, P) { P = P || null, j(D, P) }, this.useExtension = function (D) { j(D) }, this.setFlavor = function (D) { if (!l.hasOwnProperty(D)) throw Error(D + " flavor was not found"); var P = l[D]; C = D; for (var B in P) P.hasOwnProperty(B) && (S[B] = P[B]) }, this.getFlavor = function () { return C }, this.removeExtension = function (D) { r.helper.isArray(D) || (D = [D]); for (var P = 0; P < D.length; ++P) { for (var B = D[P], F = 0; F < x.length; ++F)x[F] === B && x.splice(F, 1); for (var K = 0; K < k.length; ++K)k[K] === B && k.splice(K, 1) } }, this.getAllExtensions = function () { return { language: x, output: k } }, this.getMetadata = function (D) { return D ? E.raw : E.parsed }, this.getMetadataFormat = function () { return E.format }, this._setMetadataPair = function (D, P) { E.parsed[D] = P }, this._setMetadataFormat = function (D) { E.format = D }, this._setMetadataRaw = function (D) { E.raw = D }
    }, r.subParser("anchors", function (v, S, x) { v = x.converter._dispatch("anchors.before", v, S, x); var k = function (A, C, E, O, j, I, L) { if (r.helper.isUndefined(L) && (L = ""), E = E.toLowerCase(), A.search(/\(<?\s*>? ?(['"].*['"])?\)$/m) > -1) O = ""; else if (!O) if (E || (E = C.toLowerCase().replace(/ ?\n/g, " ")), O = "#" + E, !r.helper.isUndefined(x.gUrls[E])) O = x.gUrls[E], r.helper.isUndefined(x.gTitles[E]) || (L = x.gTitles[E]); else return A; O = O.replace(r.helper.regexes.asteriskDashAndColon, r.helper.escapeCharactersCallback); var R = '<a href="' + O + '"'; return L !== "" && L !== null && (L = L.replace(/"/g, "&quot;"), L = L.replace(r.helper.regexes.asteriskDashAndColon, r.helper.escapeCharactersCallback), R += ' title="' + L + '"'), S.openLinksInNewWindow && !/^#/.test(O) && (R += ' rel="noopener noreferrer" target="E95Eblank"'), R += ">" + C + "</a>", R }; return v = v.replace(/\[((?:\[[^\]]*]|[^\[\]])*)] ?(?:\n *)?\[(.*?)]()()()()/g, k), v = v.replace(/\[((?:\[[^\]]*]|[^\[\]])*)]()[ \t]*\([ \t]?<([^>]*)>(?:[ \t]*((["'])([^"]*?)\5))?[ \t]?\)/g, k), v = v.replace(/\[((?:\[[^\]]*]|[^\[\]])*)]()[ \t]*\([ \t]?<?([\S]+?(?:\([\S]*?\)[\S]*?)?)>?(?:[ \t]*((["'])([^"]*?)\5))?[ \t]?\)/g, k), v = v.replace(/\[([^\[\]]+)]()()()()()/g, k), S.ghMentions && (v = v.replace(/(^|\s)(\\)?(@([a-z\d]+(?:[a-z\d.-]+?[a-z\d]+)*))/gmi, function (A, C, E, O, j) { if (E === "\\") return C + O; if (!r.helper.isString(S.ghMentionsLink)) throw new Error("ghMentionsLink option must be a string"); var I = S.ghMentionsLink.replace(/\{u}/g, j), L = ""; return S.openLinksInNewWindow && (L = ' rel="noopener noreferrer" target="E95Eblank"'), C + '<a href="' + I + '"' + L + ">" + O + "</a>" })), v = x.converter._dispatch("anchors.after", v, S, x), v }); var f = /([*~_]+|\b)(((https?|ftp|dict):\/\/|www\.)[^'">\s]+?\.[^'">\s]+?)()(\1)?(?=\s|$)(?!["<>])/gi, h = /([*~_]+|\b)(((https?|ftp|dict):\/\/|www\.)[^'">\s]+\.[^'">\s]+?)([.!?,()\[\]])?(\1)?(?=\s|$)(?!["<>])/gi, p = /()<(((https?|ftp|dict):\/\/|www\.)[^'">\s]+)()>()/gi, m = /(^|\s)(?:mailto:)?([A-Za-z0-9!#$%&'*+-/=?^_`{|}~.]+@[-a-z0-9]+(\.[-a-z0-9]+)*\.[a-z]+)(?=$|\s)/gmi, g = /<()(?:mailto:)?([-.\w]+@[-a-z0-9]+(\.[-a-z0-9]+)*\.[a-z]+)>/gi, y = function (v) { return function (S, x, k, A, C, E, O) { k = k.replace(r.helper.regexes.asteriskDashAndColon, r.helper.escapeCharactersCallback); var j = k, I = "", L = "", R = x || "", D = O || ""; return /^www\./i.test(k) && (k = k.replace(/^www\./i, "http://www.")), v.excludeTrailingPunctuationFromURLs && E && (I = E), v.openLinksInNewWindow && (L = ' rel="noopener noreferrer" target="E95Eblank"'), R + '<a href="' + k + '"' + L + ">" + j + "</a>" + I + D } }, b = function (v, S) { return function (x, k, A) { var C = "mailto:"; return k = k || "", A = r.subParser("unescapeSpecialChars")(A, v, S), v.encodeEmails ? (C = r.helper.encodeEmailAddress(C + A), A = r.helper.encodeEmailAddress(A)) : C = C + A, k + '<a href="' + C + '">' + A + "</a>" } }; r.subParser("autoLinks", function (v, S, x) { return v = x.converter._dispatch("autoLinks.before", v, S, x), v = v.replace(p, y(S)), v = v.replace(g, b(S, x)), v = x.converter._dispatch("autoLinks.after", v, S, x), v }), r.subParser("simplifiedAutoLinks", function (v, S, x) { return S.simplifiedAutoLink && (v = x.converter._dispatch("simplifiedAutoLinks.before", v, S, x), S.excludeTrailingPunctuationFromURLs ? v = v.replace(h, y(S)) : v = v.replace(f, y(S)), v = v.replace(m, b(S, x)), v = x.converter._dispatch("simplifiedAutoLinks.after", v, S, x)), v }), r.subParser("blockGamut", function (v, S, x) { return v = x.converter._dispatch("blockGamut.before", v, S, x), v = r.subParser("blockQuotes")(v, S, x), v = r.subParser("headers")(v, S, x), v = r.subParser("horizontalRule")(v, S, x), v = r.subParser("lists")(v, S, x), v = r.subParser("codeBlocks")(v, S, x), v = r.subParser("tables")(v, S, x), v = r.subParser("hashHTMLBlocks")(v, S, x), v = r.subParser("paragraphs")(v, S, x), v = x.converter._dispatch("blockGamut.after", v, S, x), v }), r.subParser("blockQuotes", function (v, S, x) {
      v = x.converter._dispatch("blockQuotes.before", v, S, x), v = v + `

`; var k = /(^ {0,3}>[ \t]?.+\n(.+\n)*\n*)+/gm; return S.splitAdjacentBlockquotes && (k = /^ {0,3}>[\s\S]*?(?:\n\n)/gm), v = v.replace(k, function (A) {
        return A = A.replace(/^[ \t]*>[ \t]?/gm, ""), A = A.replace(/0/g, ""), A = A.replace(/^[ \t]+$/gm, ""), A = r.subParser("githubCodeBlocks")(A, S, x), A = r.subParser("blockGamut")(A, S, x), A = A.replace(/(^|\n)/g, "$1  "), A = A.replace(/(\s*<pre>[^\r]+?<\/pre>)/gm, function (C, E) { var O = E; return O = O.replace(/^  /mg, "0"), O = O.replace(/0/g, ""), O }), r.subParser("hashBlock")(`<blockquote>
`+ A + `
</blockquote>`, S, x)
      }), v = x.converter._dispatch("blockQuotes.after", v, S, x), v
    }), r.subParser("codeBlocks", function (v, S, x) {
      v = x.converter._dispatch("codeBlocks.before", v, S, x), v += "0"; var k = /(?:\n\n|^)((?:(?:[ ]{4}|\t).*\n+)+)(\n*[ ]{0,3}[^ \t\n]|(?=0))/g; return v = v.replace(k, function (A, C, E) {
        var O = C, j = E, I = `
`; return O = r.subParser("outdent")(O, S, x), O = r.subParser("encodeCode")(O, S, x), O = r.subParser("detab")(O, S, x), O = O.replace(/^\n+/g, ""), O = O.replace(/\n+$/g, ""), S.omitExtraWLInCodeBlocks && (I = ""), O = "<pre><code>" + O + I + "</code></pre>", r.subParser("hashBlock")(O, S, x) + j
      }), v = v.replace(/0/, ""), v = x.converter._dispatch("codeBlocks.after", v, S, x), v
    }), r.subParser("codeSpans", function (v, S, x) { return v = x.converter._dispatch("codeSpans.before", v, S, x), typeof v > "u" && (v = ""), v = v.replace(/(^|[^\\])(`+)([^\r]*?[^`])\2(?!`)/gm, function (k, A, C, E) { var O = E; return O = O.replace(/^([ \t]*)/g, ""), O = O.replace(/[ \t]*$/g, ""), O = r.subParser("encodeCode")(O, S, x), O = A + "<code>" + O + "</code>", O = r.subParser("hashHTMLSpans")(O, S, x), O }), v = x.converter._dispatch("codeSpans.after", v, S, x), v }), r.subParser("completeHTMLDocument", function (v, S, x) {
      if (!S.completeHTMLDocument) return v; v = x.converter._dispatch("completeHTMLDocument.before", v, S, x); var k = "html", A = `<!DOCTYPE HTML>
`, C = "", E = `<meta charset="utf-8">
`, O = "", j = ""; typeof x.metadata.parsed.doctype < "u" && (A = "<!DOCTYPE " + x.metadata.parsed.doctype + `>
`, k = x.metadata.parsed.doctype.toString().toLowerCase(), (k === "html" || k === "html5") && (E = '<meta charset="utf-8">')); for (var I in x.metadata.parsed) if (x.metadata.parsed.hasOwnProperty(I)) switch (I.toLowerCase()) {
        case "doctype": break; case "title": C = "<title>" + x.metadata.parsed.title + `</title>
`; break; case "charset": k === "html" || k === "html5" ? E = '<meta charset="' + x.metadata.parsed.charset + `">
`: E = '<meta name="charset" content="' + x.metadata.parsed.charset + `">
`; break; case "language": case "lang": O = ' lang="' + x.metadata.parsed[I] + '"', j += '<meta name="' + I + '" content="' + x.metadata.parsed[I] + `">
`; break; default: j += '<meta name="' + I + '" content="' + x.metadata.parsed[I] + `">
`}return v = A + "<html" + O + `>
<head>
`+ C + E + j + `</head>
<body>
`+ v.trim() + `
</body>
</html>`, v = x.converter._dispatch("completeHTMLDocument.after", v, S, x), v
    }), r.subParser("detab", function (v, S, x) { return v = x.converter._dispatch("detab.before", v, S, x), v = v.replace(/\t(?=\t)/g, "    "), v = v.replace(/\t/g, "AB"), v = v.replace(/B(.+?)A/g, function (k, A) { for (var C = A, E = 4 - C.length % 4, O = 0; O < E; O++)C += " "; return C }), v = v.replace(/A/g, "    "), v = v.replace(/B/g, ""), v = x.converter._dispatch("detab.after", v, S, x), v }), r.subParser("ellipsis", function (v, S, x) { return S.ellipsis && (v = x.converter._dispatch("ellipsis.before", v, S, x), v = v.replace(/\.\.\./g, ""), v = x.converter._dispatch("ellipsis.after", v, S, x)), v }), r.subParser("emoji", function (v, S, x) { if (!S.emoji) return v; v = x.converter._dispatch("emoji.before", v, S, x); var k = /:([\S]+?):/g; return v = v.replace(k, function (A, C) { return r.helper.emojis.hasOwnProperty(C) ? r.helper.emojis[C] : A }), v = x.converter._dispatch("emoji.after", v, S, x), v }), r.subParser("encodeAmpsAndAngles", function (v, S, x) { return v = x.converter._dispatch("encodeAmpsAndAngles.before", v, S, x), v = v.replace(/&(?!#?[xX]?(?:[0-9a-fA-F]+|\w+);)/g, "&amp;"), v = v.replace(/<(?![a-z\/?$!])/gi, "&lt;"), v = v.replace(/</g, "&lt;"), v = v.replace(/>/g, "&gt;"), v = x.converter._dispatch("encodeAmpsAndAngles.after", v, S, x), v }), r.subParser("encodeBackslashEscapes", function (v, S, x) { return v = x.converter._dispatch("encodeBackslashEscapes.before", v, S, x), v = v.replace(/\\(\\)/g, r.helper.escapeCharactersCallback), v = v.replace(/\\([`*_{}\[\]()>#+.!~=|:-])/g, r.helper.escapeCharactersCallback), v = x.converter._dispatch("encodeBackslashEscapes.after", v, S, x), v }), r.subParser("encodeCode", function (v, S, x) { return v = x.converter._dispatch("encodeCode.before", v, S, x), v = v.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/([*_{}\[\]\\=~-])/g, r.helper.escapeCharactersCallback), v = x.converter._dispatch("encodeCode.after", v, S, x), v }), r.subParser("escapeSpecialCharsWithinTagAttributes", function (v, S, x) { v = x.converter._dispatch("escapeSpecialCharsWithinTagAttributes.before", v, S, x); var k = /<\/?[a-z\d_:-]+(?:[\s]+[\s\S]+?)?>/gi, A = /<!(--(?:(?:[^>-]|-[^>])(?:[^-]|-[^-])*)--)>/gi; return v = v.replace(k, function (C) { return C.replace(/(.)<\/?code>(?=.)/g, "$1`").replace(/([\\`*_~=|])/g, r.helper.escapeCharactersCallback) }), v = v.replace(A, function (C) { return C.replace(/([\\`*_~=|])/g, r.helper.escapeCharactersCallback) }), v = x.converter._dispatch("escapeSpecialCharsWithinTagAttributes.after", v, S, x), v }), r.subParser("githubCodeBlocks", function (v, S, x) {
      return S.ghCodeBlocks ? (v = x.converter._dispatch("githubCodeBlocks.before", v, S, x), v += "0", v = v.replace(/(?:^|\n)(?: {0,3})(```+|~~~+)(?: *)([^\s`~]*)\n([\s\S]*?)\n(?: {0,3})\1/g, function (k, A, C, E) {
        var O = S.omitExtraWLInCodeBlocks ? "" : `
`; return E = r.subParser("encodeCode")(E, S, x), E = r.subParser("detab")(E, S, x), E = E.replace(/^\n+/g, ""), E = E.replace(/\n+$/g, ""), E = "<pre><code" + (C ? ' class="' + C + " language-" + C + '"' : "") + ">" + E + O + "</code></pre>", E = r.subParser("hashBlock")(E, S, x), `

G`+ (x.ghCodeBlocks.push({ text: k, codeblock: E }) - 1) + `G

`}), v = v.replace(/0/, ""), x.converter._dispatch("githubCodeBlocks.after", v, S, x)) : v
    }), r.subParser("hashBlock", function (v, S, x) {
      return v = x.converter._dispatch("hashBlock.before", v, S, x), v = v.replace(/(^\n+|\n+$)/g, ""), v = `

K`+ (x.gHtmlBlocks.push(v) - 1) + `K

`, v = x.converter._dispatch("hashBlock.after", v, S, x), v
    }), r.subParser("hashCodeTags", function (v, S, x) { v = x.converter._dispatch("hashCodeTags.before", v, S, x); var k = function (A, C, E, O) { var j = E + r.subParser("encodeCode")(C, S, x) + O; return "C" + (x.gHtmlSpans.push(j) - 1) + "C" }; return v = r.helper.replaceRecursiveRegExp(v, k, "<code\\b[^>]*>", "</code>", "gim"), v = x.converter._dispatch("hashCodeTags.after", v, S, x), v }), r.subParser("hashElement", function (v, S, x) {
      return function (k, A) {
        var C = A; return C = C.replace(/\n\n/g, `
`), C = C.replace(/^\n/, ""), C = C.replace(/\n+$/g, ""), C = `

K`+ (x.gHtmlBlocks.push(C) - 1) + `K

`, C
      }
    }), r.subParser("hashHTMLBlocks", function (v, S, x) {
      v = x.converter._dispatch("hashHTMLBlocks.before", v, S, x); var k = ["pre", "div", "h1", "h2", "h3", "h4", "h5", "h6", "blockquote", "table", "dl", "ol", "ul", "script", "noscript", "form", "fieldset", "iframe", "math", "style", "section", "header", "footer", "nav", "article", "aside", "address", "audio", "canvas", "figure", "hgroup", "output", "video", "p"], A = function (D, P, B, F) {
        var K = D; return B.search(/\bmarkdown\b/) !== -1 && (K = B + x.converter.makeHtml(P) + F), `

K`+ (x.gHtmlBlocks.push(K) - 1) + `K

`}; S.backslashEscapesHTMLTags && (v = v.replace(/\\<(\/?[^>]+?)>/g, function (D, P) { return "&lt;" + P + "&gt;" })); for (var C = 0; C < k.length; ++C)for (var E, O = new RegExp("^ {0,3}(<" + k[C] + "\\b[^>]*>)", "im"), j = "<" + k[C] + "\\b[^>]*>", I = "</" + k[C] + ">"; (E = r.helper.regexIndexOf(v, O)) !== -1;) { var L = r.helper.splitAtIndex(v, E), R = r.helper.replaceRecursiveRegExp(L[1], A, j, I, "im"); if (R === L[1]) break; v = L[0].concat(R) } return v = v.replace(/(\n {0,3}(<(hr)\b([^<>])*?\/?>)[ \t]*(?=\n{2,}))/g, r.subParser("hashElement")(v, S, x)), v = r.helper.replaceRecursiveRegExp(v, function (D) {
          return `

K`+ (x.gHtmlBlocks.push(D) - 1) + `K

`}, "^ {0,3}<!--", "-->", "gm"), v = v.replace(/(?:\n\n)( {0,3}(?:<([?%])[^\r]*?\2>)[ \t]*(?=\n{2,}))/g, r.subParser("hashElement")(v, S, x)), v = x.converter._dispatch("hashHTMLBlocks.after", v, S, x), v
    }), r.subParser("hashHTMLSpans", function (v, S, x) { v = x.converter._dispatch("hashHTMLSpans.before", v, S, x); function k(A) { return "C" + (x.gHtmlSpans.push(A) - 1) + "C" } return v = v.replace(/<[^>]+?\/>/gi, function (A) { return k(A) }), v = v.replace(/<([^>]+?)>[\s\S]*?<\/\1>/g, function (A) { return k(A) }), v = v.replace(/<([^>]+?)\s[^>]+?>[\s\S]*?<\/\1>/g, function (A) { return k(A) }), v = v.replace(/<[^>]+?>/gi, function (A) { return k(A) }), v = x.converter._dispatch("hashHTMLSpans.after", v, S, x), v }), r.subParser("unhashHTMLSpans", function (v, S, x) { v = x.converter._dispatch("unhashHTMLSpans.before", v, S, x); for (var k = 0; k < x.gHtmlSpans.length; ++k) { for (var A = x.gHtmlSpans[k], C = 0; /C(\d+)C/.test(A);) { var E = RegExp.$1; if (A = A.replace("C" + E + "C", x.gHtmlSpans[E]), C === 10) { console.error("maximum nesting of 10 spans reached!!!"); break } ++C } v = v.replace("C" + k + "C", A) } return v = x.converter._dispatch("unhashHTMLSpans.after", v, S, x), v }), r.subParser("hashPreCodeTags", function (v, S, x) {
      v = x.converter._dispatch("hashPreCodeTags.before", v, S, x); var k = function (A, C, E, O) {
        var j = E + r.subParser("encodeCode")(C, S, x) + O; return `

G`+ (x.ghCodeBlocks.push({ text: A, codeblock: j }) - 1) + `G

`}; return v = r.helper.replaceRecursiveRegExp(v, k, "^ {0,3}<pre\\b[^>]*>\\s*<code\\b[^>]*>", "^ {0,3}</code>\\s*</pre>", "gim"), v = x.converter._dispatch("hashPreCodeTags.after", v, S, x), v
    }), r.subParser("headers", function (v, S, x) { v = x.converter._dispatch("headers.before", v, S, x); var k = isNaN(parseInt(S.headerLevelStart)) ? 1 : parseInt(S.headerLevelStart), A = S.smoothLivePreview ? /^(.+)[ \t]*\n={2,}[ \t]*\n+/gm : /^(.+)[ \t]*\n=+[ \t]*\n+/gm, C = S.smoothLivePreview ? /^(.+)[ \t]*\n-{2,}[ \t]*\n+/gm : /^(.+)[ \t]*\n-+[ \t]*\n+/gm; v = v.replace(A, function (j, I) { var L = r.subParser("spanGamut")(I, S, x), R = S.noHeaderId ? "" : ' id="' + O(I) + '"', D = k, P = "<h" + D + R + ">" + L + "</h" + D + ">"; return r.subParser("hashBlock")(P, S, x) }), v = v.replace(C, function (j, I) { var L = r.subParser("spanGamut")(I, S, x), R = S.noHeaderId ? "" : ' id="' + O(I) + '"', D = k + 1, P = "<h" + D + R + ">" + L + "</h" + D + ">"; return r.subParser("hashBlock")(P, S, x) }); var E = S.requireSpaceBeforeHeadingText ? /^(#{1,6})[ \t]+(.+?)[ \t]*#*\n+/gm : /^(#{1,6})[ \t]*(.+?)[ \t]*#*\n+/gm; v = v.replace(E, function (j, I, L) { var R = L; S.customizedHeaderId && (R = L.replace(/\s?\{([^{]+?)}\s*$/, "")); var D = r.subParser("spanGamut")(R, S, x), P = S.noHeaderId ? "" : ' id="' + O(L) + '"', B = k - 1 + I.length, F = "<h" + B + P + ">" + D + "</h" + B + ">"; return r.subParser("hashBlock")(F, S, x) }); function O(j) { var I, L; if (S.customizedHeaderId) { var R = j.match(/\{([^{]+?)}\s*$/); R && R[1] && (j = R[1]) } return I = j, r.helper.isString(S.prefixHeaderId) ? L = S.prefixHeaderId : S.prefixHeaderId === !0 ? L = "section-" : L = "", S.rawPrefixHeaderId || (I = L + I), S.ghCompatibleHeaderId ? I = I.replace(/ /g, "-").replace(/&amp;/g, "").replace(/T/g, "").replace(/D/g, "").replace(/[&+$,\/:;=?@"#{}|^~\[\]`\\*)(%.!'<>]/g, "").toLowerCase() : S.rawHeaderId ? I = I.replace(/ /g, "-").replace(/&amp;/g, "&").replace(/T/g, "").replace(/D/g, "$").replace(/["']/g, "-").toLowerCase() : I = I.replace(/[^\w]/g, "").toLowerCase(), S.rawPrefixHeaderId && (I = L + I), x.hashLinkCounts[I] ? I = I + "-" + x.hashLinkCounts[I]++ : x.hashLinkCounts[I] = 1, I } return v = x.converter._dispatch("headers.after", v, S, x), v }), r.subParser("horizontalRule", function (v, S, x) { v = x.converter._dispatch("horizontalRule.before", v, S, x); var k = r.subParser("hashBlock")("<hr />", S, x); return v = v.replace(/^ {0,2}( ?-){3,}[ \t]*$/gm, k), v = v.replace(/^ {0,2}( ?\*){3,}[ \t]*$/gm, k), v = v.replace(/^ {0,2}( ?_){3,}[ \t]*$/gm, k), v = x.converter._dispatch("horizontalRule.after", v, S, x), v }), r.subParser("images", function (v, S, x) { v = x.converter._dispatch("images.before", v, S, x); var k = /!\[([^\]]*?)][ \t]*()\([ \t]?<?([\S]+?(?:\([\S]*?\)[\S]*?)?)>?(?: =([*\d]+[A-Za-z%]{0,4})x([*\d]+[A-Za-z%]{0,4}))?[ \t]*(?:(["'])([^"]*?)\6)?[ \t]?\)/g, A = /!\[([^\]]*?)][ \t]*()\([ \t]?<([^>]*)>(?: =([*\d]+[A-Za-z%]{0,4})x([*\d]+[A-Za-z%]{0,4}))?[ \t]*(?:(?:(["'])([^"]*?)\6))?[ \t]?\)/g, C = /!\[([^\]]*?)][ \t]*()\([ \t]?<?(data:.+?\/.+?;base64,[A-Za-z0-9+/=\n]+?)>?(?: =([*\d]+[A-Za-z%]{0,4})x([*\d]+[A-Za-z%]{0,4}))?[ \t]*(?:(["'])([^"]*?)\6)?[ \t]?\)/g, E = /!\[([^\]]*?)] ?(?:\n *)?\[([\s\S]*?)]()()()()()/g, O = /!\[([^\[\]]+)]()()()()()/g; function j(L, R, D, P, B, F, K, V) { return P = P.replace(/\s/g, ""), I(L, R, D, P, B, F, K, V) } function I(L, R, D, P, B, F, K, V) { var W = x.gUrls, J = x.gTitles, ie = x.gDimensions; if (D = D.toLowerCase(), V || (V = ""), L.search(/\(<?\s*>? ?(['"].*['"])?\)$/m) > -1) P = ""; else if (P === "" || P === null) if ((D === "" || D === null) && (D = R.toLowerCase().replace(/ ?\n/g, " ")), P = "#" + D, !r.helper.isUndefined(W[D])) P = W[D], r.helper.isUndefined(J[D]) || (V = J[D]), r.helper.isUndefined(ie[D]) || (B = ie[D].width, F = ie[D].height); else return L; R = R.replace(/"/g, "&quot;").replace(r.helper.regexes.asteriskDashAndColon, r.helper.escapeCharactersCallback), P = P.replace(r.helper.regexes.asteriskDashAndColon, r.helper.escapeCharactersCallback); var le = '<img src="' + P + '" alt="' + R + '"'; return V && r.helper.isString(V) && (V = V.replace(/"/g, "&quot;").replace(r.helper.regexes.asteriskDashAndColon, r.helper.escapeCharactersCallback), le += ' title="' + V + '"'), B && F && (B = B === "*" ? "auto" : B, F = F === "*" ? "auto" : F, le += ' width="' + B + '"', le += ' height="' + F + '"'), le += " />", le } return v = v.replace(E, I), v = v.replace(C, j), v = v.replace(A, I), v = v.replace(k, I), v = v.replace(O, I), v = x.converter._dispatch("images.after", v, S, x), v }), r.subParser("italicsAndBold", function (v, S, x) { v = x.converter._dispatch("italicsAndBold.before", v, S, x); function k(A, C, E) { return C + A + E } return S.literalMidWordUnderscores ? (v = v.replace(/\b___(\S[\s\S]*?)___\b/g, function (A, C) { return k(C, "<strong><em>", "</em></strong>") }), v = v.replace(/\b__(\S[\s\S]*?)__\b/g, function (A, C) { return k(C, "<strong>", "</strong>") }), v = v.replace(/\b_(\S[\s\S]*?)_\b/g, function (A, C) { return k(C, "<em>", "</em>") })) : (v = v.replace(/___(\S[\s\S]*?)___/g, function (A, C) { return /\S$/.test(C) ? k(C, "<strong><em>", "</em></strong>") : A }), v = v.replace(/__(\S[\s\S]*?)__/g, function (A, C) { return /\S$/.test(C) ? k(C, "<strong>", "</strong>") : A }), v = v.replace(/_([^\s_][\s\S]*?)_/g, function (A, C) { return /\S$/.test(C) ? k(C, "<em>", "</em>") : A })), S.literalMidWordAsterisks ? (v = v.replace(/([^*]|^)\B\*\*\*(\S[\s\S]*?)\*\*\*\B(?!\*)/g, function (A, C, E) { return k(E, C + "<strong><em>", "</em></strong>") }), v = v.replace(/([^*]|^)\B\*\*(\S[\s\S]*?)\*\*\B(?!\*)/g, function (A, C, E) { return k(E, C + "<strong>", "</strong>") }), v = v.replace(/([^*]|^)\B\*(\S[\s\S]*?)\*\B(?!\*)/g, function (A, C, E) { return k(E, C + "<em>", "</em>") })) : (v = v.replace(/\*\*\*(\S[\s\S]*?)\*\*\*/g, function (A, C) { return /\S$/.test(C) ? k(C, "<strong><em>", "</em></strong>") : A }), v = v.replace(/\*\*(\S[\s\S]*?)\*\*/g, function (A, C) { return /\S$/.test(C) ? k(C, "<strong>", "</strong>") : A }), v = v.replace(/\*([^\s*][\s\S]*?)\*/g, function (A, C) { return /\S$/.test(C) ? k(C, "<em>", "</em>") : A })), v = x.converter._dispatch("italicsAndBold.after", v, S, x), v }), r.subParser("lists", function (v, S, x) {
      function k(E, O) {
        x.gListLevel++, E = E.replace(/\n{2,}$/, `
`), E += "0"; var j = /(\n)?(^ {0,3})([*+-]|\d+[.])[ \t]+((\[(x|X| )?])?[ \t]*[^\r]+?(\n{1,2}))(?=\n*(0| {0,3}([*+-]|\d+[.])[ \t]+))/gm, I = /\n[ \t]*\n(?!0)/.test(E); return S.disableForced4SpacesIndentedSublists && (j = /(\n)?(^ {0,3})([*+-]|\d+[.])[ \t]+((\[(x|X| )?])?[ \t]*[^\r]+?(\n{1,2}))(?=\n*(0|\2([*+-]|\d+[.])[ \t]+))/gm), E = E.replace(j, function (L, R, D, P, B, F, K) {
          K = K && K.trim() !== ""; var V = r.subParser("outdent")(B, S, x), W = ""; return F && S.tasklists && (W = ' class="task-list-item" style="list-style-type: none;"', V = V.replace(/^[ \t]*\[(x|X| )?]/m, function () { var J = '<input type="checkbox" disabled style="margin: 0px 0.35em 0.25em -1.6em; vertical-align: middle;"'; return K && (J += " checked"), J += ">", J })), V = V.replace(/^([-*+]|\d\.)[ \t]+[\S\n ]*/g, function (J) { return "A" + J }), R || V.search(/\n{2,}/) > -1 ? (V = r.subParser("githubCodeBlocks")(V, S, x), V = r.subParser("blockGamut")(V, S, x)) : (V = r.subParser("lists")(V, S, x), V = V.replace(/\n$/, ""), V = r.subParser("hashHTMLBlocks")(V, S, x), V = V.replace(/\n\n+/g, `

`), I ? V = r.subParser("paragraphs")(V, S, x) : V = r.subParser("spanGamut")(V, S, x)), V = V.replace("A", ""), V = "<li" + W + ">" + V + `</li>
`, V
        }), E = E.replace(/0/g, ""), x.gListLevel--, O && (E = E.replace(/\s+$/, "")), E
      } function A(E, O) { if (O === "ol") { var j = E.match(/^ *(\d+)\./); if (j && j[1] !== "1") return ' start="' + j[1] + '"' } return "" } function C(E, O, j) {
        var I = S.disableForced4SpacesIndentedSublists ? /^ ?\d+\.[ \t]/gm : /^ {0,3}\d+\.[ \t]/gm, L = S.disableForced4SpacesIndentedSublists ? /^ ?[*+-][ \t]/gm : /^ {0,3}[*+-][ \t]/gm, R = O === "ul" ? I : L, D = ""; if (E.search(R) !== -1) (function B(F) {
          var K = F.search(R), V = A(E, O); K !== -1 ? (D += `

<`+ O + V + `>
`+ k(F.slice(0, K), !!j) + "</" + O + `>
`, O = O === "ul" ? "ol" : "ul", R = O === "ul" ? I : L, B(F.slice(K))) : D += `

<`+ O + V + `>
`+ k(F, !!j) + "</" + O + `>
`})(E); else {
          var P = A(E, O); D = `

<`+ O + P + `>
`+ k(E, !!j) + "</" + O + `>
`} return D
      } return v = x.converter._dispatch("lists.before", v, S, x), v += "0", x.gListLevel ? v = v.replace(/^(( {0,3}([*+-]|\d+[.])[ \t]+)[^\r]+?(0|\n{2,}(?=\S)(?![ \t]*(?:[*+-]|\d+[.])[ \t]+)))/gm, function (E, O, j) { var I = j.search(/[*+-]/g) > -1 ? "ul" : "ol"; return C(O, I, !0) }) : v = v.replace(/(\n\n|^\n?)(( {0,3}([*+-]|\d+[.])[ \t]+)[^\r]+?(0|\n{2,}(?=\S)(?![ \t]*(?:[*+-]|\d+[.])[ \t]+)))/gm, function (E, O, j, I) { var L = I.search(/[*+-]/g) > -1 ? "ul" : "ol"; return C(j, L, !1) }), v = v.replace(/0/, ""), v = x.converter._dispatch("lists.after", v, S, x), v
    }), r.subParser("metadata", function (v, S, x) { if (!S.metadata) return v; v = x.converter._dispatch("metadata.before", v, S, x); function k(A) { x.metadata.raw = A, A = A.replace(/&/g, "&amp;").replace(/"/g, "&quot;"), A = A.replace(/\n {4}/g, " "), A.replace(/^([\S ]+): +([\s\S]+?)$/gm, function (C, E, O) { return x.metadata.parsed[E] = O, "" }) } return v = v.replace(/^\s*+(\S*?)\n([\s\S]+?)\n+\n/, function (A, C, E) { return k(E), "M" }), v = v.replace(/^\s*---+(\S*?)\n([\s\S]+?)\n---+\n/, function (A, C, E) { return C && (x.metadata.format = C), k(E), "M" }), v = v.replace(/M/g, ""), v = x.converter._dispatch("metadata.after", v, S, x), v }), r.subParser("outdent", function (v, S, x) { return v = x.converter._dispatch("outdent.before", v, S, x), v = v.replace(/^(\t|[ ]{1,4})/gm, "0"), v = v.replace(/0/g, ""), v = x.converter._dispatch("outdent.after", v, S, x), v }), r.subParser("paragraphs", function (v, S, x) {
      v = x.converter._dispatch("paragraphs.before", v, S, x), v = v.replace(/^\n+/g, ""), v = v.replace(/\n+$/g, ""); for (var k = v.split(/\n{2,}/g), A = [], C = k.length, E = 0; E < C; E++) { var O = k[E]; O.search(/(K|G)(\d+)\1/g) >= 0 ? A.push(O) : O.search(/\S/) >= 0 && (O = r.subParser("spanGamut")(O, S, x), O = O.replace(/^([ \t]*)/g, "<p>"), O += "</p>", A.push(O)) } for (C = A.length, E = 0; E < C; E++) { for (var j = "", I = A[E], L = !1; /(K|G)(\d+)\1/.test(I);) { var R = RegExp.$1, D = RegExp.$2; R === "K" ? j = x.gHtmlBlocks[D] : L ? j = r.subParser("encodeCode")(x.ghCodeBlocks[D].text, S, x) : j = x.ghCodeBlocks[D].codeblock, j = j.replace(/\$/g, "$$$$"), I = I.replace(/(\n\n)?(K|G)\d+\2(\n\n)?/, j), /^<pre\b[^>]*>\s*<code\b[^>]*>/.test(I) && (L = !0) } A[E] = I } return v = A.join(`
`), v = v.replace(/^\n+/g, ""), v = v.replace(/\n+$/g, ""), x.converter._dispatch("paragraphs.after", v, S, x)
    }), r.subParser("runExtension", function (v, S, x, k) { if (v.filter) S = v.filter(S, k.converter, x); else if (v.regex) { var A = v.regex; A instanceof RegExp || (A = new RegExp(A, "g")), S = S.replace(A, v.replace) } return S }), r.subParser("spanGamut", function (v, S, x) {
      return v = x.converter._dispatch("spanGamut.before", v, S, x), v = r.subParser("codeSpans")(v, S, x), v = r.subParser("escapeSpecialCharsWithinTagAttributes")(v, S, x), v = r.subParser("encodeBackslashEscapes")(v, S, x), v = r.subParser("images")(v, S, x), v = r.subParser("anchors")(v, S, x), v = r.subParser("autoLinks")(v, S, x), v = r.subParser("simplifiedAutoLinks")(v, S, x), v = r.subParser("emoji")(v, S, x), v = r.subParser("underline")(v, S, x), v = r.subParser("italicsAndBold")(v, S, x), v = r.subParser("strikethrough")(v, S, x), v = r.subParser("ellipsis")(v, S, x), v = r.subParser("hashHTMLSpans")(v, S, x), v = r.subParser("encodeAmpsAndAngles")(v, S, x), S.simpleLineBreaks ? /\n\nK/.test(v) || (v = v.replace(/\n+/g, `<br />
`)) : v = v.replace(/  +\n/g, `<br />
`), v = x.converter._dispatch("spanGamut.after", v, S, x), v
    }), r.subParser("strikethrough", function (v, S, x) { function k(A) { return S.simplifiedAutoLink && (A = r.subParser("simplifiedAutoLinks")(A, S, x)), "<del>" + A + "</del>" } return S.strikethrough && (v = x.converter._dispatch("strikethrough.before", v, S, x), v = v.replace(/(?:~){2}([\s\S]+?)(?:~){2}/g, function (A, C) { return k(C) }), v = x.converter._dispatch("strikethrough.after", v, S, x)), v }), r.subParser("stripLinkDefinitions", function (v, S, x) { var k = /^ {0,3}\[([^\]]+)]:[ \t]*\n?[ \t]*<?([^>\s]+)>?(?: =([*\d]+[A-Za-z%]{0,4})x([*\d]+[A-Za-z%]{0,4}))?[ \t]*\n?[ \t]*(?:(\n*)["|'(](.+?)["|')][ \t]*)?(?:\n+|(?=0))/gm, A = /^ {0,3}\[([^\]]+)]:[ \t]*\n?[ \t]*<?(data:.+?\/.+?;base64,[A-Za-z0-9+/=\n]+?)>?(?: =([*\d]+[A-Za-z%]{0,4})x([*\d]+[A-Za-z%]{0,4}))?[ \t]*\n?[ \t]*(?:(\n*)["|'(](.+?)["|')][ \t]*)?(?:\n\n|(?=0)|(?=\n\[))/gm; v += "0"; var C = function (E, O, j, I, L, R, D) { return O = O.toLowerCase(), v.toLowerCase().split(O).length - 1 < 2 ? E : (j.match(/^data:.+?\/.+?;base64,/) ? x.gUrls[O] = j.replace(/\s/g, "") : x.gUrls[O] = r.subParser("encodeAmpsAndAngles")(j, S, x), R ? R + D : (D && (x.gTitles[O] = D.replace(/"|'/g, "&quot;")), S.parseImgDimensions && I && L && (x.gDimensions[O] = { width: I, height: L }), "")) }; return v = v.replace(A, C), v = v.replace(k, C), v = v.replace(/0/, ""), v }), r.subParser("tables", function (v, S, x) {
      if (!S.tables) return v; var k = /^ {0,3}\|?.+\|.+\n {0,3}\|?[ \t]*:?[ \t]*(?:[-=]){2,}[ \t]*:?[ \t]*\|[ \t]*:?[ \t]*(?:[-=]){2,}[\s\S]+?(?:\n\n|0)/gm, A = /^ {0,3}\|.+\|[ \t]*\n {0,3}\|[ \t]*:?[ \t]*(?:[-=]){2,}[ \t]*:?[ \t]*\|[ \t]*\n( {0,3}\|.+\|[ \t]*\n)*(?:\n|0)/gm; function C(L) { return /^:[ \t]*--*$/.test(L) ? ' style="text-align:left;"' : /^--*[ \t]*:[ \t]*$/.test(L) ? ' style="text-align:right;"' : /^:[ \t]*--*[ \t]*:$/.test(L) ? ' style="text-align:center;"' : "" } function E(L, R) {
        var D = ""; return L = L.trim(), (S.tablesHeaderId || S.tableHeaderId) && (D = ' id="' + L.replace(/ /g, "_").toLowerCase() + '"'), L = r.subParser("spanGamut")(L, S, x), "<th" + D + R + ">" + L + `</th>
`} function O(L, R) {
        var D = r.subParser("spanGamut")(L, S, x); return "<td" + R + ">" + D + `</td>
`} function j(L, R) {
        for (var D = `<table>
<thead>
<tr>
`, P = L.length, B = 0; B < P; ++B)D += L[B]; for (D += `</tr>
</thead>
<tbody>
`, B = 0; B < R.length; ++B) {
          D += `<tr>
`; for (var F = 0; F < P; ++F)D += R[B][F]; D += `</tr>
`} return D += `</tbody>
</table>
`, D
      } function I(L) {
        var R, D = L.split(`
`); for (R = 0; R < D.length; ++R)/^ {0,3}\|/.test(D[R]) && (D[R] = D[R].replace(/^ {0,3}\|/, "")), /\|[ \t]*$/.test(D[R]) && (D[R] = D[R].replace(/\|[ \t]*$/, "")), D[R] = r.subParser("codeSpans")(D[R], S, x); var P = D[0].split("|").map(function (le) { return le.trim() }), B = D[1].split("|").map(function (le) { return le.trim() }), F = [], K = [], V = [], W = []; for (D.shift(), D.shift(), R = 0; R < D.length; ++R)D[R].trim() !== "" && F.push(D[R].split("|").map(function (le) { return le.trim() })); if (P.length < B.length) return L; for (R = 0; R < B.length; ++R)V.push(C(B[R])); for (R = 0; R < P.length; ++R)r.helper.isUndefined(V[R]) && (V[R] = ""), K.push(E(P[R], V[R])); for (R = 0; R < F.length; ++R) { for (var J = [], ie = 0; ie < K.length; ++ie)r.helper.isUndefined(F[R][ie]), J.push(O(F[R][ie], V[ie])); W.push(J) } return j(K, W)
      } return v = x.converter._dispatch("tables.before", v, S, x), v = v.replace(/\\(\|)/g, r.helper.escapeCharactersCallback), v = v.replace(k, I), v = v.replace(A, I), v = x.converter._dispatch("tables.after", v, S, x), v
    }), r.subParser("underline", function (v, S, x) { return S.underline && (v = x.converter._dispatch("underline.before", v, S, x), S.literalMidWordUnderscores ? (v = v.replace(/\b___(\S[\s\S]*?)___\b/g, function (k, A) { return "<u>" + A + "</u>" }), v = v.replace(/\b__(\S[\s\S]*?)__\b/g, function (k, A) { return "<u>" + A + "</u>" })) : (v = v.replace(/___(\S[\s\S]*?)___/g, function (k, A) { return /\S$/.test(A) ? "<u>" + A + "</u>" : k }), v = v.replace(/__(\S[\s\S]*?)__/g, function (k, A) { return /\S$/.test(A) ? "<u>" + A + "</u>" : k })), v = v.replace(/(_)/g, r.helper.escapeCharactersCallback), v = x.converter._dispatch("underline.after", v, S, x)), v }), r.subParser("unescapeSpecialChars", function (v, S, x) { return v = x.converter._dispatch("unescapeSpecialChars.before", v, S, x), v = v.replace(/E(\d+)E/g, function (k, A) { var C = parseInt(A); return String.fromCharCode(C) }), v = x.converter._dispatch("unescapeSpecialChars.after", v, S, x), v }), r.subParser("makeMarkdown.blockquote", function (v, S) {
      var x = ""; if (v.hasChildNodes()) for (var k = v.childNodes, A = k.length, C = 0; C < A; ++C) { var E = r.subParser("makeMarkdown.node")(k[C], S); E !== "" && (x += E) } return x = x.trim(), x = "> " + x.split(`
`).join(`
> `), x
    }), r.subParser("makeMarkdown.codeBlock", function (v, S) {
      var x = v.getAttribute("language"), k = v.getAttribute("precodenum"); return "```" + x + `
`+ S.preList[k] + "\n```"
    }), r.subParser("makeMarkdown.codeSpan", function (v) { return "`" + v.innerHTML + "`" }), r.subParser("makeMarkdown.emphasis", function (v, S) { var x = ""; if (v.hasChildNodes()) { x += "*"; for (var k = v.childNodes, A = k.length, C = 0; C < A; ++C)x += r.subParser("makeMarkdown.node")(k[C], S); x += "*" } return x }), r.subParser("makeMarkdown.header", function (v, S, x) { var k = new Array(x + 1).join("#"), A = ""; if (v.hasChildNodes()) { A = k + " "; for (var C = v.childNodes, E = C.length, O = 0; O < E; ++O)A += r.subParser("makeMarkdown.node")(C[O], S) } return A }), r.subParser("makeMarkdown.hr", function () { return "---" }), r.subParser("makeMarkdown.image", function (v) { var S = ""; return v.hasAttribute("src") && (S += "![" + v.getAttribute("alt") + "](", S += "<" + v.getAttribute("src") + ">", v.hasAttribute("width") && v.hasAttribute("height") && (S += " =" + v.getAttribute("width") + "x" + v.getAttribute("height")), v.hasAttribute("title") && (S += ' "' + v.getAttribute("title") + '"'), S += ")"), S }), r.subParser("makeMarkdown.links", function (v, S) { var x = ""; if (v.hasChildNodes() && v.hasAttribute("href")) { var k = v.childNodes, A = k.length; x = "["; for (var C = 0; C < A; ++C)x += r.subParser("makeMarkdown.node")(k[C], S); x += "](", x += "<" + v.getAttribute("href") + ">", v.hasAttribute("title") && (x += ' "' + v.getAttribute("title") + '"'), x += ")" } return x }), r.subParser("makeMarkdown.list", function (v, S, x) {
      var k = ""; if (!v.hasChildNodes()) return ""; for (var A = v.childNodes, C = A.length, E = v.getAttribute("start") || 1, O = 0; O < C; ++O)if (!(typeof A[O].tagName > "u" || A[O].tagName.toLowerCase() !== "li")) { var j = ""; x === "ol" ? j = E.toString() + ". " : j = "- ", k += j + r.subParser("makeMarkdown.listItem")(A[O], S), ++E } return k += `
<!-- -->
`, k.trim()
    }), r.subParser("makeMarkdown.listItem", function (v, S) {
      for (var x = "", k = v.childNodes, A = k.length, C = 0; C < A; ++C)x += r.subParser("makeMarkdown.node")(k[C], S); return /\n$/.test(x) ? x = x.split(`
`).join(`
    `).replace(/^ {4}$/gm, "").replace(/\n\n+/g, `

`) : x += `
`, x
    }), r.subParser("makeMarkdown.node", function (v, S, x) {
      x = x || !1; var k = ""; if (v.nodeType === 3) return r.subParser("makeMarkdown.txt")(v, S); if (v.nodeType === 8) return "<!--" + v.data + `-->

`; if (v.nodeType !== 1) return ""; var A = v.tagName.toLowerCase(); switch (A) {
        case "h1": x || (k = r.subParser("makeMarkdown.header")(v, S, 1) + `

`); break; case "h2": x || (k = r.subParser("makeMarkdown.header")(v, S, 2) + `

`); break; case "h3": x || (k = r.subParser("makeMarkdown.header")(v, S, 3) + `

`); break; case "h4": x || (k = r.subParser("makeMarkdown.header")(v, S, 4) + `

`); break; case "h5": x || (k = r.subParser("makeMarkdown.header")(v, S, 5) + `

`); break; case "h6": x || (k = r.subParser("makeMarkdown.header")(v, S, 6) + `

`); break; case "p": x || (k = r.subParser("makeMarkdown.paragraph")(v, S) + `

`); break; case "blockquote": x || (k = r.subParser("makeMarkdown.blockquote")(v, S) + `

`); break; case "hr": x || (k = r.subParser("makeMarkdown.hr")(v, S) + `

`); break; case "ol": x || (k = r.subParser("makeMarkdown.list")(v, S, "ol") + `

`); break; case "ul": x || (k = r.subParser("makeMarkdown.list")(v, S, "ul") + `

`); break; case "precode": x || (k = r.subParser("makeMarkdown.codeBlock")(v, S) + `

`); break; case "pre": x || (k = r.subParser("makeMarkdown.pre")(v, S) + `

`); break; case "table": x || (k = r.subParser("makeMarkdown.table")(v, S) + `

`); break; case "code": k = r.subParser("makeMarkdown.codeSpan")(v, S); break; case "em": case "i": k = r.subParser("makeMarkdown.emphasis")(v, S); break; case "strong": case "b": k = r.subParser("makeMarkdown.strong")(v, S); break; case "del": k = r.subParser("makeMarkdown.strikethrough")(v, S); break; case "a": k = r.subParser("makeMarkdown.links")(v, S); break; case "img": k = r.subParser("makeMarkdown.image")(v, S); break; default: k = v.outerHTML + `

`}return k
    }), r.subParser("makeMarkdown.paragraph", function (v, S) { var x = ""; if (v.hasChildNodes()) for (var k = v.childNodes, A = k.length, C = 0; C < A; ++C)x += r.subParser("makeMarkdown.node")(k[C], S); return x = x.trim(), x }), r.subParser("makeMarkdown.pre", function (v, S) { var x = v.getAttribute("prenum"); return "<pre>" + S.preList[x] + "</pre>" }), r.subParser("makeMarkdown.strikethrough", function (v, S) { var x = ""; if (v.hasChildNodes()) { x += "~~"; for (var k = v.childNodes, A = k.length, C = 0; C < A; ++C)x += r.subParser("makeMarkdown.node")(k[C], S); x += "~~" } return x }), r.subParser("makeMarkdown.strong", function (v, S) { var x = ""; if (v.hasChildNodes()) { x += "**"; for (var k = v.childNodes, A = k.length, C = 0; C < A; ++C)x += r.subParser("makeMarkdown.node")(k[C], S); x += "**" } return x }), r.subParser("makeMarkdown.table", function (v, S) {
      var x = "", k = [[], []], A = v.querySelectorAll("thead>tr>th"), C = v.querySelectorAll("tbody>tr"), E, O; for (E = 0; E < A.length; ++E) { var j = r.subParser("makeMarkdown.tableCell")(A[E], S), I = "---"; if (A[E].hasAttribute("style")) { var L = A[E].getAttribute("style").toLowerCase().replace(/\s/g, ""); switch (L) { case "text-align:left;": I = ":---"; break; case "text-align:right;": I = "---:"; break; case "text-align:center;": I = ":---:"; break } } k[0][E] = j.trim(), k[1][E] = I } for (E = 0; E < C.length; ++E) { var R = k.push([]) - 1, D = C[E].getElementsByTagName("td"); for (O = 0; O < A.length; ++O) { var P = " "; typeof D[O] < "u" && (P = r.subParser("makeMarkdown.tableCell")(D[O], S)), k[R].push(P) } } var B = 3; for (E = 0; E < k.length; ++E)for (O = 0; O < k[E].length; ++O) { var F = k[E][O].length; F > B && (B = F) } for (E = 0; E < k.length; ++E) {
        for (O = 0; O < k[E].length; ++O)E === 1 ? k[E][O].slice(-1) === ":" ? k[E][O] = r.helper.padEnd(k[E][O].slice(-1), B - 1, "-") + ":" : k[E][O] = r.helper.padEnd(k[E][O], B, "-") : k[E][O] = r.helper.padEnd(k[E][O], B); x += "| " + k[E].join(" | ") + ` |
`} return x.trim()
    }), r.subParser("makeMarkdown.tableCell", function (v, S) { var x = ""; if (!v.hasChildNodes()) return ""; for (var k = v.childNodes, A = k.length, C = 0; C < A; ++C)x += r.subParser("makeMarkdown.node")(k[C], S, !0); return x.trim() }), r.subParser("makeMarkdown.txt", function (v) { var S = v.nodeValue; return S = S.replace(/ +/g, " "), S = S.replace(/NBSP;/g, " "), S = r.helper.unescapeHTMLEntities(S), S = S.replace(/([*_~|`])/g, "\\$1"), S = S.replace(/^(\s*)>/g, "\\$1>"), S = S.replace(/^#/gm, "\\#"), S = S.replace(/^(\s*)([-=]{3,})(\s*)$/, "$1\\$2$3"), S = S.replace(/^( {0,3}\d+)\./gm, "$1\\."), S = S.replace(/^( {0,3})([+-])/gm, "$1\\$2"), S = S.replace(/]([\s]*)\(/g, "\\]$1\\("), S = S.replace(/^ {0,3}\[([\S \t]*?)]:/gm, "\\[$1]:"), S }); var w = this; n.exports ? n.exports = r : w.showdown = r
  }).call(Du)
})(WQ); var HRe = WQ.exports; const URe = ck(HRe); function GRe(n) { const e = new URe.Converter; return e.setFlavor("github"), e.makeHtml(n) } function WRe(n) {
  return n.split(`
`).filter(r => /!\[.*\]\(.*\)/.test(r) || /\[.*\]\(.*\)/.test(r) || /(^|\s)\*.*\*(\s|$)/.test(r) || /(^|\s)_.*_(\s|$)/.test(r) || /(^|\s)\*\*.*\*\*(\s|$)/.test(r) || /(^|\s)__.*__(\s|$)/.test(r) || /(^|\s)~~.*~~(\s|$)/.test(r) || r.startsWith("![") || r.startsWith("#") || r.startsWith("> ") || r.startsWith("*") || r.startsWith("- ") || r.startsWith("1. ") || r.startsWith("```") || r.startsWith("`") || r.startsWith("[") || r.startsWith("---")).length > 0
} function KRe() { const n = vr({ uploading: !1, progress: 0, uploaded: 0, total: 0, error: null, result: null }), e = () => { n.uploading = !1, n.progress = 0, n.uploaded = 0, n.total = 0, n.error = null, n.result = null }, t = ne(() => n.uploading), r = ne(() => n.progress), i = ne(() => n.error), a = ne(() => n.result); return { upload: (o, s = {}) => qRe(o, s, n, e), reset: e, state: n, isUploading: t, progress: r, error: i, result: a } } async function qRe(n, e = {}, t, r) {
  return r(), t.uploading = !0, new Promise((i, a) => {
    const o = new XMLHttpRequest; o.upload.addEventListener("loadstart", () => { t.uploading = !0, t.error = null }), o.upload.addEventListener("progress", c => { c.lengthComputable && (t.uploaded = c.loaded, t.total = c.total, t.progress = Math.round(c.loaded / c.total * 100)) }), o.upload.addEventListener("load", () => { t.progress = 100 }), o.addEventListener("error", c => { t.uploading = !1, t.error = "Upload failed", a("Upload failed") }), o.onreadystatechange = () => {
      if (o.readyState == XMLHttpRequest.DONE) {
        let c; if (o.status === 200) { let u = null; try { u = JSON.parse(o.responseText) } catch { u = o.responseText } const d = u.message || u; t.result = d, i(d) } else if (o.status === 403) c = JSON.parse(o.responseText); else try { c = JSON.parse(o.responseText) } catch { c = "Upload failed" } if (c) {
          let u, d = [[c.exc_type, c._error_message].filter(Boolean).join(" ")]; if (c.exc) { u = c.exc; try { u = JSON.parse(u)[0], console.log(u) } catch { } } let f = new Error(d.join(`
`)), h = c._server_messages ? JSON.parse(c._server_messages) : []; h = h.map(p => { try { return JSON.parse(p).message } catch { return p } }).filter(Boolean), h.length || (h = c._error_message ? [c._error_message] : ["Internal Server Error"]), f.message = h.join(`
`), t.error = f, a(f)
        } t.uploading = !1
      }
    }; const s = e.upload_endpoint || "/api/method/upload_file"; o.open("POST", s, !0), o.setRequestHeader("Accept", "application/json"), window.csrf_token && window.csrf_token !== "{{ csrf_token }}" && o.setRequestHeader("X-Frappe-CSRF-Token", window.csrf_token); const l = new FormData; n && l.append("file", n, n.name), l.append("is_private", e.private ? "1" : "0"), l.append("folder", e.folder || "Home"), e.file_url && l.append("file_url", e.file_url), e.doctype && l.append("doctype", e.doctype), e.docname && l.append("docname", e.docname), e.fieldname && l.append("fieldname", e.fieldname), e.method && l.append("method", e.method), e.type && l.append("type", e.type), e.optimize && (l.append("optimize", "1"), e.max_width && l.append("max_width", e.max_width.toString()), e.max_height && l.append("max_height", e.max_height.toString())), o.send(l)
  })
} const YRe = { components: { NodeViewWrapper: lQ, NodeViewContent: vIe }, props: cQ, computed: { selectedLanguage: { get() { return this.node.attrs.language }, set(n) { this.updateAttributes({ language: n }) } }, languages() { return this.extension.options.lowlight.listLanguages().map(e => ({ label: e, value: e })).concat([{ label: "html", value: "xml" }]).sort((e, t) => e.label.localeCompare(t.label)) } } }, ZRe = { class: "code-block-container" }, XRe = ["value"]; function JRe(n, e, t, r, i, a) { const o = Cc("node-view-content"), s = Cc("node-view-wrapper"); return Z(), Ye(s, null, { default: Ue(() => [re("div", ZRe, [Dh(re("select", { class: "language-selector form-select py-0", contenteditable: "false", "onUpdate:modelValue": e[0] || (e[0] = l => a.selectedLanguage = l) }, [e[1] || (e[1] = re("option", { value: null }, "auto", -1)), e[2] || (e[2] = re("option", { disabled: "" }, "", -1)), (Z(!0), ye(Qt, null, Wa(a.languages, (l, c) => (Z(), ye("option", { value: l.value, key: l.value }, Ht(l.label), 9, XRe))), 128))], 512), [[bq, a.selectedLanguage]]), re("pre", null, [re("code", null, [$e(o)])])])]), _: 1 }) } const QRe = yn(YRe, [["render", JRe]]), KQ = { black: "#000000", red: "#dc2626", blue: "#1579D0", green: "#16a34a", yellow: "#ca8a04", orange: "#ea580c", purple: "#9333ea", pink: "#db2777", gray: "#6b7280", indigo: "#4f46e5", teal: "#0d9488", cyan: "#06b6d4" }, qQ = { red: "#fecaca", blue: "#bfdbfe", green: "#bbf7d0", yellow: "#fef08a", orange: "#fed7aa", purple: "#e9d5ff", pink: "#fbcfe8", gray: "#e5e7eb", indigo: "#c7d2fe", teal: "#99f6e4", cyan: "#a5f3fc" }, YQ = { "#1F272E": "gray", "#ca8a04": "yellow", "#ea580c": "orange", "#dc2626": "red", "#16a34a": "green", "#1579D0": "blue", "#9333ea": "purple", "#db2777": "pink" }, ZQ = { "#fef9c3": "yellow", "#ffedd5": "orange", "#fee2e2": "red", "#dcfce7": "green", "#D3E9FC": "blue", "#f3e8ff": "purple", "#fce7f3": "pink" }; function dP(n, e, t, r) { if (r && n.startsWith("#") && r[n]) return r[n]; let i = 0, a = 0, o = 0; if (n.startsWith("#")) { const c = n.substring(1); c.length === 6 && (i = parseInt(c.substring(0, 2), 16), a = parseInt(c.substring(2, 4), 16), o = parseInt(c.substring(4, 6), 16)) } else if (n.startsWith("rgb")) { const c = /rgb\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*\)/i.exec(n); c && (i = parseInt(c[1], 10), a = parseInt(c[2], 10), o = parseInt(c[3], 10)) } if (isNaN(i) || isNaN(a) || isNaN(o)) return null; let s = null, l = 1 / 0; for (const c of e) { const u = t[c]; if (!u) continue; const d = u.startsWith("#") ? u.substring(1) : u; if (d.length !== 6) continue; const f = parseInt(d.substring(0, 2), 16), h = parseInt(d.substring(2, 4), 16), p = parseInt(d.substring(4, 6), 16), m = Math.sqrt(Math.pow(i - f, 2) + Math.pow(a - h, 2) + Math.pow(o - p, 2)); m < l && (l = m, s = c) } return s } function XQ(n, e, t = KQ, r = YQ, i = "color") { const a = Object.keys(t), o = new RegExp(`${i}:\\s*(#[0-9a-f]{6})`, "i").exec(n); if (o && o[1]) { const l = dP(o[1], a, t, r); if (l && e.includes(l)) return l === "gray" ? null : l } const s = new RegExp(`${i}:\\s*(rgb\\(\\s*\\d+\\s*,\\s*\\d+\\s*,\\s*\\d+\\s*\\))`, "i").exec(n); if (s && s[1]) { const l = dP(s[1], a, t, r); if (l && e.includes(l)) return l === "gray" ? null : l } return null } function eNe(n, e) { return XQ(n, e, KQ, YQ, "color") } function tNe(n, e) { return XQ(n, e, qQ, ZQ, "background-color") } const nNe = Bi.create({ name: "namedColor", addOptions() { return { types: ["textStyle"], colors: ["red", "blue", "green", "yellow", "orange", "purple", "pink", "gray", "teal", "cyan"] } }, addGlobalAttributes() { return [{ types: this.options.types, attributes: { color: { default: null, parseHTML: n => { const e = n.getAttribute("style"); if (e) { const t = e.match(/color:\s*var\(--prose-color-(\w+)\)/); if (t && this.options.colors.includes(t[1])) return t[1]; const r = eNe(e, this.options.colors); if (r) return r } return null }, renderHTML: n => !n.color || !this.options.colors.includes(n.color) ? {} : { style: `color: var(--prose-color-${n.color})` } } } }] }, addCommands() { return { setColorByName: n => ({ chain: e, state: t, editor: r }) => { if (!this.options.colors.includes(n)) return console.warn(`Color "${n}" is not in the allowed colors list`), !1; const { to: i, empty: a } = t.selection; let o = e().setMark("textStyle", { color: n }); return a || (o = o.setTextSelection(i).command(({ tr: s }) => (s.setStoredMarks([]), !0))), o.focus().run() }, unsetColor: () => ({ chain: n }) => n().setMark("textStyle", { color: null }).removeEmptyTextStyle().run() } } }); function rNe(n) { var e; const { char: t, allowSpaces: r, allowedPrefixes: i, startOfLine: a, $position: o } = n, s = PEe(t), l = new RegExp(`\\s${s}$`), c = a ? "^" : "", u = r ? new RegExp(`${c}${s}.*?(?=\\s${s}|$)`, "gm") : new RegExp(`${c}(?:^)?${s}[^\\s${s}]*`, "gm"), d = ((e = o.nodeBefore) === null || e === void 0 ? void 0 : e.isText) && o.nodeBefore.text; if (!d) return null; const f = o.pos - d.length, h = Array.from(d.matchAll(u)).pop(); if (!h || h.input === void 0 || h.index === void 0) return null; const p = h.input.slice(Math.max(0, h.index - 1), h.index), m = new RegExp(`^[${i == null ? void 0 : i.join("")}\0]?$`).test(p); if (i !== null && !m) return null; const g = f + h.index; let y = g + h[0].length; return r && l.test(d.slice(y - 1, y + 1)) && (h[0] += " ", y += 1), g < o.pos && y >= o.pos ? { range: { from: g, to: y }, query: h[0].slice(t.length), text: h[0] } : null } const iNe = new xn("suggestion"); function JQ({ pluginKey: n = iNe, editor: e, char: t = "@", allowSpaces: r = !1, allowedPrefixes: i = [" "], startOfLine: a = !1, decorationTag: o = "span", decorationClass: s = "suggestion", command: l = () => null, items: c = () => [], render: u = () => ({}), allow: d = () => !0, findSuggestionMatch: f = rNe }) { let h; const p = u == null ? void 0 : u(), m = new wn({ key: n, view() { return { update: async (g, y) => { var b, w, v, S, x, k, A; const C = (b = this.key) === null || b === void 0 ? void 0 : b.getState(y), E = (w = this.key) === null || w === void 0 ? void 0 : w.getState(g.state), O = C.active && E.active && C.range.from !== E.range.from, j = !C.active && E.active, I = C.active && !E.active, L = !j && !I && C.query !== E.query, R = j || O && L, D = L || O, P = I || O && L; if (!R && !D && !P) return; const B = P && !R ? C : E, F = g.dom.querySelector(`[data-decoration-id="${B.decorationId}"]`); h = { editor: e, range: B.range, query: B.query, text: B.text, items: [], command: K => l({ editor: e, range: B.range, props: K }), decorationNode: F, clientRect: F ? () => { var K; const { decorationId: V } = (K = this.key) === null || K === void 0 ? void 0 : K.getState(e.state), W = g.dom.querySelector(`[data-decoration-id="${V}"]`); return (W == null ? void 0 : W.getBoundingClientRect()) || null } : null }, R && ((v = p == null ? void 0 : p.onBeforeStart) === null || v === void 0 || v.call(p, h)), D && ((S = p == null ? void 0 : p.onBeforeUpdate) === null || S === void 0 || S.call(p, h)), (D || R) && (h.items = await c({ editor: e, query: B.query })), P && ((x = p == null ? void 0 : p.onExit) === null || x === void 0 || x.call(p, h)), D && ((k = p == null ? void 0 : p.onUpdate) === null || k === void 0 || k.call(p, h)), R && ((A = p == null ? void 0 : p.onStart) === null || A === void 0 || A.call(p, h)) }, destroy: () => { var g; h && ((g = p == null ? void 0 : p.onExit) === null || g === void 0 || g.call(p, h)) } } }, state: { init() { return { active: !1, range: { from: 0, to: 0 }, query: null, text: null, composing: !1 } }, apply(g, y, b, w) { const { isEditable: v } = e, { composing: S } = e.view, { selection: x } = g, { empty: k, from: A } = x, C = { ...y }; if (C.composing = S, v && (k || e.view.composing)) { (A < y.range.from || A > y.range.to) && !S && !y.composing && (C.active = !1); const E = f({ char: t, allowSpaces: r, allowedPrefixes: i, startOfLine: a, $position: x.$from }), O = `id_${Math.floor(Math.random() * 4294967295)}`; E && d({ editor: e, state: w, range: E.range, isActive: y.active }) ? (C.active = !0, C.decorationId = y.decorationId ? y.decorationId : O, C.range = E.range, C.query = E.query, C.text = E.text) : C.active = !1 } else C.active = !1; return C.active || (C.decorationId = null, C.range = { from: 0, to: 0 }, C.query = null, C.text = null), C } }, props: { handleKeyDown(g, y) { var b; const { active: w, range: v } = m.getState(g.state); return w && ((b = p == null ? void 0 : p.onKeyDown) === null || b === void 0 ? void 0 : b.call(p, { view: g, event: y, range: v })) || !1 }, decorations(g) { const { active: y, range: b, decorationId: w } = m.getState(g); return y ? Xn.create(g.doc, [di.inline(b.from, b.to, { nodeName: o, class: s, "data-decoration-id": w })]) : null } } }); return m } function oN(n) { return Bi.create({ name: n.name, addOptions() { return { ...n.addOptions ? n.addOptions.call(this) : {}, suggestion: { char: n.char, pluginKey: n.pluginKey, items: n.items, command: n.command, allowSpaces: n.allowSpaces, startOfLine: n.startOfLine, decorationTag: n.decorationTag || "span", decorationClass: n.decorationClass || "suggestion", render: () => { let t, r; return { onStart: i => { if (t = new eN(n.component, { editor: i.editor, props: i }), !i.clientRect || !t.element) return; const a = { getReferenceClientRect: i.clientRect, appendTo: () => document.body, content: t.element, showOnCreate: !0, interactive: !0, trigger: "manual", placement: "bottom-start" }; r = zc("body", { ...a, ...n.tippyOptions }) }, onUpdate(i) { t == null || t.updateProps(i), i.clientRect && r && r[0] && r[0].setProps({ getReferenceClientRect: i.clientRect }) }, onKeyDown(i) { return i.event.key === "Escape" ? (r && r[0] && r[0].hide(), !0) : t && t.ref && typeof t.ref.onKeyDown == "function" ? t.ref.onKeyDown(i) : !1 }, onExit() { r && r[0] && r[0].destroy(), t && t.destroy(), r = null, t = null } } } } } }, addProseMirrorPlugins() { return [JQ({ editor: this.editor, ...this.options.suggestion })] } }) } const aNe = ["onClick", "onMouseover"], oNe = { key: 0, class: "px-3 py-1.5 text-sm text-ink-gray-5" }, sN = We({ __name: "SuggestionList", props: { items: { type: Array, required: !0 }, command: { type: Function, required: !0 }, containerClass: { type: String, default: "" }, itemClass: { type: String, default: "" }, showNoResults: { type: Boolean, default: !1 } }, setup(n, { expose: e }) { const t = n, r = he(0), i = he(null), a = he([]); IL(() => { a.value = [] }); const o = () => { Pr(() => { const f = a.value[r.value]; f && f.scrollIntoView({ block: "nearest" }) }) }, s = f => { const h = t.items[f]; h && t.command(h) }, l = ({ event: f }) => t.items.length ? f.key === "ArrowUp" ? (c(), !0) : f.key === "ArrowDown" ? (u(), !0) : f.key === "Enter" ? (d(), !0) : !1 : !1, c = () => { r.value = (r.value + t.items.length - 1) % t.items.length, o() }, u = () => { r.value = (r.value + 1) % t.items.length, o() }, d = () => { s(r.value) }; return Ct(() => t.items, () => { r.value = 0 }), e({ onKeyDown: l }), (f, h) => n.items.length ? (Z(), ye("div", { key: 0, ref_key: "container", ref: i, class: Tt(["relative max-h-[300px] min-w-40 overflow-y-auto rounded-lg bg-surface-white p-1 text-base shadow-lg", n.containerClass]) }, [(Z(!0), ye(Qt, null, Wa(n.items, (p, m) => (Z(), ye("button", { key: m, ref_for: !0, ref: g => { g && (a.value[m] = g) }, class: Tt(["flex w-full items-center whitespace-nowrap rounded-md px-2 py-1.5 text-sm text-ink-gray-9", m === r.value ? "bg-surface-gray-2" : "", n.itemClass]), onClick: g => s(m), onMouseover: g => r.value = m }, [ut(f.$slots, "default", { item: p, index: m }, () => [re("span", null, Ht(p.display || p.title || p.name), 1)])], 42, aNe))), 128)), !n.items.length && n.showNoResults ? (Z(), ye("div", oNe, " No results ")) : mt("", !0)], 2)) : mt("", !0) } }), sNe = { class: "mr-2" }, lNe = We({ __name: "EmojiList", props: { items: { type: Array, required: !0 }, editor: { type: Object, required: !0 }, range: { type: Object, required: !0 }, command: { type: Function, required: !0 } }, setup(n, { expose: e }) { const t = n, r = he(null), i = o => { o && t.command(o) }; return e({ onKeyDown: ({ event: o }) => { var s; return ((s = r.value) == null ? void 0 : s.onKeyDown({ event: o })) ?? !1 } }), (o, s) => (Z(), Ye(sN, { ref_key: "suggestionList", ref: r, items: n.items, command: l => i(l), "item-class": "py-2" }, { default: Ue(({ item: l }) => [re("span", sNe, Ht(l.emoji), 1), re("span", null, Ht(l.name), 1)]), _: 1 }, 8, ["items", "command"])) } }), cNe = [{ name: "grinning", emoji: "" }, { name: "grimacing", emoji: "" }, { name: "grin", emoji: "" }, { name: "joy", emoji: "" }, { name: "rofl", emoji: "" }, { name: "smiley", emoji: "" }, { name: "smile", emoji: "" }, { name: "sweat_smile", emoji: "" }, { name: "laughing", emoji: "" }, { name: "innocent", emoji: "" }, { name: "wink", emoji: "" }, { name: "blush", emoji: "" }, { name: "slightly_smiling_face", emoji: "" }, { name: "upside_down_face", emoji: "" }, { name: "relaxed", emoji: "" }, { name: "yum", emoji: "" }, { name: "relieved", emoji: "" }, { name: "heart_eyes", emoji: "" }, { name: "kissing_heart", emoji: "" }, { name: "kissing", emoji: "" }, { name: "kissing_smiling_eyes", emoji: "" }, { name: "kissing_closed_eyes", emoji: "" }, { name: "stuck_out_tongue_winking_eye", emoji: "" }, { name: "stuck_out_tongue_closed_eyes", emoji: "" }, { name: "stuck_out_tongue", emoji: "" }, { name: "money_mouth_face", emoji: "" }, { name: "nerd_face", emoji: "" }, { name: "sunglasses", emoji: "" }, { name: "clown_face", emoji: "" }, { name: "cowboy_hat_face", emoji: "" }, { name: "hugs", emoji: "" }, { name: "smirk", emoji: "" }, { name: "no_mouth", emoji: "" }, { name: "neutral_face", emoji: "" }, { name: "expressionless", emoji: "" }, { name: "unamused", emoji: "" }, { name: "roll_eyes", emoji: "" }, { name: "thinking", emoji: "" }, { name: "lying_face", emoji: "" }, { name: "flushed", emoji: "" }, { name: "disappointed", emoji: "" }, { name: "worried", emoji: "" }, { name: "angry", emoji: "" }, { name: "rage", emoji: "" }, { name: "pensive", emoji: "" }, { name: "confused", emoji: "" }, { name: "slightly_frowning_face", emoji: "" }, { name: "frowning_face", emoji: "" }, { name: "persevere", emoji: "" }, { name: "confounded", emoji: "" }, { name: "tired_face", emoji: "" }, { name: "weary", emoji: "" }, { name: "triumph", emoji: "" }, { name: "open_mouth", emoji: "" }, { name: "scream", emoji: "" }, { name: "fearful", emoji: "" }, { name: "cold_sweat", emoji: "" }, { name: "hushed", emoji: "" }, { name: "frowning_with_open_mouth", emoji: "" }, { name: "anguished", emoji: "" }, { name: "cry", emoji: "" }, { name: "disappointed_relieved", emoji: "" }, { name: "drooling_face", emoji: "" }, { name: "sleepy", emoji: "" }, { name: "sweat", emoji: "" }, { name: "sob", emoji: "" }, { name: "dizzy_face", emoji: "" }, { name: "astonished", emoji: "" }, { name: "zipper_mouth_face", emoji: "" }, { name: "nauseated_face", emoji: "" }, { name: "sneezing_face", emoji: "" }, { name: "mask", emoji: "" }, { name: "face_with_thermometer", emoji: "" }, { name: "face_with_head_bandage", emoji: "" }, { name: "sleeping", emoji: "" }, { name: "zzz", emoji: "" }, { name: "poop", emoji: "" }, { name: "smiling_imp", emoji: "" }, { name: "imp", emoji: "" }, { name: "japanese_ogre", emoji: "" }, { name: "japanese_goblin", emoji: "" }, { name: "skull", emoji: "" }, { name: "ghost", emoji: "" }, { name: "alien", emoji: "" }, { name: "robot", emoji: "" }, { name: "smiley_cat", emoji: "" }, { name: "smile_cat", emoji: "" }, { name: "joy_cat", emoji: "" }, { name: "heart_eyes_cat", emoji: "" }, { name: "smirk_cat", emoji: "" }, { name: "kissing_cat", emoji: "" }, { name: "scream_cat", emoji: "" }, { name: "crying_cat_face", emoji: "" }, { name: "pouting_cat", emoji: "" }, { name: "raised_hands", emoji: "" }, { name: "clap", emoji: "" }, { name: "wave", emoji: "" }, { name: "call_me_hand", emoji: "" }, { name: "+1", emoji: "" }, { name: "-1", emoji: "" }, { name: "facepunch", emoji: "" }, { name: "fist", emoji: "" }, { name: "fist_left", emoji: "" }, { name: "fist_right", emoji: "" }, { name: "v", emoji: "" }, { name: "ok_hand", emoji: "" }, { name: "raised_hand", emoji: "" }, { name: "raised_back_of_hand", emoji: "" }, { name: "open_hands", emoji: "" }, { name: "muscle", emoji: "" }, { name: "pray", emoji: "" }, { name: "handshake", emoji: "" }, { name: "point_up", emoji: "" }, { name: "point_up_2", emoji: "" }, { name: "point_down", emoji: "" }, { name: "point_left", emoji: "" }, { name: "point_right", emoji: "" }, { name: "fu", emoji: "" }, { name: "raised_hand_with_fingers_splayed", emoji: "" }, { name: "metal", emoji: "" }, { name: "crossed_fingers", emoji: "" }, { name: "vulcan_salute", emoji: "" }, { name: "writing_hand", emoji: "" }, { name: "selfie", emoji: "" }, { name: "nail_care", emoji: "" }, { name: "lips", emoji: "" }, { name: "tongue", emoji: "" }, { name: "ear", emoji: "" }, { name: "nose", emoji: "" }, { name: "eye", emoji: "" }, { name: "eyes", emoji: "" }, { name: "bust_in_silhouette", emoji: "" }, { name: "busts_in_silhouette", emoji: "" }, { name: "speaking_head", emoji: "" }, { name: "baby", emoji: "" }, { name: "boy", emoji: "" }, { name: "girl", emoji: "" }, { name: "man", emoji: "" }, { name: "woman", emoji: "" }, { name: "blonde_woman", emoji: "" }, { name: "blonde_man", emoji: "" }, { name: "older_man", emoji: "" }, { name: "older_woman", emoji: "" }, { name: "man_with_gua_pi_mao", emoji: "" }, { name: "woman_with_turban", emoji: "" }, { name: "man_with_turban", emoji: "" }, { name: "policewoman", emoji: "" }, { name: "policeman", emoji: "" }, { name: "construction_worker_woman", emoji: "" }, { name: "construction_worker_man", emoji: "" }, { name: "guardswoman", emoji: "" }, { name: "guardsman", emoji: "" }, { name: "female_detective", emoji: "" }, { name: "male_detective", emoji: "" }, { name: "woman_health_worker", emoji: "" }, { name: "man_health_worker", emoji: "" }, { name: "woman_farmer", emoji: "" }, { name: "man_farmer", emoji: "" }, { name: "woman_cook", emoji: "" }, { name: "man_cook", emoji: "" }, { name: "woman_student", emoji: "" }, { name: "man_student", emoji: "" }, { name: "woman_singer", emoji: "" }, { name: "man_singer", emoji: "" }, { name: "woman_teacher", emoji: "" }, { name: "man_teacher", emoji: "" }, { name: "woman_factory_worker", emoji: "" }, { name: "man_factory_worker", emoji: "" }, { name: "woman_technologist", emoji: "" }, { name: "man_technologist", emoji: "" }, { name: "woman_office_worker", emoji: "" }, { name: "man_office_worker", emoji: "" }, { name: "woman_mechanic", emoji: "" }, { name: "man_mechanic", emoji: "" }, { name: "woman_scientist", emoji: "" }, { name: "man_scientist", emoji: "" }, { name: "woman_artist", emoji: "" }, { name: "man_artist", emoji: "" }, { name: "woman_firefighter", emoji: "" }, { name: "man_firefighter", emoji: "" }, { name: "woman_pilot", emoji: "" }, { name: "man_pilot", emoji: "" }, { name: "woman_astronaut", emoji: "" }, { name: "man_astronaut", emoji: "" }, { name: "woman_judge", emoji: "" }, { name: "man_judge", emoji: "" }, { name: "mrs_claus", emoji: "" }, { name: "santa", emoji: "" }, { name: "angel", emoji: "" }, { name: "pregnant_woman", emoji: "" }, { name: "princess", emoji: "" }, { name: "prince", emoji: "" }, { name: "bride_with_veil", emoji: "" }, { name: "person_in_tuxedo", emoji: "" }, { name: "running_woman", emoji: "" }, { name: "running_man", emoji: "" }, { name: "walking_woman", emoji: "" }, { name: "walking_man", emoji: "" }, { name: "dancer", emoji: "" }, { name: "man_dancing", emoji: "" }, { name: "dancing_women", emoji: "" }, { name: "dancing_men", emoji: "" }, { name: "couple", emoji: "" }, { name: "two_men_holding_hands", emoji: "" }, { name: "two_women_holding_hands", emoji: "" }, { name: "bowing_woman", emoji: "" }, { name: "bowing_man", emoji: "" }, { name: "man_facepalming", emoji: "" }, { name: "woman_facepalming", emoji: "" }, { name: "woman_shrugging", emoji: "" }, { name: "man_shrugging", emoji: "" }, { name: "tipping_hand_woman", emoji: "" }, { name: "tipping_hand_man", emoji: "" }, { name: "no_good_woman", emoji: "" }, { name: "no_good_man", emoji: "" }, { name: "ok_woman", emoji: "" }, { name: "ok_man", emoji: "" }, { name: "raising_hand_woman", emoji: "" }, { name: "raising_hand_man", emoji: "" }, { name: "pouting_woman", emoji: "" }, { name: "pouting_man", emoji: "" }, { name: "frowning_woman", emoji: "" }, { name: "frowning_man", emoji: "" }, { name: "haircut_woman", emoji: "" }, { name: "haircut_man", emoji: "" }, { name: "massage_woman", emoji: "" }, { name: "massage_man", emoji: "" }, { name: "couple_with_heart", emoji: "" }, { name: "couple_with_heart_woman_woman", emoji: "" }, { name: "couple_with_heart_man_man", emoji: "" }, { name: "couplekiss_man_woman", emoji: "" }, { name: "couplekiss_woman_woman", emoji: "" }, { name: "couplekiss_man_man", emoji: "" }, { name: "family", emoji: "" }, { name: "family_man_woman_girl", emoji: "" }, { name: "family_man_woman_girl_boy", emoji: "" }, { name: "family_man_woman_boy_boy", emoji: "" }, { name: "family_man_woman_girl_girl", emoji: "" }, { name: "family_woman_woman_boy", emoji: "" }, { name: "family_woman_woman_girl", emoji: "" }, { name: "family_woman_woman_girl_boy", emoji: "" }, { name: "family_woman_woman_boy_boy", emoji: "" }, { name: "family_woman_woman_girl_girl", emoji: "" }, { name: "family_man_man_boy", emoji: "" }, { name: "family_man_man_girl", emoji: "" }, { name: "family_man_man_girl_boy", emoji: "" }, { name: "family_man_man_boy_boy", emoji: "" }, { name: "family_man_man_girl_girl", emoji: "" }, { name: "family_woman_boy", emoji: "" }, { name: "family_woman_girl", emoji: "" }, { name: "family_woman_girl_boy", emoji: "" }, { name: "family_woman_boy_boy", emoji: "" }, { name: "family_woman_girl_girl", emoji: "" }, { name: "family_man_boy", emoji: "" }, { name: "family_man_girl", emoji: "" }, { name: "family_man_girl_boy", emoji: "" }, { name: "family_man_boy_boy", emoji: "" }, { name: "family_man_girl_girl", emoji: "" }, { name: "womans_clothes", emoji: "" }, { name: "tshirt", emoji: "" }, { name: "jeans", emoji: "" }, { name: "necktie", emoji: "" }, { name: "dress", emoji: "" }, { name: "bikini", emoji: "" }, { name: "kimono", emoji: "" }, { name: "lipstick", emoji: "" }, { name: "kiss", emoji: "" }, { name: "footprints", emoji: "" }, { name: "high_heel", emoji: "" }, { name: "sandal", emoji: "" }, { name: "boot", emoji: "" }, { name: "mans_shoe", emoji: "" }, { name: "athletic_shoe", emoji: "" }, { name: "womans_hat", emoji: "" }, { name: "tophat", emoji: "" }, { name: "rescue_worker_helmet", emoji: "" }, { name: "mortar_board", emoji: "" }, { name: "crown", emoji: "" }, { name: "school_satchel", emoji: "" }, { name: "pouch", emoji: "" }, { name: "purse", emoji: "" }, { name: "handbag", emoji: "" }, { name: "briefcase", emoji: "" }, { name: "eyeglasses", emoji: "" }, { name: "dark_sunglasses", emoji: "" }, { name: "ring", emoji: "" }, { name: "closed_umbrella", emoji: "" }, { name: "dog", emoji: "" }, { name: "cat", emoji: "" }, { name: "mouse", emoji: "" }, { name: "hamster", emoji: "" }, { name: "rabbit", emoji: "" }, { name: "fox_face", emoji: "" }, { name: "bear", emoji: "" }, { name: "panda_face", emoji: "" }, { name: "koala", emoji: "" }, { name: "tiger", emoji: "" }, { name: "lion", emoji: "" }, { name: "cow", emoji: "" }, { name: "pig", emoji: "" }, { name: "pig_nose", emoji: "" }, { name: "frog", emoji: "" }, { name: "squid", emoji: "" }, { name: "octopus", emoji: "" }, { name: "shrimp", emoji: "" }, { name: "monkey_face", emoji: "" }, { name: "gorilla", emoji: "" }, { name: "see_no_evil", emoji: "" }, { name: "hear_no_evil", emoji: "" }, { name: "speak_no_evil", emoji: "" }, { name: "monkey", emoji: "" }, { name: "chicken", emoji: "" }, { name: "penguin", emoji: "" }, { name: "bird", emoji: "" }, { name: "baby_chick", emoji: "" }, { name: "hatching_chick", emoji: "" }, { name: "hatched_chick", emoji: "" }, { name: "duck", emoji: "" }, { name: "eagle", emoji: "" }, { name: "owl", emoji: "" }, { name: "bat", emoji: "" }, { name: "wolf", emoji: "" }, { name: "boar", emoji: "" }, { name: "horse", emoji: "" }, { name: "unicorn", emoji: "" }, { name: "honeybee", emoji: "" }, { name: "bug", emoji: "" }, { name: "butterfly", emoji: "" }, { name: "snail", emoji: "" }, { name: "lady_beetle", emoji: "" }, { name: "ant", emoji: "" }, { name: "spider", emoji: "" }, { name: "scorpion", emoji: "" }, { name: "crab", emoji: "" }, { name: "snake", emoji: "" }, { name: "lizard", emoji: "" }, { name: "turtle", emoji: "" }, { name: "tropical_fish", emoji: "" }, { name: "fish", emoji: "" }, { name: "blowfish", emoji: "" }, { name: "dolphin", emoji: "" }, { name: "shark", emoji: "" }, { name: "whale", emoji: "" }, { name: "whale2", emoji: "" }, { name: "crocodile", emoji: "" }, { name: "leopard", emoji: "" }, { name: "tiger2", emoji: "" }, { name: "water_buffalo", emoji: "" }, { name: "ox", emoji: "" }, { name: "cow2", emoji: "" }, { name: "deer", emoji: "" }, { name: "dromedary_camel", emoji: "" }, { name: "camel", emoji: "" }, { name: "elephant", emoji: "" }, { name: "rhinoceros", emoji: "" }, { name: "goat", emoji: "" }, { name: "ram", emoji: "" }, { name: "sheep", emoji: "" }, { name: "racehorse", emoji: "" }, { name: "pig2", emoji: "" }, { name: "rat", emoji: "" }, { name: "mouse2", emoji: "" }, { name: "rooster", emoji: "" }, { name: "turkey", emoji: "" }, { name: "dove", emoji: "" }, { name: "dog2", emoji: "" }, { name: "poodle", emoji: "" }, { name: "cat2", emoji: "" }, { name: "rabbit2", emoji: "" }, { name: "chipmunk", emoji: "" }, { name: "paw_prints", emoji: "" }, { name: "dragon", emoji: "" }, { name: "dragon_face", emoji: "" }, { name: "cactus", emoji: "" }, { name: "christmas_tree", emoji: "" }, { name: "evergreen_tree", emoji: "" }, { name: "deciduous_tree", emoji: "" }, { name: "palm_tree", emoji: "" }, { name: "seedling", emoji: "" }, { name: "herb", emoji: "" }, { name: "shamrock", emoji: "" }, { name: "four_leaf_clover", emoji: "" }, { name: "bamboo", emoji: "" }, { name: "tanabata_tree", emoji: "" }, { name: "leaves", emoji: "" }, { name: "fallen_leaf", emoji: "" }, { name: "maple_leaf", emoji: "" }, { name: "ear_of_rice", emoji: "" }, { name: "hibiscus", emoji: "" }, { name: "sunflower", emoji: "" }, { name: "rose", emoji: "" }, { name: "wilted_flower", emoji: "" }, { name: "tulip", emoji: "" }, { name: "blossom", emoji: "" }, { name: "cherry_blossom", emoji: "" }, { name: "bouquet", emoji: "" }, { name: "mushroom", emoji: "" }, { name: "chestnut", emoji: "" }, { name: "jack_o_lantern", emoji: "" }, { name: "shell", emoji: "" }, { name: "spider_web", emoji: "" }, { name: "earth_americas", emoji: "" }, { name: "earth_africa", emoji: "" }, { name: "earth_asia", emoji: "" }, { name: "full_moon", emoji: "" }, { name: "waning_gibbous_moon", emoji: "" }, { name: "last_quarter_moon", emoji: "" }, { name: "waning_crescent_moon", emoji: "" }, { name: "new_moon", emoji: "" }, { name: "waxing_crescent_moon", emoji: "" }, { name: "first_quarter_moon", emoji: "" }, { name: "waxing_gibbous_moon", emoji: "" }, { name: "new_moon_with_face", emoji: "" }, { name: "full_moon_with_face", emoji: "" }, { name: "first_quarter_moon_with_face", emoji: "" }, { name: "last_quarter_moon_with_face", emoji: "" }, { name: "sun_with_face", emoji: "" }, { name: "crescent_moon", emoji: "" }, { name: "star", emoji: "" }, { name: "star2", emoji: "" }, { name: "dizzy", emoji: "" }, { name: "sparkles", emoji: "" }, { name: "comet", emoji: "" }, { name: "sunny", emoji: "" }, { name: "sun_behind_small_cloud", emoji: "" }, { name: "partly_sunny", emoji: "" }, { name: "sun_behind_large_cloud", emoji: "" }, { name: "sun_behind_rain_cloud", emoji: "" }, { name: "cloud", emoji: "" }, { name: "cloud_with_rain", emoji: "" }, { name: "cloud_with_lightning_and_rain", emoji: "" }, { name: "cloud_with_lightning", emoji: "" }, { name: "zap", emoji: "" }, { name: "fire", emoji: "" }, { name: "boom", emoji: "" }, { name: "snowflake", emoji: "" }, { name: "cloud_with_snow", emoji: "" }, { name: "snowman", emoji: "" }, { name: "snowman_with_snow", emoji: "" }, { name: "wind_face", emoji: "" }, { name: "dash", emoji: "" }, { name: "tornado", emoji: "" }, { name: "fog", emoji: "" }, { name: "open_umbrella", emoji: "" }, { name: "umbrella", emoji: "" }, { name: "droplet", emoji: "" }, { name: "sweat_drops", emoji: "" }, { name: "ocean", emoji: "" }, { name: "green_apple", emoji: "" }, { name: "apple", emoji: "" }, { name: "pear", emoji: "" }, { name: "tangerine", emoji: "" }, { name: "lemon", emoji: "" }, { name: "banana", emoji: "" }, { name: "watermelon", emoji: "" }, { name: "grapes", emoji: "" }, { name: "strawberry", emoji: "" }, { name: "melon", emoji: "" }, { name: "cherries", emoji: "" }, { name: "peach", emoji: "" }, { name: "pineapple", emoji: "" }, { name: "kiwi_fruit", emoji: "" }, { name: "avocado", emoji: "" }, { name: "tomato", emoji: "" }, { name: "eggplant", emoji: "" }, { name: "cucumber", emoji: "" }, { name: "carrot", emoji: "" }, { name: "hot_pepper", emoji: "" }, { name: "potato", emoji: "" }, { name: "corn", emoji: "" }, { name: "sweet_potato", emoji: "" }, { name: "peanuts", emoji: "" }, { name: "honey_pot", emoji: "" }, { name: "croissant", emoji: "" }, { name: "bread", emoji: "" }, { name: "baguette_bread", emoji: "" }, { name: "cheese", emoji: "" }, { name: "egg", emoji: "" }, { name: "bacon", emoji: "" }, { name: "pancakes", emoji: "" }, { name: "poultry_leg", emoji: "" }, { name: "meat_on_bone", emoji: "" }, { name: "fried_shrimp", emoji: "" }, { name: "fried_egg", emoji: "" }, { name: "hamburger", emoji: "" }, { name: "fries", emoji: "" }, { name: "stuffed_flatbread", emoji: "" }, { name: "hotdog", emoji: "" }, { name: "pizza", emoji: "" }, { name: "spaghetti", emoji: "" }, { name: "taco", emoji: "" }, { name: "burrito", emoji: "" }, { name: "green_salad", emoji: "" }, { name: "shallow_pan_of_food", emoji: "" }, { name: "ramen", emoji: "" }, { name: "stew", emoji: "" }, { name: "fish_cake", emoji: "" }, { name: "sushi", emoji: "" }, { name: "bento", emoji: "" }, { name: "curry", emoji: "" }, { name: "rice_ball", emoji: "" }, { name: "rice", emoji: "" }, { name: "rice_cracker", emoji: "" }, { name: "oden", emoji: "" }, { name: "dango", emoji: "" }, { name: "shaved_ice", emoji: "" }, { name: "ice_cream", emoji: "" }, { name: "icecream", emoji: "" }, { name: "cake", emoji: "" }, { name: "birthday", emoji: "" }, { name: "custard", emoji: "" }, { name: "candy", emoji: "" }, { name: "lollipop", emoji: "" }, { name: "chocolate_bar", emoji: "" }, { name: "popcorn", emoji: "" }, { name: "doughnut", emoji: "" }, { name: "cookie", emoji: "" }, { name: "milk_glass", emoji: "" }, { name: "beer", emoji: "" }, { name: "beers", emoji: "" }, { name: "clinking_glasses", emoji: "" }, { name: "wine_glass", emoji: "" }, { name: "tumbler_glass", emoji: "" }, { name: "cocktail", emoji: "" }, { name: "tropical_drink", emoji: "" }, { name: "champagne", emoji: "" }, { name: "sake", emoji: "" }, { name: "tea", emoji: "" }, { name: "coffee", emoji: "" }, { name: "baby_bottle", emoji: "" }, { name: "spoon", emoji: "" }, { name: "fork_and_knife", emoji: "" }, { name: "plate_with_cutlery", emoji: "" }, { name: "soccer", emoji: "" }, { name: "basketball", emoji: "" }, { name: "football", emoji: "" }, { name: "baseball", emoji: "" }, { name: "tennis", emoji: "" }, { name: "volleyball", emoji: "" }, { name: "rugby_football", emoji: "" }, { name: "8ball", emoji: "" }, { name: "golf", emoji: "" }, { name: "golfing_woman", emoji: "" }, { name: "golfing_man", emoji: "" }, { name: "ping_pong", emoji: "" }, { name: "badminton", emoji: "" }, { name: "goal_net", emoji: "" }, { name: "ice_hockey", emoji: "" }, { name: "field_hockey", emoji: "" }, { name: "cricket_bat_and_ball", emoji: "" }, { name: "ski", emoji: "" }, { name: "skier", emoji: "" }, { name: "snowboarder", emoji: "" }, { name: "person_fencing", emoji: "" }, { name: "women_wrestling", emoji: "" }, { name: "men_wrestling", emoji: "" }, { name: "woman_cartwheeling", emoji: "" }, { name: "man_cartwheeling", emoji: "" }, { name: "woman_playing_handball", emoji: "" }, { name: "man_playing_handball", emoji: "" }, { name: "ice_skate", emoji: "" }, { name: "bow_and_arrow", emoji: "" }, { name: "fishing_pole_and_fish", emoji: "" }, { name: "boxing_glove", emoji: "" }, { name: "martial_arts_uniform", emoji: "" }, { name: "rowing_woman", emoji: "" }, { name: "rowing_man", emoji: "" }, { name: "swimming_woman", emoji: "" }, { name: "swimming_man", emoji: "" }, { name: "woman_playing_water_polo", emoji: "" }, { name: "man_playing_water_polo", emoji: "" }, { name: "surfing_woman", emoji: "" }, { name: "surfing_man", emoji: "" }, { name: "bath", emoji: "" }, { name: "basketball_woman", emoji: "" }, { name: "basketball_man", emoji: "" }, { name: "weight_lifting_woman", emoji: "" }, { name: "weight_lifting_man", emoji: "" }, { name: "biking_woman", emoji: "" }, { name: "biking_man", emoji: "" }, { name: "mountain_biking_woman", emoji: "" }, { name: "mountain_biking_man", emoji: "" }, { name: "horse_racing", emoji: "" }, { name: "business_suit_levitating", emoji: "" }, { name: "trophy", emoji: "" }, { name: "running_shirt_with_sash", emoji: "" }, { name: "medal_sports", emoji: "" }, { name: "medal_military", emoji: "" }, { name: "1st_place_medal", emoji: "" }, { name: "2nd_place_medal", emoji: "" }, { name: "3rd_place_medal", emoji: "" }, { name: "reminder_ribbon", emoji: "" }, { name: "rosette", emoji: "" }, { name: "ticket", emoji: "" }, { name: "tickets", emoji: "" }, { name: "performing_arts", emoji: "" }, { name: "art", emoji: "" }, { name: "circus_tent", emoji: "" }, { name: "woman_juggling", emoji: "" }, { name: "man_juggling", emoji: "" }, { name: "microphone", emoji: "" }, { name: "headphones", emoji: "" }, { name: "musical_score", emoji: "" }, { name: "musical_keyboard", emoji: "" }, { name: "drum", emoji: "" }, { name: "saxophone", emoji: "" }, { name: "trumpet", emoji: "" }, { name: "guitar", emoji: "" }, { name: "violin", emoji: "" }, { name: "clapper", emoji: "" }, { name: "video_game", emoji: "" }, { name: "space_invader", emoji: "" }, { name: "dart", emoji: "" }, { name: "game_die", emoji: "" }, { name: "slot_machine", emoji: "" }, { name: "bowling", emoji: "" }, { name: "red_car", emoji: "" }, { name: "taxi", emoji: "" }, { name: "blue_car", emoji: "" }, { name: "bus", emoji: "" }, { name: "trolleybus", emoji: "" }, { name: "racing_car", emoji: "" }, { name: "police_car", emoji: "" }, { name: "ambulance", emoji: "" }, { name: "fire_engine", emoji: "" }, { name: "minibus", emoji: "" }, { name: "truck", emoji: "" }, { name: "articulated_lorry", emoji: "" }, { name: "tractor", emoji: "" }, { name: "kick_scooter", emoji: "" }, { name: "motorcycle", emoji: "" }, { name: "bike", emoji: "" }, { name: "motor_scooter", emoji: "" }, { name: "rotating_light", emoji: "" }, { name: "oncoming_police_car", emoji: "" }, { name: "oncoming_bus", emoji: "" }, { name: "oncoming_automobile", emoji: "" }, { name: "oncoming_taxi", emoji: "" }, { name: "aerial_tramway", emoji: "" }, { name: "mountain_cableway", emoji: "" }, { name: "suspension_railway", emoji: "" }, { name: "railway_car", emoji: "" }, { name: "train", emoji: "" }, { name: "monorail", emoji: "" }, { name: "bullettrain_side", emoji: "" }, { name: "bullettrain_front", emoji: "" }, { name: "light_rail", emoji: "" }, { name: "mountain_railway", emoji: "" }, { name: "steam_locomotive", emoji: "" }, { name: "train2", emoji: "" }, { name: "metro", emoji: "" }, { name: "tram", emoji: "" }, { name: "station", emoji: "" }, { name: "helicopter", emoji: "" }, { name: "small_airplane", emoji: "" }, { name: "airplane", emoji: "" }, { name: "flight_departure", emoji: "" }, { name: "flight_arrival", emoji: "" }, { name: "sailboat", emoji: "" }, { name: "motor_boat", emoji: "" }, { name: "speedboat", emoji: "" }, { name: "ferry", emoji: "" }, { name: "passenger_ship", emoji: "" }, { name: "rocket", emoji: "" }, { name: "artificial_satellite", emoji: "" }, { name: "seat", emoji: "" }, { name: "canoe", emoji: "" }, { name: "anchor", emoji: "" }, { name: "construction", emoji: "" }, { name: "fuelpump", emoji: "" }, { name: "busstop", emoji: "" }, { name: "vertical_traffic_light", emoji: "" }, { name: "traffic_light", emoji: "" }, { name: "checkered_flag", emoji: "" }, { name: "ship", emoji: "" }, { name: "ferris_wheel", emoji: "" }, { name: "roller_coaster", emoji: "" }, { name: "carousel_horse", emoji: "" }, { name: "building_construction", emoji: "" }, { name: "foggy", emoji: "" }, { name: "tokyo_tower", emoji: "" }, { name: "factory", emoji: "" }, { name: "fountain", emoji: "" }, { name: "rice_scene", emoji: "" }, { name: "mountain", emoji: "" }, { name: "mountain_snow", emoji: "" }, { name: "mount_fuji", emoji: "" }, { name: "volcano", emoji: "" }, { name: "japan", emoji: "" }, { name: "camping", emoji: "" }, { name: "tent", emoji: "" }, { name: "national_park", emoji: "" }, { name: "motorway", emoji: "" }, { name: "railway_track", emoji: "" }, { name: "sunrise", emoji: "" }, { name: "sunrise_over_mountains", emoji: "" }, { name: "desert", emoji: "" }, { name: "beach_umbrella", emoji: "" }, { name: "desert_island", emoji: "" }, { name: "city_sunrise", emoji: "" }, { name: "city_sunset", emoji: "" }, { name: "cityscape", emoji: "" }, { name: "night_with_stars", emoji: "" }, { name: "bridge_at_night", emoji: "" }, { name: "milky_way", emoji: "" }, { name: "stars", emoji: "" }, { name: "sparkler", emoji: "" }, { name: "fireworks", emoji: "" }, { name: "rainbow", emoji: "" }, { name: "houses", emoji: "" }, { name: "european_castle", emoji: "" }, { name: "japanese_castle", emoji: "" }, { name: "stadium", emoji: "" }, { name: "statue_of_liberty", emoji: "" }, { name: "house", emoji: "" }, { name: "house_with_garden", emoji: "" }, { name: "derelict_house", emoji: "" }, { name: "office", emoji: "" }, { name: "department_store", emoji: "" }, { name: "post_office", emoji: "" }, { name: "european_post_office", emoji: "" }, { name: "hospital", emoji: "" }, { name: "bank", emoji: "" }, { name: "hotel", emoji: "" }, { name: "convenience_store", emoji: "" }, { name: "school", emoji: "" }, { name: "love_hotel", emoji: "" }, { name: "wedding", emoji: "" }, { name: "classical_building", emoji: "" }, { name: "church", emoji: "" }, { name: "mosque", emoji: "" }, { name: "synagogue", emoji: "" }, { name: "kaaba", emoji: "" }, { name: "shinto_shrine", emoji: "" }, { name: "watch", emoji: "" }, { name: "iphone", emoji: "" }, { name: "calling", emoji: "" }, { name: "computer", emoji: "" }, { name: "keyboard", emoji: "" }, { name: "desktop_computer", emoji: "" }, { name: "printer", emoji: "" }, { name: "computer_mouse", emoji: "" }, { name: "trackball", emoji: "" }, { name: "joystick", emoji: "" }, { name: "clamp", emoji: "" }, { name: "minidisc", emoji: "" }, { name: "floppy_disk", emoji: "" }, { name: "cd", emoji: "" }, { name: "dvd", emoji: "" }, { name: "vhs", emoji: "" }, { name: "camera", emoji: "" }, { name: "camera_flash", emoji: "" }, { name: "video_camera", emoji: "" }, { name: "movie_camera", emoji: "" }, { name: "film_projector", emoji: "" }, { name: "film_strip", emoji: "" }, { name: "telephone_receiver", emoji: "" }, { name: "phone", emoji: "" }, { name: "pager", emoji: "" }, { name: "fax", emoji: "" }, { name: "tv", emoji: "" }, { name: "radio", emoji: "" }, { name: "studio_microphone", emoji: "" }, { name: "level_slider", emoji: "" }, { name: "control_knobs", emoji: "" }, { name: "stopwatch", emoji: "" }, { name: "timer_clock", emoji: "" }, { name: "alarm_clock", emoji: "" }, { name: "mantelpiece_clock", emoji: "" }, { name: "hourglass_flowing_sand", emoji: "" }, { name: "hourglass", emoji: "" }, { name: "satellite", emoji: "" }, { name: "battery", emoji: "" }, { name: "electric_plug", emoji: "" }, { name: "bulb", emoji: "" }, { name: "flashlight", emoji: "" }, { name: "candle", emoji: "" }, { name: "wastebasket", emoji: "" }, { name: "oil_drum", emoji: "" }, { name: "money_with_wings", emoji: "" }, { name: "dollar", emoji: "" }, { name: "yen", emoji: "" }, { name: "euro", emoji: "" }, { name: "pound", emoji: "" }, { name: "moneybag", emoji: "" }, { name: "credit_card", emoji: "" }, { name: "gem", emoji: "" }, { name: "balance_scale", emoji: "" }, { name: "wrench", emoji: "" }, { name: "hammer", emoji: "" }, { name: "hammer_and_pick", emoji: "" }, { name: "hammer_and_wrench", emoji: "" }, { name: "pick", emoji: "" }, { name: "nut_and_bolt", emoji: "" }, { name: "gear", emoji: "" }, { name: "chains", emoji: "" }, { name: "gun", emoji: "" }, { name: "bomb", emoji: "" }, { name: "hocho", emoji: "" }, { name: "dagger", emoji: "" }, { name: "crossed_swords", emoji: "" }, { name: "shield", emoji: "" }, { name: "smoking", emoji: "" }, { name: "skull_and_crossbones", emoji: "" }, { name: "coffin", emoji: "" }, { name: "funeral_urn", emoji: "" }, { name: "amphora", emoji: "" }, { name: "crystal_ball", emoji: "" }, { name: "prayer_beads", emoji: "" }, { name: "barber", emoji: "" }, { name: "alembic", emoji: "" }, { name: "telescope", emoji: "" }, { name: "microscope", emoji: "" }, { name: "hole", emoji: "" }, { name: "pill", emoji: "" }, { name: "syringe", emoji: "" }, { name: "thermometer", emoji: "" }, { name: "label", emoji: "" }, { name: "bookmark", emoji: "" }, { name: "toilet", emoji: "" }, { name: "shower", emoji: "" }, { name: "bathtub", emoji: "" }, { name: "key", emoji: "" }, { name: "old_key", emoji: "" }, { name: "couch_and_lamp", emoji: "" }, { name: "sleeping_bed", emoji: "" }, { name: "bed", emoji: "" }, { name: "door", emoji: "" }, { name: "bellhop_bell", emoji: "" }, { name: "framed_picture", emoji: "" }, { name: "world_map", emoji: "" }, { name: "parasol_on_ground", emoji: "" }, { name: "moyai", emoji: "" }, { name: "shopping", emoji: "" }, { name: "shopping_cart", emoji: "" }, { name: "balloon", emoji: "" }, { name: "flags", emoji: "" }, { name: "ribbon", emoji: "" }, { name: "gift", emoji: "" }, { name: "confetti_ball", emoji: "" }, { name: "tada", emoji: "" }, { name: "dolls", emoji: "" }, { name: "wind_chime", emoji: "" }, { name: "crossed_flags", emoji: "" }, { name: "izakaya_lantern", emoji: "" }, { name: "email", emoji: "" }, { name: "envelope_with_arrow", emoji: "" }, { name: "incoming_envelope", emoji: "" }, { name: "e-mail", emoji: "" }, { name: "love_letter", emoji: "" }, { name: "postbox", emoji: "" }, { name: "mailbox_closed", emoji: "" }, { name: "mailbox", emoji: "" }, { name: "mailbox_with_mail", emoji: "" }, { name: "mailbox_with_no_mail", emoji: "" }, { name: "package", emoji: "" }, { name: "postal_horn", emoji: "" }, { name: "inbox_tray", emoji: "" }, { name: "outbox_tray", emoji: "" }, { name: "scroll", emoji: "" }, { name: "page_with_curl", emoji: "" }, { name: "bookmark_tabs", emoji: "" }, { name: "bar_chart", emoji: "" }, { name: "chart_with_upwards_trend", emoji: "" }, { name: "chart_with_downwards_trend", emoji: "" }, { name: "page_facing_up", emoji: "" }, { name: "date", emoji: "" }, { name: "calendar", emoji: "" }, { name: "spiral_calendar", emoji: "" }, { name: "card_index", emoji: "" }, { name: "card_file_box", emoji: "" }, { name: "ballot_box", emoji: "" }, { name: "file_cabinet", emoji: "" }, { name: "clipboard", emoji: "" }, { name: "spiral_notepad", emoji: "" }, { name: "file_folder", emoji: "" }, { name: "open_file_folder", emoji: "" }, { name: "card_index_dividers", emoji: "" }, { name: "newspaper_roll", emoji: "" }, { name: "newspaper", emoji: "" }, { name: "notebook", emoji: "" }, { name: "closed_book", emoji: "" }, { name: "green_book", emoji: "" }, { name: "blue_book", emoji: "" }, { name: "orange_book", emoji: "" }, { name: "notebook_with_decorative_cover", emoji: "" }, { name: "ledger", emoji: "" }, { name: "books", emoji: "" }, { name: "open_book", emoji: "" }, { name: "link", emoji: "" }, { name: "paperclip", emoji: "" }, { name: "paperclips", emoji: "" }, { name: "scissors", emoji: "" }, { name: "triangular_ruler", emoji: "" }, { name: "straight_ruler", emoji: "" }, { name: "pushpin", emoji: "" }, { name: "round_pushpin", emoji: "" }, { name: "triangular_flag_on_post", emoji: "" }, { name: "white_flag", emoji: "" }, { name: "black_flag", emoji: "" }, { name: "rainbow_flag", emoji: "" }, { name: "closed_lock_with_key", emoji: "" }, { name: "lock", emoji: "" }, { name: "unlock", emoji: "" }, { name: "lock_with_ink_pen", emoji: "" }, { name: "pen", emoji: "" }, { name: "fountain_pen", emoji: "" }, { name: "black_nib", emoji: "" }, { name: "memo", emoji: "" }, { name: "pencil2", emoji: "" }, { name: "crayon", emoji: "" }, { name: "paintbrush", emoji: "" }, { name: "mag", emoji: "" }, { name: "mag_right", emoji: "" }, { name: "heart", emoji: "" }, { name: "yellow_heart", emoji: "" }, { name: "green_heart", emoji: "" }, { name: "blue_heart", emoji: "" }, { name: "purple_heart", emoji: "" }, { name: "black_heart", emoji: "" }, { name: "broken_heart", emoji: "" }, { name: "heavy_heart_exclamation", emoji: "" }, { name: "two_hearts", emoji: "" }, { name: "revolving_hearts", emoji: "" }, { name: "heartbeat", emoji: "" }, { name: "heartpulse", emoji: "" }, { name: "sparkling_heart", emoji: "" }, { name: "cupid", emoji: "" }, { name: "gift_heart", emoji: "" }, { name: "heart_decoration", emoji: "" }, { name: "peace_symbol", emoji: "" }, { name: "latin_cross", emoji: "" }, { name: "star_and_crescent", emoji: "" }, { name: "om", emoji: "" }, { name: "wheel_of_dharma", emoji: "" }, { name: "star_of_david", emoji: "" }, { name: "six_pointed_star", emoji: "" }, { name: "menorah", emoji: "" }, { name: "yin_yang", emoji: "" }, { name: "orthodox_cross", emoji: "" }, { name: "place_of_worship", emoji: "" }, { name: "ophiuchus", emoji: "" }, { name: "aries", emoji: "" }, { name: "taurus", emoji: "" }, { name: "gemini", emoji: "" }, { name: "cancer", emoji: "" }, { name: "leo", emoji: "" }, { name: "virgo", emoji: "" }, { name: "libra", emoji: "" }, { name: "scorpius", emoji: "" }, { name: "sagittarius", emoji: "" }, { name: "capricorn", emoji: "" }, { name: "aquarius", emoji: "" }, { name: "pisces", emoji: "" }, { name: "id", emoji: "" }, { name: "atom_symbol", emoji: "" }, { name: "u7a7a", emoji: "" }, { name: "u5272", emoji: "" }, { name: "radioactive", emoji: "" }, { name: "biohazard", emoji: "" }, { name: "mobile_phone_off", emoji: "" }, { name: "vibration_mode", emoji: "" }, { name: "u6709", emoji: "" }, { name: "u7121", emoji: "" }, { name: "u7533", emoji: "" }, { name: "u55b6", emoji: "" }, { name: "u6708", emoji: "" }, { name: "eight_pointed_black_star", emoji: "" }, { name: "vs", emoji: "" }, { name: "accept", emoji: "" }, { name: "white_flower", emoji: "" }, { name: "ideograph_advantage", emoji: "" }, { name: "secret", emoji: "" }, { name: "congratulations", emoji: "" }, { name: "u5408", emoji: "" }, { name: "u6e80", emoji: "" }, { name: "u7981", emoji: "" }, { name: "a", emoji: "" }, { name: "b", emoji: "" }, { name: "ab", emoji: "" }, { name: "cl", emoji: "" }, { name: "o2", emoji: "" }, { name: "sos", emoji: "" }, { name: "no_entry", emoji: "" }, { name: "name_badge", emoji: "" }, { name: "no_entry_sign", emoji: "" }, { name: "x", emoji: "" }, { name: "o", emoji: "" }, { name: "stop_sign", emoji: "" }, { name: "anger", emoji: "" }, { name: "hotsprings", emoji: "" }, { name: "no_pedestrians", emoji: "" }, { name: "do_not_litter", emoji: "" }, { name: "no_bicycles", emoji: "" }, { name: "non-potable_water", emoji: "" }, { name: "underage", emoji: "" }, { name: "no_mobile_phones", emoji: "" }, { name: "exclamation", emoji: "" }, { name: "grey_exclamation", emoji: "" }, { name: "question", emoji: "" }, { name: "grey_question", emoji: "" }, { name: "bangbang", emoji: "" }, { name: "interrobang", emoji: "" }, { name: "100", emoji: "" }, { name: "low_brightness", emoji: "" }, { name: "high_brightness", emoji: "" }, { name: "trident", emoji: "" }, { name: "fleur_de_lis", emoji: "" }, { name: "part_alternation_mark", emoji: "" }, { name: "warning", emoji: "" }, { name: "children_crossing", emoji: "" }, { name: "beginner", emoji: "" }, { name: "recycle", emoji: "" }, { name: "u6307", emoji: "" }, { name: "chart", emoji: "" }, { name: "sparkle", emoji: "" }, { name: "eight_spoked_asterisk", emoji: "" }, { name: "negative_squared_cross_mark", emoji: "" }, { name: "white_check_mark", emoji: "" }, { name: "diamond_shape_with_a_dot_inside", emoji: "" }, { name: "cyclone", emoji: "" }, { name: "loop", emoji: "" }, { name: "globe_with_meridians", emoji: "" }, { name: "m", emoji: "" }, { name: "atm", emoji: "" }, { name: "sa", emoji: "" }, { name: "passport_control", emoji: "" }, { name: "customs", emoji: "" }, { name: "baggage_claim", emoji: "" }, { name: "left_luggage", emoji: "" }, { name: "wheelchair", emoji: "" }, { name: "no_smoking", emoji: "" }, { name: "wc", emoji: "" }, { name: "parking", emoji: "" }, { name: "potable_water", emoji: "" }, { name: "mens", emoji: "" }, { name: "womens", emoji: "" }, { name: "baby_symbol", emoji: "" }, { name: "restroom", emoji: "" }, { name: "put_litter_in_its_place", emoji: "" }, { name: "cinema", emoji: "" }, { name: "signal_strength", emoji: "" }, { name: "koko", emoji: "" }, { name: "ng", emoji: "" }, { name: "ok", emoji: "" }, { name: "up", emoji: "" }, { name: "cool", emoji: "" }, { name: "new", emoji: "" }, { name: "free", emoji: "" }, { name: "zero", emoji: "0" }, { name: "one", emoji: "1" }, { name: "two", emoji: "2" }, { name: "three", emoji: "3" }, { name: "four", emoji: "4" }, { name: "five", emoji: "5" }, { name: "six", emoji: "6" }, { name: "seven", emoji: "7" }, { name: "eight", emoji: "8" }, { name: "nine", emoji: "9" }, { name: "keycap_ten", emoji: "" }, { name: "asterisk", emoji: "*" }, { name: "1234", emoji: "" }, { name: "arrow_forward", emoji: "" }, { name: "pause_button", emoji: "" }, { name: "next_track_button", emoji: "" }, { name: "stop_button", emoji: "" }, { name: "record_button", emoji: "" }, { name: "play_or_pause_button", emoji: "" }, { name: "previous_track_button", emoji: "" }, { name: "fast_forward", emoji: "" }, { name: "rewind", emoji: "" }, { name: "twisted_rightwards_arrows", emoji: "" }, { name: "repeat", emoji: "" }, { name: "repeat_one", emoji: "" }, { name: "arrow_backward", emoji: "" }, { name: "arrow_up_small", emoji: "" }, { name: "arrow_down_small", emoji: "" }, { name: "arrow_double_up", emoji: "" }, { name: "arrow_double_down", emoji: "" }, { name: "arrow_right", emoji: "" }, { name: "arrow_left", emoji: "" }, { name: "arrow_up", emoji: "" }, { name: "arrow_down", emoji: "" }, { name: "arrow_upper_right", emoji: "" }, { name: "arrow_lower_right", emoji: "" }, { name: "arrow_lower_left", emoji: "" }, { name: "arrow_upper_left", emoji: "" }, { name: "arrow_up_down", emoji: "" }, { name: "left_right_arrow", emoji: "" }, { name: "arrows_counterclockwise", emoji: "" }, { name: "arrow_right_hook", emoji: "" }, { name: "leftwards_arrow_with_hook", emoji: "" }, { name: "arrow_heading_up", emoji: "" }, { name: "arrow_heading_down", emoji: "" }, { name: "hash", emoji: "#" }, { name: "information_source", emoji: "" }, { name: "abc", emoji: "" }, { name: "abcd", emoji: "" }, { name: "capital_abcd", emoji: "" }, { name: "symbols", emoji: "" }, { name: "musical_note", emoji: "" }, { name: "notes", emoji: "" }, { name: "wavy_dash", emoji: "" }, { name: "curly_loop", emoji: "" }, { name: "heavy_check_mark", emoji: "" }, { name: "arrows_clockwise", emoji: "" }, { name: "heavy_plus_sign", emoji: "" }, { name: "heavy_minus_sign", emoji: "" }, { name: "heavy_division_sign", emoji: "" }, { name: "heavy_multiplication_x", emoji: "" }, { name: "heavy_dollar_sign", emoji: "" }, { name: "currency_exchange", emoji: "" }, { name: "copyright", emoji: "" }, { name: "registered", emoji: "" }, { name: "tm", emoji: "" }, { name: "end", emoji: "" }, { name: "back", emoji: "" }, { name: "on", emoji: "" }, { name: "top", emoji: "" }, { name: "soon", emoji: "" }, { name: "ballot_box_with_check", emoji: "" }, { name: "radio_button", emoji: "" }, { name: "white_circle", emoji: "" }, { name: "black_circle", emoji: "" }, { name: "red_circle", emoji: "" }, { name: "large_blue_circle", emoji: "" }, { name: "small_orange_diamond", emoji: "" }, { name: "small_blue_diamond", emoji: "" }, { name: "large_orange_diamond", emoji: "" }, { name: "large_blue_diamond", emoji: "" }, { name: "small_red_triangle", emoji: "" }, { name: "black_small_square", emoji: "" }, { name: "white_small_square", emoji: "" }, { name: "black_large_square", emoji: "" }, { name: "white_large_square", emoji: "" }, { name: "small_red_triangle_down", emoji: "" }, { name: "black_medium_square", emoji: "" }, { name: "white_medium_square", emoji: "" }, { name: "black_medium_small_square", emoji: "" }, { name: "white_medium_small_square", emoji: "" }, { name: "black_square_button", emoji: "" }, { name: "white_square_button", emoji: "" }, { name: "speaker", emoji: "" }, { name: "sound", emoji: "" }, { name: "loud_sound", emoji: "" }, { name: "mute", emoji: "" }, { name: "mega", emoji: "" }, { name: "loudspeaker", emoji: "" }, { name: "bell", emoji: "" }, { name: "no_bell", emoji: "" }, { name: "black_joker", emoji: "" }, { name: "mahjong", emoji: "" }, { name: "spades", emoji: "" }, { name: "clubs", emoji: "" }, { name: "hearts", emoji: "" }, { name: "diamonds", emoji: "" }, { name: "flower_playing_cards", emoji: "" }, { name: "thought_balloon", emoji: "" }, { name: "right_anger_bubble", emoji: "" }, { name: "speech_balloon", emoji: "" }, { name: "left_speech_bubble", emoji: "" }, { name: "clock1", emoji: "" }, { name: "clock2", emoji: "" }, { name: "clock3", emoji: "" }, { name: "clock4", emoji: "" }, { name: "clock5", emoji: "" }, { name: "clock6", emoji: "" }, { name: "clock7", emoji: "" }, { name: "clock8", emoji: "" }, { name: "clock9", emoji: "" }, { name: "clock10", emoji: "" }, { name: "clock11", emoji: "" }, { name: "clock12", emoji: "" }, { name: "clock130", emoji: "" }, { name: "clock230", emoji: "" }, { name: "clock330", emoji: "" }, { name: "clock430", emoji: "" }, { name: "clock530", emoji: "" }, { name: "clock630", emoji: "" }, { name: "clock730", emoji: "" }, { name: "clock830", emoji: "" }, { name: "clock930", emoji: "" }, { name: "clock1030", emoji: "" }, { name: "clock1130", emoji: "" }, { name: "clock1230", emoji: "" }, { name: "afghanistan", emoji: "" }, { name: "aland_islands", emoji: "" }, { name: "albania", emoji: "" }, { name: "algeria", emoji: "" }, { name: "american_samoa", emoji: "" }, { name: "andorra", emoji: "" }, { name: "angola", emoji: "" }, { name: "anguilla", emoji: "" }, { name: "antarctica", emoji: "" }, { name: "antigua_barbuda", emoji: "" }, { name: "argentina", emoji: "" }, { name: "armenia", emoji: "" }, { name: "aruba", emoji: "" }, { name: "australia", emoji: "" }, { name: "austria", emoji: "" }, { name: "azerbaijan", emoji: "" }, { name: "bahamas", emoji: "" }, { name: "bahrain", emoji: "" }, { name: "bangladesh", emoji: "" }, { name: "barbados", emoji: "" }, { name: "belarus", emoji: "" }, { name: "belgium", emoji: "" }, { name: "belize", emoji: "" }, { name: "benin", emoji: "" }, { name: "bermuda", emoji: "" }, { name: "bhutan", emoji: "" }, { name: "bolivia", emoji: "" }, { name: "caribbean_netherlands", emoji: "" }, { name: "bosnia_herzegovina", emoji: "" }, { name: "botswana", emoji: "" }, { name: "brazil", emoji: "" }, { name: "british_indian_ocean_territory", emoji: "" }, { name: "british_virgin_islands", emoji: "" }, { name: "brunei", emoji: "" }, { name: "bulgaria", emoji: "" }, { name: "burkina_faso", emoji: "" }, { name: "burundi", emoji: "" }, { name: "cape_verde", emoji: "" }, { name: "cambodia", emoji: "" }, { name: "cameroon", emoji: "" }, { name: "canada", emoji: "" }, { name: "canary_islands", emoji: "" }, { name: "cayman_islands", emoji: "" }, { name: "central_african_republic", emoji: "" }, { name: "chad", emoji: "" }, { name: "chile", emoji: "" }, { name: "cn", emoji: "" }, { name: "christmas_island", emoji: "" }, { name: "cocos_islands", emoji: "" }, { name: "colombia", emoji: "" }, { name: "comoros", emoji: "" }, { name: "congo_brazzaville", emoji: "" }, { name: "congo_kinshasa", emoji: "" }, { name: "cook_islands", emoji: "" }, { name: "costa_rica", emoji: "" }, { name: "croatia", emoji: "" }, { name: "cuba", emoji: "" }, { name: "curacao", emoji: "" }, { name: "cyprus", emoji: "" }, { name: "czech_republic", emoji: "" }, { name: "denmark", emoji: "" }, { name: "djibouti", emoji: "" }, { name: "dominica", emoji: "" }, { name: "dominican_republic", emoji: "" }, { name: "ecuador", emoji: "" }, { name: "egypt", emoji: "" }, { name: "el_salvador", emoji: "" }, { name: "equatorial_guinea", emoji: "" }, { name: "eritrea", emoji: "" }, { name: "estonia", emoji: "" }, { name: "ethiopia", emoji: "" }, { name: "eu", emoji: "" }, { name: "falkland_islands", emoji: "" }, { name: "faroe_islands", emoji: "" }, { name: "fiji", emoji: "" }, { name: "finland", emoji: "" }, { name: "fr", emoji: "" }, { name: "french_guiana", emoji: "" }, { name: "french_polynesia", emoji: "" }, { name: "french_southern_territories", emoji: "" }, { name: "gabon", emoji: "" }, { name: "gambia", emoji: "" }, { name: "georgia", emoji: "" }, { name: "de", emoji: "" }, { name: "ghana", emoji: "" }, { name: "gibraltar", emoji: "" }, { name: "greece", emoji: "" }, { name: "greenland", emoji: "" }, { name: "grenada", emoji: "" }, { name: "guadeloupe", emoji: "" }, { name: "guam", emoji: "" }, { name: "guatemala", emoji: "" }, { name: "guernsey", emoji: "" }, { name: "guinea", emoji: "" }, { name: "guinea_bissau", emoji: "" }, { name: "guyana", emoji: "" }, { name: "haiti", emoji: "" }, { name: "honduras", emoji: "" }, { name: "hong_kong", emoji: "" }, { name: "hungary", emoji: "" }, { name: "iceland", emoji: "" }, { name: "india", emoji: "" }, { name: "indonesia", emoji: "" }, { name: "iran", emoji: "" }, { name: "iraq", emoji: "" }, { name: "ireland", emoji: "" }, { name: "isle_of_man", emoji: "" }, { name: "israel", emoji: "" }, { name: "it", emoji: "" }, { name: "cote_divoire", emoji: "" }, { name: "jamaica", emoji: "" }, { name: "jp", emoji: "" }, { name: "jersey", emoji: "" }, { name: "jordan", emoji: "" }, { name: "kazakhstan", emoji: "" }, { name: "kenya", emoji: "" }, { name: "kiribati", emoji: "" }, { name: "kosovo", emoji: "" }, { name: "kuwait", emoji: "" }, { name: "kyrgyzstan", emoji: "" }, { name: "laos", emoji: "" }, { name: "latvia", emoji: "" }, { name: "lebanon", emoji: "" }, { name: "lesotho", emoji: "" }, { name: "liberia", emoji: "" }, { name: "libya", emoji: "" }, { name: "liechtenstein", emoji: "" }, { name: "lithuania", emoji: "" }, { name: "luxembourg", emoji: "" }, { name: "macau", emoji: "" }, { name: "macedonia", emoji: "" }, { name: "madagascar", emoji: "" }, { name: "malawi", emoji: "" }, { name: "malaysia", emoji: "" }, { name: "maldives", emoji: "" }, { name: "mali", emoji: "" }, { name: "malta", emoji: "" }, { name: "marshall_islands", emoji: "" }, { name: "martinique", emoji: "" }, { name: "mauritania", emoji: "" }, { name: "mauritius", emoji: "" }, { name: "mayotte", emoji: "" }, { name: "mexico", emoji: "" }, { name: "micronesia", emoji: "" }, { name: "moldova", emoji: "" }, { name: "monaco", emoji: "" }, { name: "mongolia", emoji: "" }, { name: "montenegro", emoji: "" }, { name: "montserrat", emoji: "" }, { name: "morocco", emoji: "" }, { name: "mozambique", emoji: "" }, { name: "myanmar", emoji: "" }, { name: "namibia", emoji: "" }, { name: "nauru", emoji: "" }, { name: "nepal", emoji: "" }, { name: "netherlands", emoji: "" }, { name: "new_caledonia", emoji: "" }, { name: "new_zealand", emoji: "" }, { name: "nicaragua", emoji: "" }, { name: "niger", emoji: "" }, { name: "nigeria", emoji: "" }, { name: "niue", emoji: "" }, { name: "norfolk_island", emoji: "" }, { name: "northern_mariana_islands", emoji: "" }, { name: "north_korea", emoji: "" }, { name: "norway", emoji: "" }, { name: "oman", emoji: "" }, { name: "pakistan", emoji: "" }, { name: "palau", emoji: "" }, { name: "palestinian_territories", emoji: "" }, { name: "panama", emoji: "" }, { name: "papua_new_guinea", emoji: "" }, { name: "paraguay", emoji: "" }, { name: "peru", emoji: "" }, { name: "philippines", emoji: "" }, { name: "pitcairn_islands", emoji: "" }, { name: "poland", emoji: "" }, { name: "portugal", emoji: "" }, { name: "puerto_rico", emoji: "" }, { name: "qatar", emoji: "" }, { name: "reunion", emoji: "" }, { name: "romania", emoji: "" }, { name: "ru", emoji: "" }, { name: "rwanda", emoji: "" }, { name: "st_barthelemy", emoji: "" }, { name: "st_helena", emoji: "" }, { name: "st_kitts_nevis", emoji: "" }, { name: "st_lucia", emoji: "" }, { name: "st_pierre_miquelon", emoji: "" }, { name: "st_vincent_grenadines", emoji: "" }, { name: "samoa", emoji: "" }, { name: "san_marino", emoji: "" }, { name: "sao_tome_principe", emoji: "" }, { name: "saudi_arabia", emoji: "" }, { name: "senegal", emoji: "" }, { name: "serbia", emoji: "" }, { name: "seychelles", emoji: "" }, { name: "sierra_leone", emoji: "" }, { name: "singapore", emoji: "" }, { name: "sint_maarten", emoji: "" }, { name: "slovakia", emoji: "" }, { name: "slovenia", emoji: "" }, { name: "solomon_islands", emoji: "" }, { name: "somalia", emoji: "" }, { name: "south_africa", emoji: "" }, { name: "south_georgia_south_sandwich_islands", emoji: "" }, { name: "kr", emoji: "" }, { name: "south_sudan", emoji: "" }, { name: "es", emoji: "" }, { name: "sri_lanka", emoji: "" }, { name: "sudan", emoji: "" }, { name: "suriname", emoji: "" }, { name: "swaziland", emoji: "" }, { name: "sweden", emoji: "" }, { name: "switzerland", emoji: "" }, { name: "syria", emoji: "" }, { name: "taiwan", emoji: "" }, { name: "tajikistan", emoji: "" }, { name: "tanzania", emoji: "" }, { name: "thailand", emoji: "" }, { name: "timor_leste", emoji: "" }, { name: "togo", emoji: "" }, { name: "tokelau", emoji: "" }, { name: "tonga", emoji: "" }, { name: "trinidad_tobago", emoji: "" }, { name: "tunisia", emoji: "" }, { name: "tr", emoji: "" }, { name: "turkmenistan", emoji: "" }, { name: "turks_caicos_islands", emoji: "" }, { name: "tuvalu", emoji: "" }, { name: "uganda", emoji: "" }, { name: "ukraine", emoji: "" }, { name: "united_arab_emirates", emoji: "" }, { name: "uk", emoji: "" }, { name: "us", emoji: "" }, { name: "us_virgin_islands", emoji: "" }, { name: "uruguay", emoji: "" }, { name: "uzbekistan", emoji: "" }, { name: "vanuatu", emoji: "" }, { name: "vatican_city", emoji: "" }, { name: "venezuela", emoji: "" }, { name: "vietnam", emoji: "" }, { name: "wallis_futuna", emoji: "" }, { name: "western_sahara", emoji: "" }, { name: "yemen", emoji: "" }, { name: "zambia", emoji: "" }, { name: "zimbabwe", emoji: "" }, { name: "star_struck", emoji: "" }, { name: "face_with_raised_eyebrow", emoji: "" }, { name: "exploding_head", emoji: "" }, { name: "crazy_face", emoji: "" }, { name: "face_with_symbols_over_mouth", emoji: "" }, { name: "face_vomiting", emoji: "" }, { name: "shushing_face", emoji: "" }, { name: "face_with_hand_over_mouth", emoji: "" }, { name: "face_with_monocle", emoji: "" }, { name: "child", emoji: "" }, { name: "adult", emoji: "" }, { name: "older_adult", emoji: "" }, { name: "woman_with_headscarf", emoji: "" }, { name: "bearded_person", emoji: "" }, { name: "breast_feeding", emoji: "" }, { name: "mage", emoji: "" }, { name: "woman_mage", emoji: "" }, { name: "fairy", emoji: "" }, { name: "vampire", emoji: "" }, { name: "merperson", emoji: "" }, { name: "merman", emoji: "" }, { name: "elf", emoji: "" }, { name: "genie", emoji: "" }, { name: "woman_genie", emoji: "" }, { name: "zombie", emoji: "" }, { name: "woman_zombie", emoji: "" }, { name: "person_in_steamy_room", emoji: "" }, { name: "woman_in_steamy_room", emoji: "" }, { name: "person_climbing", emoji: "" }, { name: "woman_climbing", emoji: "" }, { name: "person_in_lotus_position", emoji: "" }, { name: "woman_in_lotus_position", emoji: "" }, { name: "love_you_gesture", emoji: "" }, { name: "palms_up_together", emoji: "" }, { name: "brain", emoji: "" }, { name: "orange_heart", emoji: "" }, { name: "scarf", emoji: "" }, { name: "gloves", emoji: "" }, { name: "coat", emoji: "" }, { name: "socks", emoji: "" }, { name: "billed_cap", emoji: "" }, { name: "zebra", emoji: "" }, { name: "giraffe", emoji: "" }, { name: "hedgehog", emoji: "" }, { name: "sauropod", emoji: "" }, { name: "t_rex", emoji: "" }, { name: "cricket", emoji: "" }, { name: "coconut", emoji: "" }, { name: "broccoli", emoji: "" }, { name: "pretzel", emoji: "" }, { name: "cut_of_meat", emoji: "" }, { name: "sandwich", emoji: "" }, { name: "bowl_with_spoon", emoji: "" }, { name: "canned_food", emoji: "" }, { name: "dumpling", emoji: "" }, { name: "fortune_cookie", emoji: "" }, { name: "takeout_box", emoji: "" }, { name: "pie", emoji: "" }, { name: "cup_with_straw", emoji: "" }, { name: "chopsticks", emoji: "" }, { name: "flying_saucer", emoji: "" }, { name: "sled", emoji: "" }, { name: "curling_stone", emoji: "" }, { name: "svalbard_and_jan_mayen", emoji: "" }, { name: "st_martin", emoji: "" }, { name: "us_outlying_islands", emoji: "" }, { name: "tristan_da_cunha", emoji: "" }, { name: "heard_and_mc_donald_islands", emoji: "" }, { name: "ceuta_and_melilla", emoji: "" }, { name: "diego_garcia", emoji: "" }, { name: "ascension_island", emoji: "" }, { name: "bouvet_island", emoji: "" }, { name: "clipperton_island", emoji: "" }, { name: "united_nations", emoji: "" }, { name: "smiling_face_with_three_hearts", emoji: "" }, { name: "hot_face", emoji: "" }, { name: "cold_face", emoji: "" }, { name: "partying_face", emoji: "" }, { name: "woozy_face", emoji: "" }, { name: "pleading_face", emoji: "" }, { name: "man_red_haired", emoji: "" }, { name: "man_curly_haired", emoji: "" }, { name: "man_white_haired", emoji: "" }, { name: "man_bald", emoji: "" }, { name: "woman_red_haired", emoji: "" }, { name: "woman_curly_haired", emoji: "" }, { name: "woman_white_haired", emoji: "" }, { name: "woman_bald", emoji: "" }, { name: "superhero", emoji: "" }, { name: "man_superhero", emoji: "" }, { name: "woman_superhero", emoji: "" }, { name: "supervillain", emoji: "" }, { name: "woman_supervillain", emoji: "" }, { name: "man_supervillain", emoji: "" }, { name: "leg", emoji: "" }, { name: "foot", emoji: "" }, { name: "bone", emoji: "" }, { name: "tooth", emoji: "" }, { name: "goggles", emoji: "" }, { name: "lab_coat", emoji: "" }, { name: "hiking_boot", emoji: "" }, { name: "flat_shoe", emoji: "" }, { name: "raccoon", emoji: "" }, { name: "llama", emoji: "" }, { name: "hippopotamus", emoji: "" }, { name: "kangaroo", emoji: "" }, { name: "badger", emoji: "" }, { name: "swan", emoji: "" }, { name: "peacock", emoji: "" }, { name: "parrot", emoji: "" }, { name: "lobster", emoji: "" }, { name: "mosquito", emoji: "" }, { name: "microbe", emoji: "" }, { name: "mango", emoji: "" }, { name: "leafy_green", emoji: "" }, { name: "bagel", emoji: "" }, { name: "salt", emoji: "" }, { name: "moon_cake", emoji: "" }, { name: "cupcake", emoji: "" }, { name: "compass", emoji: "" }, { name: "brick", emoji: "" }, { name: "skateboard", emoji: "" }, { name: "luggage", emoji: "" }, { name: "firecracker", emoji: "" }, { name: "red_gift_envelope", emoji: "" }, { name: "softball", emoji: "" }, { name: "flying_disc", emoji: "" }, { name: "lacrosse", emoji: "" }, { name: "nazar_amulet", emoji: "" }, { name: "jigsaw", emoji: "" }, { name: "teddy_bear", emoji: "" }, { name: "chess_pawn", emoji: "" }, { name: "thread", emoji: "" }, { name: "yarn", emoji: "" }, { name: "abacus", emoji: "" }, { name: "receipt", emoji: "" }, { name: "toolbox", emoji: "" }, { name: "magnet", emoji: "" }, { name: "test_tube", emoji: "" }, { name: "petri_dish", emoji: "" }, { name: "dna", emoji: "" }, { name: "lotion_bottle", emoji: "" }, { name: "safety_pin", emoji: "" }, { name: "broom", emoji: "" }, { name: "basket", emoji: "" }, { name: "roll_of_toilet_paper", emoji: "" }, { name: "soap", emoji: "" }, { name: "sponge", emoji: "" }, { name: "fire_extinguisher", emoji: "" }, { name: "infinity", emoji: "" }, { name: "pirate_flag", emoji: "" }, { name: "waffle", emoji: "" }, { name: "otter", emoji: "" }, { name: "sloth", emoji: "" }, { name: "ice_cube", emoji: "" }, { name: "ringer_planet", emoji: "" }, { name: "flamingo", emoji: "" }, { name: "yawning_face", emoji: "" }, { name: "pinching_hand", emoji: "" }, { name: "service_dog", emoji: "" }, { name: "orangutan", emoji: "" }, { name: "auto_rickshaw", emoji: "" }, { name: "parachute", emoji: "" }, { name: "yo-yo", emoji: "" }, { name: "kite", emoji: "" }, { name: "brown_square", emoji: "" }, { name: "purple_square", emoji: "" }, { name: "blue_square", emoji: "" }, { name: "green_square", emoji: "" }, { name: "yellow_square", emoji: "" }, { name: "orange_square", emoji: "" }, { name: "red_square", emoji: "" }, { name: "brown_circle", emoji: "" }, { name: "purple_circle", emoji: "" }, { name: "green_circle", emoji: "" }, { name: "yellow_circle", emoji: "" }, { name: "orange_circle", emoji: "" }, { name: "razor", emoji: "" }, { name: "chair", emoji: "" }, { name: "stethoscope", emoji: "" }, { name: "adhesive_bandage", emoji: "" }, { name: "drop_of_blood", emoji: "" }, { name: "probing_cane", emoji: "" }, { name: "axe", emoji: "" }, { name: "diya_lamp", emoji: "" }, { name: "banjo", emoji: "" }, { name: "ballet_shoes", emoji: "" }, { name: "shorts", emoji: "" }, { name: "briefs", emoji: "" }, { name: "one_piece_swimsuit", emoji: "" }, { name: "sari", emoji: "" }, { name: "safety_vest", emoji: "" }, { name: "diving_mask", emoji: "" }, { name: "motorized_wheelchair", emoji: "" }, { name: "manual_wheelchair", emoji: "" }, { name: "hindu_temple", emoji: "" }, { name: "mat", emoji: "" }, { name: "beverage_box", emoji: "" }, { name: "oyster", emoji: "" }, { name: "butter", emoji: "" }, { name: "falafel", emoji: "" }, { name: "onion", emoji: "" }, { name: "garlic", emoji: "" }, { name: "skunk", emoji: "" }, { name: "guide_dog", emoji: "" }, { name: "people_holding_hands", emoji: "" }, { name: "woman_in_manual_wheelchair", emoji: "" }, { name: "man_in_manual_wheelchair", emoji: "" }, { name: "woman_in_motorized_wheelchair", emoji: "" }, { name: "man_in_motorized_wheelchair", emoji: "" }, { name: "woman_with_probing_cane", emoji: "" }, { name: "man_with_probing_cane", emoji: "" }, { name: "woman_kneeling", emoji: "" }, { name: "man_kneeling", emoji: "" }, { name: "man_standing", emoji: "" }, { name: "woman_standing", emoji: "" }, { name: "deaf_woman", emoji: "" }, { name: "deaf_man", emoji: "" }, { name: "hear_with_hearing_aid", emoji: "" }, { name: "mechanical_leg", emoji: "" }, { name: "mechanical_arm", emoji: "" }, { name: "white_heart", emoji: "" }, { name: "brown_heart", emoji: "" }, { name: "transgender_flag", emoji: "" }, { name: "smiling_face_with_tear", emoji: "" }, { name: "disguised_face", emoji: "" }, { name: "pinched_fingers", emoji: "" }, { name: "anatomical_heart", emoji: "" }, { name: "lungs", emoji: "" }, { name: "ninja", emoji: "" }, { name: "mx_claus", emoji: "" }, { name: "people_hugging", emoji: "" }, { name: "black_cat", emoji: "" }, { name: "bison", emoji: "" }, { name: "mammoth", emoji: "" }, { name: "beaver", emoji: "" }, { name: "dodo", emoji: "" }, { name: "feather", emoji: "" }, { name: "seal", emoji: "" }, { name: "beetle", emoji: "" }, { name: "cockroach", emoji: "" }, { name: "fly", emoji: "" }, { name: "worm", emoji: "" }, { name: "potted_plant", emoji: "" }, { name: "blueberries", emoji: "" }, { name: "olive", emoji: "" }, { name: "bell_pepper", emoji: "" }, { name: "flatbread", emoji: "" }, { name: "tamale", emoji: "" }, { name: "fondue", emoji: "" }, { name: "teapot", emoji: "" }, { name: "bubble_tea", emoji: "" }, { name: "rock", emoji: "" }, { name: "wood", emoji: "" }, { name: "hut", emoji: "" }, { name: "pickup_truck", emoji: "" }, { name: "roller_skate", emoji: "" }, { name: "magic_wand", emoji: "" }, { name: "piata", emoji: "" }, { name: "nesting_dolls", emoji: "" }, { name: "sewing_needle", emoji: "" }, { name: "knot", emoji: "" }, { name: "thong_sandal", emoji: "" }, { name: "military_helmet", emoji: "" }, { name: "accordion", emoji: "" }, { name: "long_drum", emoji: "" }, { name: "coin", emoji: "" }, { name: "boomerang", emoji: "" }, { name: "carpentry_saw", emoji: "" }, { name: "screwdriver", emoji: "" }, { name: "hook", emoji: "" }, { name: "ladder", emoji: "" }, { name: "mirror", emoji: "" }, { name: "window", emoji: "" }, { name: "plunger", emoji: "" }, { name: "mouse_trap", emoji: "" }, { name: "bucket", emoji: "" }, { name: "toothbrush", emoji: "" }, { name: "headstone", emoji: "" }, { name: "placard", emoji: "" }, { name: "transgender_symbol", emoji: "" }, { name: "man_feeding_baby", emoji: "" }, { name: "person_feeding_baby", emoji: "" }, { name: "polar_bear", emoji: "" }, { name: "melting_face", emoji: "" }, { name: "smiling_face", emoji: "" }, { name: "face_with_open_eyes_and_hand_over_mouth", emoji: "" }, { name: "face_with_peeking_eye", emoji: "" }, { name: "saluting_face", emoji: "" }, { name: "dotted_line_face", emoji: "" }, { name: "face_in_clouds", emoji: "" }, { name: "face_exhaling", emoji: "" }, { name: "face_with_spiral_eyes", emoji: "" }, { name: "face_with_diagonal_mouth", emoji: "" }, { name: "frowning_face", emoji: "" }, { name: "face_holding_back_tears", emoji: "" }, { name: "heart_on_fire", emoji: "" }, { name: "mending_heart", emoji: "" }, { name: "eye_in_speech_bubble", emoji: "" }, { name: "rightwards_hand", emoji: "" }, { name: "leftwards_hand", emoji: "" }, { name: "palm_down_hand", emoji: "" }, { name: "palm_up_hand", emoji: "" }, { name: "hand_with_index_finger_and_thumb_crossed", emoji: "" }, { name: "index_pointing_at_the_viewer", emoji: "" }, { name: "heart_hands", emoji: "" }, { name: "biting_lip", emoji: "" }, { name: "man_beard", emoji: "" }, { name: "woman_beard", emoji: "" }, { name: "person_red_hair", emoji: "" }, { name: "person_curly_hair", emoji: "" }, { name: "person_white_hair", emoji: "" }, { name: "person_bald", emoji: "" }, { name: "man_blond_hair", emoji: "" }, { name: "person_frowning", emoji: "" }, { name: "person_pouting", emoji: "" }, { name: "person_gesturing_no", emoji: "" }, { name: "person_gesturing_ok", emoji: "" }, { name: "person_tipping_hand", emoji: "" }, { name: "person_raising_hand", emoji: "" }, { name: "deaf_person", emoji: "" }, { name: "man_bowing", emoji: "" }, { name: "person_facepalming", emoji: "" }, { name: "person_shrugging", emoji: "" }, { name: "health_worker", emoji: "" }, { name: "student", emoji: "" }, { name: "teacher", emoji: "" }, { name: "judge", emoji: "" }, { name: "farmer", emoji: "" }, { name: "cook", emoji: "" }, { name: "mechanic", emoji: "" }, { name: "factory_worker", emoji: "" }, { name: "office_worker", emoji: "" }, { name: "scientist", emoji: "" }, { name: "technologist", emoji: "" }, { name: "singer", emoji: "" }, { name: "artist", emoji: "" }, { name: "pilot", emoji: "" }, { name: "astronaut", emoji: "" }, { name: "firefighter", emoji: "" }, { name: "man_police_officer", emoji: "" }, { name: "man_detective", emoji: "" }, { name: "man_guard", emoji: "" }, { name: "man_construction_worker", emoji: "" }, { name: "person_with_crown", emoji: "" }, { name: "man_wearing_turban", emoji: "" }, { name: "man_in_tuxedo", emoji: "" }, { name: "woman_in_tuxedo", emoji: "" }, { name: "man_with_veil", emoji: "" }, { name: "woman_with_veil", emoji: "" }, { name: "pregnant_man", emoji: "" }, { name: "pregnant_person", emoji: "" }, { name: "woman_feeding_baby", emoji: "" }, { name: "man_mage", emoji: "" }, { name: "man_fairy", emoji: "" }, { name: "woman_fairy", emoji: "" }, { name: "man_vampire", emoji: "" }, { name: "woman_vampire", emoji: "" }, { name: "mermaid", emoji: "" }, { name: "man_elf", emoji: "" }, { name: "woman_elf", emoji: "" }, { name: "man_genie", emoji: "" }, { name: "man_zombie", emoji: "" }, { name: "troll", emoji: "" }, { name: "person_getting_massage", emoji: "" }, { name: "person_getting_haircut", emoji: "" }, { name: "man_walking", emoji: "" }, { name: "person_standing", emoji: "" }, { name: "person_kneeling", emoji: "" }, { name: "person_with_white_cane", emoji: "" }, { name: "person_in_motorized_wheelchair", emoji: "" }, { name: "person_in_manual_wheelchair", emoji: "" }, { name: "man_running", emoji: "" }, { name: "women_with_bunny_ears", emoji: "" }, { name: "man_in_steamy_room", emoji: "" }, { name: "man_climbing", emoji: "" }, { name: "man_golfing", emoji: "" }, { name: "man_surfing", emoji: "" }, { name: "man_rowing_boat", emoji: "" }, { name: "man_swimming", emoji: "" }, { name: "man_bouncing_ball", emoji: "" }, { name: "man_lifting_weights", emoji: "" }, { name: "man_biking", emoji: "" }, { name: "man_mountain_biking", emoji: "" }, { name: "person_cartwheeling", emoji: "" }, { name: "people_wrestling", emoji: "" }, { name: "person_playing_water_polo", emoji: "" }, { name: "person_playing_handball", emoji: "" }, { name: "person_juggling", emoji: "" }, { name: "man_in_lotus_position", emoji: "" }, { name: "kiss_woman_man", emoji: "" }, { name: "couple_with_heart_woman_man", emoji: "" }, { name: "family_man_woman_boy", emoji: "" }, { name: "red_hair", emoji: "" }, { name: "curly_hair", emoji: "" }, { name: "white_hair", emoji: "" }, { name: "bald", emoji: "" }, { name: "coral", emoji: "" }, { name: "lotus", emoji: "" }, { name: "empty_nest", emoji: "" }, { name: "nest_with_eggs", emoji: "" }, { name: "beans", emoji: "" }, { name: "pouring_liquid", emoji: "" }, { name: "jar", emoji: "" }, { name: "playground_slide", emoji: "" }, { name: "wheel", emoji: "" }, { name: "ring_buoy", emoji: "" }, { name: "hamsa", emoji: "" }, { name: "mirror_ball", emoji: "" }, { name: "low_battery", emoji: "" }, { name: "crutch", emoji: "" }, { name: "xray", emoji: "" }, { name: "elevator", emoji: "" }, { name: "bubbles", emoji: "" }, { name: "identification_card", emoji: "" }, { name: "eject_button", emoji: "" }, { name: "female_sign", emoji: "" }, { name: "male_sign", emoji: "" }, { name: "heavy_equals_sign", emoji: "" }, { name: "medical_symbol", emoji: "" }, { name: "england", emoji: "" }, { name: "scotland", emoji: "" }, { name: "wales", emoji: "" }], uNe = cNe, dNe = oN({ name: "emoji", char: ":", pluginKey: new xn("emojiSuggestion"), items: ({ query: n }) => uNe.filter(e => e.name.toLowerCase().includes(n.toLowerCase())).sort((e, t) => { const r = e.name.toLowerCase(), i = t.name.toLowerCase(), a = n.toLowerCase(); return r === a && i !== a ? -1 : i === a && r !== a ? 1 : r.startsWith(a) && !i.startsWith(a) ? -1 : i.startsWith(a) && !r.startsWith(a) ? 1 : r.length - i.length }).slice(0, 5), command: ({ editor: n, range: e, props: t }) => { t && t.emoji ? n.chain().focus().deleteRange(e).insertContent(t.emoji).run() : console.error("Emoji command execution error: emoji property not found on selected item or item is invalid.", t) }, component: lNe }), fNe = jl.create({ name: "heading", addOptions() { return { levels: [1, 2, 3, 4, 5, 6], HTMLAttributes: {} } }, content: "inline*", group: "block", defining: !0, addAttributes() { return { level: { default: 1, rendered: !1 } } }, parseHTML() { return this.options.levels.map(n => ({ tag: `h${n}`, attrs: { level: n } })) }, renderHTML({ node: n, HTMLAttributes: e }) { return [`h${this.options.levels.includes(n.attrs.level) ? n.attrs.level : this.options.levels[0]}`, Zr(this.options.HTMLAttributes, e), 0] }, addCommands() { return { setHeading: n => ({ commands: e }) => this.options.levels.includes(n.level) ? e.setNode(this.name, n) : !1, toggleHeading: n => ({ commands: e }) => this.options.levels.includes(n.level) ? e.toggleNode(this.name, "paragraph", n) : !1 } }, addKeyboardShortcuts() { return this.options.levels.reduce((n, e) => ({ ...n, [`Mod-Alt-${e}`]: () => this.editor.commands.toggleHeading({ level: e }) }), {}) }, addInputRules() { return this.options.levels.map(n => i2({ find: new RegExp(`^(#{${Math.min(...this.options.levels)},${n}})\\s$`), type: this.type, getAttributes: { level: n } })) } }), hNe = fNe.extend({ addInputRules() { return this.options.levels.map(n => { let e = new RegExp(`^(#{${n}}) $`); return i2({ find: e, type: this.type, getAttributes: { level: n } }) }) } }), pNe = jk.create({ name: "namedHighlight", addOptions() { return { HTMLAttributes: {}, multicolor: !0, colors: ["yellow", "blue", "green", "red", "orange", "purple", "pink", "gray", "teal", "cyan"] } }, addAttributes() { return this.options.multicolor ? { color: { default: null, parseHTML: n => { const e = n.getAttribute("style"); if (e) { const r = e.match(/background-color:\s*var\(--prose-highlight-(\w+)\)/); if (r && this.options.colors.includes(r[1])) return r[1] } const t = n.getAttribute("data-color"); if (t) { const r = dP(t, this.options.colors, qQ, ZQ); if (r) return r } if (e) { const r = tNe(e, this.options.colors); if (r) return r } return null }, renderHTML: n => !n.color || !this.options.colors.includes(n.color) ? {} : { style: `background-color: var(--prose-highlight-${n.color})` } } } : {} }, parseHTML() { return [{ tag: "mark" }] }, renderHTML({ HTMLAttributes: n }) { return ["mark", Zr(this.options.HTMLAttributes, n), 0] }, addCommands() { return { setHighlightByName: n => ({ chain: e, commands: t, editor: r, state: i }) => { if (!this.options.colors.includes(n)) return console.warn(`Highlight color "${n}" is not in the allowed colors list`), !1; const { from: a, to: o, empty: s } = i.selection; let l = e(); return this.options.multicolor ? l = l.setMark(this.name, { color: n }) : l = l.setMark(this.name), s || (l = l.setTextSelection(o).command(({ tr: c }) => (c.setStoredMarks([]), !0))), l.focus().run() }, toggleHighlightByName: n => ({ chain: e, commands: t, editor: r, state: i }) => { if (!this.options.colors.includes(n)) return console.warn(`Highlight color "${n}" is not in the allowed colors list`), !1; const { to: a, empty: o } = i.selection, s = this.options.multicolor ? { color: n } : void 0, l = r.isActive(this.name, s); let c = e().toggleMark(this.name, s); return !o && !l && (c = c.setTextSelection(a).command(({ tr: u }) => (u.setStoredMarks([]), !0))), c.focus().run() }, unsetHighlight: () => ({ commands: n }) => n.unsetMark(this.name) } } }), mNe = { class: "lucide lucide-move-diagonal-2", xmlns: "http://www.w3.org/2000/svg", width: "24", height: "24", viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", "stroke-width": "1.5", "stroke-linecap": "round", "stroke-linejoin": "round" }; function gNe(n, e) { return Z(), ye("svg", mNe, e[0] || (e[0] = [re("path", { d: "M19 13v6h-6" }, null, -1), re("path", { d: "M5 11V5h6" }, null, -1), re("path", { d: "m5 5 14 14" }, null, -1)])) } const vNe = dn({ name: "lucide-move-diagonal-2", render: gNe }), yNe = { class: "lucide lucide-align-left", xmlns: "http://www.w3.org/2000/svg", width: "24", height: "24", viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", "stroke-width": "1.5", "stroke-linecap": "round", "stroke-linejoin": "round" }; function _Ne(n, e) { return Z(), ye("svg", yNe, e[0] || (e[0] = [re("path", { d: "M15 12H3" }, null, -1), re("path", { d: "M17 18H3" }, null, -1), re("path", { d: "M21 6H3" }, null, -1)])) } const bNe = dn({ name: "lucide-align-left", render: _Ne }), wNe = { class: "lucide lucide-align-center", xmlns: "http://www.w3.org/2000/svg", width: "24", height: "24", viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", "stroke-width": "1.5", "stroke-linecap": "round", "stroke-linejoin": "round" }; function xNe(n, e) { return Z(), ye("svg", wNe, e[0] || (e[0] = [re("path", { d: "M17 12H7" }, null, -1), re("path", { d: "M19 18H5" }, null, -1), re("path", { d: "M21 6H3" }, null, -1)])) } const SNe = dn({ name: "lucide-align-center", render: xNe }), TNe = { class: "lucide lucide-align-right", xmlns: "http://www.w3.org/2000/svg", width: "24", height: "24", viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", "stroke-width": "1.5", "stroke-linecap": "round", "stroke-linejoin": "round" }; function kNe(n, e) { return Z(), ye("svg", TNe, e[0] || (e[0] = [re("path", { d: "M21 12H9" }, null, -1), re("path", { d: "M21 18H7" }, null, -1), re("path", { d: "M21 6H3" }, null, -1)])) } const CNe = dn({ name: "lucide-align-right", render: kNe }), ANe = { class: "relative" }, ENe = ["src", "alt", "width", "height"], MNe = { class: "absolute bottom-2 right-2 flex items-center gap-2" }, ONe = { key: 0, class: "flex divide-x divide-outline-gray-5 rounded bg-black/65" }, DNe = { key: 1, class: "inset-0 absolute flex items-center justify-center z-10" }, jNe = { class: "bg-gray-900/80 p-2 inset-0 leading-none rounded-sm flex flex-col items-center justify-center gap-2" }, PNe = { class: "flex items-center gap-2" }, INe = ["disabled"], LNe = { key: 1, class: "w-full py-1.5" }, RNe = We({ __name: "ImageNodeView", props: cQ, setup(n) { const e = n, t = he(null), r = he(null), i = he(!1), a = he(0), o = he(0), s = he(1); function l() { e.editor.commands.setNodeSelection(e.getPos()) } const c = he(e.node.attrs.alt || ""), u = he(!1); un(() => { if (u.value = e.editor.isEditable, t.value) { const S = e.node.attrs.width || t.value.naturalWidth, x = e.node.attrs.height || t.value.naturalHeight; S && x && (s.value = x / S) } }), e.editor.on("update", () => { u.value = e.editor.isEditable }); function d(S) { const x = S.target.value; c.value = x, e.updateAttributes({ alt: x }) } function f(S) { S.key === "Enter" ? (S.preventDefault(), p()) : (S.key === "Escape" || S.key === "ArrowDown") && (S.preventDefault(), m()), S.key === "ArrowUp" && (S.preventDefault(), g()) } function h(S) { e.editor.commands.focus(), e.editor.chain().setTextSelection(S).scrollIntoView().run() } function p() { const S = e.getPos(); e.editor.commands.focus(), e.editor.chain().setTextSelection(S + 1).createParagraphNear().scrollIntoView().run() } function m() { const S = e.getPos(); h(S + 1) } function g() { const S = e.getPos(); h(S - 1) } function y(S) { var A, C, E; if (!u.value) return; l(), i.value = !0, a.value = S.clientX, o.value = ((A = t.value) == null ? void 0 : A.offsetWidth) || e.node.attrs.width || 0; const x = e.node.attrs.width || ((C = t.value) == null ? void 0 : C.naturalWidth), k = e.node.attrs.height || ((E = t.value) == null ? void 0 : E.naturalHeight); x && k ? s.value = k / x : s.value = 1, window.addEventListener("mousemove", b), window.addEventListener("mouseup", w), document.body.style.cursor = "ew-resize" } function b(S) { if (!i.value || !t.value || !r.value) return; const k = e.editor.view.dom.clientWidth, A = S.clientX - a.value; let C = o.value + A; C = Math.max(50, Math.min(C, k)); const E = C * s.value; t.value.style.width = `${C}px`, t.value.style.height = `${E}px`, r.value.style.width = `${C}px` } function w() { if (i.value && (i.value = !1, window.removeEventListener("mousemove", b), window.removeEventListener("mouseup", w), document.body.style.cursor = "", t.value && r.value)) { const S = t.value.offsetWidth, x = t.value.offsetHeight; e.updateAttributes({ width: S, height: x }), t.value.style.width = "", t.value.style.height = "", r.value.style.width = "" } } function v(S) { e.editor.commands.setImageAlign(S) } return (S, x) => (Z(), Ye(X(lQ), null, { default: Ue(() => [re("div", { ref_key: "containerRef", ref: r, class: Tt(["relative overflow-hidden not-prose my-6 rounded-[2px] block max-w-full", [{ "ring-2 ring-outline-gray-3 ring-offset-2": S.selected }, S.node.attrs.align === "center" ? "mx-auto" : "", S.node.attrs.align === "right" ? "ml-auto mr-0" : "", S.node.attrs.align === "left" ? "mr-auto ml-0" : ""]]), style: aa({ width: S.node.attrs.width ? `${S.node.attrs.width}px` : "auto" }) }, [re("div", ANe, [S.node.attrs.src ? (Z(), ye("img", { key: 0, ref_key: "imageRef", ref: t, class: "rounded-[2px]", src: S.node.attrs.src, alt: S.node.attrs.alt || "", width: S.node.attrs.width, height: S.node.attrs.height, onClick: ar(l, ["stop"]) }, null, 8, ENe)) : mt("", !0), re("div", MNe, [S.selected && u.value ? (Z(), ye("div", ONe, [re("button", { onClick: x[0] || (x[0] = ar(k => v("left"), ["stop"])), class: Tt(["px-1.5 py-1 hover:text-ink-white", S.node.attrs.align === "left" ? "text-ink-white" : "text-ink-gray-4"]) }, [$e(X(bNe), { class: "size-4" })], 2), re("button", { onClick: x[1] || (x[1] = ar(k => v("center"), ["stop"])), class: Tt(["px-1.5 py-1 hover:text-ink-white", S.node.attrs.align === "center" ? "text-ink-white" : "text-ink-gray-4"]) }, [$e(X(SNe), { class: "size-4" })], 2), re("button", { onClick: x[2] || (x[2] = ar(k => v("right"), ["stop"])), class: Tt(["px-1.5 py-1 hover:text-ink-white", S.node.attrs.align === "right" ? "text-ink-white" : "text-ink-gray-4"]) }, [$e(X(CNe), { class: "size-4" })], 2)])) : mt("", !0), S.selected && u.value ? (Z(), ye("button", { key: 1, class: "cursor-nw-resize bg-black/65 rounded p-1", onMousedown: ar(y, ["prevent"]) }, [$e(X(vNe), { class: "text-white size-4" })], 32)) : mt("", !0)]), S.node.attrs.loading ? (Z(), ye("div", DNe, [re("div", jNe, [re("div", PNe, [$e(uk, { class: "text-gray-100 size-4" }), x[4] || (x[4] = re("span", { class: "text-gray-100" }, "Uploading...", -1))])])])) : mt("", !0)]), (u.value || S.node.attrs.alt) && !S.node.attrs.error ? Dh((Z(), ye("input", { key: 0, "onUpdate:modelValue": x[3] || (x[3] = k => c.value = k), class: "w-full text-center bg-transparent text-sm text-ink-gray-6 h-7 border-none focus:ring-0 placeholder-ink-gray-4", placeholder: "Add caption", disabled: !u.value, onChange: d, onKeydown: f }, null, 40, INe)), [[PS, c.value]]) : mt("", !0), S.node.attrs.error ? (Z(), ye("div", LNe, [$e(X(bR), { message: `Upload Failed: ${S.node.attrs.error}` }, null, 8, ["message"])])) : mt("", !0)], 6)]), _: 1 })) } }), NNe = /(?:^|\s)(!\[(.+|:?)]\((\S+)(?:(?:\s+)["'](\S+)["'])?\))$/, BNe = jl.create({ name: "image", group: "block", draggable: !0, selectable: !0, addAttributes() { return { src: { default: null }, alt: { default: null }, title: { default: null }, width: { default: null }, height: { default: null }, loading: { default: !1, parseHTML: () => !1 }, align: { default: "left", parseHTML: n => { const e = (n.getAttribute("data-align") || n.getAttribute("align") || "left").toLowerCase(); return ["left", "center", "right"].includes(e) ? e : "left" }, renderHTML: n => ({ "data-align": n.align || "left" }) }, uploadId: { default: null, parseHTML: () => null }, error: { default: null, parseHTML: () => null } } }, parseHTML() { return [{ tag: "img[src]", getAttrs: n => { if (typeof n == "string") return {}; const e = n; return { src: e.getAttribute("src"), alt: e.getAttribute("alt"), title: e.getAttribute("title"), width: e.getAttribute("width"), height: e.getAttribute("height") } } }] }, renderHTML({ HTMLAttributes: n }) { return ["img", Zr(this.options.HTMLAttributes || {}, n)] }, addNodeView() { return uQ(RNe) }, addOptions() { return { uploadFunction: null, HTMLAttributes: {} } }, addCommands() { return { setImageAlign: n => ({ commands: e }) => e.updateAttributes(this.name, { align: n }), setImage: n => ({ commands: e, editor: t }) => { const r = e.insertContent({ type: this.name, attrs: n }); return r && n.src && zNe(t.view, n.src, (i, a) => { c6(n.src, t.view, a) }), r }, uploadImage: n => ({ editor: e }) => eee(n, e.view, null, this.options), selectAndUploadImage: () => ({ editor: n }) => { const e = document.createElement("input"); return e.type = "file", e.accept = "image/*", e.onchange = t => { const r = t.target; if (r.files && r.files.length) { const i = r.files[0]; n.commands.uploadImage(i) } }, e.click(), !0 } } }, addInputRules() { return [OEe({ find: NNe, type: this.type, getAttributes: n => { const [, , e, t, r] = n; return { src: t, alt: e, title: r } } })] }, addProseMirrorPlugins() { const n = this; return [new wn({ props: { handleDOMEvents: { drop: (e, t) => { var s, l; if (!((l = (s = t.dataTransfer) == null ? void 0 : s.files) == null ? void 0 : l.length) || !n.options.uploadFunction) return !1; const i = Array.from(t.dataTransfer.files).filter(c => /image/i.test(c.type)); if (i.length === 0) return !1; t.preventDefault(); const a = e.posAtCoords({ left: t.clientX, top: t.clientY }); let o = null; if (a) { o = a.pos; const c = e.state.tr.setSelection(vt.near(e.state.doc.resolve(o))); e.dispatch(c) } return u6(i, e, o, n.options), !0 }, handlePaste: (e, t) => { var a; if (!n.options.uploadFunction) return !1; const r = (a = t.clipboardData) == null ? void 0 : a.items; if (!r || r.length === 0) return !1; const i = []; for (let o = 0; o < r.length; o++) { const s = r[o]; if (s.kind === "file" && s.type.indexOf("image/") !== -1) { const l = s.getAsFile(); l && i.push(l) } } return i.length === 0 ? !1 : (t.preventDefault(), u6(i, e, null, n.options), !0) } } }, appendTransaction(e, t, r) { const i = []; return e.some(a => a.docChanged) && r.doc.descendants((a, o) => { a.type.name === "image" && a.attrs.src && (!a.attrs.width || !a.attrs.height) && !a.attrs.loading && i.push({ node: a, pos: o }) }), i.length === 0 || i.forEach(({ node: a, pos: o }) => { const s = n.editor; s && c6(a.attrs.src, s.view, o) }), null } })] } }); function $Ne(n, e) { if (!e) return null; let t = null; return n.state.doc.descendants((r, i) => { if (r.type.name === "image" && r.attrs.uploadId === e) return t = i + r.nodeSize, !1 }), t } function QQ(n, e, t, r, i, a, o = !1) { if (!r.uploadFunction) return console.error("uploadFunction option is not provided"), !1; const s = `upload-${Date.now()}-${Math.random().toString(36).substring(2, 9)}`; return lst(n).then(l => { const c = e.state.schema.nodes.image.create({ loading: !0, uploadId: s, src: l }), u = e.state.tr; if (t != null) u.insert(t, c); else if (i === "replace") u.replaceSelectionWith(c); else { const d = e.state.selection.from; u.insert(d, c) } if (e.dispatch(u), o) { const d = c.nodeSize || 1; setTimeout(() => { try { let f = null; if (e.state.doc.descendants((h, p) => { if (h.type.name === "image" && h.attrs.uploadId === s) return f = p, !1 }), f !== null) { const h = f + d, p = e.state.tr.setSelection(vt.near(e.state.doc.resolve(h))); e.dispatch(p) } } catch (f) { console.error("Error moving cursor:", f) } }, 10) } return r.uploadFunction(n) }).then(l => tee(l.src).then(c => ({ ...l, width: c.width, height: c.height })).catch(() => l)).then(l => { const c = e.state.tr; e.state.doc.descendants((u, d) => { if (u.type.name === "image" && u.attrs.uploadId === s) return c.setNodeMarkup(d, void 0, { ...u.attrs, src: l.src, width: l.width || u.attrs.width, height: l.height || u.attrs.height, loading: !1 }), !1 }), e.dispatch(c), a && a(s) }).catch(l => { console.error("Image upload failed:", l); try { const c = e.state.tr; e.state.doc.descendants((u, d) => { if (u.type.name === "image" && u.attrs.uploadId === s) return c.setNodeMarkup(d, void 0, { ...u.attrs, loading: !1, error: l.message || "Failed to upload image" }), !1 }), e.dispatch(c) } catch (c) { console.error("Error updating failed node:", c) } a && a(s) }), !0 } function FNe(n, e, t, r, i) { return QQ(n, e, t, r, "insert", i, !0) } function eee(n, e, t, r) { return QQ(n, e, t, r, "replace") } function zNe(n, e, t) { n.state.doc.descendants((r, i) => { if (r.type.name === "image" && r.attrs.src === e) return t(r, i), !1 }) } function c6(n, e, t) { tee(n).then(r => { const i = e.state.doc.nodeAt(t); if (!i || i.type.name !== "image") return; const a = i.attrs; if (a.width == null || a.height == null) { const o = e.state.tr.setNodeMarkup(t, void 0, { ...a, width: a.width ?? r.width, height: a.height ?? r.height }); e.dispatch(o) } }).catch(r => { }) } function tee(n) { return new Promise((e, t) => { const r = new Image; r.onload = () => e({ width: r.naturalWidth, height: r.naturalHeight }), r.onerror = t, r.src = n }) } function u6(n, e, t, r) { if (n.length === 1) { eee(n[0], e, t, r); return } let i = [...n], a = null; const o = () => { if (i.length === 0) return; const s = i.shift(); if (!s) return; const l = a ? $Ne(e, a) : t; FNe(s, e, l, r, c => { a = c, setTimeout(o, 100) }) }; o() } const VNe = { key: 1, class: "mr-2 h-4 w-4" }, HNe = We({ __name: "SlashCommandsList", props: { items: { type: Array, required: !0 }, editor: { type: Object, required: !0 }, range: { type: Object, required: !0 }, command: { type: Function, required: !0 }, query: String }, setup(n, { expose: e }) { const t = n, r = he(null), i = o => { o && t.command(o) }; return e({ onKeyDown: ({ event: o }) => { var s; return ((s = r.value) == null ? void 0 : s.onKeyDown({ event: o })) ?? !1 } }), (o, s) => (Z(), Ye(sN, { ref_key: "suggestionList", ref: r, items: t.items, command: l => i(l), "container-class": "min-w-48", "item-class": "h-7", "show-no-results": !0 }, { default: Ue(({ item: l }) => [l.icon ? (Z(), Ye(dl(l.icon), { key: 0, class: "mr-2 h-4 w-4" })) : (Z(), ye("div", VNe)), re("span", null, Ht(l.title), 1)]), _: 1 }, 8, ["items", "command"])) } }), UNe = { class: "lucide lucide-heading-2", xmlns: "http://www.w3.org/2000/svg", width: "24", height: "24", viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", "stroke-width": "1.5", "stroke-linecap": "round", "stroke-linejoin": "round" }; function GNe(n, e) { return Z(), ye("svg", UNe, e[0] || (e[0] = [re("path", { d: "M4 12h8" }, null, -1), re("path", { d: "M4 18V6" }, null, -1), re("path", { d: "M12 18V6" }, null, -1), re("path", { d: "M21 18h-4c0-4 4-3 4-6 0-1.5-2-2.5-4-1" }, null, -1)])) } const WNe = dn({ name: "lucide-heading-2", render: GNe }), KNe = { class: "lucide lucide-heading-3", xmlns: "http://www.w3.org/2000/svg", width: "24", height: "24", viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", "stroke-width": "1.5", "stroke-linecap": "round", "stroke-linejoin": "round" }; function qNe(n, e) { return Z(), ye("svg", KNe, e[0] || (e[0] = [rk('<path d="M4 12h8"></path><path d="M4 18V6"></path><path d="M12 18V6"></path><path d="M17.5 10.5c1.7-1 3.5 0 3.5 1.5a2 2 0 0 1-2 2"></path><path d="M17 17.5c2 1.5 4 .3 4-1.5a2 2 0 0 0-2-2"></path>', 5)])) } const YNe = dn({ name: "lucide-heading-3", render: qNe }), ZNe = { class: "lucide lucide-list", xmlns: "http://www.w3.org/2000/svg", width: "24", height: "24", viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", "stroke-width": "1.5", "stroke-linecap": "round", "stroke-linejoin": "round" }; function XNe(n, e) { return Z(), ye("svg", ZNe, e[0] || (e[0] = [rk('<path d="M3 12h.01"></path><path d="M3 18h.01"></path><path d="M3 6h.01"></path><path d="M8 12h13"></path><path d="M8 18h13"></path><path d="M8 6h13"></path>', 6)])) } const JNe = dn({ name: "lucide-list", render: XNe }), QNe = { class: "lucide lucide-list-ordered", xmlns: "http://www.w3.org/2000/svg", width: "24", height: "24", viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", "stroke-width": "1.5", "stroke-linecap": "round", "stroke-linejoin": "round" }; function e3e(n, e) { return Z(), ye("svg", QNe, e[0] || (e[0] = [rk('<path d="M10 12h11"></path><path d="M10 18h11"></path><path d="M10 6h11"></path><path d="M4 10h2"></path><path d="M4 6h1v4"></path><path d="M6 18H4c0-1 2-2 2-3s-1-1.5-2-1"></path>', 6)])) } const t3e = dn({ name: "lucide-list-ordered", render: e3e }), n3e = { class: "lucide lucide-code", xmlns: "http://www.w3.org/2000/svg", width: "24", height: "24", viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", "stroke-width": "1.5", "stroke-linecap": "round", "stroke-linejoin": "round" }; function r3e(n, e) { return Z(), ye("svg", n3e, e[0] || (e[0] = [re("polyline", { points: "16 18 22 12 16 6" }, null, -1), re("polyline", { points: "8 6 2 12 8 18" }, null, -1)])) } const i3e = dn({ name: "lucide-code", render: r3e }), a3e = { class: "lucide lucide-quote", xmlns: "http://www.w3.org/2000/svg", width: "24", height: "24", viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", "stroke-width": "1.5", "stroke-linecap": "round", "stroke-linejoin": "round" }; function o3e(n, e) { return Z(), ye("svg", a3e, e[0] || (e[0] = [re("path", { d: "M16 3a2 2 0 0 0-2 2v6a2 2 0 0 0 2 2 1 1 0 0 1 1 1v1a2 2 0 0 1-2 2 1 1 0 0 0-1 1v2a1 1 0 0 0 1 1 6 6 0 0 0 6-6V5a2 2 0 0 0-2-2z" }, null, -1), re("path", { d: "M5 3a2 2 0 0 0-2 2v6a2 2 0 0 0 2 2 1 1 0 0 1 1 1v1a2 2 0 0 1-2 2 1 1 0 0 0-1 1v2a1 1 0 0 0 1 1 6 6 0 0 0 6-6V5a2 2 0 0 0-2-2z" }, null, -1)])) } const s3e = dn({ name: "lucide-quote", render: o3e }), l3e = { class: "lucide lucide-image", xmlns: "http://www.w3.org/2000/svg", width: "24", height: "24", viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", "stroke-width": "1.5", "stroke-linecap": "round", "stroke-linejoin": "round" }; function c3e(n, e) { return Z(), ye("svg", l3e, e[0] || (e[0] = [re("rect", { width: "18", height: "18", x: "3", y: "3", rx: "2", ry: "2" }, null, -1), re("circle", { cx: "9", cy: "9", r: "2" }, null, -1), re("path", { d: "m21 15-3.086-3.086a2 2 0 0 0-2.828 0L6 21" }, null, -1)])) } const u3e = dn({ name: "lucide-image", render: c3e }), d3e = { class: "lucide lucide-video", xmlns: "http://www.w3.org/2000/svg", width: "24", height: "24", viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", "stroke-width": "1.5", "stroke-linecap": "round", "stroke-linejoin": "round" }; function f3e(n, e) { return Z(), ye("svg", d3e, e[0] || (e[0] = [re("path", { d: "m16 13 5.223 3.482a.5.5 0 0 0 .777-.416V7.87a.5.5 0 0 0-.752-.432L16 10.5" }, null, -1), re("rect", { x: "2", y: "6", width: "14", height: "12", rx: "2" }, null, -1)])) } const h3e = dn({ name: "lucide-video", render: f3e }), p3e = { class: "lucide lucide-link", xmlns: "http://www.w3.org/2000/svg", width: "24", height: "24", viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", "stroke-width": "1.5", "stroke-linecap": "round", "stroke-linejoin": "round" }; function m3e(n, e) { return Z(), ye("svg", p3e, e[0] || (e[0] = [re("path", { d: "M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71" }, null, -1), re("path", { d: "M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71" }, null, -1)])) } const g3e = dn({ name: "lucide-link", render: m3e }), v3e = { class: "lucide lucide-minus", xmlns: "http://www.w3.org/2000/svg", width: "24", height: "24", viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", "stroke-width": "1.5", "stroke-linecap": "round", "stroke-linejoin": "round" }; function y3e(n, e) { return Z(), ye("svg", v3e, e[0] || (e[0] = [re("path", { d: "M5 12h14" }, null, -1)])) } const nee = dn({ name: "lucide-minus", render: y3e }), _3e = { class: "lucide lucide-table-2", xmlns: "http://www.w3.org/2000/svg", width: "24", height: "24", viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", "stroke-width": "1.5", "stroke-linecap": "round", "stroke-linejoin": "round" }; function b3e(n, e) { return Z(), ye("svg", _3e, e[0] || (e[0] = [re("path", { d: "M9 3H5a2 2 0 0 0-2 2v4m6-6h10a2 2 0 0 1 2 2v4M9 3v18m0 0h10a2 2 0 0 0 2-2V9M9 21H5a2 2 0 0 1-2-2V9m0 0h18" }, null, -1)])) } const w3e = dn({ name: "lucide-table-2", render: b3e }), x3e = new xn("slashCommandSuggestion"), S3e = () => [{ title: "Heading 2", icon: WNe, command: ({ editor: n, range: e }) => { n.chain().focus().deleteRange(e).setNode("heading", { level: 2 }).run() } }, { title: "Heading 3", icon: YNe, command: ({ editor: n, range: e }) => { n.chain().focus().deleteRange(e).setNode("heading", { level: 3 }).run() } }, { title: "Bullet List", icon: JNe, command: ({ editor: n, range: e }) => { n.chain().focus().deleteRange(e).toggleBulletList().run() } }, { title: "Ordered List", icon: t3e, command: ({ editor: n, range: e }) => { n.chain().focus().deleteRange(e).toggleOrderedList().run() } }, { title: "Code Block", icon: i3e, command: ({ editor: n, range: e }) => { n.chain().focus().deleteRange(e).toggleCodeBlock().run() } }, { title: "Blockquote", icon: s3e, command: ({ editor: n, range: e }) => { n.chain().focus().deleteRange(e).toggleBlockquote().run() } }, { title: "Image", icon: u3e, command: ({ editor: n, range: e }) => { n.chain().focus().deleteRange(e).selectAndUploadImage().run() } }, { title: "Video", icon: h3e, command: ({ editor: n, range: e }) => { n.chain().focus().deleteRange(e).selectAndUploadVideo().run() } }, { title: "Link", icon: g3e, command: ({ editor: n, range: e }) => { n.chain().focus().deleteRange(e).setLink({ href: "" }).run() } }, { title: "Horizontal Rule", icon: nee, command: ({ editor: n, range: e }) => { n.chain().focus().deleteRange(e).setHorizontalRule().run() } }, { title: "Table", icon: w3e, command: ({ editor: n, range: e }) => { n.chain().focus().deleteRange(e).insertTable({ rows: 3, cols: 3, withHeaderRow: !0 }).run() } }], T3e = oN({ name: "slashCommands", char: "/", pluginKey: x3e, items: ({ query: n }) => S3e().filter(t => t.title.toLowerCase().startsWith(n.toLowerCase())), command: ({ editor: n, range: e, props: t }) => { t && typeof t.command == "function" ? t.command({ editor: n, range: e }) : console.error("Slash command execution error: command function not found on selected item or item is invalid.", t) }, component: HNe }), ree = jl.create({ name: "tagItem", group: "inline", inline: !0, selectable: !0, atom: !0, addAttributes() { return { tagId: { default: null, parseHTML: n => n.getAttribute("data-tag-id"), renderHTML: n => n.tagId ? { "data-tag-id": n.tagId } : {} }, tagLabel: { default: "tag", parseHTML: n => n.getAttribute("data-tag-label"), renderHTML: n => ({ "data-tag-label": n.tagLabel }) } } }, parseHTML() { return [{ tag: "span.tag-item", getAttrs: n => { const e = n; return { tagId: e.getAttribute("data-tag-id"), tagLabel: e.getAttribute("data-tag-label") || e.innerText.replace(/^#/, "") } } }] }, renderHTML({ HTMLAttributes: n }) { return ["span", Zr(n, { class: "tag-item" }), `#${n["data-tag-label"]}`] }, addCommands() { return { setTag: n => ({ commands: e }) => e.insertContent({ type: this.name, attrs: n }) } } }), k3e = oN({ name: "tagSuggestion", char: "#", pluginKey: new xn("tagSuggestion"), component: sN, addOptions() { return { tags: [] } }, items: ({ query: n, editor: e }) => { const { tags: t } = e.extensionManager.extensions.find(a => a.name === "tagSuggestion").options; let r = Po(t), i = r.filter(a => a.label.toLowerCase().startsWith(n.toLowerCase())).map(a => ({ ...a, display: a.label })); return n.length > 0 && !r.some(a => a.label.toLowerCase() === n.toLowerCase()) && i.push({ display: `New tag: "${n}"`, label: n, isNew: !0 }), i }, command: ({ editor: n, range: e, props: t }) => { const r = { tagLabel: t.label, ...t.id && !t.isNew && { tagId: t.id } }; n.chain().focus().insertContentAt(e, [{ type: ree.name, attrs: r }, { type: "text", text: " " }]).run() }, tippyOptions: { placement: "bottom-start", offset: [0, 8] }, allowSpaces: !1, decorationTag: "span", decorationClass: "tag-suggestion-active" }), C3e = { class: "rounded bg-surface-gray-7 px-2 py-1 text-xs text-ink-white shadow-xl" }, as = We({ inheritAttrs: !1, __name: "Tooltip", props: { text: { default: "" }, hoverDelay: { default: .5 }, placement: { default: "top" }, arrowClass: { default: "fill-surface-gray-7" }, disabled: { type: Boolean, default: !1 } }, setup(n) { const e = n, t = ne(() => e.hoverDelay * 1e3); return (r, i) => r.disabled ? ut(r.$slots, "default", { key: 0 }) : (Z(), Ye(X(ASe), { key: 1, delayDuration: t.value }, { default: Ue(() => [$e(X(MSe), null, { default: Ue(() => [$e(X(OSe), { "as-child": "" }, { default: Ue(() => [ut(r.$slots, "default")]), _: 3 }), $e(X(ISe), null, { default: Ue(() => [e.text || r.$slots.body ? (Z(), Ye(X(jSe), { key: 0, side: e.placement, "side-offset": 4, class: "z-[100]" }, { default: Ue(() => [ut(r.$slots, "body", {}, () => [re("div", C3e, [re("div", null, Ht(e.text), 1)])]), $e(X(PSe), { class: Tt(e.arrowClass), width: 8, height: 4 }, null, 8, ["class"])]), _: 3 }, 8, ["side"])) : mt("", !0)]), _: 3 })]), _: 3 })]), _: 3 }, 8, ["delayDuration"])) } }); function A3e(n) { const { targetRef: e, zoomLevel: t = he(100), onSwipeLeft: r, onSwipeRight: i, onDoubleTap: a, onTap: o, onPanStart: s, onPanMove: l, onPanAnimate: c, onPanEnd: u, onPinchStart: d, onPinchMove: f, onPinchEnd: h, doubleTapDelay: p = 300, minSwipeDistance: m = 50, maxVerticalSwipeDistance: g = 75, maxTapDuration: y = 200, maxTapMovement: b = 10, panThreshold: w = 5, inertiaDamping: v = .94, inertiaVelocityThreshold: S = .5 } = n, x = he(!1), k = he(!1), A = he(!1), C = he({ x: 0, y: 0 }), E = he(0), O = he(0), j = he(0), I = he(null), L = he(0), R = he({ x: 0, y: 0 }), D = he({ x: 0, y: 0 }), P = he(null), B = () => { P.value !== null && (cancelAnimationFrame(P.value), P.value = null), A.value = !1, D.value = { x: 0, y: 0 } }, F = W => { B(), W.preventDefault(), x.value = !1, k.value = !1, I.value = W.touches; const J = performance.now(), ie = J - E.value; if (ie < p && ie > 0 && W.touches.length === 1 && a) { a(W), E.value = 0, O.value = 0; return } if (O.value = J, W.touches.length === 1) { E.value = J; const le = W.touches[0]; C.value = { x: le.clientX, y: le.clientY }, L.value = J, R.value = { ...C.value }, D.value = { x: 0, y: 0 }, s && s(W) } else if (W.touches.length === 2) { E.value = 0; const le = W.touches[0], De = W.touches[1]; j.value = Math.hypot(De.clientX - le.clientX, De.clientY - le.clientY), k.value = !0, d && d(W) } else E.value = 0, O.value = 0 }, K = W => { if (!I.value) return; W.preventDefault(); const J = performance.now(), ie = J - L.value; if (W.touches.length === 2 && I.value.length === 2) { x.value = !1, k.value = !0; const le = W.touches[0], De = W.touches[1], ae = Math.hypot(De.clientX - le.clientX, De.clientY - le.clientY); if (j.value > 0 && f) { const pe = ae / j.value; f(pe, W) } D.value = { x: 0, y: 0 } } else if (W.touches.length === 1 && I.value.length === 1 && !k.value) { const le = W.touches[0].clientX, De = W.touches[0].clientY, ae = le - R.value.x, pe = De - R.value.y; ie > 1 ? D.value = { x: ae / ie, y: pe / ie } : D.value = { x: 0, y: 0 }, L.value = J, R.value = { x: le, y: De }; const se = le - C.value.x, ge = De - C.value.y; if (!x.value && t.value > 100 && (Math.abs(se) > w || Math.abs(ge) > w) && (x.value = !0, C.value = { x: le, y: De }), x.value && l) { const _e = t.value / 100, je = se / _e, U = ge / _e; l(je, U, W) } } }, V = W => { var pe; const J = W.touches.length, ie = performance.now(), le = x.value, De = k.value, ae = { ...D.value }; if (le && I.value && J < I.value.length) if (x.value = !1, u && u(W), Math.hypot(ae.x, ae.y) > S && c && t.value > 100) { A.value = !0; let ge = performance.now(), _e = { ...ae }; const je = U => { if (!A.value) return; const q = Math.max(1, U - ge); ge = U; const ee = t.value / 100, de = _e.x * q / ee, me = _e.y * q / ee; c(de, me); const fe = Math.pow(Math.min(.999, v), q / 16.67); _e.x *= fe, _e.y *= fe, Math.hypot(_e.x, _e.y) < .01 || t.value <= 100 ? B() : P.value = requestAnimationFrame(je) }; P.value = requestAnimationFrame(je) } else D.value = { x: 0, y: 0 }; else le || (D.value = { x: 0, y: 0 }); if (De && J < 2 && (k.value = !1, j.value = 0, h && h(W)), J === 0 && W.changedTouches.length === 1 && O.value > 0 && ((pe = I.value) == null ? void 0 : pe.length) === 1) { const se = W.changedTouches[0], ge = se.clientX - C.value.x, _e = se.clientY - C.value.y, je = ie - O.value; !le && t.value <= 100 && Math.abs(ge) > m && Math.abs(_e) < g ? ge < 0 && r ? r() : ge > 0 && i && i() : !le && je < y && Math.abs(ge) < b && Math.abs(_e) < b && o && o(W) } J === 0 ? (O.value = 0, C.value = { x: 0, y: 0 }, I.value = null, k.value = !1, A.value || (D.value = { x: 0, y: 0 })) : J === 1 && !x.value && !k.value && (C.value = { x: W.touches[0].clientX, y: W.touches[0].clientY }, O.value = performance.now(), I.value = W.touches) }; return Ct(e, (W, J) => { J && (J.removeEventListener("touchstart", F), J.removeEventListener("touchmove", K), J.removeEventListener("touchend", V), J.removeEventListener("touchcancel", V), B()), W && (W.addEventListener("touchstart", F, { passive: !1 }), W.addEventListener("touchmove", K, { passive: !1 }), W.addEventListener("touchend", V, { passive: !0 }), W.addEventListener("touchcancel", V, { passive: !0 })) }, { immediate: !0 }), { isPanning: ba(x), isPinching: ba(k), isAnimatingPan: ba(A) } } function E3e({ initialIndex: n, imageCount: e, onNavigate: t }) { const r = he(n.value); Ct(n, o => { r.value = o, t == null || t() }); function i() { e.value > 0 && (r.value = (r.value + 1) % e.value, t == null || t()) } function a() { e.value > 0 && (r.value = (r.value - 1 + e.value) % e.value, t == null || t()) } return { currentIndex: r, nextImage: i, previousImage: a } } function M3e({ containerRef: n, isEnabled: e }) { const t = he(100), r = he({ x: 0, y: 0 }), i = he(!1), a = he({ x: 0, y: 0 }), o = he({ x: 0, y: 0 }), s = 90, l = 110; Ct(t, (p, m) => { p <= 100 && m > 100 && (r.value = { x: 0, y: 0 }) }); function c() { t.value = Math.min(t.value + 25, 300) } function u() { const p = Math.max(t.value - 25, 25); t.value > 100 && p < 100 ? t.value = 100 : t.value = p } function d() { t.value = 100, r.value = { x: 0, y: 0 }, i.value = !1, o.value = { x: 0, y: 0 } } function f(p) { if (t.value <= 100) return; p.preventDefault(), i.value = !0, a.value = { x: p.clientX, y: p.clientY }, o.value = { ...r.value }; const m = y => { if (!i.value) return; const b = y.clientX - a.value.x, w = y.clientY - a.value.y, v = t.value / 100; r.value = { x: o.value.x + b / v, y: o.value.y + w / v } }, g = () => { i.value && (i.value = !1, document.removeEventListener("mousemove", m), document.removeEventListener("mouseup", g)) }; document.addEventListener("mousemove", m), document.addEventListener("mouseup", g) } function h(p) { var m; if (e.value && (m = n.value) != null && m.contains(p.target)) { p.preventDefault(); let g = p.ctrlKey ? .5 : .2; const y = -p.deltaY * g, b = t.value, w = Math.round(b + y); let v = Math.max(25, Math.min(300, w)); (b > 100 && v < 100 || b < 100 && v > 100) && Math.abs(100 - v) < Math.abs(y) * 1.5 && (v = 100), t.value = v } } return un(() => { const p = n.value; p && p.addEventListener("wheel", h, { passive: !1, capture: !0 }) }), cr(() => { const p = n.value; p && p.removeEventListener("wheel", h, { capture: !0 }), i.value && (i.value = !1) }), { zoomLevel: t, panPosition: r, isMousePanning: i, initialPanPositionOnGestureStart: o, zoomIn: c, zoomOut: u, resetZoom: d, handlePanStart: f, snapThresholdLower: s, snapThresholdUpper: l } } const O3e = { class: "lucide lucide-download", xmlns: "http://www.w3.org/2000/svg", width: "24", height: "24", viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", "stroke-width": "1.5", "stroke-linecap": "round", "stroke-linejoin": "round" }; function D3e(n, e) { return Z(), ye("svg", O3e, e[0] || (e[0] = [re("path", { d: "M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4" }, null, -1), re("polyline", { points: "7 10 12 15 17 10" }, null, -1), re("line", { x1: "12", x2: "12", y1: "15", y2: "3" }, null, -1)])) } const j3e = dn({ name: "lucide-download", render: D3e }), P3e = { class: "lucide lucide-maximize", xmlns: "http://www.w3.org/2000/svg", width: "24", height: "24", viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", "stroke-width": "1.5", "stroke-linecap": "round", "stroke-linejoin": "round" }; function I3e(n, e) { return Z(), ye("svg", P3e, e[0] || (e[0] = [re("path", { d: "M8 3H5a2 2 0 0 0-2 2v3" }, null, -1), re("path", { d: "M21 8V5a2 2 0 0 0-2-2h-3" }, null, -1), re("path", { d: "M3 16v3a2 2 0 0 0 2 2h3" }, null, -1), re("path", { d: "M16 21h3a2 2 0 0 0 2-2v-3" }, null, -1)])) } const L3e = dn({ name: "lucide-maximize", render: I3e }), R3e = { class: "lucide lucide-minimize", xmlns: "http://www.w3.org/2000/svg", width: "24", height: "24", viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", "stroke-width": "1.5", "stroke-linecap": "round", "stroke-linejoin": "round" }; function N3e(n, e) { return Z(), ye("svg", R3e, e[0] || (e[0] = [re("path", { d: "M8 3v3a2 2 0 0 1-2 2H3" }, null, -1), re("path", { d: "M21 8h-3a2 2 0 0 1-2-2V3" }, null, -1), re("path", { d: "M3 16h3a2 2 0 0 1 2 2v3" }, null, -1), re("path", { d: "M16 21v-3a2 2 0 0 1 2-2h3" }, null, -1)])) } const B3e = dn({ name: "lucide-minimize", render: N3e }), $3e = { class: "lucide lucide-chevron-left", xmlns: "http://www.w3.org/2000/svg", width: "24", height: "24", viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", "stroke-width": "1.5", "stroke-linecap": "round", "stroke-linejoin": "round" }; function F3e(n, e) { return Z(), ye("svg", $3e, e[0] || (e[0] = [re("path", { d: "m15 18-6-6 6-6" }, null, -1)])) } const z3e = dn({ name: "lucide-chevron-left", render: F3e }), V3e = { class: "lucide lucide-chevron-right", xmlns: "http://www.w3.org/2000/svg", width: "24", height: "24", viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", "stroke-width": "1.5", "stroke-linecap": "round", "stroke-linejoin": "round" }; function H3e(n, e) { return Z(), ye("svg", V3e, e[0] || (e[0] = [re("path", { d: "m9 18 6-6-6-6" }, null, -1)])) } const U3e = dn({ name: "lucide-chevron-right", render: H3e }), G3e = { class: "lucide lucide-plus", xmlns: "http://www.w3.org/2000/svg", width: "24", height: "24", viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", "stroke-width": "1.5", "stroke-linecap": "round", "stroke-linejoin": "round" }; function W3e(n, e) { return Z(), ye("svg", G3e, e[0] || (e[0] = [re("path", { d: "M5 12h14" }, null, -1), re("path", { d: "M12 5v14" }, null, -1)])) } const K3e = dn({ name: "lucide-plus", render: W3e }), q3e = { class: "lucide lucide-x", xmlns: "http://www.w3.org/2000/svg", width: "24", height: "24", viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", "stroke-width": "1.5", "stroke-linecap": "round", "stroke-linejoin": "round" }; function Y3e(n, e) { return Z(), ye("svg", q3e, e[0] || (e[0] = [re("path", { d: "M18 6 6 18" }, null, -1), re("path", { d: "m6 6 12 12" }, null, -1)])) } const lN = dn({ name: "lucide-x", render: Y3e }), Z3e = { class: "relative z-10 flex flex-col items-center" }, X3e = ["src", "alt"], J3e = { class: "bg-black/65 rounded flex items-center" }, Q3e = { class: "px-2 text-sm tabular-nums text-gray-400 select-none" }, eBe = { class: "bg-black/65 rounded flex items-center" }, tBe = { class: "bg-black/65 rounded flex items-center" }, nBe = { class: "bg-black/65 rounded flex items-center" }, rBe = 3e3, iBe = We({ __name: "ImageViewerModal", props: { show: { type: Boolean }, images: {}, initialIndex: {} }, emits: ["update:show"], setup(n, { emit: e }) { const t = n, r = e, i = Mx("imageContainer"), a = Mx("backdropElement"), o = Mx("controlsBar"), s = he(0), l = he(!1), c = he(100), u = he(!0), d = he(null), { zoomLevel: f, panPosition: h, isMousePanning: p, initialPanPositionOnGestureStart: m, zoomIn: g, zoomOut: y, resetZoom: b, handlePanStart: w, snapThresholdLower: v, snapThresholdUpper: S } = M3e({ containerRef: i, isEnabled: M0(t, "show") }), { currentIndex: x, nextImage: k, previousImage: A } = E3e({ initialIndex: M0(t, "initialIndex"), imageCount: ne(() => t.images.length), onNavigate: b }), C = ne(() => t.images[x.value]), { isPanning: E, isPinching: O, isAnimatingPan: j } = A3e({ targetRef: i, zoomLevel: f, panThreshold: 10, onSwipeLeft: () => { f.value <= 100 && k() }, onSwipeRight: () => { f.value <= 100 && A() }, onDoubleTap: V => { var W; (W = o.value) != null && W.contains(V.target) || (f.value > 100 ? b() : (f.value = 200, h.value = { x: 0, y: 0 })) }, onTap: V => { V.target === a.value && D() }, onPanStart: () => { f.value <= 100 || (m.value = { ...h.value }) }, onPanMove: (V, W) => { f.value <= 100 || (h.value = { x: m.value.x + V, y: m.value.y + W }) }, onPanAnimate: (V, W) => { h.value = { x: h.value.x + V, y: h.value.y + W } }, onPinchStart: () => { c.value = f.value, m.value = { ...h.value } }, onPinchMove: V => { const W = c.value * V; let J = Math.max(25, Math.min(300, Math.round(W))); J > v && J < S && (J = 100), f.value = J }, onPinchEnd: () => { f.value < 100 && b(), m.value = { x: 0, y: 0 } } }), I = ne(() => p.value || E.value); function L() { u.value = !0, d.value && clearTimeout(d.value), d.value = setTimeout(() => { !I.value && !O.value ? u.value = !1 : L() }, rBe) } function R() { (!O.value || !u.value) && L() } function D() { r("update:show", !1), b(), d.value && (clearTimeout(d.value), d.value = null) } function P() { var ie; const V = C.value, W = document.createElement("a"); W.href = V.src; const J = ((ie = V.alt) == null ? void 0 : ie.replace(/[^a-z0-9]/gi, "_").toLowerCase()) || V.src.split("/").pop() || "download"; W.download = J.includes(".") ? J : `${J}.jpg`, document.body.appendChild(W), W.click(), document.body.removeChild(W) } function B() { const V = i.value; l.value ? document.exitFullscreen && (document.exitFullscreen(), l.value = !1) : V != null && V.requestFullscreen && (V.requestFullscreen(), l.value = !0) } function F() { l.value = !!document.fullscreenElement } function K(V) { if (t.show) switch (R(), V.key) { case "ArrowLeft": I.value || A(), V.preventDefault(); break; case "ArrowRight": I.value || k(), V.preventDefault(); break; case "+": case "=": g(), V.preventDefault(); break; case "-": y(), V.preventDefault(); break; case "Escape": D(), V.preventDefault(); break; case "f": case "F": B(), V.preventDefault(); break } } return Ct(() => t.show, V => { V ? (u.value = !0, b(), L()) : (d.value && (clearTimeout(d.value), d.value = null), l.value && document.exitFullscreen && document.exitFullscreen()) }), Ct(o, V => { if (V) { const W = () => { s.value = V.offsetHeight }, J = new ResizeObserver(W); J.observe(V), W(), cr(() => J.disconnect()) } else s.value = 0 }), un(() => { document.addEventListener("fullscreenchange", F), document.addEventListener("keydown", K) }), cr(() => { document.removeEventListener("fullscreenchange", F), document.removeEventListener("keydown", K), d.value && clearTimeout(d.value), l.value && document.exitFullscreen && document.exitFullscreen() }), (V, W) => (Z(), Ye(rb, { to: "body" }, [$e(dq, { "enter-active-class": "transition-opacity duration-150 ease-in-out", "leave-active-class": "transition-opacity duration-150 ease-in-out", "enter-from-class": "opacity-0", "leave-to-class": "opacity-0", appear: "" }, { default: Ue(() => [t.show ? (Z(), ye("div", { key: 0, class: "fixed top-0 left-0 w-full h-full bg-black sm:bg-black/90 z-[50] flex flex-col justify-center items-center overflow-hidden touch-none", ref_key: "imageContainer", ref: i, onMousemove: R, onTouchstart: R, onTouchmove: R }, [re("div", { class: "absolute inset-0 z-0", ref_key: "backdropElement", ref: a, onClick: D }, null, 512), re("div", Z3e, [re("img", { src: C.value.src, alt: C.value.alt || "Image preview", class: "max-w-screen max-h-screen object-contain block", style: aa({ transform: `scale(${X(f) / 100}) translate(${X(h).x}px, ${X(h).y}px)`, cursor: X(f) > 100 ? X(p) ? "grabbing" : "grab" : "default", transition: I.value || X(O) || X(j) ? "none" : "transform 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275)" }), onMousedown: W[0] || (W[0] = (...J) => X(w) && X(w)(...J)), draggable: "false" }, null, 44, X3e)]), C.value.alt ? (Z(), ye("div", { key: 0, class: Tt(["absolute bottom-4 p-2 text-center rounded-sm text-white text-sm bg-black/65 z-10 transition-opacity duration-300 ease-in-out", { "opacity-0 pointer-events-none": !u.value }]) }, Ht(C.value.alt), 3)) : mt("", !0), re("div", { ref_key: "controlsBar", ref: o, class: Tt(["absolute top-4 flex items-center space-x-3 p-2 text-white z-20 transition-opacity duration-300 ease-in-out", { "opacity-0 pointer-events-none": !u.value }]), onTouchstart: W[6] || (W[6] = ar(() => { }, ["stop"])), onTouchmove: W[7] || (W[7] = ar(() => { }, ["stop"])), onTouchend: W[8] || (W[8] = ar(() => { }, ["stop"])), onMousedown: W[9] || (W[9] = ar(() => { }, ["stop"])), onWheel: W[10] || (W[10] = ar(() => { }, ["stop"])) }, [re("div", J3e, [$e(as, { text: "Previous image" }, { default: Ue(() => [re("button", { class: "p-2 hover:bg-gray-900 rounded-l focus:outline-none", onClick: W[1] || (W[1] = ar((...J) => X(A) && X(A)(...J), ["stop"])) }, [$e(X(z3e), { class: "size-4" })])]), _: 1 }), re("span", Q3e, Ht(X(x) + 1) + "/" + Ht(t.images.length), 1), $e(as, { text: "Next image" }, { default: Ue(() => [re("button", { class: "p-2 hover:bg-gray-900 rounded-r focus:outline-none", onClick: W[2] || (W[2] = ar((...J) => X(k) && X(k)(...J), ["stop"])) }, [$e(X(U3e), { class: "size-4" })])]), _: 1 })]), re("div", eBe, [$e(as, { text: "Zoom out" }, { default: Ue(() => [re("button", { class: "p-2 hover:bg-gray-900 rounded-l focus:outline-none", onClick: W[3] || (W[3] = ar((...J) => X(y) && X(y)(...J), ["stop"])) }, [$e(X(nee), { class: "size-4" })])]), _: 1 }), $e(as, { text: "Reset zoom" }, { default: Ue(() => [re("button", { class: "p-2 hover:bg-gray-900 text-sm text-gray-400 focus:outline-none", onClick: W[4] || (W[4] = ar((...J) => X(b) && X(b)(...J), ["stop"])) }, Ht(X(f)) + "% ", 1)]), _: 1 }), $e(as, { text: "Zoom in" }, { default: Ue(() => [re("button", { class: "p-2 hover:bg-gray-900 rounded-r focus:outline-none", onClick: W[5] || (W[5] = ar((...J) => X(g) && X(g)(...J), ["stop"])) }, [$e(X(K3e), { class: "size-4" })])]), _: 1 })]), re("div", tBe, [$e(as, { text: "Download image" }, { default: Ue(() => [re("button", { class: "p-2 hover:bg-gray-900 rounded-l focus:outline-none", onClick: ar(P, ["stop"]) }, [$e(X(j3e), { class: "size-4" })])]), _: 1 }), $e(as, { text: l.value ? "Exit fullscreen" : "Enter fullscreen" }, { default: Ue(() => [re("button", { class: "p-2 hover:bg-gray-900 rounded-r focus:outline-none hidden sm:block", onClick: ar(B, ["stop"]) }, [l.value ? (Z(), Ye(X(B3e), { key: 1, class: "size-4" })) : (Z(), Ye(X(L3e), { key: 0, class: "size-4" }))])]), _: 1 }, 8, ["text"])]), re("div", nBe, [$e(as, { text: "Close" }, { default: Ue(() => [re("button", { class: "p-2 hover:bg-gray-900 rounded focus:outline-none", onClick: ar(D, ["stop"]) }, [$e(X(lN), { class: "size-4" })])]), _: 1 })])], 34)], 544)) : mt("", !0)]), _: 1 })])) } }), aBe = Bi.create({
  name: "imageViewer", onBeforeCreate() {
    if (!document.querySelector("style[data-image-viewer-style]")) {
      const n = document.createElement("style"); n.textContent = `
          .ProseMirror:not(.ProseMirror-focused) img {
            cursor: pointer;
          }
        `, n.setAttribute("data-image-viewer-style", "true"), document.head.appendChild(n)
    }
  }, onDestroy() { const n = document.querySelector("style[data-image-viewer-style]"); n && document.head.removeChild(n) }, addCommands() { return { openImageViewer: n => ({ editor: e }) => { const t = []; e.state.doc.descendants(i => (i.type.name === "image" && t.push({ src: i.attrs.src, alt: i.attrs.alt || null }), !0)); const r = t.findIndex(i => i.src === n); return oBe(t, r), !0 } } }, addProseMirrorPlugins() { const n = this; return [new wn({ key: new xn("imageViewer"), props: { handleClick(e, t, r) { if (n.editor.isEditable) return !1; const { state: i } = e, a = i.doc.nodeAt(t); if ((a == null ? void 0 : a.type.name) === "image") { r.preventDefault(); const o = a.attrs.src; return n.editor.commands.openImageViewer(o), !0 } if (r.target instanceof HTMLImageElement) { let o = !1; if (i.doc.descendants((s, l) => { if (s.type.name === "image" && !o) { const c = e.nodeDOM(l); if (c && (c === r.target || c.contains(r.target))) return r.preventDefault(), n.editor.commands.openImageViewer(s.attrs.src), o = !0, !1 } return !0 }), o) return !0 } return !1 } } })] }
}); function oBe(n, e) { const t = document.createElement("div"); document.body.appendChild(t); const r = R0({ render() { return Gt(iBe, { show: !0, images: n, initialIndex: e, "onUpdate:show": i => { i || setTimeout(() => { r.unmount(), t.remove() }, 0) } }) } }); r.mount(t) } const sBe = "aaa1rp3bb0ott3vie4c1le2ogado5udhabi7c0ademy5centure6ountant0s9o1tor4d0s1ult4e0g1ro2tna4f0l1rica5g0akhan5ency5i0g1rbus3force5tel5kdn3l0ibaba4pay4lfinanz6state5y2sace3tom5m0azon4ericanexpress7family11x2fam3ica3sterdam8nalytics7droid5quan4z2o0l2partments8p0le4q0uarelle8r0ab1mco4chi3my2pa2t0e3s0da2ia2sociates9t0hleta5torney7u0ction5di0ble3o3spost5thor3o0s4vianca6w0s2x0a2z0ure5ba0by2idu3namex3narepublic11d1k2r0celona5laycard4s5efoot5gains6seball5ketball8uhaus5yern5b0c1t1va3cg1n2d1e0ats2uty4er2ntley5rlin4st0buy5t2f1g1h0arti5i0ble3d1ke2ng0o3o1z2j1lack0friday9ockbuster8g1omberg7ue3m0s1w2n0pparibas9o0ats3ehringer8fa2m1nd2o0k0ing5sch2tik2on4t1utique6x2r0adesco6idgestone9oadway5ker3ther5ussels7s1t1uild0ers6siness6y1zz3v1w1y1z0h3ca0b1fe2l0l1vinklein9m0era3p2non3petown5ital0one8r0avan4ds2e0er0s4s2sa1e1h1ino4t0ering5holic7ba1n1re3c1d1enter4o1rn3f0a1d2g1h0anel2nel4rity4se2t2eap3intai5ristmas6ome4urch5i0priani6rcle4sco3tadel4i0c2y3k1l0aims4eaning6ick2nic1que6othing5ud3ub0med6m1n1o0ach3des3ffee4llege4ogne5m0cast4mbank4unity6pany2re3uter5sec4ndos3struction8ulting7tact3ractors9oking4l1p2rsica5untry4pon0s4rses6pa2r0edit0card4union9icket5own3s1uise0s6u0isinella9v1w1x1y0mru3ou3z2dabur3d1nce3ta1e1ing3sun4y2clk3ds2e0al0er2s3gree4livery5l1oitte5ta3mocrat6ntal2ist5si0gn4v2hl2iamonds6et2gital5rect0ory7scount3ver5h2y2j1k1m1np2o0cs1tor4g1mains5t1wnload7rive4tv2ubai3nlop4pont4rban5vag2r2z2earth3t2c0o2deka3u0cation8e1g1mail3erck5nergy4gineer0ing9terprises10pson4quipment8r0icsson6ni3s0q1tate5t1u0rovision8s2vents5xchange6pert3osed4ress5traspace10fage2il1rwinds6th3mily4n0s2rm0ers5shion4t3edex3edback6rrari3ero6i0delity5o2lm2nal1nce1ial7re0stone6mdale6sh0ing5t0ness6j1k1lickr3ghts4r2orist4wers5y2m1o0o0d1tball6rd1ex2sale4um3undation8x2r0ee1senius7l1ogans4ntier7tr2ujitsu5n0d2rniture7tbol5yi3ga0l0lery3o1up4me0s3p1rden4y2b0iz3d0n2e0a1nt0ing5orge5f1g0ee3h1i0ft0s3ves2ing5l0ass3e1obal2o4m0ail3bh2o1x2n1odaddy5ld0point6f2o0dyear5g0le4p1t1v2p1q1r0ainger5phics5tis4een3ipe3ocery4up4s1t1u0ardian6cci3ge2ide2tars5ru3w1y2hair2mburg5ngout5us3bo2dfc0bank7ealth0care8lp1sinki6re1mes5iphop4samitsu7tachi5v2k0t2m1n1ockey4ldings5iday5medepot5goods5s0ense7nda3rse3spital5t0ing5t0els3mail5use3w2r1sbc3t1u0ghes5yatt3undai7ibm2cbc2e1u2d1e0ee3fm2kano4l1m0amat4db2mo0bilien9n0c1dustries8finiti5o2g1k1stitute6urance4e4t0ernational10uit4vestments10o1piranga7q1r0ish4s0maili5t0anbul7t0au2v3jaguar4va3cb2e0ep2tzt3welry6io2ll2m0p2nj2o0bs1urg4t1y2p0morgan6rs3uegos4niper7kaufen5ddi3e0rryhotels6logistics9properties14fh2g1h1i0a1ds2m1ndle4tchen5wi3m1n1oeln3matsu5sher5p0mg2n2r0d1ed3uokgroup8w1y0oto4z2la0caixa5mborghini8er3ncaster6d0rover6xess5salle5t0ino3robe5w0yer5b1c1ds2ease3clerc5frak4gal2o2xus4gbt3i0dl2fe0insurance9style7ghting6ke2lly3mited4o2ncoln4k2psy3ve1ing5k1lc1p2oan0s3cker3us3l1ndon4tte1o3ve3pl0financial11r1s1t0d0a3u0ndbeck6xe1ury5v1y2ma0drid4if1son4keup4n0agement7go3p1rket0ing3s4riott5shalls7ttel5ba2c0kinsey7d1e0d0ia3et2lbourne7me1orial6n0u2rckmsd7g1h1iami3crosoft7l1ni1t2t0subishi9k1l0b1s2m0a2n1o0bi0le4da2e1i1m1nash3ey2ster5rmon3tgage6scow4to0rcycles9v0ie4p1q1r1s0d2t0n1r2u0seum3ic4v1w1x1y1z2na0b1goya4me2tura4vy3ba2c1e0c1t0bank4flix4work5ustar5w0s2xt0direct7us4f0l2g0o2hk2i0co2ke1on3nja3ssan1y5l1o0kia3rton4w0ruz3tv4p1r0a1w2tt2u1yc2z2obi1server7ffice5kinawa6layan0group9dnavy5lo3m0ega4ne1g1l0ine5oo2pen3racle3nge4g0anic5igins6saka4tsuka4t2vh3pa0ge2nasonic7ris2s1tners4s1y3y2ccw3e0t2f0izer5g1h0armacy6d1ilips5one2to0graphy6s4ysio5ics1tet2ures6d1n0g1k2oneer5zza4k1l0ace2y0station9umbing5s3m1n0c2ohl2ker3litie5rn2st3r0america6xi3ess3ime3o0d0uctions8f1gressive8mo2perties3y5tection8u0dential9s1t1ub2w0c2y2qa1pon3uebec3st5racing4dio4e0ad1lestate6tor2y4cipes5d0stone5umbrella9hab3ise0n3t2liance6n0t0als5pair3ort3ublican8st0aurant8view0s5xroth6ich0ardli6oh3l1o1p2o0cks3deo3gers4om3s0vp3u0gby3hr2n2w0e2yukyu6sa0arland6fe0ty4kura4le1on3msclub4ung5ndvik0coromant12ofi4p1rl2s1ve2xo3b0i1s2c0a1b1haeffler7midt4olarships8ol3ule3warz5ience5ot3d1e0arch3t2cure1ity6ek2lect4ner3rvices6ven3w1x0y3fr2g1h0angrila6rp2w2ell3ia1ksha5oes2p0ping5uji3w3i0lk2na1gles5te3j1k0i0n2y0pe4l0ing4m0art3ile4n0cf3o0ccer3ial4ftbank4ware6hu2lar2utions7ng1y2y2pa0ce3ort2t3r0l2s1t0ada2ples4r1tebank4farm7c0group6ockholm6rage3e3ream4udio2y3yle4u0cks3pplies3y2ort5rf1gery5zuki5v1watch4iss4x1y0dney4stems6z2tab1ipei4lk2obao4rget4tamotors6r2too4x0i3c0i2d0k2eam2ch0nology8l1masek5nnis4va3f1g1h0d1eater2re6iaa2ckets5enda4ps2res2ol4j0maxx4x2k0maxx5l1m0all4n1o0day3kyo3ols3p1ray3shiba5tal3urs3wn2yota3s3r0ade1ing4ining5vel0ers0insurance16ust3v2t1ube2i1nes3shu4v0s2w1z2ua1bank3s2g1k1nicom3versity8o2ol2ps2s1y1z2va0cations7na1guard7c1e0gas3ntures6risign5mgensberater2ung14sicherung10t2g1i0ajes4deo3g1king4llas4n1p1rgin4sa1ion4va1o3laanderen9n1odka3lvo3te1ing3o2yage5u2wales2mart4ter4ng0gou5tch0es6eather0channel12bcam3er2site5d0ding5ibo2r3f1hoswho6ien2ki2lliamhill9n0dows4e1ners6me2olterskluwer11odside6rk0s2ld3w2s1tc1f3xbox3erox4finity6ihuan4n2xx2yz3yachts4hoo3maxun5ndex5e1odobashi7ga2kohama6u0tube6t1un3za0ppos4ra3ero3ip2m1one3uerich6w2", lBe = "121342632165322333335355455655552435435422463632574574330355524444661154543332344423364211133222221212112052232222232212222223222241112222224322321222", Sg = (n, e) => { for (const t in e) n[t] = e[t]; return n }, fP = "numeric", hP = "ascii", pP = "alpha", Ux = "asciinumeric", _w = "alphanumeric", mP = "domain", iee = "emoji", cBe = "scheme", uBe = "slashscheme", d6 = "whitespace"; function dBe(n, e) { return n in e || (e[n] = []), e[n] } function Jf(n, e, t) { e[fP] && (e[Ux] = !0, e[_w] = !0), e[hP] && (e[Ux] = !0, e[pP] = !0), e[Ux] && (e[_w] = !0), e[pP] && (e[_w] = !0), e[_w] && (e[mP] = !0), e[iee] && (e[mP] = !0); for (const r in e) { const i = dBe(r, t); i.indexOf(n) < 0 && i.push(n) } } function fBe(n, e) { const t = {}; for (const r in e) e[r].indexOf(n) >= 0 && (t[r] = !0); return t } function ga(n) { n === void 0 && (n = null), this.j = {}, this.jr = [], this.jd = null, this.t = n } ga.groups = {}; ga.prototype = { accepts() { return !!this.t }, go(n) { const e = this, t = e.j[n]; if (t) return t; for (let r = 0; r < e.jr.length; r++) { const i = e.jr[r][0], a = e.jr[r][1]; if (a && i.test(n)) return a } return e.jd }, has(n, e) { return e === void 0 && (e = !1), e ? n in this.j : !!this.go(n) }, ta(n, e, t, r) { for (let i = 0; i < n.length; i++)this.tt(n[i], e, t, r) }, tr(n, e, t, r) { r = r || ga.groups; let i; return e && e.j ? i = e : (i = new ga(e), t && r && Jf(e, t, r)), this.jr.push([n, i]), i }, ts(n, e, t, r) { let i = this; const a = n.length; if (!a) return i; for (let o = 0; o < a - 1; o++)i = i.tt(n[o]); return i.tt(n[a - 1], e, t, r) }, tt(n, e, t, r) { r = r || ga.groups; const i = this; if (e && e.j) return i.j[n] = e, e; const a = e; let o, s = i.go(n); if (s ? (o = new ga, Sg(o.j, s.j), o.jr.push.apply(o.jr, s.jr), o.jd = s.jd, o.t = s.t) : o = new ga, a) { if (r) if (o.t && typeof o.t == "string") { const l = Sg(fBe(o.t, r), t); Jf(a, l, r) } else t && Jf(a, t, r); o.t = a } return i.j[n] = o, o } }; const Xt = (n, e, t, r, i) => n.ta(e, t, r, i), oo = (n, e, t, r, i) => n.tr(e, t, r, i), f6 = (n, e, t, r, i) => n.ts(e, t, r, i), qe = (n, e, t, r, i) => n.tt(e, t, r, i), ec = "WORD", gP = "UWORD", s_ = "LOCALHOST", vP = "TLD", yP = "UTLD", Gx = "SCHEME", bm = "SLASH_SCHEME", cN = "NUM", aee = "WS", uN = "NL", o0 = "OPENBRACE", s0 = "CLOSEBRACE", h2 = "OPENBRACKET", p2 = "CLOSEBRACKET", m2 = "OPENPAREN", g2 = "CLOSEPAREN", v2 = "OPENANGLEBRACKET", y2 = "CLOSEANGLEBRACKET", _2 = "FULLWIDTHLEFTPAREN", b2 = "FULLWIDTHRIGHTPAREN", w2 = "LEFTCORNERBRACKET", x2 = "RIGHTCORNERBRACKET", S2 = "LEFTWHITECORNERBRACKET", T2 = "RIGHTWHITECORNERBRACKET", k2 = "FULLWIDTHLESSTHAN", C2 = "FULLWIDTHGREATERTHAN", A2 = "AMPERSAND", E2 = "APOSTROPHE", M2 = "ASTERISK", Cu = "AT", O2 = "BACKSLASH", D2 = "BACKTICK", j2 = "CARET", Iu = "COLON", dN = "COMMA", P2 = "DOLLAR", Ys = "DOT", I2 = "EQUALS", fN = "EXCLAMATION", Zs = "HYPHEN", L2 = "PERCENT", R2 = "PIPE", N2 = "PLUS", B2 = "POUND", $2 = "QUERY", hN = "QUOTE", pN = "SEMI", Xs = "SLASH", l0 = "TILDE", F2 = "UNDERSCORE", oee = "EMOJI", z2 = "SYM"; var see = Object.freeze({ __proto__: null, WORD: ec, UWORD: gP, LOCALHOST: s_, TLD: vP, UTLD: yP, SCHEME: Gx, SLASH_SCHEME: bm, NUM: cN, WS: aee, NL: uN, OPENBRACE: o0, CLOSEBRACE: s0, OPENBRACKET: h2, CLOSEBRACKET: p2, OPENPAREN: m2, CLOSEPAREN: g2, OPENANGLEBRACKET: v2, CLOSEANGLEBRACKET: y2, FULLWIDTHLEFTPAREN: _2, FULLWIDTHRIGHTPAREN: b2, LEFTCORNERBRACKET: w2, RIGHTCORNERBRACKET: x2, LEFTWHITECORNERBRACKET: S2, RIGHTWHITECORNERBRACKET: T2, FULLWIDTHLESSTHAN: k2, FULLWIDTHGREATERTHAN: C2, AMPERSAND: A2, APOSTROPHE: E2, ASTERISK: M2, AT: Cu, BACKSLASH: O2, BACKTICK: D2, CARET: j2, COLON: Iu, COMMA: dN, DOLLAR: P2, DOT: Ys, EQUALS: I2, EXCLAMATION: fN, HYPHEN: Zs, PERCENT: L2, PIPE: R2, PLUS: N2, POUND: B2, QUERY: $2, QUOTE: hN, SEMI: pN, SLASH: Xs, TILDE: l0, UNDERSCORE: F2, EMOJI: oee, SYM: z2 }); const $p = /[a-z]/, JE = /\p{L}/u, QE = /\p{Emoji}/u, eM = /\d/, h6 = /\s/, p6 = `
`, hBe = "", pBe = ""; let bw = null, ww = null; function mBe(n) { n === void 0 && (n = []); const e = {}; ga.groups = e; const t = new ga; bw == null && (bw = m6(sBe)), ww == null && (ww = m6(lBe)), qe(t, "'", E2), qe(t, "{", o0), qe(t, "}", s0), qe(t, "[", h2), qe(t, "]", p2), qe(t, "(", m2), qe(t, ")", g2), qe(t, "<", v2), qe(t, ">", y2), qe(t, "", _2), qe(t, "", b2), qe(t, "", w2), qe(t, "", x2), qe(t, "", S2), qe(t, "", T2), qe(t, "", k2), qe(t, "", C2), qe(t, "&", A2), qe(t, "*", M2), qe(t, "@", Cu), qe(t, "`", D2), qe(t, "^", j2), qe(t, ":", Iu), qe(t, ",", dN), qe(t, "$", P2), qe(t, ".", Ys), qe(t, "=", I2), qe(t, "!", fN), qe(t, "-", Zs), qe(t, "%", L2), qe(t, "|", R2), qe(t, "+", N2), qe(t, "#", B2), qe(t, "?", $2), qe(t, '"', hN), qe(t, "/", Xs), qe(t, ";", pN), qe(t, "~", l0), qe(t, "_", F2), qe(t, "\\", O2); const r = oo(t, eM, cN, { [fP]: !0 }); oo(r, eM, r); const i = oo(t, $p, ec, { [hP]: !0 }); oo(i, $p, i); const a = oo(t, JE, gP, { [pP]: !0 }); oo(a, $p), oo(a, JE, a); const o = oo(t, h6, aee, { [d6]: !0 }); qe(t, p6, uN, { [d6]: !0 }), qe(o, p6), oo(o, h6, o); const s = oo(t, QE, oee, { [iee]: !0 }); oo(s, QE, s), qe(s, hBe, s); const l = qe(s, pBe); oo(l, QE, s); const c = [[$p, i]], u = [[$p, null], [JE, a]]; for (let d = 0; d < bw.length; d++)ru(t, bw[d], vP, ec, c); for (let d = 0; d < ww.length; d++)ru(t, ww[d], yP, gP, u); Jf(vP, { tld: !0, ascii: !0 }, e), Jf(yP, { utld: !0, alpha: !0 }, e), ru(t, "file", Gx, ec, c), ru(t, "mailto", Gx, ec, c), ru(t, "http", bm, ec, c), ru(t, "https", bm, ec, c), ru(t, "ftp", bm, ec, c), ru(t, "ftps", bm, ec, c), Jf(Gx, { scheme: !0, ascii: !0 }, e), Jf(bm, { slashscheme: !0, ascii: !0 }, e), n = n.sort((d, f) => d[0] > f[0] ? 1 : -1); for (let d = 0; d < n.length; d++) { const f = n[d][0], p = n[d][1] ? { [cBe]: !0 } : { [uBe]: !0 }; f.indexOf("-") >= 0 ? p[mP] = !0 : $p.test(f) ? eM.test(f) ? p[Ux] = !0 : p[hP] = !0 : p[fP] = !0, f6(t, f, f, p) } return f6(t, "localhost", s_, { ascii: !0 }), t.jd = new ga(z2), { start: t, tokens: Sg({ groups: e }, see) } } function gBe(n, e) { const t = vBe(e.replace(/[A-Z]/g, s => s.toLowerCase())), r = t.length, i = []; let a = 0, o = 0; for (; o < r;) { let s = n, l = null, c = 0, u = null, d = -1, f = -1; for (; o < r && (l = s.go(t[o]));)s = l, s.accepts() ? (d = 0, f = 0, u = s) : d >= 0 && (d += t[o].length, f++), c += t[o].length, a += t[o].length, o++; a -= d, o -= f, c -= d, i.push({ t: u.t, v: e.slice(a - c, a), s: a - c, e: a }) } return i } function vBe(n) { const e = [], t = n.length; let r = 0; for (; r < t;) { let i = n.charCodeAt(r), a, o = i < 55296 || i > 56319 || r + 1 === t || (a = n.charCodeAt(r + 1)) < 56320 || a > 57343 ? n[r] : n.slice(r, r + 2); e.push(o), r += o.length } return e } function ru(n, e, t, r, i) { let a; const o = e.length; for (let s = 0; s < o - 1; s++) { const l = e[s]; n.j[l] ? a = n.j[l] : (a = new ga(r), a.jr = i.slice(), n.j[l] = a), n = a } return a = new ga(t), a.jr = i.slice(), n.j[e[o - 1]] = a, a } function m6(n) { const e = [], t = []; let r = 0, i = "0123456789"; for (; r < n.length;) { let a = 0; for (; i.indexOf(n[r + a]) >= 0;)a++; if (a > 0) { e.push(t.join("")); for (let o = parseInt(n.substring(r, r + a), 10); o > 0; o--)t.pop(); r += a } else t.push(n[r]), r++ } return e } const l_ = { defaultProtocol: "http", events: null, format: g6, formatHref: g6, nl2br: !1, tagName: "a", target: null, rel: null, validate: !0, truncate: 1 / 0, className: null, attributes: null, ignoreTags: [], render: null }; function mN(n, e) { e === void 0 && (e = null); let t = Sg({}, l_); n && (t = Sg(t, n instanceof mN ? n.o : n)); const r = t.ignoreTags, i = []; for (let a = 0; a < r.length; a++)i.push(r[a].toUpperCase()); this.o = t, e && (this.defaultRender = e), this.ignoreTags = i } mN.prototype = { o: l_, ignoreTags: [], defaultRender(n) { return n }, check(n) { return this.get("validate", n.toString(), n) }, get(n, e, t) { const r = e != null; let i = this.o[n]; return i && (typeof i == "object" ? (i = t.t in i ? i[t.t] : l_[n], typeof i == "function" && r && (i = i(e, t))) : typeof i == "function" && r && (i = i(e, t.t, t)), i) }, getObj(n, e, t) { let r = this.o[n]; return typeof r == "function" && e != null && (r = r(e, t.t, t)), r }, render(n) { const e = n.render(this); return (this.get("render", null, n) || this.defaultRender)(e, n.t, n) } }; function g6(n) { return n } function lee(n, e) { this.t = "token", this.v = n, this.tk = e } lee.prototype = { isLink: !1, toString() { return this.v }, toHref(n) { return this.toString() }, toFormattedString(n) { const e = this.toString(), t = n.get("truncate", e, this), r = n.get("format", e, this); return t && r.length > t ? r.substring(0, t) + "" : r }, toFormattedHref(n) { return n.get("formatHref", this.toHref(n.get("defaultProtocol")), this) }, startIndex() { return this.tk[0].s }, endIndex() { return this.tk[this.tk.length - 1].e }, toObject(n) { return n === void 0 && (n = l_.defaultProtocol), { type: this.t, value: this.toString(), isLink: this.isLink, href: this.toHref(n), start: this.startIndex(), end: this.endIndex() } }, toFormattedObject(n) { return { type: this.t, value: this.toFormattedString(n), isLink: this.isLink, href: this.toFormattedHref(n), start: this.startIndex(), end: this.endIndex() } }, validate(n) { return n.get("validate", this.toString(), this) }, render(n) { const e = this, t = this.toHref(n.get("defaultProtocol")), r = n.get("formatHref", t, this), i = n.get("tagName", t, e), a = this.toFormattedString(n), o = {}, s = n.get("className", t, e), l = n.get("target", t, e), c = n.get("rel", t, e), u = n.getObj("attributes", t, e), d = n.getObj("events", t, e); return o.href = r, s && (o.class = s), l && (o.target = l), c && (o.rel = c), u && Sg(o, u), { tagName: i, attributes: o, content: a, eventListeners: d } } }; function Hk(n, e) { class t extends lee { constructor(i, a) { super(i, a), this.t = n } } for (const r in e) t.prototype[r] = e[r]; return t.t = n, t } const v6 = Hk("email", { isLink: !0, toHref() { return "mailto:" + this.toString() } }), y6 = Hk("text"), yBe = Hk("nl"), xw = Hk("url", { isLink: !0, toHref(n) { return n === void 0 && (n = l_.defaultProtocol), this.hasProtocol() ? this.v : `${n}://${this.v}` }, hasProtocol() { const n = this.tk; return n.length >= 2 && n[0].t !== s_ && n[1].t === Iu } }), so = n => new ga(n); function _Be(n) { let { groups: e } = n; const t = e.domain.concat([A2, M2, Cu, O2, D2, j2, P2, I2, Zs, cN, L2, R2, N2, B2, Xs, z2, l0, F2]), r = [E2, Iu, dN, Ys, fN, $2, hN, pN, v2, y2, o0, s0, p2, h2, m2, g2, _2, b2, w2, x2, S2, T2, k2, C2], i = [A2, E2, M2, O2, D2, j2, P2, I2, Zs, o0, s0, L2, R2, N2, B2, $2, Xs, z2, l0, F2], a = so(), o = qe(a, l0); Xt(o, i, o), Xt(o, e.domain, o); const s = so(), l = so(), c = so(); Xt(a, e.domain, s), Xt(a, e.scheme, l), Xt(a, e.slashscheme, c), Xt(s, i, o), Xt(s, e.domain, s); const u = qe(s, Cu); qe(o, Cu, u), qe(l, Cu, u), qe(c, Cu, u); const d = qe(o, Ys); Xt(d, i, o), Xt(d, e.domain, o); const f = so(); Xt(u, e.domain, f), Xt(f, e.domain, f); const h = qe(f, Ys); Xt(h, e.domain, f); const p = so(v6); Xt(h, e.tld, p), Xt(h, e.utld, p), qe(u, s_, p); const m = qe(f, Zs); Xt(m, e.domain, f), Xt(p, e.domain, f), qe(p, Ys, h), qe(p, Zs, m); const g = qe(p, Iu); Xt(g, e.numeric, v6); const y = qe(s, Zs), b = qe(s, Ys); Xt(y, e.domain, s), Xt(b, i, o), Xt(b, e.domain, s); const w = so(xw); Xt(b, e.tld, w), Xt(b, e.utld, w), Xt(w, e.domain, s), Xt(w, i, o), qe(w, Ys, b), qe(w, Zs, y), qe(w, Cu, u); const v = qe(w, Iu), S = so(xw); Xt(v, e.numeric, S); const x = so(xw), k = so(); Xt(x, t, x), Xt(x, r, k), Xt(k, t, x), Xt(k, r, k), qe(w, Xs, x), qe(S, Xs, x); const A = qe(l, Iu), C = qe(c, Iu), E = qe(C, Xs), O = qe(E, Xs); Xt(l, e.domain, s), qe(l, Ys, b), qe(l, Zs, y), Xt(c, e.domain, s), qe(c, Ys, b), qe(c, Zs, y), Xt(A, e.domain, x), qe(A, Xs, x), Xt(O, e.domain, x), Xt(O, t, x), qe(O, Xs, x); const j = [[o0, s0], [h2, p2], [m2, g2], [v2, y2], [_2, b2], [w2, x2], [S2, T2], [k2, C2]]; for (let I = 0; I < j.length; I++) { const [L, R] = j[I], D = qe(x, L); qe(k, L, D), qe(D, R, x); const P = so(xw); Xt(D, t, P); const B = so(); Xt(D, r), Xt(P, t, P), Xt(P, r, B), Xt(B, t, P), Xt(B, r, B), qe(P, R, x), qe(B, R, x) } return qe(a, s_, w), qe(a, uN, yBe), { start: a, tokens: see } } function bBe(n, e, t) { let r = t.length, i = 0, a = [], o = []; for (; i < r;) { let s = n, l = null, c = null, u = 0, d = null, f = -1; for (; i < r && !(l = s.go(t[i].t));)o.push(t[i++]); for (; i < r && (c = l || s.go(t[i].t));)l = null, s = c, s.accepts() ? (f = 0, d = s) : f >= 0 && f++, i++, u++; if (f < 0) i -= u, i < r && (o.push(t[i]), i++); else { o.length > 0 && (a.push(tM(y6, e, o)), o = []), i -= f, u -= f; const h = d.t, p = t.slice(i - u, i); a.push(tM(h, e, p)) } } return o.length > 0 && a.push(tM(y6, e, o)), a } function tM(n, e, t) { const r = t[0].s, i = t[t.length - 1].e, a = e.slice(r, i); return new n(a, t) } const wBe = typeof console < "u" && console && console.warn || (() => { }), xBe = "until manual call of linkify.init(). Register all schemes and plugins before invoking linkify the first time.", or = { scanner: null, parser: null, tokenQueue: [], pluginQueue: [], customSchemes: [], initialized: !1 }; function SBe() { ga.groups = {}, or.scanner = null, or.parser = null, or.tokenQueue = [], or.pluginQueue = [], or.customSchemes = [], or.initialized = !1 } function _6(n, e) {
  if (e === void 0 && (e = !1), or.initialized && wBe(`linkifyjs: already initialized - will not register custom scheme "${n}" ${xBe}`), !/^[0-9a-z]+(-[0-9a-z]+)*$/.test(n)) throw new Error(`linkifyjs: incorrect scheme format.
1. Must only contain digits, lowercase ASCII letters or "-"
2. Cannot start or end with "-"
3. "-" cannot repeat`); or.customSchemes.push([n, e])
} function TBe() { or.scanner = mBe(or.customSchemes); for (let n = 0; n < or.tokenQueue.length; n++)or.tokenQueue[n][1]({ scanner: or.scanner }); or.parser = _Be(or.scanner.tokens); for (let n = 0; n < or.pluginQueue.length; n++)or.pluginQueue[n][1]({ scanner: or.scanner, parser: or.parser }); or.initialized = !0 } function cee(n) { return or.initialized || TBe(), bBe(or.parser.start, n, gBe(or.scanner.start, n)) } function uee(n, e, t) { if (e === void 0 && (e = null), t === void 0 && (t = null), e && typeof e == "object") { if (t) throw Error(`linkifyjs: Invalid link type ${e}; must be a string`); t = e, e = null } const r = new mN(t), i = cee(n), a = []; for (let o = 0; o < i.length; o++) { const s = i[o]; s.isLink && (!e || s.t === e) && r.check(s) && a.push(s.toFormattedObject(r)) } return a } function kBe(n) { return n.length === 1 ? n[0].isLink : n.length === 3 && n[1].isLink ? ["()", "[]"].includes(n[0].value + n[2].value) : !1 } function CBe(n) { return new wn({ key: new xn("autolink"), appendTransaction: (e, t, r) => { const i = e.some(c => c.docChanged) && !t.doc.eq(r.doc), a = e.some(c => c.getMeta("preventAutolink")); if (!i || a) return; const { tr: o } = r, s = HAe(t.doc, [...e]); if (ZAe(s).forEach(({ newRange: c }) => { const u = GAe(r.doc, c, h => h.isTextblock); let d, f; if (u.length > 1 ? (d = u[0], f = r.doc.textBetween(d.pos, d.pos + d.node.nodeSize, void 0, " ")) : u.length && r.doc.textBetween(c.from, c.to, " ", " ").endsWith(" ") && (d = u[0], f = r.doc.textBetween(d.pos, c.to, void 0, " ")), d && f) { const h = f.split(" ").filter(y => y !== ""); if (h.length <= 0) return !1; const p = h[h.length - 1], m = d.pos + f.lastIndexOf(p); if (!p) return !1; const g = cee(p).map(y => y.toObject(n.defaultProtocol)); if (!kBe(g)) return !1; g.filter(y => y.isLink).map(y => ({ ...y, from: m + y.start + 1, to: m + y.end + 1 })).filter(y => r.schema.marks.code ? !r.doc.rangeHasMark(y.from, y.to, r.schema.marks.code) : !0).filter(y => n.validate(y.value)).forEach(y => { gJ(y.from, y.to, r.doc).some(b => b.mark.type === n.type) || o.addMark(y.from, y.to, n.type.create({ href: y.href })) }) } }), !!o.steps.length) return o } }) } function ABe(n) { return new wn({ key: new xn("handleClickLink"), props: { handleClick: (e, t, r) => { var i, a; if (r.button !== 0 || !e.editable) return !1; let o = r.target; const s = []; for (; o.nodeName !== "DIV";)s.push(o), o = o.parentNode; if (!s.find(f => f.nodeName === "A")) return !1; const l = mJ(e.state, n.type.name), c = r.target, u = (i = c == null ? void 0 : c.href) !== null && i !== void 0 ? i : l.href, d = (a = c == null ? void 0 : c.target) !== null && a !== void 0 ? a : l.target; return c && u ? (window.open(u, d), !0) : !1 } } }) } function EBe(n) { return new wn({ key: new xn("handlePasteLink"), props: { handlePaste: (e, t, r) => { const { state: i } = e, { selection: a } = i, { empty: o } = a; if (o) return !1; let s = ""; r.content.forEach(c => { s += c.textContent }); const l = uee(s, { defaultProtocol: n.defaultProtocol }).find(c => c.isLink && c.value === s); return !s || !l ? !1 : (n.editor.commands.setMark(n.type, { href: l.href }), !0) } } }) } const MBe = /[\u0000-\u0020\u00A0\u1680\u180E\u2000-\u2029\u205F\u3000]/g; function b6(n, e) { const t = ["http", "https", "ftp", "ftps", "mailto", "tel", "callto", "sms", "cid", "xmpp"]; return e && e.forEach(r => { const i = typeof r == "string" ? r : r.scheme; i && t.push(i) }), !n || n.replace(MBe, "").match(new RegExp(`^(?:(?:${t.join("|")}):|[^a-z]|[a-z+.-]+(?:[^a-z+.-:]|$))`, "i")) } const OBe = jk.create({ name: "link", priority: 1e3, keepOnSplit: !1, exitable: !0, onCreate() { this.options.protocols.forEach(n => { if (typeof n == "string") { _6(n); return } _6(n.scheme, n.optionalSlashes) }) }, onDestroy() { SBe() }, inclusive() { return this.options.autolink }, addOptions() { return { openOnClick: !0, linkOnPaste: !0, autolink: !0, protocols: [], defaultProtocol: "http", HTMLAttributes: { target: "_blank", rel: "noopener noreferrer nofollow", class: null }, validate: n => !!n } }, addAttributes() { return { href: { default: null, parseHTML(n) { return n.getAttribute("href") } }, target: { default: this.options.HTMLAttributes.target }, rel: { default: this.options.HTMLAttributes.rel }, class: { default: this.options.HTMLAttributes.class } } }, parseHTML() { return [{ tag: "a[href]", getAttrs: n => { const e = n.getAttribute("href"); return !e || !b6(e, this.options.protocols) ? !1 : null } }] }, renderHTML({ HTMLAttributes: n }) { return b6(n.href, this.options.protocols) ? ["a", Zr(this.options.HTMLAttributes, n), 0] : ["a", Zr(this.options.HTMLAttributes, { ...n, href: "" }), 0] }, addCommands() { return { setLink: n => ({ chain: e }) => e().setMark(this.name, n).setMeta("preventAutolink", !0).run(), toggleLink: n => ({ chain: e }) => e().toggleMark(this.name, n, { extendEmptyMarkRange: !0 }).setMeta("preventAutolink", !0).run(), unsetLink: () => ({ chain: n }) => n().unsetMark(this.name, { extendEmptyMarkRange: !0 }).setMeta("preventAutolink", !0).run() } }, addPasteRules() { return [jEe({ find: n => { const e = []; if (n) { const { validate: t } = this.options, r = uee(n).filter(i => i.isLink && t(i.value)); r.length && r.forEach(i => e.push({ text: i.value, data: { href: i.href }, index: i.start })) } return e }, type: this.type, getAttributes: n => { var e; return { href: (e = n.data) === null || e === void 0 ? void 0 : e.href } } })] }, addProseMirrorPlugins() { const n = []; return this.options.autolink && n.push(CBe({ type: this.type, defaultProtocol: this.options.defaultProtocol, validate: this.options.validate })), this.options.openOnClick === !0 && n.push(ABe({ type: this.type })), this.options.linkOnPaste && n.push(EBe({ editor: this.editor, defaultProtocol: this.options.defaultProtocol, type: this.type })), n } }); function dee(n) { return !!(n === "" || /^(https?:\/\/|mailto:|tel:|\/\/)[^\s]+$/i.test(n) || /^([./#][^\s]*)$/i.test(n) || /^[\w\-]([\w\-./#?=&%]*)$/i.test(n)) } const DBe = { class: "p-2 flex min-w-72 items-center gap-2 bg-surface-white shadow-xl rounded-lg" }, jBe = { class: "shrink-0 flex items-center gap-2" }, PBe = We({ __name: "EditLink", props: { href: {} }, emits: ["updateHref", "close"], setup(n, { emit: e }) { const t = n, r = e, i = he(t.href), a = Mx("input"), o = () => { (i.value === "" || dee(i.value)) && r("updateHref", i.value) }; return un(async () => { var s; await Pr(), (s = a.value) != null && s.el && (a.value.el.focus(), a.value.el.select()) }), (s, l) => (Z(), ye("div", DBe, [$e(vR, { ref_key: "input", ref: a, type: "text", class: "w-full", placeholder: "https://example.com", modelValue: i.value, "onUpdate:modelValue": l[0] || (l[0] = c => i.value = c), onKeydown: [X4(o, ["enter"]), l[1] || (l[1] = X4(c => s.$emit("close"), ["esc"]))] }, null, 8, ["modelValue"]), re("div", jBe, [$e(as, { text: "Submit", placement: "top" }, { default: Ue(() => [$e(ed, { label: "Submit", onClick: o }, { icon: Ue(() => [$e(X(NSe), { class: "size-4" })]), _: 1 })]), _: 1 }), $e(as, { text: "Remove link", placement: "top" }, { default: Ue(() => [$e(ed, { label: "Remove link", onClick: l[2] || (l[2] = c => s.$emit("updateHref", "")) }, { icon: Ue(() => [$e(X(lN), { class: "size-4" })]), _: 1 })]), _: 1 })])])) } }); function IBe(n) { return new wn({ key: new xn("handlePasteLink"), props: { handlePaste: (e, t, r) => { const { state: i } = e, { selection: a } = i, { empty: o } = a; if (o) return !1; let s = ""; if (r.content.forEach(c => { s += c.textContent }), !s) return !1; let l = dee(s) ? s : null; return l ? n.editor.chain().setTextSelection({ from: a.from, to: a.to }).setLink({ href: l }).setTextSelection(a.to).command(({ tr: c }) => (c.setStoredMarks([]), !0)).run() : !1 } } }) } const LBe = OBe.extend({ addOptions() { var n; return { ...(n = this.parent) == null ? void 0 : n.call(this), openOnClick: !1, autolink: !0, defaultProtocol: "https", linkOnPaste: !1 } }, addCommands() { var n; return { ...(n = this.parent) == null ? void 0 : n.call(this), openLinkEditor: () => ({ editor: e }) => { const { state: t } = e, { from: r, to: i } = t.selection, { doc: a } = t; let o, s, l = !1; if (r === i) { const h = t.selection.$from, p = Pk(h, this.type); if (p) o = p, s = a.resolve(p.from).marks().find(m => m.type === this.type), e.chain().setTextSelection({ from: p.from, to: p.to }).run(), l = !0; else return !1 } else o = { from: r, to: i }, s = a.resolve(r).marks().find(h => h.type === this.type); if (!o) return !1; const c = (s == null ? void 0 : s.attrs.href) || "", u = o.from, d = o.to, f = () => { RBe(c, e.view.dom).then(h => { if (h === null) return; let p = e.chain().focus(null, { scrollIntoView: !1 }); if (h === "") { p.setTextSelection({ from: u, to: d }).unsetLink().command(({ tr: y }) => (y.setStoredMarks([]), !0)).run(); return } p = p.setTextSelection({ from: u, to: d }).setLink({ href: h }).setTextSelection(d).command(({ tr: y }) => (y.setStoredMarks([]), !0)); const m = d, g = m < a.content.size ? a.textBetween(m, m + 1) : null; (g === null || g !== " ") && (p = p.insertContent(" ")), p.run() }).catch(() => { }) }; return l ? requestAnimationFrame(f) : f(), !0 } } }, addKeyboardShortcuts() { return { "Mod-k": () => this.editor.commands.openLinkEditor() } }, addProseMirrorPlugins() { var e; let n = ((e = this.parent) == null ? void 0 : e.call(this)) || []; return n.push(IBe({ editor: this.editor, defaultProtocol: this.options.defaultProtocol, type: this.type })), n.push(NBe({ editor: this.editor, type: this.type })), n } }); function RBe(n, e) { return new Promise((t, r) => { const i = document.createElement("div"); document.body.appendChild(i); let a; const o = window.getSelection(); if (o && o.rangeCount > 0) { const h = o.getRangeAt(0), p = h.getBoundingClientRect(), m = h.collapsed; a = { getBoundingClientRect: () => ({ width: 0, height: p.height, top: p.top, right: m ? p.left : p.right, bottom: p.bottom, left: p.left, x: p.left, y: p.top, toJSON: () => { } }) } } else a = { getBoundingClientRect: () => e.getBoundingClientRect() }; let s = null, l = null, c = !1, u = !1; const d = (h, p) => { u || (u = !0, h === "resolve" ? t(p) : r(p)) }, f = () => { c || (c = !0, d("reject", "Link editing cancelled or destroyed"), requestAnimationFrame(() => { l == null || l.destroy(), s == null || s.unmount(), i == null || i.remove(), s = null, l = null })) }; if (s = R0({ render() { return Gt(PBe, { href: n, onClose: () => { d("reject", "Link editing cancelled"), f() }, onUpdateHref: h => { d("resolve", h), f() } }) } }), s.mount(i), l = zc(e, { getReferenceClientRect: () => a.getBoundingClientRect(), content: i, trigger: "manual", interactive: !0, appendTo: document.body, placement: "top", arrow: !1, theme: "link-editor", maxWidth: "none", onHidden() { f() }, hideOnClick: !0, interactiveDebounce: 75 }), !l) { i.remove(), d("reject", "Failed to initialize link editor tooltip"); return } l.show() }) } function NBe(n) { return new wn({ key: new xn("clearLinkMarkOnBoundary"), appendTransaction: (e, t, r) => { if (!n.editor.isEditable) return null; const { tr: i, doc: a, selection: o, storedMarks: s } = r, { $from: l, empty: c } = o; if (!c || !s || s.length === 0) return null; const u = n.type; return !s.some(p => p.type === u) || l.marks().some(p => p.type === u) ? null : i.setStoredMarks([]) } }) } const BBe = new xn("mention"), $Be = jl.create({ name: "mention", addOptions() { return { HTMLAttributes: {}, renderText({ options: n, node: e }) { var t; return `${n.suggestion.char}${(t = e.attrs.label) !== null && t !== void 0 ? t : e.attrs.id}` }, deleteTriggerWithBackspace: !1, renderHTML({ options: n, node: e }) { var t; return ["span", Zr(this.HTMLAttributes, n.HTMLAttributes), `${n.suggestion.char}${(t = e.attrs.label) !== null && t !== void 0 ? t : e.attrs.id}`] }, suggestion: { char: "@", pluginKey: BBe, command: ({ editor: n, range: e, props: t }) => { var r, i, a; const o = n.view.state.selection.$to.nodeAfter; ((r = o == null ? void 0 : o.text) === null || r === void 0 ? void 0 : r.startsWith(" ")) && (e.to += 1), n.chain().focus().insertContentAt(e, [{ type: this.name, attrs: t }, { type: "text", text: " " }]).run(), (a = (i = n.view.dom.ownerDocument.defaultView) === null || i === void 0 ? void 0 : i.getSelection()) === null || a === void 0 || a.collapseToEnd() }, allow: ({ state: n, range: e }) => { const t = n.doc.resolve(e.from), r = n.schema.nodes[this.name]; return !!t.parent.type.contentMatch.matchType(r) } } } }, group: "inline", inline: !0, selectable: !1, atom: !0, addAttributes() { return { id: { default: null, parseHTML: n => n.getAttribute("data-id"), renderHTML: n => n.id ? { "data-id": n.id } : {} }, label: { default: null, parseHTML: n => n.getAttribute("data-label"), renderHTML: n => n.label ? { "data-label": n.label } : {} } } }, parseHTML() { return [{ tag: `span[data-type="${this.name}"]` }] }, renderHTML({ node: n, HTMLAttributes: e }) { if (this.options.renderLabel !== void 0) return console.warn("renderLabel is deprecated use renderText and renderHTML instead"), ["span", Zr({ "data-type": this.name }, this.options.HTMLAttributes, e), this.options.renderLabel({ options: this.options, node: n })]; const t = { ...this.options }; t.HTMLAttributes = Zr({ "data-type": this.name }, this.options.HTMLAttributes, e); const r = this.options.renderHTML({ options: t, node: n }); return typeof r == "string" ? ["span", Zr({ "data-type": this.name }, this.options.HTMLAttributes, e), r] : r }, renderText({ node: n }) { return this.options.renderLabel !== void 0 ? (console.warn("renderLabel is deprecated use renderText and renderHTML instead"), this.options.renderLabel({ options: this.options, node: n })) : this.options.renderText({ options: this.options, node: n }) }, addKeyboardShortcuts() { return { Backspace: () => this.editor.commands.command(({ tr: n, state: e }) => { let t = !1; const { selection: r } = e, { empty: i, anchor: a } = r; return i ? (e.doc.nodesBetween(a - 1, a, (o, s) => { if (o.type.name === this.name) return t = !0, n.insertText(this.options.deleteTriggerWithBackspace ? "" : this.options.suggestion.char || "", s, s + o.nodeSize), !1 }), t) : !1 }) } }, addProseMirrorPlugins() { return [JQ({ editor: this.editor, ...this.options.suggestion })] } }); const FBe = { props: { items: { type: Array, required: !0 }, command: { type: Function, required: !0 } }, data() { return { selectedIndex: 0 } }, watch: { items() { this.selectedIndex = 0 } }, methods: { onKeyDown({ event: n }) { return n.key === "ArrowUp" ? (this.upHandler(), !0) : n.key === "ArrowDown" ? (this.downHandler(), !0) : n.key === "Enter" ? (this.enterHandler(), !0) : !1 }, upHandler() { this.selectedIndex = (this.selectedIndex + this.items.length - 1) % this.items.length }, downHandler() { this.selectedIndex = (this.selectedIndex + 1) % this.items.length }, enterHandler() { this.selectItem(this.selectedIndex) }, selectItem(n) { const e = this.items[n]; e && this.command({ id: e.value, label: e.label }) } } }, zBe = { key: 0, class: "min-w-40 rounded-lg border bg-surface-white p-1 text-base shadow-lg" }, VBe = ["onClick", "onMouseover"]; function HBe(n, e, t, r, i, a) { return Z(), ye("div", null, [t.items.length ? (Z(), ye("div", zBe, [(Z(!0), ye(Qt, null, Wa(t.items, (o, s) => (Z(), ye("button", { class: Tt([s === i.selectedIndex ? "bg-surface-gray-2" : "", "flex w-full items-center whitespace-nowrap rounded-md px-2 py-2 text-sm text-ink-gray-9"]), key: s, onClick: l => a.selectItem(s), onMouseover: l => i.selectedIndex = s }, Ht(o.label), 43, VBe))), 128))])) : mt("", !0)]) } const UBe = yn(FBe, [["render", HBe]]); function GBe(n) { return $Be.configure({ HTMLAttributes: { class: "mention" }, suggestion: WBe(n) }) } function WBe(n) { return { items: ({ query: e }) => n.filter(t => t.label.toLowerCase().startsWith(e.toLowerCase())).slice(0, 10), render: () => { let e, t; return { onStart: r => { e = new eN(UBe, { props: r, editor: r.editor }), r.clientRect && (t = zc("body", { getReferenceClientRect: r.clientRect, appendTo: () => document.body, content: e.element, showOnCreate: !0, interactive: !0, trigger: "manual", placement: "bottom-start" })) }, onUpdate(r) { e.updateProps(r), r.clientRect && t[0].setProps({ getReferenceClientRect: r.clientRect }) }, onKeyDown(r) { var i; return r.event.key === "Escape" ? (t[0].hide(), !0) : (i = e.ref) == null ? void 0 : i.onKeyDown(r) }, onExit() { t[0].destroy(), e.destroy() } } } } } const KBe = "modulepreload", qBe = function (n) { return "/assets/helpdesk/desk/" + n }, w6 = {}, _n = function (e, t, r) { if (!t || t.length === 0) return e(); const i = document.getElementsByTagName("link"); return Promise.all(t.map(a => { if (a = qBe(a), a in w6) return; w6[a] = !0; const o = a.endsWith(".css"), s = o ? '[rel="stylesheet"]' : ""; if (!!r) for (let u = i.length - 1; u >= 0; u--) { const d = i[u]; if (d.href === a && (!o || d.rel === "stylesheet")) return } else if (document.querySelector(`link[href="${a}"]${s}`)) return; const c = document.createElement("link"); if (c.rel = o ? "stylesheet" : KBe, o || (c.as = "script", c.crossOrigin = ""), c.href = a, document.head.appendChild(c), o) return new Promise((u, d) => { c.addEventListener("load", u), c.addEventListener("error", () => d(new Error(`Unable to preload CSS for ${a}`))) }) })).then(() => e()).catch(a => { const o = new Event("vite:preloadError", { cancelable: !0 }); if (o.payload = a, window.dispatchEvent(o), !o.defaultPrevented) throw a }) }, YBe = {}, ZBe = { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 24 24", width: "24", height: "24" }; function XBe(n, e) { return Z(), ye("svg", ZBe, e[0] || (e[0] = [re("path", { fill: "none", d: "M0 0H24V24H0z" }, null, -1), re("path", { d: "M13 20h-2v-7H4v7H2V4h2v7h7V4h2v16zm8-12v12h-2v-9.796l-2 .536V8.67L19.5 8H21z", fill: "currentColor" }, null, -1)])) } const JBe = yn(YBe, [["render", XBe]]), QBe = {}, e5e = { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 24 24", width: "24", height: "24" }; function t5e(n, e) { return Z(), ye("svg", e5e, e[0] || (e[0] = [re("path", { fill: "none", d: "M0 0H24V24H0z" }, null, -1), re("path", { d: "M4 4v7h7V4h2v16h-2v-7H4v7H2V4h2zm14.5 4c2.071 0 3.75 1.679 3.75 3.75 0 .857-.288 1.648-.772 2.28l-.148.18L18.034 18H22v2h-7v-1.556l4.82-5.546c.268-.307.43-.709.43-1.148 0-.966-.784-1.75-1.75-1.75-.918 0-1.671.707-1.744 1.606l-.006.144h-2C14.75 9.679 16.429 8 18.5 8z", fill: "currentColor" }, null, -1)])) } const n5e = yn(QBe, [["render", t5e]]), r5e = {}, i5e = { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 24 24", width: "24", height: "24" }; function a5e(n, e) { return Z(), ye("svg", i5e, e[0] || (e[0] = [re("path", { fill: "none", d: "M0 0H24V24H0z" }, null, -1), re("path", { d: "M22 8l-.002 2-2.505 2.883c1.59.435 2.757 1.89 2.757 3.617 0 2.071-1.679 3.75-3.75 3.75-1.826 0-3.347-1.305-3.682-3.033l1.964-.382c.156.806.866 1.415 1.718 1.415.966 0 1.75-.784 1.75-1.75s-.784-1.75-1.75-1.75c-.286 0-.556.069-.794.19l-1.307-1.547L19.35 10H15V8h7zM4 4v7h7V4h2v16h-2v-7H4v7H2V4h2z", fill: "currentColor" }, null, -1)])) } const o5e = yn(r5e, [["render", a5e]]), s5e = {}, l5e = { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 24 24", width: "24", height: "24" }; function c5e(n, e) { return Z(), ye("svg", l5e, e[0] || (e[0] = [re("path", { fill: "none", d: "M0 0H24V24H0z" }, null, -1), re("path", { d: "M13 20h-2v-7H4v7H2V4h2v7h7V4h2v16zm9-12v8h1.5v2H22v2h-2v-2h-5.5v-1.34l5-8.66H22zm-2 3.133L17.19 16H20v-4.867z", fill: "currentColor" }, null, -1)])) } const u5e = yn(s5e, [["render", c5e]]), d5e = {}, f5e = { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 24 24", width: "24", height: "24" }; function h5e(n, e) { return Z(), ye("svg", f5e, e[0] || (e[0] = [re("path", { fill: "none", d: "M0 0H24V24H0z" }, null, -1), re("path", { d: "M22 8v2h-4.323l-.464 2.636c.33-.089.678-.136 1.037-.136 2.21 0 4 1.79 4 4s-1.79 4-4 4c-1.827 0-3.367-1.224-3.846-2.897l1.923-.551c.24.836 1.01 1.448 1.923 1.448 1.105 0 2-.895 2-2s-.895-2-2-2c-.63 0-1.193.292-1.56.748l-1.81-.904L16 8h6zM4 4v7h7V4h2v16h-2v-7H4v7H2V4h2z", fill: "currentColor" }, null, -1)])) } const p5e = yn(d5e, [["render", h5e]]), m5e = {}, g5e = { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 24 24", width: "24", height: "24" }; function v5e(n, e) { return Z(), ye("svg", g5e, e[0] || (e[0] = [re("path", { fill: "none", d: "M0 0H24V24H0z" }, null, -1), re("path", { d: "M21.097 8l-2.598 4.5c2.21 0 4.001 1.79 4.001 4s-1.79 4-4 4-4-1.79-4-4c0-.736.199-1.426.546-2.019L18.788 8h2.309zM4 4v7h7V4h2v16h-2v-7H4v7H2V4h2zm14.5 10.5c-1.105 0-2 .895-2 2s.895 2 2 2 2-.895 2-2-.895-2-2-2z", fill: "currentColor" }, null, -1)])) } const y5e = yn(m5e, [["render", v5e]]), _5e = {}, b5e = { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 24 24", width: "24", height: "24" }; function w5e(n, e) { return Z(), ye("svg", b5e, e[0] || (e[0] = [re("path", { fill: "none", d: "M0 0h24v24H0z" }, null, -1), re("path", { d: "M13 6v15h-2V6H5V4h14v2z", fill: "currentColor" }, null, -1)])) } const x5e = yn(_5e, [["render", w5e]]), S5e = {}, T5e = { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 24 24", width: "24", height: "24" }; function k5e(n, e) { return Z(), ye("svg", T5e, e[0] || (e[0] = [re("path", { fill: "none", d: "M0 0h24v24H0z" }, null, -1), re("path", { d: "M8 11h4.5a2.5 2.5 0 1 0 0-5H8v5zm10 4.5a4.5 4.5 0 0 1-4.5 4.5H6V4h6.5a4.5 4.5 0 0 1 3.256 7.606A4.498 4.498 0 0 1 18 15.5zM8 13v5h5.5a2.5 2.5 0 1 0 0-5H8z", fill: "currentColor" }, null, -1)])) } const C5e = yn(S5e, [["render", k5e]]), A5e = {}, E5e = { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 24 24", width: "24", height: "24" }; function M5e(n, e) { return Z(), ye("svg", E5e, e[0] || (e[0] = [re("path", { fill: "none", d: "M0 0h24v24H0z" }, null, -1), re("path", { d: "M15 20H7v-2h2.927l2.116-12H9V4h8v2h-2.927l-2.116 12H15z", fill: "currentColor" }, null, -1)])) } const O5e = yn(A5e, [["render", M5e]]), D5e = {}, j5e = { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 24 24", width: "24", height: "24" }; function P5e(n, e) { return Z(), ye("svg", j5e, e[0] || (e[0] = [re("path", { fill: "none", d: "M0 0h24v24H0z" }, null, -1), re("path", { d: "M8 3v9a4 4 0 1 0 8 0V3h2v9a6 6 0 1 1-12 0V3h2zM4 20h16v2H4v-2z", fill: "currentColor" }, null, -1)])) } const I5e = yn(D5e, [["render", P5e]]), L5e = {}, R5e = { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 24 24", width: "24", height: "24" }; function N5e(n, e) { return Z(), ye("svg", R5e, e[0] || (e[0] = [re("path", { fill: "none", d: "M0 0h24v24H0z" }, null, -1), re("path", { d: "M3 4h18v2H3V4zm2 15h14v2H5v-2zm-2-5h18v2H3v-2zm2-5h14v2H5V9z", fill: "currentColor" }, null, -1)])) } const B5e = yn(L5e, [["render", N5e]]), $5e = {}, F5e = { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 24 24", width: "24", height: "24" }; function z5e(n, e) { return Z(), ye("svg", F5e, e[0] || (e[0] = [re("path", { fill: "none", d: "M0 0h24v24H0z" }, null, -1), re("path", { d: "M3 4h18v2H3V4zm0 15h14v2H3v-2zm0-5h18v2H3v-2zm0-5h14v2H3V9z", fill: "currentColor" }, null, -1)])) } const V5e = yn($5e, [["render", z5e]]), H5e = {}, U5e = { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 24 24", width: "24", height: "24" }; function G5e(n, e) { return Z(), ye("svg", U5e, e[0] || (e[0] = [re("path", { fill: "none", d: "M0 0h24v24H0z" }, null, -1), re("path", { d: "M3 4h18v2H3V4zm4 15h14v2H7v-2zm-4-5h18v2H3v-2zm4-5h14v2H7V9z", fill: "currentColor" }, null, -1)])) } const W5e = yn(H5e, [["render", G5e]]), K5e = {}, q5e = { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 24 24", width: "24", height: "24" }; function Y5e(n, e) { return Z(), ye("svg", q5e, e[0] || (e[0] = [re("path", { fill: "none", d: "M0 0h24v24H0z" }, null, -1), re("path", { d: "M15.246 14H8.754l-1.6 4H5l6-15h2l6 15h-2.154l-1.6-4zm-.8-2L12 5.885 9.554 12h4.892zM3 20h18v2H3v-2z", fill: "currentColor" }, null, -1)])) } const Z5e = yn(K5e, [["render", Y5e]]), X5e = {}, J5e = { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 24 24", width: "24", height: "24" }; function Q5e(n, e) { return Z(), ye("svg", J5e, e[0] || (e[0] = [re("path", { fill: "none", d: "M0 0h24v24H0z" }, null, -1), re("path", { d: "M8 4h13v2H8V4zM5 3v3h1v1H3V6h1V4H3V3h2zM3 14v-2.5h2V11H3v-1h3v2.5H4v.5h2v1H3zm2 5.5H3v-1h2V18H3v-1h3v4H3v-1h2v-.5zM8 11h13v2H8v-2zm0 7h13v2H8v-2z", fill: "currentColor" }, null, -1)])) } const e8e = yn(X5e, [["render", Q5e]]), t8e = {}, n8e = { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 24 24", width: "24", height: "24" }; function r8e(n, e) { return Z(), ye("svg", n8e, e[0] || (e[0] = [re("path", { fill: "none", d: "M0 0h24v24H0z" }, null, -1), re("path", { d: "M8 4h13v2H8V4zM4.5 6.5a1.5 1.5 0 1 1 0-3 1.5 1.5 0 0 1 0 3zm0 7a1.5 1.5 0 1 1 0-3 1.5 1.5 0 0 1 0 3zm0 6.9a1.5 1.5 0 1 1 0-3 1.5 1.5 0 0 1 0 3zM8 11h13v2H8v-2zm0 7h13v2H8v-2z", fill: "currentColor" }, null, -1)])) } const i8e = yn(t8e, [["render", r8e]]), a8e = {}, o8e = { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 24 24", width: "24", height: "24" }; function s8e(n, e) { return Z(), ye("svg", o8e, e[0] || (e[0] = [re("path", { fill: "none", d: "M0 0h24v24H0z" }, null, -1), re("path", { d: "M19.417 6.679C20.447 7.773 21 9 21 10.989c0 3.5-2.457 6.637-6.03 8.188l-.893-1.378c3.335-1.804 3.987-4.145 4.247-5.621-.537.278-1.24.375-1.929.311-1.804-.167-3.226-1.648-3.226-3.489a3.5 3.5 0 0 1 3.5-3.5c1.073 0 2.099.49 2.748 1.179zm-10 0C10.447 7.773 11 9 11 10.989c0 3.5-2.457 6.637-6.03 8.188l-.893-1.378c3.335-1.804 3.987-4.145 4.247-5.621-.537.278-1.24.375-1.929.311C4.591 12.322 3.17 10.841 3.17 9a3.5 3.5 0 0 1 3.5-3.5c1.073 0 2.099.49 2.748 1.179z", fill: "currentColor" }, null, -1)])) } const l8e = yn(a8e, [["render", s8e]]), c8e = {}, u8e = { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 24 24", width: "24", height: "24" }; function d8e(n, e) { return Z(), ye("svg", u8e, e[0] || (e[0] = [re("path", { fill: "none", d: "M0 0h24v24H0z" }, null, -1), re("path", { d: "M16.95 8.464l1.414-1.414 4.95 4.95-4.95 4.95-1.414-1.414L20.485 12 16.95 8.464zm-9.9 0L3.515 12l3.535 3.536-1.414 1.414L.686 12l4.95-4.95L7.05 8.464z", fill: "currentColor" }, null, -1)])) } const f8e = yn(c8e, [["render", d8e]]), h8e = {}, p8e = { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 24 24", width: "24", height: "24" }; function m8e(n, e) { return Z(), ye("svg", p8e, e[0] || (e[0] = [re("path", { fill: "none", d: "M0 0h24v24H0z" }, null, -1), re("path", { d: "M18.364 15.536L16.95 14.12l1.414-1.414a5 5 0 1 0-7.071-7.071L9.879 7.05 8.464 5.636 9.88 4.222a7 7 0 0 1 9.9 9.9l-1.415 1.414zm-2.828 2.828l-1.415 1.414a7 7 0 0 1-9.9-9.9l1.415-1.414L7.05 9.88l-1.414 1.414a5 5 0 1 0 7.071 7.071l1.414-1.414 1.415 1.414zm-.708-10.607l1.415 1.415-7.071 7.07-1.415-1.414 7.071-7.07z", fill: "currentColor" }, null, -1)])) } const g8e = yn(h8e, [["render", m8e]]), v8e = {}, y8e = { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 24 24", width: "24", height: "24" }; function _8e(n, e) { return Z(), ye("svg", y8e, e[0] || (e[0] = [re("path", { fill: "none", d: "M0 0h24v24H0z" }, null, -1), re("path", { d: "M21 15v3h3v2h-3v3h-2v-3h-3v-2h3v-3h2zm.008-12c.548 0 .992.445.992.993V13h-2V5H4v13.999L14 9l3 3v2.829l-3-3L6.827 19H14v2H2.992A.993.993 0 0 1 2 20.007V3.993A1 1 0 0 1 2.992 3h18.016zM8 7a2 2 0 1 1 0 4 2 2 0 0 1 0-4z", fill: "currentColor" }, null, -1)])) } const b8e = yn(v8e, [["render", _8e]]), w8e = {}, x8e = { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 24 24", width: "24", height: "24" }; function S8e(n, e) { return Z(), ye("svg", x8e, e[0] || (e[0] = [re("path", { fill: "none", d: "M0 0H24V24H0z" }, null, -1), re("path", { d: "M16 4c.552 0 1 .448 1 1v4.2l5.213-3.65c.226-.158.538-.103.697.124.058.084.09.184.09.286v12.08c0 .276-.224.5-.5.5-.103 0-.203-.032-.287-.09L17 14.8V19c0 .552-.448 1-1 1H2c-.552 0-1-.448-1-1V5c0-.552.448-1 1-1h14zm-1 2H3v12h12V6zM8 8h2v3h3v2H9.999L10 16H8l-.001-3H5v-2h3V8zm13 .841l-4 2.8v.718l4 2.8V8.84z", fill: "currentColor" }, null, -1)])) } const T8e = yn(w8e, [["render", S8e]]), k8e = {}, C8e = { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 24 24", width: "24", height: "24" }; function A8e(n, e) { return Z(), ye("svg", C8e, e[0] || (e[0] = [re("path", { fill: "none", d: "M0 0h24v24H0z" }, null, -1), re("path", { d: "M5.828 7l2.536 2.536L6.95 10.95 2 6l4.95-4.95 1.414 1.414L5.828 5H13a8 8 0 1 1 0 16H4v-2h9a6 6 0 1 0 0-12H5.828z", fill: "currentColor" }, null, -1)])) } const E8e = yn(k8e, [["render", A8e]]), M8e = {}, O8e = { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 24 24", width: "24", height: "24" }; function D8e(n, e) { return Z(), ye("svg", O8e, e[0] || (e[0] = [re("path", { fill: "none", d: "M0 0h24v24H0z" }, null, -1), re("path", { d: "M18.172 7H11a6 6 0 1 0 0 12h9v2h-9a8 8 0 1 1 0-16h7.172l-2.536-2.536L17.05 1.05 22 6l-4.95 4.95-1.414-1.414L18.172 7z", fill: "currentColor" }, null, -1)])) } const j8e = yn(M8e, [["render", D8e]]), P8e = {}, I8e = { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 24 24", width: "24", height: "24" }; function L8e(n, e) { return Z(), ye("svg", I8e, e[0] || (e[0] = [re("path", { fill: "none", d: "M0 0h24v24H0z" }, null, -1), re("path", { d: "M2 11h2v2H2v-2zm4 0h12v2H6v-2zm14 0h2v2h-2v-2z", fill: "currentColor" }, null, -1)])) } const R8e = yn(P8e, [["render", L8e]]), N8e = {}, B8e = { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 24 24", width: "24", height: "24" }; function $8e(n, e) { return Z(), ye("svg", B8e, e[0] || (e[0] = [re("path", { fill: "none", d: "M0 0h24v24H0z" }, null, -1), re("path", { d: "M13 10v4h6v-4h-6zm-2 0H5v4h6v-4zm2 9h6v-3h-6v3zm-2 0v-3H5v3h6zm2-14v3h6V5h-6zm-2 0H5v3h6V5zM4 3h16a1 1 0 0 1 1 1v16a1 1 0 0 1-1 1H4a1 1 0 0 1-1-1V4a1 1 0 0 1 1-1z", fill: "currentColor" }, null, -1)])) } const F8e = yn(N8e, [["render", $8e]]), z8e = { Paragraph: { label: "Paragraph", icon: x5e, action: n => n.chain().focus().setParagraph().run(), isActive: n => n.isActive("paragraph") }, "Heading 1": { label: "Heading 1", text: "H1", icon: JBe, action: n => n.chain().focus().toggleHeading({ level: 1 }).run(), isActive: n => n.isActive("heading", { level: 1 }) }, "Heading 2": { label: "Heading 2", text: "H2", icon: n5e, action: n => n.chain().focus().toggleHeading({ level: 2 }).run(), isActive: n => n.isActive("heading", { level: 2 }) }, "Heading 3": { label: "Heading 3", text: "H3", icon: o5e, action: n => n.chain().focus().toggleHeading({ level: 3 }).run(), isActive: n => n.isActive("heading", { level: 3 }) }, "Heading 4": { label: "Heading 4", text: "H4", icon: u5e, action: n => n.chain().focus().toggleHeading({ level: 4 }).run(), isActive: n => n.isActive("heading", { level: 4 }) }, "Heading 5": { label: "Heading 5", text: "H5", icon: p5e, action: n => n.chain().focus().toggleHeading({ level: 5 }).run(), isActive: n => n.isActive("heading", { level: 5 }) }, "Heading 6": { label: "Heading 6", text: "H6", icon: y5e, action: n => n.chain().focus().toggleHeading({ level: 6 }).run(), isActive: n => n.isActive("heading", { level: 6 }) }, Bold: { label: "Bold", icon: C5e, action: n => n.chain().focus().toggleBold().run(), isActive: n => n.isActive("bold") }, Italic: { label: "Italic", icon: O5e, action: n => n.chain().focus().toggleItalic().run(), isActive: n => n.isActive("italic") }, Underline: { label: "Underline", icon: I5e, action: n => n.chain().focus().toggleUnderline().run(), isActive: n => n.isActive("underline") }, "Bullet List": { label: "Bullet List", icon: i8e, action: n => n.chain().focus().toggleBulletList().run(), isActive: n => n.isActive("bulletList") }, "Numbered List": { label: "Numbered List", icon: e8e, action: n => n.chain().focus().toggleOrderedList().run(), isActive: n => n.isActive("orderedList") }, "Align Center": { label: "Align Center", icon: B5e, action: n => n.chain().focus().setTextAlign("center").run(), isActive: n => n.isActive({ textAlign: "center" }) }, "Align Left": { label: "Align Left", icon: V5e, action: n => n.chain().focus().setTextAlign("left").run(), isActive: n => n.isActive({ textAlign: "left" }) }, "Align Right": { label: "Align Right", icon: W5e, action: n => n.chain().focus().setTextAlign("right").run(), isActive: n => n.isActive({ textAlign: "right" }) }, FontColor: { label: "Font Color", icon: Z5e, isActive: n => n.isActive("textStyle") || n.isActive("highlight"), component: Em(() => _n(() => import("./FontColor-6bccaf8e.js"), [])) }, Blockquote: { label: "Blockquote", icon: l8e, action: n => n.chain().focus().toggleBlockquote().run(), isActive: n => n.isActive("blockquote") }, Code: { label: "Code", icon: f8e, action: n => n.chain().focus().toggleCodeBlock().run(), isActive: n => n.isActive("codeBlock") }, "Horizontal Rule": { label: "Horizontal Rule", icon: R8e, action: n => n.chain().focus().setHorizontalRule().run(), isActive: n => !1 }, Link: { label: "Link", icon: g8e, isActive: n => n.isActive("link"), component: Em(() => _n(() => import("./InsertLink-3873f86e.js"), [])) }, Image: { label: "Image", icon: b8e, isActive: n => !1, component: Em(() => _n(() => import("./InsertImage-71a9b680.js"), [])) }, Video: { label: "Video", icon: T8e, isActive: n => !1, component: Em(() => _n(() => import("./InsertVideo-9c775419.js"), ["assets/InsertVideo-9c775419.js", "assets/FileUploader-3bc7c8ba.js"])) }, Undo: { label: "Undo", icon: E8e, action: n => n.chain().focus().undo().run(), isActive: n => !1 }, Redo: { label: "Redo", icon: j8e, action: n => n.chain().focus().redo().run(), isActive: n => !1 }, InsertTable: { label: "Insert Table", icon: F8e, action: n => n.chain().focus().insertTable({ rows: 3, cols: 3, withHeaderRow: !0 }).run(), isActive: n => !1 }, AddColumnBefore: { label: "Add Column Before", action: n => n.chain().focus().addColumnBefore().run(), isActive: n => !1, isDisabled: n => !n.can().addColumnBefore() }, AddColumnAfter: { label: "Add Column After", action: n => n.chain().focus().addColumnAfter().run(), isActive: n => !1, isDisabled: n => !n.can().addColumnAfter() }, DeleteColumn: { label: "Delete Column", action: n => n.chain().focus().deleteColumn().run(), isActive: n => !1, isDisabled: n => !n.can().deleteColumn() }, AddRowBefore: { label: "Add Row Before", action: n => n.chain().focus().addRowBefore().run(), isActive: n => !1, isDisabled: n => !n.can().addRowBefore() }, AddRowAfter: { label: "Add Row After", action: n => n.chain().focus().addRowAfter().run(), isActive: n => !1, isDisabled: n => !n.can().addRowAfter() }, DeleteRow: { label: "Delete Row", action: n => n.chain().focus().deleteRow().run(), isActive: n => !1, isDisabled: n => !n.can().deleteRow() }, DeleteTable: { label: "Delete Table", action: n => n.chain().focus().deleteTable().run(), isActive: n => !1, isDisabled: n => !n.can().deleteTable() }, MergeCells: { label: "Merge Cells", action: n => n.chain().focus().mergeCells().run(), isActive: n => !1, isDisabled: n => !n.can().mergeCells() }, SplitCell: { label: "Split Cell", action: n => n.chain().focus().splitCell().run(), isActive: n => !1, isDisabled: n => !n.can().splitCell() }, ToggleHeaderColumn: { label: "Toggle Header Column", action: n => n.chain().focus().toggleHeaderColumn().run(), isActive: n => !1, isDisabled: n => !n.can().toggleHeaderColumn() }, ToggleHeaderRow: { label: "Toggle Header Row", action: n => n.chain().focus().toggleHeaderRow().run(), isActive: n => !1, isDisabled: n => !n.can().toggleHeaderRow() }, ToggleHeaderCell: { label: "Toggle Header Cell", action: n => n.chain().focus().toggleHeaderCell().run(), isActive: n => !1, isDisabled: n => !n.can().toggleHeaderCell() }, Separator: { type: "separator" } }; function Uk(n) { return n instanceof Array ? n.map(Uk) : typeof n == "object" ? n : z8e[n] } const V8e = { name: "TipTapMenu", props: ["buttons"], inject: ["editor"], components: { Popover: mY }, methods: { onButtonClick(n) { n.action(this.editor) } } }, H8e = { class: "inline-flex bg-surface-white px-1 py-1" }, U8e = { class: "inline-flex items-center gap-1" }, G8e = { key: 0, class: "h-4 w-[2px] border-l" }, W8e = { key: 1, class: "shrink-0" }, K8e = ["onClick", "set"], q8e = { key: 1 }, Y8e = { class: "rounded border bg-surface-white p-1 shadow-md" }, Z8e = { class: "w-full" }, X8e = ["onClick"], J8e = ["onClick", "title"], Q8e = { key: 1, class: "inline-block h-4 min-w-[1rem] text-sm leading-4" }; function e4e(n, e, t, r, i, a) { const o = Cc("Popover"); return Z(), ye("div", H8e, [re("div", U8e, [(Z(!0), ye(Qt, null, Wa(t.buttons, s => (Z(), ye(Qt, { key: s.label }, [s.type === "separator" ? (Z(), ye("div", G8e)) : s.map ? (Z(), ye("div", W8e, [$e(o, null, { target: Ue(({ togglePopover: l }) => [re("button", { class: "rounded px-2 py-1 text-base font-medium text-ink-gray-8 transition-colors hover:bg-surface-gray-2", onClick: l, set: n.activeBtn = s.find(c => c.isActive(a.editor)) || s[0] }, [n.activeBtn.icon ? (Z(), Ye(dl(n.activeBtn.icon), { key: 0, class: "h-4 w-4" })) : (Z(), ye("span", q8e, Ht(n.activeBtn.label), 1))], 8, K8e)]), body: Ue(({ close: l }) => [re("ul", Y8e, [(Z(!0), ye(Qt, null, Wa(s, c => Dh((Z(), ye("li", Z8e, [re("button", { class: "w-full rounded px-2 py-1 text-left text-base hover:bg-surface-menu-bar", onClick: () => { a.onButtonClick(c), l() } }, Ht(c.label), 9, X8e)], 512)), [[ag, c.isDisabled ? !c.isDisabled(a.editor) : !0]])), 256))])]), _: 2 }, 1024)])) : (Z(), Ye(dl(s.component || "div"), Sn({ key: 2, ref_for: !0 }, { editor: a.editor }), { default: Ue(l => [re("button", { class: Tt(["flex rounded p-1 text-ink-gray-8 transition-colors", s.isActive(a.editor) || l != null && l.isActive ? "bg-surface-gray-2" : "hover:bg-surface-gray-2"]), onClick: c => l != null && l.onClick ? l.onClick(s) : a.onButtonClick(s), title: s.label }, [s.icon ? (Z(), Ye(dl(s.icon), { key: 0, class: "h-4 w-4" })) : (Z(), ye("span", Q8e, Ht(s.text), 1))], 10, J8e)]), _: 2 }, 1040))], 64))), 128))])]) } const fee = yn(V8e, [["render", e4e]]), t4e = { name: "TextEditorBubbleMenu", props: ["buttons", "options"], components: { BubbleMenu: hIe, Menu: fee }, inject: ["editor"], computed: { bubbleMenuButtons() { if (!this.buttons) return !1; let n; return Array.isArray(this.buttons) ? n = this.buttons : n = ["Paragraph", "Heading 2", "Heading 3", "Separator", "Bold", "Italic", "FontColor", "Link", "Separator", "Bullet List", "Numbered List", "Separator", "Align Left", "Align Center", "Align Right", "Separator", "Image", "Video", "Blockquote", "Code", ["InsertTable", "AddColumnBefore", "AddColumnAfter", "DeleteColumn", "AddRowBefore", "AddRowAfter", "DeleteRow", "MergeCells", "SplitCell", "ToggleHeaderColumn", "ToggleHeaderRow", "ToggleHeaderCell", "DeleteTable"]], n.map(Uk) } } }; function n4e(n, e, t, r, i, a) { const o = Cc("Menu"), s = Cc("BubbleMenu"); return a.bubbleMenuButtons ? (Z(), Ye(s, Sn({ key: 0, class: "bubble-menu rounded-md shadow-sm", "tippy-options": { duration: 100 }, editor: a.editor }, t.options), { default: Ue(() => [$e(o, { class: "rounded-md border-gray-100 shadow-lg", buttons: a.bubbleMenuButtons }, null, 8, ["buttons"])]), _: 1 }, 16, ["editor"])) : mt("", !0) } const r4e = yn(t4e, [["render", n4e]]), i4e = { name: "TextEditorFixedMenu", props: ["buttons"], components: { Menu: fee }, inject: ["editor"], computed: { fixedMenuButtons() { if (!this.buttons) return !1; let n; return Array.isArray(this.buttons) ? n = this.buttons : n = [["Heading 1", "Heading 2", "Heading 3", "Heading 4", "Heading 5", "Heading 6"], "Paragraph", "Separator", "Bold", "Italic", "Separator", "Bullet List", "Numbered List", "Separator", "Align Left", "Align Center", "Align Right", "FontColor", "Separator", "Image", "Video", "Link", "Blockquote", "Code", "Horizontal Rule", ["InsertTable", "AddColumnBefore", "AddColumnAfter", "DeleteColumn", "AddRowBefore", "AddRowAfter", "DeleteRow", "MergeCells", "SplitCell", "ToggleHeaderColumn", "ToggleHeaderRow", "ToggleHeaderCell", "DeleteTable"], "Separator", "Undo", "Redo"], n.map(Uk) } } }; function a4e(n, e, t, r, i, a) { const o = Cc("Menu"); return a.fixedMenuButtons ? (Z(), Ye(o, { key: 0, buttons: a.fixedMenuButtons }, null, 8, ["buttons"])) : mt("", !0) } const o4e = yn(i4e, [["render", a4e]]), s4e = { name: "TextEditorFloatingMenu", props: ["buttons"], components: { FloatingMenu: gIe }, inject: ["editor"], computed: { floatingMenuButtons() { if (!this.buttons) return !1; let n; return Array.isArray(this.buttons) ? n = this.buttons : n = ["Paragraph", "Heading 2", "Heading 3", "Bullet List", "Numbered List", "Blockquote", "Code", "Horizontal Rule"], n.map(Uk) } } }, l4e = ["onClick", "title"], c4e = { key: 1, class: "inline-block h-4 min-w-[1rem] text-sm leading-4" }; function u4e(n, e, t, r, i, a) { const o = Cc("FloatingMenu"); return a.floatingMenuButtons ? (Z(), Ye(o, { key: 0, "tippy-options": { duration: 100 }, editor: a.editor, class: "flex" }, { default: Ue(() => [(Z(!0), ye(Qt, null, Wa(a.floatingMenuButtons, s => (Z(), ye("button", { key: s.label, class: Tt(["flex rounded p-1 text-ink-gray-8 transition-colors", s.isActive(a.editor) ? "bg-surface-gray-2" : "hover:bg-surface-gray-2"]), onClick: () => s.action(a.editor), title: s.label }, [s.icon ? (Z(), Ye(dl(s.icon), { key: 0, class: "h-4 w-4" })) : (Z(), ye("span", c4e, Ht(s.text), 1))], 10, l4e))), 128))]), _: 1 }, 8, ["editor"])) : mt("", !0) } const d4e = yn(s4e, [["render", u4e]]), f4e = jl.create({ name: "video", group: "block", selectable: !0, draggable: !0, atom: !0, addOptions() { return { uploadFunction: null, HTMLAttributes: {} } }, addAttributes() { return { src: { default: null } } }, parseHTML() { return [{ tag: "video" }] }, renderHTML({ HTMLAttributes: n }) { return ["video", Zr(this.options.HTMLAttributes, n, { controls: "" })] }, addCommands() { return { setVideo: n => ({ commands: e }) => e.insertContent({ type: this.name, attrs: n }), uploadVideo: n => ({ editor: e }) => { const t = e.state.selection.from; return h4e(n, e.view, t, this.options) }, selectAndUploadVideo: () => ({ editor: n }) => { if (!this.options.uploadFunction) return console.error("uploadFunction option is not provided for videos."), !1; const e = document.createElement("input"); return e.type = "file", e.accept = "video/*", e.onchange = t => { const r = t.target; if (r.files && r.files.length) { const i = r.files[0]; n.commands.uploadVideo(i) } }, e.click(), !0 } } }, addNodeView() { return ({ editor: n, node: e }) => { const t = document.createElement("div"); t.className = "relative aspect-w-16 aspect-h-9" + (n.isEditable ? " cursor-pointer" : ""); const r = document.createElement("video"); if (n.isEditable && (r.className = "pointer-events-none"), r.src = e.attrs.src, r.setAttribute("controls", ""), n.isEditable) { let i = document.createElement("div"); i.className = "absolute top-0 right-0 text-xs m-2 bg-surface-gray-6 text-ink-white px-2 py-1 rounded-md", i.innerHTML = "Video", t.append(i) } return t.append(r), { dom: t } } } }); function h4e(n, e, t, r) { return r.uploadFunction ? (r.uploadFunction(n).then(i => { const { schema: a } = e.state, o = a.nodes.video.create({ src: i.src }), s = e.state.tr; t != null ? s.insert(t, o) : s.replaceSelectionWith(o), e.dispatch(s) }).catch(i => { console.error("Video upload failed:", i) }), !0) : (console.error("uploadFunction option is not provided for videos."), !1) } const p4e = LRe($Le), ift = { name: "TextEditor", inheritAttrs: !1, components: { EditorContent: mIe, TextEditorFixedMenu: o4e, TextEditorBubbleMenu: r4e, TextEditorFloatingMenu: d4e }, props: { content: { type: String, default: null }, placeholder: { type: [String, Function], default: "" }, editorClass: { type: [String, Array, Object], default: "" }, editable: { type: Boolean, default: !0 }, bubbleMenu: { type: [Boolean, Array], default: !1 }, bubbleMenuOptions: { type: Object, default: () => ({}) }, fixedMenu: { type: [Boolean, Array], default: !1 }, floatingMenu: { type: [Boolean, Array], default: !1 }, extensions: { type: Array, default: () => [] }, starterkitOptions: { type: Object, default: () => ({}) }, mentions: { type: Array, default: () => [] }, tags: { type: Array, default: () => [] }, uploadFunction: { type: Function, default: n => KRe().upload(n).then(t => ({ src: t.file_url })) } }, emits: ["change", "focus", "blur"], expose: ["editor"], provide() { return { editor: ne(() => this.editor) } }, data() { return { editor: null } }, watch: { content(n) { this.editor.getHTML() !== n && this.editor.commands.setContent(n) }, editable(n) { this.editor.setEditable(n) }, editorProps: { deep: !0, handler(n) { this.editor && this.editor.setOptions({ editorProps: n }) } } }, mounted() { var n; this.editor = new pIe({ content: this.content || null, editorProps: this.editorProps, editable: this.editable, extensions: [FPe.configure({ ...this.starterkitOptions, codeBlock: !1, heading: !1 }), hNe.configure({ ...typeof ((n = this.starterkitOptions) == null ? void 0 : n.heading) == "object" && this.starterkitOptions.heading !== null ? this.starterkitOptions.heading : {} }), zOe.configure({ resizable: !0 }), UOe, HOe, VOe, mDe, GOe.configure({ types: ["heading", "paragraph"] }), WOe, nNe, pNe, RMe.extend({ addNodeView() { return uQ(QRe) } }).configure({ lowlight: p4e }), BNe.configure({ uploadFunction: this.uploadFunction }), aBe, f4e.configure({ uploadFunction: this.uploadFunction }), LBe.configure({ openOnClick: !1 }), NMe.configure({ placeholder: typeof this.placeholder == "function" ? this.placeholder : () => this.placeholder }), GBe(this.mentions), dNe, T3e, ree, k3e.configure({ tags: () => this.tags }), ...this.extensions || []], onUpdate: ({ editor: e }) => { this.$emit("change", e.getHTML()) }, onFocus: ({ editor: e, event: t }) => { this.$emit("focus", t) }, onBlur: ({ editor: e, event: t }) => { this.$emit("blur", t) } }) }, beforeUnmount() { this.editor.destroy(), this.editor = null }, computed: { editorProps() { return { attributes: { class: Tt(["prose prose-table:table-fixed prose-td:p-2 prose-th:p-2 prose-td:border prose-th:border prose-td:border-outline-gray-2 prose-th:border-outline-gray-2 prose-td:relative prose-th:relative prose-th:bg-surface-gray-2", this.editorClass]) }, clipboardTextParser: (n, e) => { if (!WRe(n) || !confirm("Do you want to convert markdown content to HTML before pasting?")) return; let t = document.createElement("div"); return t.innerHTML = GRe(n), (this.editor.view.someProp("clipboardParser") || this.editor.view.someProp("domParser") || $Re.fromSchema(this.editor.schema)).parseSlice(t, { preserveWhitespace: !0, context: e }) } } } } }; const m4e = { class: "lucide lucide-info", xmlns: "http://www.w3.org/2000/svg", width: "24", height: "24", viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", "stroke-width": "1.5", "stroke-linecap": "round", "stroke-linejoin": "round" }; function g4e(n, e) { return Z(), ye("svg", m4e, e[0] || (e[0] = [re("circle", { cx: "12", cy: "12", r: "10" }, null, -1), re("path", { d: "M12 16v-4" }, null, -1), re("path", { d: "M12 8h.01" }, null, -1)])) } const v4e = dn({ name: "lucide-info", render: g4e }), y4e = { class: "lucide lucide-triangle-alert", xmlns: "http://www.w3.org/2000/svg", width: "24", height: "24", viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", "stroke-width": "1.5", "stroke-linecap": "round", "stroke-linejoin": "round" }; function _4e(n, e) { return Z(), ye("svg", y4e, e[0] || (e[0] = [re("path", { d: "m21.73 18-8-14a2 2 0 0 0-3.48 0l-8 14A2 2 0 0 0 4 21h16a2 2 0 0 0 1.73-3" }, null, -1), re("path", { d: "M12 9v4" }, null, -1), re("path", { d: "M12 17h.01" }, null, -1)])) } const b4e = dn({ name: "lucide-alert-triangle", render: _4e }), w4e = {}, x4e = { xmlns: "http://www.w3.org/2000/svg", fill: "none", viewBox: "0 0 16 16" }; function S4e(n, e) { return Z(), ye("svg", x4e, e[0] || (e[0] = [re("path", { fill: "currentColor", d: "M8 .75a7.25 7.25 0 1 1 0 14.5A7.25 7.25 0 0 1 8 .75Zm0 1a6.25 6.25 0 1 0 0 12.5 6.25 6.25 0 0 0 0-12.5Zm2.59 3.527a.501.501 0 0 1 .758.623l-.057.085-3.848 4.666a.501.501 0 0 1-.78-.011L4.936 8.41l-.053-.086a.501.501 0 0 1 .775-.6l.07.074 1.34 1.733 3.45-4.183.072-.072Z" }, null, -1)])) } const T4e = yn(w4e, [["render", S4e]]), k4e = { class: "flex items-center gap-2 flex-grow overflow-hidden" }, C4e = { class: "flex flex-col flex-grow overflow-hidden" }, A4e = { class: "flex items-center gap-2 h-7" }, E4e = We({ __name: "Toast", props: { open: { type: Boolean }, message: {}, type: {}, duration: {}, icon: { type: [Object, Function] }, closable: { type: Boolean }, action: {} }, emits: ["update:open", "action"], setup(n, { emit: e }) { const t = n, r = e, i = ne({ get: () => t.open, set: o => r("update:open", o) }); function a() { var o, s; (s = (o = t.action) == null ? void 0 : o.onClick) == null || s.call(o), r("action") } return (o, s) => (Z(), Ye(X(wSe), { open: i.value, "onUpdate:open": s[0] || (s[0] = l => i.value = l), duration: o.closable ? o.duration : 0, class: Tt(["toast-root-animatable", "bg-surface-gray-6 border-none rounded-md px-4 py-1.5 shadow-lg flex items-center justify-between gap-3 min-w-[280px] max-w-[400px] pointer-events-auto list-none"]) }, { default: Ue(() => [re("div", k4e, [re("div", null, [o.icon ? (Z(), Ye(dl(o.icon), { key: 0, class: "flex-shrink-0 size-4" })) : o.type == "success" ? (Z(), Ye(T4e, { key: 1, class: "flex-shrink-0 size-4 text-ink-green-2" })) : o.type == "warning" ? (Z(), Ye(X(b4e), { key: 2, class: "flex-shrink-0 size-4 text-ink-amber-2" })) : o.type == "error" ? (Z(), Ye(X(v4e), { key: 3, class: "flex-shrink-0 size-4 text-ink-red-2" })) : mt("", !0)]), re("div", C4e, [o.message ? (Z(), Ye(X(kSe), { key: 0, class: "text-p-sm break-words text-ink-white" }, { default: Ue(() => [Fo(Ht(o.message), 1)]), _: 1 })) : mt("", !0)])]), re("div", A4e, [o.action ? (Z(), Ye(X(xSe), { key: 0, class: "flex-shrink-0 rounded px-2 py-1 text-sm text-ink-blue-link hover:text-ink-gray-3 focus:outline-none focus-visible:ring focus-visible:ring-outline-gray-4", "alt-text": o.action.altText || o.action.label, onClick: a }, { default: Ue(() => [Fo(Ht(o.action.label), 1)]), _: 1 }, 8, ["alt-text"])) : mt("", !0), o.closable ? (Z(), Ye(X(eZ), { key: 1, class: "flex-shrink-0 rounded p-1 text-ink-white hover:text-ink-gray-3 focus:outline-none focus-visible:ring focus-visible:ring-outline-gray-4" }, { default: Ue(() => [$e(X(lN), { class: "size-4" })]), _: 1 })) : mt("", !0)])]), _: 1 }, 8, ["open", "duration"])) } }); const pc = he([]); let M4e = 0; const x6 = (n, e) => { const t = pc.value.findIndex(r => r.id === n); t !== -1 && (pc.value[t] = { ...pc.value[t], ...e, open: !0 }) }, fs = { create: n => { const e = `toast-${M4e++}`, t = n.duration != null ? n.duration * 1e3 : 5e3, r = { id: n.id || e, open: !0, message: n.message, type: n.type || "info", duration: t, action: n.action, icon: n.icon, closable: n.closable ?? !0 }; return pc.value.push(r), r.id }, remove: n => { pc.value = pc.value.filter(e => e.id !== n) }, removeAll: () => { pc.value = [] }, promise: async (n, e) => { const t = e.duration ?? 0, r = fs.create({ message: e.loading, type: "info", icon: () => Gt(uk, { class: "text-ink-white" }), duration: t, closable: !1 }); try { const i = await n, a = typeof e.success == "function" ? e.success(i) : e.success, o = e.successDuration ?? e.duration ?? 5; return x6(r, { message: a, type: "success", duration: o * 1e3, icon: void 0, closable: !0 }), i } catch (i) { const a = typeof e.error == "function" ? e.error(i) : e.error, o = e.errorDuration ?? e.duration ?? 5; throw x6(r, { message: a, type: "error", duration: o * 1e3, icon: void 0, closable: !0 }), i } }, success: (n, e = {}) => fs.create({ message: n, type: "success", ...e }), error: (n, e = {}) => fs.create({ message: n, type: "error", ...e }), warning: (n, e = {}) => fs.create({ message: n, type: "warning", ...e }), info: (n, e = {}) => fs.create({ message: n, type: "info", ...e }) }, O4e = We({ name: "FrappeToasts", setup() { const n = (t, r) => { if (!r) fs.remove(t); else { const i = pc.value.find(a => a.id === t); i && (i.open = !0) } }, e = t => { fs.remove(t.id) }; return () => pc.value.map(t => Gt(E4e, { key: t.id, open: t.open, message: t.message, type: t.type, duration: t.duration, action: t.action, icon: t.icon, closable: t.closable, "onUpdate:open": r => n(t.id, r), onAction: () => e(t) })) } }); const D4e = We({ __name: "ToastProvider", setup(n) { return (e, t) => (Z(), Ye(X(dSe), { "swipe-direction": "down" }, { default: Ue(() => [ut(e.$slots, "default"), $e(X(O4e)), $e(X(TSe), { class: "fixed bottom-0 items-end right-0 flex flex-col p-5 gap-[10px] w-auto max-w-full z-[2147483647] outline-none pointer-events-none" })]), _: 3 })) } }), j4e = We({ __name: "FrappeUIProvider", setup(n) { return (e, t) => (Z(), Ye(D4e, null, { default: Ue(() => [ut(e.$slots, "default")]), _: 3 })) } });/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */var _P = function (n, e) { return _P = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (t, r) { t.__proto__ = r } || function (t, r) { for (var i in r) Object.prototype.hasOwnProperty.call(r, i) && (t[i] = r[i]) }, _P(n, e) }; function te(n, e) { if (typeof e != "function" && e !== null) throw new TypeError("Class extends value " + String(e) + " is not a constructor or null"); _P(n, e); function t() { this.constructor = n } n.prototype = e === null ? Object.create(e) : (t.prototype = e.prototype, new t) } var P4e = function () { function n() { this.firefox = !1, this.ie = !1, this.edge = !1, this.newEdge = !1, this.weChat = !1 } return n }(), I4e = function () { function n() { this.browser = new P4e, this.node = !1, this.wxa = !1, this.worker = !1, this.svgSupported = !1, this.touchEventsSupported = !1, this.pointerEventsSupported = !1, this.domSupported = !1, this.transformSupported = !1, this.transform3dSupported = !1, this.hasGlobalWindow = typeof window < "u" } return n }(), mu = new I4e; typeof wx == "object" && typeof wx.getSystemInfoSync == "function" ? (mu.wxa = !0, mu.touchEventsSupported = !0) : typeof document > "u" && typeof self < "u" ? mu.worker = !0 : !mu.hasGlobalWindow || "Deno" in window ? (mu.node = !0, mu.svgSupported = !0) : L4e(navigator.userAgent, mu); function L4e(n, e) { var t = e.browser, r = n.match(/Firefox\/([\d.]+)/), i = n.match(/MSIE\s([\d.]+)/) || n.match(/Trident\/.+?rv:(([\d.]+))/), a = n.match(/Edge?\/([\d.]+)/), o = /micromessenger/i.test(n); r && (t.firefox = !0, t.version = r[1]), i && (t.ie = !0, t.version = i[1]), a && (t.edge = !0, t.version = a[1], t.newEdge = +a[1].split(".")[0] > 18), o && (t.weChat = !0), e.svgSupported = typeof SVGRect < "u", e.touchEventsSupported = "ontouchstart" in window && !t.ie && !t.edge, e.pointerEventsSupported = "onpointerdown" in window && (t.edge || t.ie && +t.version >= 11), e.domSupported = typeof document < "u"; var s = document.documentElement.style; e.transform3dSupported = (t.ie && "transition" in s || t.edge || "WebKitCSSMatrix" in window && "m11" in new WebKitCSSMatrix || "MozPerspective" in s) && !("OTransition" in s), e.transformSupported = e.transform3dSupported || t.ie && +t.version >= 9 } const en = mu; var gN = 12, hee = "sans-serif", Td = gN + "px " + hee, R4e = 20, N4e = 100, B4e = "007LLmW'55;N0500LLLLLLLLLL00NNNLzWW\\\\WQb\\0FWLg\\bWb\\WQ\\WrWWQ000CL5LLFLL0LL**F*gLLLL5F0LF\\FFF5.5N"; function $4e(n) { var e = {}; if (typeof JSON > "u") return e; for (var t = 0; t < n.length; t++) { var r = String.fromCharCode(t + 32), i = (n.charCodeAt(t) - R4e) / N4e; e[r] = i } return e } var F4e = $4e(B4e), kd = { createCanvas: function () { return typeof document < "u" && document.createElement("canvas") }, measureText: function () { var n, e; return function (t, r) { if (!n) { var i = kd.createCanvas(); n = i && i.getContext("2d") } if (n) return e !== r && (e = n.font = r || Td), n.measureText(t); t = t || "", r = r || Td; var a = /((?:\d+)?\.?\d*)px/.exec(r), o = a && +a[1] || gN, s = 0; if (r.indexOf("mono") >= 0) s = o * t.length; else for (var l = 0; l < t.length; l++) { var c = F4e[t[l]]; s += c == null ? o : c * o } return { width: s } } }(), loadImage: function (n, e, t) { var r = new Image; return r.onload = e, r.onerror = t, r.src = n, r } }, pee = xl(["Function", "RegExp", "Date", "Error", "CanvasGradient", "CanvasPattern", "Image", "Canvas"], function (n, e) { return n["[object " + e + "]"] = !0, n }, {}), mee = xl(["Int8", "Uint8", "Uint8Clamped", "Int16", "Uint16", "Int32", "Uint32", "Float32", "Float64"], function (n, e) { return n["[object " + e + "Array]"] = !0, n }, {}), Wg = Object.prototype.toString, Gk = Array.prototype, z4e = Gk.forEach, V4e = Gk.filter, vN = Gk.slice, H4e = Gk.map, S6 = (function () { }).constructor, Sw = S6 ? S6.prototype : null, yN = "__proto__", U4e = 2311; function gee() { return U4e++ } function _N() { for (var n = [], e = 0; e < arguments.length; e++)n[e] = arguments[e]; typeof console < "u" && console.error.apply(console, n) } function lt(n) { if (n == null || typeof n != "object") return n; var e = n, t = Wg.call(n); if (t === "[object Array]") { if (!c0(n)) { e = []; for (var r = 0, i = n.length; r < i; r++)e[r] = lt(n[r]) } } else if (mee[t]) { if (!c0(n)) { var a = n.constructor; if (a.from) e = a.from(n); else { e = new a(n.length); for (var r = 0, i = n.length; r < i; r++)e[r] = n[r] } } } else if (!pee[t] && !c0(n) && !Tg(n)) { e = {}; for (var o in n) n.hasOwnProperty(o) && o !== yN && (e[o] = lt(n[o])) } return e } function xt(n, e, t) { if (!ot(e) || !ot(n)) return t ? lt(e) : n; for (var r in e) if (e.hasOwnProperty(r) && r !== yN) { var i = n[r], a = e[r]; ot(a) && ot(i) && !ke(a) && !ke(i) && !Tg(a) && !Tg(i) && !T6(a) && !T6(i) && !c0(a) && !c0(i) ? xt(i, a, t) : (t || !(r in n)) && (n[r] = lt(e[r])) } return n } function bN(n, e) { for (var t = n[0], r = 1, i = n.length; r < i; r++)t = xt(t, n[r], e); return t } function be(n, e) { if (Object.assign) Object.assign(n, e); else for (var t in e) e.hasOwnProperty(t) && t !== yN && (n[t] = e[t]); return n } function rt(n, e, t) { for (var r = Bt(e), i = 0, a = r.length; i < a; i++) { var o = r[i]; (t ? e[o] != null : n[o] == null) && (n[o] = e[o]) } return n } function Et(n, e) { if (n) { if (n.indexOf) return n.indexOf(e); for (var t = 0, r = n.length; t < r; t++)if (n[t] === e) return t } return -1 } function G4e(n, e) { var t = n.prototype; function r() { } r.prototype = e.prototype, n.prototype = new r; for (var i in t) t.hasOwnProperty(i) && (n.prototype[i] = t[i]); n.prototype.constructor = n, n.superClass = e } function Cr(n, e, t) { if (n = "prototype" in n ? n.prototype : n, e = "prototype" in e ? e.prototype : e, Object.getOwnPropertyNames) for (var r = Object.getOwnPropertyNames(e), i = 0; i < r.length; i++) { var a = r[i]; a !== "constructor" && (t ? e[a] != null : n[a] == null) && (n[a] = e[a]) } else rt(n, e, t) } function Ii(n) { return !n || typeof n == "string" ? !1 : typeof n.length == "number" } function $(n, e, t) { if (n && e) if (n.forEach && n.forEach === z4e) n.forEach(e, t); else if (n.length === +n.length) for (var r = 0, i = n.length; r < i; r++)e.call(t, n[r], r, n); else for (var a in n) n.hasOwnProperty(a) && e.call(t, n[a], a, n) } function Ae(n, e, t) { if (!n) return []; if (!e) return wN(n); if (n.map && n.map === H4e) return n.map(e, t); for (var r = [], i = 0, a = n.length; i < a; i++)r.push(e.call(t, n[i], i, n)); return r } function xl(n, e, t, r) { if (n && e) { for (var i = 0, a = n.length; i < a; i++)t = e.call(r, t, n[i], i, n); return t } } function pn(n, e, t) { if (!n) return []; if (!e) return wN(n); if (n.filter && n.filter === V4e) return n.filter(e, t); for (var r = [], i = 0, a = n.length; i < a; i++)e.call(t, n[i], i, n) && r.push(n[i]); return r } function W4e(n, e, t) { if (n && e) { for (var r = 0, i = n.length; r < i; r++)if (e.call(t, n[r], r, n)) return n[r] } } function Bt(n) { if (!n) return []; if (Object.keys) return Object.keys(n); var e = []; for (var t in n) n.hasOwnProperty(t) && e.push(t); return e } function K4e(n, e) { for (var t = [], r = 2; r < arguments.length; r++)t[r - 2] = arguments[r]; return function () { return n.apply(e, t.concat(vN.call(arguments))) } } var He = Sw && tt(Sw.bind) ? Sw.call.bind(Sw.bind) : K4e; function wt(n) { for (var e = [], t = 1; t < arguments.length; t++)e[t - 1] = arguments[t]; return function () { return n.apply(this, e.concat(vN.call(arguments))) } } function ke(n) { return Array.isArray ? Array.isArray(n) : Wg.call(n) === "[object Array]" } function tt(n) { return typeof n == "function" } function Fe(n) { return typeof n == "string" } function bP(n) { return Wg.call(n) === "[object String]" } function nn(n) { return typeof n == "number" } function ot(n) { var e = typeof n; return e === "function" || !!n && e === "object" } function T6(n) { return !!pee[Wg.call(n)] } function ka(n) { return !!mee[Wg.call(n)] } function Tg(n) { return typeof n == "object" && typeof n.nodeType == "number" && typeof n.ownerDocument == "object" } function Wk(n) { return n.colorStops != null } function q4e(n) { return n.image != null } function Y4e(n) { return Wg.call(n) === "[object RegExp]" } function c_(n) { return n !== n } function Xr() { for (var n = [], e = 0; e < arguments.length; e++)n[e] = arguments[e]; for (var t = 0, r = n.length; t < r; t++)if (n[t] != null) return n[t] } function yt(n, e) { return n ?? e } function pl(n, e, t) { return n ?? e ?? t } function wN(n) { for (var e = [], t = 1; t < arguments.length; t++)e[t - 1] = arguments[t]; return vN.apply(n, e) } function xN(n) { if (typeof n == "number") return [n, n, n, n]; var e = n.length; return e === 2 ? [n[0], n[1], n[0], n[1]] : e === 3 ? [n[0], n[1], n[2], n[1]] : n } function na(n, e) { if (!n) throw new Error(e) } function ps(n) { return n == null ? null : typeof n.trim == "function" ? n.trim() : n.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, "") } var vee = "__ec_primitive__"; function V2(n) { n[vee] = !0 } function c0(n) { return n[vee] } var Z4e = function () { function n() { this.data = {} } return n.prototype.delete = function (e) { var t = this.has(e); return t && delete this.data[e], t }, n.prototype.has = function (e) { return this.data.hasOwnProperty(e) }, n.prototype.get = function (e) { return this.data[e] }, n.prototype.set = function (e, t) { return this.data[e] = t, this }, n.prototype.keys = function () { return Bt(this.data) }, n.prototype.forEach = function (e) { var t = this.data; for (var r in t) t.hasOwnProperty(r) && e(t[r], r) }, n }(), yee = typeof Map == "function"; function X4e() { return yee ? new Map : new Z4e } var J4e = function () { function n(e) { var t = ke(e); this.data = X4e(); var r = this; e instanceof n ? e.each(i) : e && $(e, i); function i(a, o) { t ? r.set(a, o) : r.set(o, a) } } return n.prototype.hasKey = function (e) { return this.data.has(e) }, n.prototype.get = function (e) { return this.data.get(e) }, n.prototype.set = function (e, t) { return this.data.set(e, t), t }, n.prototype.each = function (e, t) { this.data.forEach(function (r, i) { e.call(t, r, i) }) }, n.prototype.keys = function () { var e = this.data.keys(); return yee ? Array.from(e) : e }, n.prototype.removeKey = function (e) { this.data.delete(e) }, n }(); function Ze(n) { return new J4e(n) } function u_(n, e) { for (var t = new n.constructor(n.length + e.length), r = 0; r < n.length; r++)t[r] = n[r]; for (var i = n.length, r = 0; r < e.length; r++)t[r + i] = e[r]; return t } function Kk(n, e) { var t; if (Object.create) t = Object.create(n); else { var r = function () { }; r.prototype = n, t = new r } return e && be(t, e), t } function _ee(n) { var e = n.style; e.webkitUserSelect = "none", e.userSelect = "none", e.webkitTapHighlightColor = "rgba(0,0,0,0)", e["-webkit-touch-callout"] = "none" } function Ge(n, e) { return n.hasOwnProperty(e) } function gr() { } var Wx = 180 / Math.PI; function np(n, e) { return n == null && (n = 0), e == null && (e = 0), [n, e] } function Wi(n, e) { return n[0] = e[0], n[1] = e[1], n } function _c(n) { return [n[0], n[1]] } function Q4e(n, e, t) { return n[0] = e, n[1] = t, n } function k6(n, e, t) { return n[0] = e[0] + t[0], n[1] = e[1] + t[1], n } function wP(n, e, t, r) { return n[0] = e[0] + t[0] * r, n[1] = e[1] + t[1] * r, n } function Qf(n, e, t) { return n[0] = e[0] - t[0], n[1] = e[1] - t[1], n } function xP(n) { return Math.sqrt(e$e(n)) } function e$e(n) { return n[0] * n[0] + n[1] * n[1] } function Kx(n, e, t) { return n[0] = e[0] * t, n[1] = e[1] * t, n } function Kg(n, e) { var t = xP(e); return t === 0 ? (n[0] = 0, n[1] = 0) : (n[0] = e[0] / t, n[1] = e[1] / t), n } function SP(n, e) { return Math.sqrt((n[0] - e[0]) * (n[0] - e[0]) + (n[1] - e[1]) * (n[1] - e[1])) } var Hu = SP; function t$e(n, e) { return (n[0] - e[0]) * (n[0] - e[0]) + (n[1] - e[1]) * (n[1] - e[1]) } var bh = t$e; function qx(n, e, t, r) { return n[0] = e[0] + r * (t[0] - e[0]), n[1] = e[1] + r * (t[1] - e[1]), n } function fi(n, e, t) { var r = e[0], i = e[1]; return n[0] = t[0] * r + t[2] * i + t[4], n[1] = t[1] * r + t[3] * i + t[5], n } function Uu(n, e, t) { return n[0] = Math.min(e[0], t[0]), n[1] = Math.min(e[1], t[1]), n } function Gu(n, e, t) { return n[0] = Math.max(e[0], t[0]), n[1] = Math.max(e[1], t[1]), n } var Fp = function () { function n(e, t) { this.target = e, this.topTarget = t && t.topTarget } return n }(), n$e = function () { function n(e) { this.handler = e, e.on("mousedown", this._dragStart, this), e.on("mousemove", this._drag, this), e.on("mouseup", this._dragEnd, this) } return n.prototype._dragStart = function (e) { for (var t = e.target; t && !t.draggable;)t = t.parent || t.__hostTarget; t && (this._draggingTarget = t, t.dragging = !0, this._x = e.offsetX, this._y = e.offsetY, this.handler.dispatchToElement(new Fp(t, e), "dragstart", e.event)) }, n.prototype._drag = function (e) { var t = this._draggingTarget; if (t) { var r = e.offsetX, i = e.offsetY, a = r - this._x, o = i - this._y; this._x = r, this._y = i, t.drift(a, o, e), this.handler.dispatchToElement(new Fp(t, e), "drag", e.event); var s = this.handler.findHover(r, i, t).target, l = this._dropTarget; this._dropTarget = s, t !== s && (l && s !== l && this.handler.dispatchToElement(new Fp(l, e), "dragleave", e.event), s && s !== l && this.handler.dispatchToElement(new Fp(s, e), "dragenter", e.event)) } }, n.prototype._dragEnd = function (e) { var t = this._draggingTarget; t && (t.dragging = !1), this.handler.dispatchToElement(new Fp(t, e), "dragend", e.event), this._dropTarget && this.handler.dispatchToElement(new Fp(this._dropTarget, e), "drop", e.event), this._draggingTarget = null, this._dropTarget = null }, n }(); const r$e = n$e; var i$e = function () { function n(e) { e && (this._$eventProcessor = e) } return n.prototype.on = function (e, t, r, i) { this._$handlers || (this._$handlers = {}); var a = this._$handlers; if (typeof t == "function" && (i = r, r = t, t = null), !r || !e) return this; var o = this._$eventProcessor; t != null && o && o.normalizeQuery && (t = o.normalizeQuery(t)), a[e] || (a[e] = []); for (var s = 0; s < a[e].length; s++)if (a[e][s].h === r) return this; var l = { h: r, query: t, ctx: i || this, callAtLast: r.zrEventfulCallAtLast }, c = a[e].length - 1, u = a[e][c]; return u && u.callAtLast ? a[e].splice(c, 0, l) : a[e].push(l), this }, n.prototype.isSilent = function (e) { var t = this._$handlers; return !t || !t[e] || !t[e].length }, n.prototype.off = function (e, t) { var r = this._$handlers; if (!r) return this; if (!e) return this._$handlers = {}, this; if (t) { if (r[e]) { for (var i = [], a = 0, o = r[e].length; a < o; a++)r[e][a].h !== t && i.push(r[e][a]); r[e] = i } r[e] && r[e].length === 0 && delete r[e] } else delete r[e]; return this }, n.prototype.trigger = function (e) { for (var t = [], r = 1; r < arguments.length; r++)t[r - 1] = arguments[r]; if (!this._$handlers) return this; var i = this._$handlers[e], a = this._$eventProcessor; if (i) for (var o = t.length, s = i.length, l = 0; l < s; l++) { var c = i[l]; if (!(a && a.filter && c.query != null && !a.filter(e, c.query))) switch (o) { case 0: c.h.call(c.ctx); break; case 1: c.h.call(c.ctx, t[0]); break; case 2: c.h.call(c.ctx, t[0], t[1]); break; default: c.h.apply(c.ctx, t); break } } return a && a.afterTrigger && a.afterTrigger(e), this }, n.prototype.triggerWithContext = function (e) { for (var t = [], r = 1; r < arguments.length; r++)t[r - 1] = arguments[r]; if (!this._$handlers) return this; var i = this._$handlers[e], a = this._$eventProcessor; if (i) for (var o = t.length, s = t[o - 1], l = i.length, c = 0; c < l; c++) { var u = i[c]; if (!(a && a.filter && u.query != null && !a.filter(e, u.query))) switch (o) { case 0: u.h.call(s); break; case 1: u.h.call(s, t[0]); break; case 2: u.h.call(s, t[0], t[1]); break; default: u.h.apply(s, t.slice(1, o - 1)); break } } return a && a.afterTrigger && a.afterTrigger(e), this }, n }(); const Go = i$e; var a$e = Math.log(2); function TP(n, e, t, r, i, a) { var o = r + "-" + i, s = n.length; if (a.hasOwnProperty(o)) return a[o]; if (e === 1) { var l = Math.round(Math.log((1 << s) - 1 & ~i) / a$e); return n[t][l] } for (var c = r | 1 << t, u = t + 1; r & 1 << u;)u++; for (var d = 0, f = 0, h = 0; f < s; f++) { var p = 1 << f; p & i || (d += (h % 2 ? -1 : 1) * n[t][f] * TP(n, e - 1, u, c, i | p, a), h++) } return a[o] = d, d } function C6(n, e) { var t = [[n[0], n[1], 1, 0, 0, 0, -e[0] * n[0], -e[0] * n[1]], [0, 0, 0, n[0], n[1], 1, -e[1] * n[0], -e[1] * n[1]], [n[2], n[3], 1, 0, 0, 0, -e[2] * n[2], -e[2] * n[3]], [0, 0, 0, n[2], n[3], 1, -e[3] * n[2], -e[3] * n[3]], [n[4], n[5], 1, 0, 0, 0, -e[4] * n[4], -e[4] * n[5]], [0, 0, 0, n[4], n[5], 1, -e[5] * n[4], -e[5] * n[5]], [n[6], n[7], 1, 0, 0, 0, -e[6] * n[6], -e[6] * n[7]], [0, 0, 0, n[6], n[7], 1, -e[7] * n[6], -e[7] * n[7]]], r = {}, i = TP(t, 8, 0, 0, 0, r); if (i !== 0) { for (var a = [], o = 0; o < 8; o++)for (var s = 0; s < 8; s++)a[s] == null && (a[s] = 0), a[s] += ((o + s) % 2 ? -1 : 1) * TP(t, 7, o === 0 ? 1 : 0, 1 << o, 1 << s, r) / i * e[o]; return function (l, c, u) { var d = c * a[6] + u * a[7] + 1; l[0] = (c * a[0] + u * a[1] + a[2]) / d, l[1] = (c * a[3] + u * a[4] + a[5]) / d } } } var A6 = "___zrEVENTSAVED", nM = []; function o$e(n, e, t, r, i) { return kP(nM, e, r, i, !0) && kP(n, t, nM[0], nM[1]) } function kP(n, e, t, r, i) { if (e.getBoundingClientRect && en.domSupported && !bee(e)) { var a = e[A6] || (e[A6] = {}), o = s$e(e, a), s = l$e(o, a, i); if (s) return s(n, t, r), !0 } return !1 } function s$e(n, e) { var t = e.markers; if (t) return t; t = e.markers = []; for (var r = ["left", "right"], i = ["top", "bottom"], a = 0; a < 4; a++) { var o = document.createElement("div"), s = o.style, l = a % 2, c = (a >> 1) % 2; s.cssText = ["position: absolute", "visibility: hidden", "padding: 0", "margin: 0", "border-width: 0", "user-select: none", "width:0", "height:0", r[l] + ":0", i[c] + ":0", r[1 - l] + ":auto", i[1 - c] + ":auto", ""].join("!important;"), n.appendChild(o), t.push(o) } return t } function l$e(n, e, t) { for (var r = t ? "invTrans" : "trans", i = e[r], a = e.srcCoords, o = [], s = [], l = !0, c = 0; c < 4; c++) { var u = n[c].getBoundingClientRect(), d = 2 * c, f = u.left, h = u.top; o.push(f, h), l = l && a && f === a[d] && h === a[d + 1], s.push(n[c].offsetLeft, n[c].offsetTop) } return l && i ? i : (e.srcCoords = o, e[r] = t ? C6(s, o) : C6(o, s)) } function bee(n) { return n.nodeName.toUpperCase() === "CANVAS" } var c$e = /([&<>"'])/g, u$e = { "&": "&amp;", "<": "&lt;", ">": "&gt;", '"': "&quot;", "'": "&#39;" }; function Ai(n) { return n == null ? "" : (n + "").replace(c$e, function (e, t) { return u$e[t] }) } var d$e = /^(?:mouse|pointer|contextmenu|drag|drop)|click/, rM = [], f$e = en.browser.firefox && +en.browser.version.split(".")[0] < 39; function CP(n, e, t, r) { return t = t || {}, r ? E6(n, e, t) : f$e && e.layerX != null && e.layerX !== e.offsetX ? (t.zrX = e.layerX, t.zrY = e.layerY) : e.offsetX != null ? (t.zrX = e.offsetX, t.zrY = e.offsetY) : E6(n, e, t), t } function E6(n, e, t) { if (en.domSupported && n.getBoundingClientRect) { var r = e.clientX, i = e.clientY; if (bee(n)) { var a = n.getBoundingClientRect(); t.zrX = r - a.left, t.zrY = i - a.top; return } else if (kP(rM, n, r, i)) { t.zrX = rM[0], t.zrY = rM[1]; return } } t.zrX = t.zrY = 0 } function SN(n) { return n || window.event } function po(n, e, t) { if (e = SN(e), e.zrX != null) return e; var r = e.type, i = r && r.indexOf("touch") >= 0; if (i) { var o = r !== "touchend" ? e.targetTouches[0] : e.changedTouches[0]; o && CP(n, o, e, t) } else { CP(n, e, e, t); var a = h$e(e); e.zrDelta = a ? a / 120 : -(e.detail || 0) / 3 } var s = e.button; return e.which == null && s !== void 0 && d$e.test(e.type) && (e.which = s & 1 ? 1 : s & 2 ? 3 : s & 4 ? 2 : 0), e } function h$e(n) { var e = n.wheelDelta; if (e) return e; var t = n.deltaX, r = n.deltaY; if (t == null || r == null) return e; var i = Math.abs(r !== 0 ? r : t), a = r > 0 ? -1 : r < 0 ? 1 : t > 0 ? -1 : 1; return 3 * i * a } function AP(n, e, t, r) { n.addEventListener(e, t, r) } function p$e(n, e, t, r) { n.removeEventListener(e, t, r) } var Dc = function (n) { n.preventDefault(), n.stopPropagation(), n.cancelBubble = !0 }; function M6(n) { return n.which === 2 || n.which === 3 } var m$e = function () { function n() { this._track = [] } return n.prototype.recognize = function (e, t, r) { return this._doTrack(e, t, r), this._recognize(e) }, n.prototype.clear = function () { return this._track.length = 0, this }, n.prototype._doTrack = function (e, t, r) { var i = e.touches; if (i) { for (var a = { points: [], touches: [], target: t, event: e }, o = 0, s = i.length; o < s; o++) { var l = i[o], c = CP(r, l, {}); a.points.push([c.zrX, c.zrY]), a.touches.push(l) } this._track.push(a) } }, n.prototype._recognize = function (e) { for (var t in iM) if (iM.hasOwnProperty(t)) { var r = iM[t](this._track, e); if (r) return r } }, n }(); function O6(n) { var e = n[1][0] - n[0][0], t = n[1][1] - n[0][1]; return Math.sqrt(e * e + t * t) } function g$e(n) { return [(n[0][0] + n[1][0]) / 2, (n[0][1] + n[1][1]) / 2] } var iM = { pinch: function (n, e) { var t = n.length; if (t) { var r = (n[t - 1] || {}).points, i = (n[t - 2] || {}).points || r; if (i && i.length > 1 && r && r.length > 1) { var a = O6(r) / O6(i); !isFinite(a) && (a = 1), e.pinchScale = a; var o = g$e(r); return e.pinchX = o[0], e.pinchY = o[1], { type: "pinch", target: n[0].target, event: e } } } } }; function Va() { return [1, 0, 0, 1, 0, 0] } function qk(n) { return n[0] = 1, n[1] = 0, n[2] = 0, n[3] = 1, n[4] = 0, n[5] = 0, n } function TN(n, e) { return n[0] = e[0], n[1] = e[1], n[2] = e[2], n[3] = e[3], n[4] = e[4], n[5] = e[5], n } function bc(n, e, t) { var r = e[0] * t[0] + e[2] * t[1], i = e[1] * t[0] + e[3] * t[1], a = e[0] * t[2] + e[2] * t[3], o = e[1] * t[2] + e[3] * t[3], s = e[0] * t[4] + e[2] * t[5] + e[4], l = e[1] * t[4] + e[3] * t[5] + e[5]; return n[0] = r, n[1] = i, n[2] = a, n[3] = o, n[4] = s, n[5] = l, n } function Sl(n, e, t) { return n[0] = e[0], n[1] = e[1], n[2] = e[2], n[3] = e[3], n[4] = e[4] + t[0], n[5] = e[5] + t[1], n } function rp(n, e, t, r) { r === void 0 && (r = [0, 0]); var i = e[0], a = e[2], o = e[4], s = e[1], l = e[3], c = e[5], u = Math.sin(t), d = Math.cos(t); return n[0] = i * d + s * u, n[1] = -i * u + s * d, n[2] = a * d + l * u, n[3] = -a * u + d * l, n[4] = d * (o - r[0]) + u * (c - r[1]) + r[0], n[5] = d * (c - r[1]) - u * (o - r[0]) + r[1], n } function kN(n, e, t) { var r = t[0], i = t[1]; return n[0] = e[0] * r, n[1] = e[1] * i, n[2] = e[2] * r, n[3] = e[3] * i, n[4] = e[4] * r, n[5] = e[5] * i, n } function qg(n, e) { var t = e[0], r = e[2], i = e[4], a = e[1], o = e[3], s = e[5], l = t * o - a * r; return l ? (l = 1 / l, n[0] = o * l, n[1] = -a * l, n[2] = -r * l, n[3] = t * l, n[4] = (r * s - o * i) * l, n[5] = (a * i - t * s) * l, n) : null } function v$e(n) { var e = Va(); return TN(e, n), e } var y$e = function () { function n(e, t) { this.x = e || 0, this.y = t || 0 } return n.prototype.copy = function (e) { return this.x = e.x, this.y = e.y, this }, n.prototype.clone = function () { return new n(this.x, this.y) }, n.prototype.set = function (e, t) { return this.x = e, this.y = t, this }, n.prototype.equal = function (e) { return e.x === this.x && e.y === this.y }, n.prototype.add = function (e) { return this.x += e.x, this.y += e.y, this }, n.prototype.scale = function (e) { this.x *= e, this.y *= e }, n.prototype.scaleAndAdd = function (e, t) { this.x += e.x * t, this.y += e.y * t }, n.prototype.sub = function (e) { return this.x -= e.x, this.y -= e.y, this }, n.prototype.dot = function (e) { return this.x * e.x + this.y * e.y }, n.prototype.len = function () { return Math.sqrt(this.x * this.x + this.y * this.y) }, n.prototype.lenSquare = function () { return this.x * this.x + this.y * this.y }, n.prototype.normalize = function () { var e = this.len(); return this.x /= e, this.y /= e, this }, n.prototype.distance = function (e) { var t = this.x - e.x, r = this.y - e.y; return Math.sqrt(t * t + r * r) }, n.prototype.distanceSquare = function (e) { var t = this.x - e.x, r = this.y - e.y; return t * t + r * r }, n.prototype.negate = function () { return this.x = -this.x, this.y = -this.y, this }, n.prototype.transform = function (e) { if (e) { var t = this.x, r = this.y; return this.x = e[0] * t + e[2] * r + e[4], this.y = e[1] * t + e[3] * r + e[5], this } }, n.prototype.toArray = function (e) { return e[0] = this.x, e[1] = this.y, e }, n.prototype.fromArray = function (e) { this.x = e[0], this.y = e[1] }, n.set = function (e, t, r) { e.x = t, e.y = r }, n.copy = function (e, t) { e.x = t.x, e.y = t.y }, n.len = function (e) { return Math.sqrt(e.x * e.x + e.y * e.y) }, n.lenSquare = function (e) { return e.x * e.x + e.y * e.y }, n.dot = function (e, t) { return e.x * t.x + e.y * t.y }, n.add = function (e, t, r) { e.x = t.x + r.x, e.y = t.y + r.y }, n.sub = function (e, t, r) { e.x = t.x - r.x, e.y = t.y - r.y }, n.scale = function (e, t, r) { e.x = t.x * r, e.y = t.y * r }, n.scaleAndAdd = function (e, t, r, i) { e.x = t.x + r.x * i, e.y = t.y + r.y * i }, n.lerp = function (e, t, r, i) { var a = 1 - i; e.x = a * t.x + i * r.x, e.y = a * t.y + i * r.y }, n }(); const St = y$e; var Tw = Math.min, kw = Math.max, cf = new St, uf = new St, df = new St, ff = new St, Fv = new St, zv = new St, _$e = function () { function n(e, t, r, i) { r < 0 && (e = e + r, r = -r), i < 0 && (t = t + i, i = -i), this.x = e, this.y = t, this.width = r, this.height = i } return n.prototype.union = function (e) { var t = Tw(e.x, this.x), r = Tw(e.y, this.y); isFinite(this.x) && isFinite(this.width) ? this.width = kw(e.x + e.width, this.x + this.width) - t : this.width = e.width, isFinite(this.y) && isFinite(this.height) ? this.height = kw(e.y + e.height, this.y + this.height) - r : this.height = e.height, this.x = t, this.y = r }, n.prototype.applyTransform = function (e) { n.applyTransform(this, this, e) }, n.prototype.calculateTransform = function (e) { var t = this, r = e.width / t.width, i = e.height / t.height, a = Va(); return Sl(a, a, [-t.x, -t.y]), kN(a, a, [r, i]), Sl(a, a, [e.x, e.y]), a }, n.prototype.intersect = function (e, t) { if (!e) return !1; e instanceof n || (e = n.create(e)); var r = this, i = r.x, a = r.x + r.width, o = r.y, s = r.y + r.height, l = e.x, c = e.x + e.width, u = e.y, d = e.y + e.height, f = !(a < l || c < i || s < u || d < o); if (t) { var h = 1 / 0, p = 0, m = Math.abs(a - l), g = Math.abs(c - i), y = Math.abs(s - u), b = Math.abs(d - o), w = Math.min(m, g), v = Math.min(y, b); a < l || c < i ? w > p && (p = w, m < g ? St.set(zv, -m, 0) : St.set(zv, g, 0)) : w < h && (h = w, m < g ? St.set(Fv, m, 0) : St.set(Fv, -g, 0)), s < u || d < o ? v > p && (p = v, y < b ? St.set(zv, 0, -y) : St.set(zv, 0, b)) : w < h && (h = w, y < b ? St.set(Fv, 0, y) : St.set(Fv, 0, -b)) } return t && St.copy(t, f ? Fv : zv), f }, n.prototype.contain = function (e, t) { var r = this; return e >= r.x && e <= r.x + r.width && t >= r.y && t <= r.y + r.height }, n.prototype.clone = function () { return new n(this.x, this.y, this.width, this.height) }, n.prototype.copy = function (e) { n.copy(this, e) }, n.prototype.plain = function () { return { x: this.x, y: this.y, width: this.width, height: this.height } }, n.prototype.isFinite = function () { return isFinite(this.x) && isFinite(this.y) && isFinite(this.width) && isFinite(this.height) }, n.prototype.isZero = function () { return this.width === 0 || this.height === 0 }, n.create = function (e) { return new n(e.x, e.y, e.width, e.height) }, n.copy = function (e, t) { e.x = t.x, e.y = t.y, e.width = t.width, e.height = t.height }, n.applyTransform = function (e, t, r) { if (!r) { e !== t && n.copy(e, t); return } if (r[1] < 1e-5 && r[1] > -1e-5 && r[2] < 1e-5 && r[2] > -1e-5) { var i = r[0], a = r[3], o = r[4], s = r[5]; e.x = t.x * i + o, e.y = t.y * a + s, e.width = t.width * i, e.height = t.height * a, e.width < 0 && (e.x += e.width, e.width = -e.width), e.height < 0 && (e.y += e.height, e.height = -e.height); return } cf.x = df.x = t.x, cf.y = ff.y = t.y, uf.x = ff.x = t.x + t.width, uf.y = df.y = t.y + t.height, cf.transform(r), ff.transform(r), uf.transform(r), df.transform(r), e.x = Tw(cf.x, uf.x, df.x, ff.x), e.y = Tw(cf.y, uf.y, df.y, ff.y); var l = kw(cf.x, uf.x, df.x, ff.x), c = kw(cf.y, uf.y, df.y, ff.y); e.width = l - e.x, e.height = c - e.y }, n }(); const kt = _$e; var wee = "silent"; function b$e(n, e, t) { return { type: n, event: t, target: e.target, topTarget: e.topTarget, cancelBubble: !1, offsetX: t.zrX, offsetY: t.zrY, gestureEvent: t.gestureEvent, pinchX: t.pinchX, pinchY: t.pinchY, pinchScale: t.pinchScale, wheelDelta: t.zrDelta, zrByTouch: t.zrByTouch, which: t.which, stop: w$e } } function w$e() { Dc(this.event) } var x$e = function (n) { te(e, n); function e() { var t = n !== null && n.apply(this, arguments) || this; return t.handler = null, t } return e.prototype.dispose = function () { }, e.prototype.setCursor = function () { }, e }(Go), Vv = function () { function n(e, t) { this.x = e, this.y = t } return n }(), S$e = ["click", "dblclick", "mousewheel", "mouseout", "mouseup", "mousedown", "mousemove", "contextmenu"], aM = new kt(0, 0, 0, 0), xee = function (n) { te(e, n); function e(t, r, i, a, o) { var s = n.call(this) || this; return s._hovered = new Vv(0, 0), s.storage = t, s.painter = r, s.painterRoot = a, s._pointerSize = o, i = i || new x$e, s.proxy = null, s.setHandlerProxy(i), s._draggingMgr = new r$e(s), s } return e.prototype.setHandlerProxy = function (t) { this.proxy && this.proxy.dispose(), t && ($(S$e, function (r) { t.on && t.on(r, this[r], this) }, this), t.handler = this), this.proxy = t }, e.prototype.mousemove = function (t) { var r = t.zrX, i = t.zrY, a = See(this, r, i), o = this._hovered, s = o.target; s && !s.__zr && (o = this.findHover(o.x, o.y), s = o.target); var l = this._hovered = a ? new Vv(r, i) : this.findHover(r, i), c = l.target, u = this.proxy; u.setCursor && u.setCursor(c ? c.cursor : "default"), s && c !== s && this.dispatchToElement(o, "mouseout", t), this.dispatchToElement(l, "mousemove", t), c && c !== s && this.dispatchToElement(l, "mouseover", t) }, e.prototype.mouseout = function (t) { var r = t.zrEventControl; r !== "only_globalout" && this.dispatchToElement(this._hovered, "mouseout", t), r !== "no_globalout" && this.trigger("globalout", { type: "globalout", event: t }) }, e.prototype.resize = function () { this._hovered = new Vv(0, 0) }, e.prototype.dispatch = function (t, r) { var i = this[t]; i && i.call(this, r) }, e.prototype.dispose = function () { this.proxy.dispose(), this.storage = null, this.proxy = null, this.painter = null }, e.prototype.setCursorStyle = function (t) { var r = this.proxy; r.setCursor && r.setCursor(t) }, e.prototype.dispatchToElement = function (t, r, i) { t = t || {}; var a = t.target; if (!(a && a.silent)) { for (var o = "on" + r, s = b$e(r, t, i); a && (a[o] && (s.cancelBubble = !!a[o].call(a, s)), a.trigger(r, s), a = a.__hostTarget ? a.__hostTarget : a.parent, !s.cancelBubble);); s.cancelBubble || (this.trigger(r, s), this.painter && this.painter.eachOtherLayer && this.painter.eachOtherLayer(function (l) { typeof l[o] == "function" && l[o].call(l, s), l.trigger && l.trigger(r, s) })) } }, e.prototype.findHover = function (t, r, i) { var a = this.storage.getDisplayList(), o = new Vv(t, r); if (D6(a, o, t, r, i), this._pointerSize && !o.target) { for (var s = [], l = this._pointerSize, c = l / 2, u = new kt(t - c, r - c, l, l), d = a.length - 1; d >= 0; d--) { var f = a[d]; f !== i && !f.ignore && !f.ignoreCoarsePointer && (!f.parent || !f.parent.ignoreCoarsePointer) && (aM.copy(f.getBoundingRect()), f.transform && aM.applyTransform(f.transform), aM.intersect(u) && s.push(f)) } if (s.length) for (var h = 4, p = Math.PI / 12, m = Math.PI * 2, g = 0; g < c; g += h)for (var y = 0; y < m; y += p) { var b = t + g * Math.cos(y), w = r + g * Math.sin(y); if (D6(s, o, b, w, i), o.target) return o } } return o }, e.prototype.processGesture = function (t, r) { this._gestureMgr || (this._gestureMgr = new m$e); var i = this._gestureMgr; r === "start" && i.clear(); var a = i.recognize(t, this.findHover(t.zrX, t.zrY, null).target, this.proxy.dom); if (r === "end" && i.clear(), a) { var o = a.type; t.gestureEvent = o; var s = new Vv; s.target = a.target, this.dispatchToElement(s, o, a.event) } }, e }(Go); $(["click", "mousedown", "mouseup", "mousewheel", "dblclick", "contextmenu"], function (n) { xee.prototype[n] = function (e) { var t = e.zrX, r = e.zrY, i = See(this, t, r), a, o; if ((n !== "mouseup" || !i) && (a = this.findHover(t, r), o = a.target), n === "mousedown") this._downEl = o, this._downPoint = [e.zrX, e.zrY], this._upEl = o; else if (n === "mouseup") this._upEl = o; else if (n === "click") { if (this._downEl !== this._upEl || !this._downPoint || Hu(this._downPoint, [e.zrX, e.zrY]) > 4) return; this._downPoint = null } this.dispatchToElement(a, n, e) } }); function T$e(n, e, t) { if (n[n.rectHover ? "rectContain" : "contain"](e, t)) { for (var r = n, i = void 0, a = !1; r;) { if (r.ignoreClip && (a = !0), !a) { var o = r.getClipPath(); if (o && !o.contain(e, t)) return !1 } r.silent && (i = !0); var s = r.__hostTarget; r = s || r.parent } return i ? wee : !0 } return !1 } function D6(n, e, t, r, i) { for (var a = n.length - 1; a >= 0; a--) { var o = n[a], s = void 0; if (o !== i && !o.ignore && (s = T$e(o, t, r)) && (!e.topTarget && (e.topTarget = o), s !== wee)) { e.target = o; break } } } function See(n, e, t) { var r = n.painter; return e < 0 || e > r.getWidth() || t < 0 || t > r.getHeight() } const k$e = xee; var Tee = 32, Hv = 7; function C$e(n) { for (var e = 0; n >= Tee;)e |= n & 1, n >>= 1; return n + e } function j6(n, e, t, r) { var i = e + 1; if (i === t) return 1; if (r(n[i++], n[e]) < 0) { for (; i < t && r(n[i], n[i - 1]) < 0;)i++; A$e(n, e, i) } else for (; i < t && r(n[i], n[i - 1]) >= 0;)i++; return i - e } function A$e(n, e, t) { for (t--; e < t;) { var r = n[e]; n[e++] = n[t], n[t--] = r } } function P6(n, e, t, r, i) { for (r === e && r++; r < t; r++) { for (var a = n[r], o = e, s = r, l; o < s;)l = o + s >>> 1, i(a, n[l]) < 0 ? s = l : o = l + 1; var c = r - o; switch (c) { case 3: n[o + 3] = n[o + 2]; case 2: n[o + 2] = n[o + 1]; case 1: n[o + 1] = n[o]; break; default: for (; c > 0;)n[o + c] = n[o + c - 1], c-- }n[o] = a } } function oM(n, e, t, r, i, a) { var o = 0, s = 0, l = 1; if (a(n, e[t + i]) > 0) { for (s = r - i; l < s && a(n, e[t + i + l]) > 0;)o = l, l = (l << 1) + 1, l <= 0 && (l = s); l > s && (l = s), o += i, l += i } else { for (s = i + 1; l < s && a(n, e[t + i - l]) <= 0;)o = l, l = (l << 1) + 1, l <= 0 && (l = s); l > s && (l = s); var c = o; o = i - l, l = i - c } for (o++; o < l;) { var u = o + (l - o >>> 1); a(n, e[t + u]) > 0 ? o = u + 1 : l = u } return l } function sM(n, e, t, r, i, a) { var o = 0, s = 0, l = 1; if (a(n, e[t + i]) < 0) { for (s = i + 1; l < s && a(n, e[t + i - l]) < 0;)o = l, l = (l << 1) + 1, l <= 0 && (l = s); l > s && (l = s); var c = o; o = i - l, l = i - c } else { for (s = r - i; l < s && a(n, e[t + i + l]) >= 0;)o = l, l = (l << 1) + 1, l <= 0 && (l = s); l > s && (l = s), o += i, l += i } for (o++; o < l;) { var u = o + (l - o >>> 1); a(n, e[t + u]) < 0 ? l = u : o = u + 1 } return l } function E$e(n, e) { var t = Hv, r, i, a = 0, o = []; r = [], i = []; function s(h, p) { r[a] = h, i[a] = p, a += 1 } function l() { for (; a > 1;) { var h = a - 2; if (h >= 1 && i[h - 1] <= i[h] + i[h + 1] || h >= 2 && i[h - 2] <= i[h] + i[h - 1]) i[h - 1] < i[h + 1] && h--; else if (i[h] > i[h + 1]) break; u(h) } } function c() { for (; a > 1;) { var h = a - 2; h > 0 && i[h - 1] < i[h + 1] && h--, u(h) } } function u(h) { var p = r[h], m = i[h], g = r[h + 1], y = i[h + 1]; i[h] = m + y, h === a - 3 && (r[h + 1] = r[h + 2], i[h + 1] = i[h + 2]), a--; var b = sM(n[g], n, p, m, 0, e); p += b, m -= b, m !== 0 && (y = oM(n[p + m - 1], n, g, y, y - 1, e), y !== 0 && (m <= y ? d(p, m, g, y) : f(p, m, g, y))) } function d(h, p, m, g) { var y = 0; for (y = 0; y < p; y++)o[y] = n[h + y]; var b = 0, w = m, v = h; if (n[v++] = n[w++], --g === 0) { for (y = 0; y < p; y++)n[v + y] = o[b + y]; return } if (p === 1) { for (y = 0; y < g; y++)n[v + y] = n[w + y]; n[v + g] = o[b]; return } for (var S = t, x, k, A; ;) { x = 0, k = 0, A = !1; do if (e(n[w], o[b]) < 0) { if (n[v++] = n[w++], k++, x = 0, --g === 0) { A = !0; break } } else if (n[v++] = o[b++], x++, k = 0, --p === 1) { A = !0; break } while ((x | k) < S); if (A) break; do { if (x = sM(n[w], o, b, p, 0, e), x !== 0) { for (y = 0; y < x; y++)n[v + y] = o[b + y]; if (v += x, b += x, p -= x, p <= 1) { A = !0; break } } if (n[v++] = n[w++], --g === 0) { A = !0; break } if (k = oM(o[b], n, w, g, 0, e), k !== 0) { for (y = 0; y < k; y++)n[v + y] = n[w + y]; if (v += k, w += k, g -= k, g === 0) { A = !0; break } } if (n[v++] = o[b++], --p === 1) { A = !0; break } S-- } while (x >= Hv || k >= Hv); if (A) break; S < 0 && (S = 0), S += 2 } if (t = S, t < 1 && (t = 1), p === 1) { for (y = 0; y < g; y++)n[v + y] = n[w + y]; n[v + g] = o[b] } else { if (p === 0) throw new Error; for (y = 0; y < p; y++)n[v + y] = o[b + y] } } function f(h, p, m, g) { var y = 0; for (y = 0; y < g; y++)o[y] = n[m + y]; var b = h + p - 1, w = g - 1, v = m + g - 1, S = 0, x = 0; if (n[v--] = n[b--], --p === 0) { for (S = v - (g - 1), y = 0; y < g; y++)n[S + y] = o[y]; return } if (g === 1) { for (v -= p, b -= p, x = v + 1, S = b + 1, y = p - 1; y >= 0; y--)n[x + y] = n[S + y]; n[v] = o[w]; return } for (var k = t; ;) { var A = 0, C = 0, E = !1; do if (e(o[w], n[b]) < 0) { if (n[v--] = n[b--], A++, C = 0, --p === 0) { E = !0; break } } else if (n[v--] = o[w--], C++, A = 0, --g === 1) { E = !0; break } while ((A | C) < k); if (E) break; do { if (A = p - sM(o[w], n, h, p, p - 1, e), A !== 0) { for (v -= A, b -= A, p -= A, x = v + 1, S = b + 1, y = A - 1; y >= 0; y--)n[x + y] = n[S + y]; if (p === 0) { E = !0; break } } if (n[v--] = o[w--], --g === 1) { E = !0; break } if (C = g - oM(n[b], o, 0, g, g - 1, e), C !== 0) { for (v -= C, w -= C, g -= C, x = v + 1, S = w + 1, y = 0; y < C; y++)n[x + y] = o[S + y]; if (g <= 1) { E = !0; break } } if (n[v--] = n[b--], --p === 0) { E = !0; break } k-- } while (A >= Hv || C >= Hv); if (E) break; k < 0 && (k = 0), k += 2 } if (t = k, t < 1 && (t = 1), g === 1) { for (v -= p, b -= p, x = v + 1, S = b + 1, y = p - 1; y >= 0; y--)n[x + y] = n[S + y]; n[v] = o[w] } else { if (g === 0) throw new Error; for (S = v - (g - 1), y = 0; y < g; y++)n[S + y] = o[y] } } return { mergeRuns: l, forceMergeRuns: c, pushRun: s } } function Yx(n, e, t, r) { t || (t = 0), r || (r = n.length); var i = r - t; if (!(i < 2)) { var a = 0; if (i < Tee) { a = j6(n, t, r, e), P6(n, t, r, t + a, e); return } var o = E$e(n, e), s = C$e(i); do { if (a = j6(n, t, r, e), a < s) { var l = i; l > s && (l = s), P6(n, t, t + l, t + a, e), a = l } o.pushRun(t, a), o.mergeRuns(), i -= a, t += a } while (i !== 0); o.forceMergeRuns() } } var Ba = 1, Sy = 2, wm = 4, I6 = !1; function lM() { I6 || (I6 = !0, console.warn("z / z2 / zlevel of displayable is invalid, which may cause unexpected errors")) } function L6(n, e) { return n.zlevel === e.zlevel ? n.z === e.z ? n.z2 - e.z2 : n.z - e.z : n.zlevel - e.zlevel } var M$e = function () { function n() { this._roots = [], this._displayList = [], this._displayListLen = 0, this.displayableSortFunc = L6 } return n.prototype.traverse = function (e, t) { for (var r = 0; r < this._roots.length; r++)this._roots[r].traverse(e, t) }, n.prototype.getDisplayList = function (e, t) { t = t || !1; var r = this._displayList; return (e || !r.length) && this.updateDisplayList(t), r }, n.prototype.updateDisplayList = function (e) { this._displayListLen = 0; for (var t = this._roots, r = this._displayList, i = 0, a = t.length; i < a; i++)this._updateAndAddDisplayable(t[i], null, e); r.length = this._displayListLen, Yx(r, L6) }, n.prototype._updateAndAddDisplayable = function (e, t, r) { if (!(e.ignore && !r)) { e.beforeUpdate(), e.update(), e.afterUpdate(); var i = e.getClipPath(); if (e.ignoreClip) t = null; else if (i) { t ? t = t.slice() : t = []; for (var a = i, o = e; a;)a.parent = o, a.updateTransform(), t.push(a), o = a, a = a.getClipPath() } if (e.childrenRef) { for (var s = e.childrenRef(), l = 0; l < s.length; l++) { var c = s[l]; e.__dirty && (c.__dirty |= Ba), this._updateAndAddDisplayable(c, t, r) } e.__dirty = 0 } else { var u = e; t && t.length ? u.__clipPaths = t : u.__clipPaths && u.__clipPaths.length > 0 && (u.__clipPaths = []), isNaN(u.z) && (lM(), u.z = 0), isNaN(u.z2) && (lM(), u.z2 = 0), isNaN(u.zlevel) && (lM(), u.zlevel = 0), this._displayList[this._displayListLen++] = u } var d = e.getDecalElement && e.getDecalElement(); d && this._updateAndAddDisplayable(d, t, r); var f = e.getTextGuideLine(); f && this._updateAndAddDisplayable(f, t, r); var h = e.getTextContent(); h && this._updateAndAddDisplayable(h, t, r) } }, n.prototype.addRoot = function (e) { e.__zr && e.__zr.storage === this || this._roots.push(e) }, n.prototype.delRoot = function (e) { if (e instanceof Array) { for (var t = 0, r = e.length; t < r; t++)this.delRoot(e[t]); return } var i = Et(this._roots, e); i >= 0 && this._roots.splice(i, 1) }, n.prototype.delAllRoots = function () { this._roots = [], this._displayList = [], this._displayListLen = 0 }, n.prototype.getRoots = function () { return this._roots }, n.prototype.dispose = function () { this._displayList = null, this._roots = null }, n }(); const O$e = M$e; var kee; kee = en.hasGlobalWindow && (window.requestAnimationFrame && window.requestAnimationFrame.bind(window) || window.msRequestAnimationFrame && window.msRequestAnimationFrame.bind(window) || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame) || function (n) { return setTimeout(n, 16) }; const EP = kee; var Zx = { linear: function (n) { return n }, quadraticIn: function (n) { return n * n }, quadraticOut: function (n) { return n * (2 - n) }, quadraticInOut: function (n) { return (n *= 2) < 1 ? .5 * n * n : -.5 * (--n * (n - 2) - 1) }, cubicIn: function (n) { return n * n * n }, cubicOut: function (n) { return --n * n * n + 1 }, cubicInOut: function (n) { return (n *= 2) < 1 ? .5 * n * n * n : .5 * ((n -= 2) * n * n + 2) }, quarticIn: function (n) { return n * n * n * n }, quarticOut: function (n) { return 1 - --n * n * n * n }, quarticInOut: function (n) { return (n *= 2) < 1 ? .5 * n * n * n * n : -.5 * ((n -= 2) * n * n * n - 2) }, quinticIn: function (n) { return n * n * n * n * n }, quinticOut: function (n) { return --n * n * n * n * n + 1 }, quinticInOut: function (n) { return (n *= 2) < 1 ? .5 * n * n * n * n * n : .5 * ((n -= 2) * n * n * n * n + 2) }, sinusoidalIn: function (n) { return 1 - Math.cos(n * Math.PI / 2) }, sinusoidalOut: function (n) { return Math.sin(n * Math.PI / 2) }, sinusoidalInOut: function (n) { return .5 * (1 - Math.cos(Math.PI * n)) }, exponentialIn: function (n) { return n === 0 ? 0 : Math.pow(1024, n - 1) }, exponentialOut: function (n) { return n === 1 ? 1 : 1 - Math.pow(2, -10 * n) }, exponentialInOut: function (n) { return n === 0 ? 0 : n === 1 ? 1 : (n *= 2) < 1 ? .5 * Math.pow(1024, n - 1) : .5 * (-Math.pow(2, -10 * (n - 1)) + 2) }, circularIn: function (n) { return 1 - Math.sqrt(1 - n * n) }, circularOut: function (n) { return Math.sqrt(1 - --n * n) }, circularInOut: function (n) { return (n *= 2) < 1 ? -.5 * (Math.sqrt(1 - n * n) - 1) : .5 * (Math.sqrt(1 - (n -= 2) * n) + 1) }, elasticIn: function (n) { var e, t = .1, r = .4; return n === 0 ? 0 : n === 1 ? 1 : (!t || t < 1 ? (t = 1, e = r / 4) : e = r * Math.asin(1 / t) / (2 * Math.PI), -(t * Math.pow(2, 10 * (n -= 1)) * Math.sin((n - e) * (2 * Math.PI) / r))) }, elasticOut: function (n) { var e, t = .1, r = .4; return n === 0 ? 0 : n === 1 ? 1 : (!t || t < 1 ? (t = 1, e = r / 4) : e = r * Math.asin(1 / t) / (2 * Math.PI), t * Math.pow(2, -10 * n) * Math.sin((n - e) * (2 * Math.PI) / r) + 1) }, elasticInOut: function (n) { var e, t = .1, r = .4; return n === 0 ? 0 : n === 1 ? 1 : (!t || t < 1 ? (t = 1, e = r / 4) : e = r * Math.asin(1 / t) / (2 * Math.PI), (n *= 2) < 1 ? -.5 * (t * Math.pow(2, 10 * (n -= 1)) * Math.sin((n - e) * (2 * Math.PI) / r)) : t * Math.pow(2, -10 * (n -= 1)) * Math.sin((n - e) * (2 * Math.PI) / r) * .5 + 1) }, backIn: function (n) { var e = 1.70158; return n * n * ((e + 1) * n - e) }, backOut: function (n) { var e = 1.70158; return --n * n * ((e + 1) * n + e) + 1 }, backInOut: function (n) { var e = 2.5949095; return (n *= 2) < 1 ? .5 * (n * n * ((e + 1) * n - e)) : .5 * ((n -= 2) * n * ((e + 1) * n + e) + 2) }, bounceIn: function (n) { return 1 - Zx.bounceOut(1 - n) }, bounceOut: function (n) { return n < 1 / 2.75 ? 7.5625 * n * n : n < 2 / 2.75 ? 7.5625 * (n -= 1.5 / 2.75) * n + .75 : n < 2.5 / 2.75 ? 7.5625 * (n -= 2.25 / 2.75) * n + .9375 : 7.5625 * (n -= 2.625 / 2.75) * n + .984375 }, bounceInOut: function (n) { return n < .5 ? Zx.bounceIn(n * 2) * .5 : Zx.bounceOut(n * 2 - 1) * .5 + .5 } }; const Cee = Zx; var Cw = Math.pow, od = Math.sqrt, H2 = 1e-8, Aee = 1e-4, R6 = od(3), Aw = 1 / 3, tl = np(), bo = np(), Km = np(); function Wu(n) { return n > -H2 && n < H2 } function Eee(n) { return n > H2 || n < -H2 } function Nr(n, e, t, r, i) { var a = 1 - i; return a * a * (a * n + 3 * i * e) + i * i * (i * r + 3 * a * t) } function N6(n, e, t, r, i) { var a = 1 - i; return 3 * (((e - n) * a + 2 * (t - e) * i) * a + (r - t) * i * i) } function U2(n, e, t, r, i, a) { var o = r + 3 * (e - t) - n, s = 3 * (t - e * 2 + n), l = 3 * (e - n), c = n - i, u = s * s - 3 * o * l, d = s * l - 9 * o * c, f = l * l - 3 * s * c, h = 0; if (Wu(u) && Wu(d)) if (Wu(s)) a[0] = 0; else { var p = -l / s; p >= 0 && p <= 1 && (a[h++] = p) } else { var m = d * d - 4 * u * f; if (Wu(m)) { var g = d / u, p = -s / o + g, y = -g / 2; p >= 0 && p <= 1 && (a[h++] = p), y >= 0 && y <= 1 && (a[h++] = y) } else if (m > 0) { var b = od(m), w = u * s + 1.5 * o * (-d + b), v = u * s + 1.5 * o * (-d - b); w < 0 ? w = -Cw(-w, Aw) : w = Cw(w, Aw), v < 0 ? v = -Cw(-v, Aw) : v = Cw(v, Aw); var p = (-s - (w + v)) / (3 * o); p >= 0 && p <= 1 && (a[h++] = p) } else { var S = (2 * u * s - 3 * o * d) / (2 * od(u * u * u)), x = Math.acos(S) / 3, k = od(u), A = Math.cos(x), p = (-s - 2 * k * A) / (3 * o), y = (-s + k * (A + R6 * Math.sin(x))) / (3 * o), C = (-s + k * (A - R6 * Math.sin(x))) / (3 * o); p >= 0 && p <= 1 && (a[h++] = p), y >= 0 && y <= 1 && (a[h++] = y), C >= 0 && C <= 1 && (a[h++] = C) } } return h } function Mee(n, e, t, r, i) { var a = 6 * t - 12 * e + 6 * n, o = 9 * e + 3 * r - 3 * n - 9 * t, s = 3 * e - 3 * n, l = 0; if (Wu(o)) { if (Eee(a)) { var c = -s / a; c >= 0 && c <= 1 && (i[l++] = c) } } else { var u = a * a - 4 * o * s; if (Wu(u)) i[0] = -a / (2 * o); else if (u > 0) { var d = od(u), c = (-a + d) / (2 * o), f = (-a - d) / (2 * o); c >= 0 && c <= 1 && (i[l++] = c), f >= 0 && f <= 1 && (i[l++] = f) } } return l } function Cd(n, e, t, r, i, a) { var o = (e - n) * i + n, s = (t - e) * i + e, l = (r - t) * i + t, c = (s - o) * i + o, u = (l - s) * i + s, d = (u - c) * i + c; a[0] = n, a[1] = o, a[2] = c, a[3] = d, a[4] = d, a[5] = u, a[6] = l, a[7] = r } function Oee(n, e, t, r, i, a, o, s, l, c, u) { var d, f = .005, h = 1 / 0, p, m, g, y; tl[0] = l, tl[1] = c; for (var b = 0; b < 1; b += .05)bo[0] = Nr(n, t, i, o, b), bo[1] = Nr(e, r, a, s, b), g = bh(tl, bo), g < h && (d = b, h = g); h = 1 / 0; for (var w = 0; w < 32 && !(f < Aee); w++)p = d - f, m = d + f, bo[0] = Nr(n, t, i, o, p), bo[1] = Nr(e, r, a, s, p), g = bh(bo, tl), p >= 0 && g < h ? (d = p, h = g) : (Km[0] = Nr(n, t, i, o, m), Km[1] = Nr(e, r, a, s, m), y = bh(Km, tl), m <= 1 && y < h ? (d = m, h = y) : f *= .5); return u && (u[0] = Nr(n, t, i, o, d), u[1] = Nr(e, r, a, s, d)), od(h) } function D$e(n, e, t, r, i, a, o, s, l) { for (var c = n, u = e, d = 0, f = 1 / l, h = 1; h <= l; h++) { var p = h * f, m = Nr(n, t, i, o, p), g = Nr(e, r, a, s, p), y = m - c, b = g - u; d += Math.sqrt(y * y + b * b), c = m, u = g } return d } function qr(n, e, t, r) { var i = 1 - r; return i * (i * n + 2 * r * e) + r * r * t } function MP(n, e, t, r) { return 2 * ((1 - r) * (e - n) + r * (t - e)) } function j$e(n, e, t, r, i) { var a = n - 2 * e + t, o = 2 * (e - n), s = n - r, l = 0; if (Wu(a)) { if (Eee(o)) { var c = -s / o; c >= 0 && c <= 1 && (i[l++] = c) } } else { var u = o * o - 4 * a * s; if (Wu(u)) { var c = -o / (2 * a); c >= 0 && c <= 1 && (i[l++] = c) } else if (u > 0) { var d = od(u), c = (-o + d) / (2 * a), f = (-o - d) / (2 * a); c >= 0 && c <= 1 && (i[l++] = c), f >= 0 && f <= 1 && (i[l++] = f) } } return l } function Dee(n, e, t) { var r = n + t - 2 * e; return r === 0 ? .5 : (n - e) / r } function d_(n, e, t, r, i) { var a = (e - n) * r + n, o = (t - e) * r + e, s = (o - a) * r + a; i[0] = n, i[1] = a, i[2] = s, i[3] = s, i[4] = o, i[5] = t } function jee(n, e, t, r, i, a, o, s, l) { var c, u = .005, d = 1 / 0; tl[0] = o, tl[1] = s; for (var f = 0; f < 1; f += .05) { bo[0] = qr(n, t, i, f), bo[1] = qr(e, r, a, f); var h = bh(tl, bo); h < d && (c = f, d = h) } d = 1 / 0; for (var p = 0; p < 32 && !(u < Aee); p++) { var m = c - u, g = c + u; bo[0] = qr(n, t, i, m), bo[1] = qr(e, r, a, m); var h = bh(bo, tl); if (m >= 0 && h < d) c = m, d = h; else { Km[0] = qr(n, t, i, g), Km[1] = qr(e, r, a, g); var y = bh(Km, tl); g <= 1 && y < d ? (c = g, d = y) : u *= .5 } } return l && (l[0] = qr(n, t, i, c), l[1] = qr(e, r, a, c)), od(d) } function P$e(n, e, t, r, i, a, o) { for (var s = n, l = e, c = 0, u = 1 / o, d = 1; d <= o; d++) { var f = d * u, h = qr(n, t, i, f), p = qr(e, r, a, f), m = h - s, g = p - l; c += Math.sqrt(m * m + g * g), s = h, l = p } return c } var I$e = /cubic-bezier\(([0-9,\.e ]+)\)/; function CN(n) { var e = n && I$e.exec(n); if (e) { var t = e[1].split(","), r = +ps(t[0]), i = +ps(t[1]), a = +ps(t[2]), o = +ps(t[3]); if (isNaN(r + i + a + o)) return; var s = []; return function (l) { return l <= 0 ? 0 : l >= 1 ? 1 : U2(0, r, a, 1, l, s) && Nr(0, i, o, 1, s[0]) } } } var L$e = function () { function n(e) { this._inited = !1, this._startTime = 0, this._pausedTime = 0, this._paused = !1, this._life = e.life || 1e3, this._delay = e.delay || 0, this.loop = e.loop || !1, this.onframe = e.onframe || gr, this.ondestroy = e.ondestroy || gr, this.onrestart = e.onrestart || gr, e.easing && this.setEasing(e.easing) } return n.prototype.step = function (e, t) { if (this._inited || (this._startTime = e + this._delay, this._inited = !0), this._paused) { this._pausedTime += t; return } var r = this._life, i = e - this._startTime - this._pausedTime, a = i / r; a < 0 && (a = 0), a = Math.min(a, 1); var o = this.easingFunc, s = o ? o(a) : a; if (this.onframe(s), a === 1) if (this.loop) { var l = i % r; this._startTime = e - l, this._pausedTime = 0, this.onrestart() } else return !0; return !1 }, n.prototype.pause = function () { this._paused = !0 }, n.prototype.resume = function () { this._paused = !1 }, n.prototype.setEasing = function (e) { this.easing = e, this.easingFunc = tt(e) ? e : Cee[e] || CN(e) }, n }(); const R$e = L$e; var Pee = function () { function n(e) { this.value = e } return n }(), N$e = function () { function n() { this._len = 0 } return n.prototype.insert = function (e) { var t = new Pee(e); return this.insertEntry(t), t }, n.prototype.insertEntry = function (e) { this.head ? (this.tail.next = e, e.prev = this.tail, e.next = null, this.tail = e) : this.head = this.tail = e, this._len++ }, n.prototype.remove = function (e) { var t = e.prev, r = e.next; t ? t.next = r : this.head = r, r ? r.prev = t : this.tail = t, e.next = e.prev = null, this._len-- }, n.prototype.len = function () { return this._len }, n.prototype.clear = function () { this.head = this.tail = null, this._len = 0 }, n }(), B$e = function () { function n(e) { this._list = new N$e, this._maxSize = 10, this._map = {}, this._maxSize = e } return n.prototype.put = function (e, t) { var r = this._list, i = this._map, a = null; if (i[e] == null) { var o = r.len(), s = this._lastRemovedEntry; if (o >= this._maxSize && o > 0) { var l = r.head; r.remove(l), delete i[l.key], a = l.value, this._lastRemovedEntry = l } s ? s.value = t : s = new Pee(t), s.key = e, r.insertEntry(s), i[e] = s } return a }, n.prototype.get = function (e) { var t = this._map[e], r = this._list; if (t != null) return t !== r.tail && (r.remove(t), r.insertEntry(t)), t.value }, n.prototype.clear = function () { this._list.clear(), this._map = {} }, n.prototype.len = function () { return this._list.len() }, n }(); const _b = B$e; var B6 = { transparent: [0, 0, 0, 0], aliceblue: [240, 248, 255, 1], antiquewhite: [250, 235, 215, 1], aqua: [0, 255, 255, 1], aquamarine: [127, 255, 212, 1], azure: [240, 255, 255, 1], beige: [245, 245, 220, 1], bisque: [255, 228, 196, 1], black: [0, 0, 0, 1], blanchedalmond: [255, 235, 205, 1], blue: [0, 0, 255, 1], blueviolet: [138, 43, 226, 1], brown: [165, 42, 42, 1], burlywood: [222, 184, 135, 1], cadetblue: [95, 158, 160, 1], chartreuse: [127, 255, 0, 1], chocolate: [210, 105, 30, 1], coral: [255, 127, 80, 1], cornflowerblue: [100, 149, 237, 1], cornsilk: [255, 248, 220, 1], crimson: [220, 20, 60, 1], cyan: [0, 255, 255, 1], darkblue: [0, 0, 139, 1], darkcyan: [0, 139, 139, 1], darkgoldenrod: [184, 134, 11, 1], darkgray: [169, 169, 169, 1], darkgreen: [0, 100, 0, 1], darkgrey: [169, 169, 169, 1], darkkhaki: [189, 183, 107, 1], darkmagenta: [139, 0, 139, 1], darkolivegreen: [85, 107, 47, 1], darkorange: [255, 140, 0, 1], darkorchid: [153, 50, 204, 1], darkred: [139, 0, 0, 1], darksalmon: [233, 150, 122, 1], darkseagreen: [143, 188, 143, 1], darkslateblue: [72, 61, 139, 1], darkslategray: [47, 79, 79, 1], darkslategrey: [47, 79, 79, 1], darkturquoise: [0, 206, 209, 1], darkviolet: [148, 0, 211, 1], deeppink: [255, 20, 147, 1], deepskyblue: [0, 191, 255, 1], dimgray: [105, 105, 105, 1], dimgrey: [105, 105, 105, 1], dodgerblue: [30, 144, 255, 1], firebrick: [178, 34, 34, 1], floralwhite: [255, 250, 240, 1], forestgreen: [34, 139, 34, 1], fuchsia: [255, 0, 255, 1], gainsboro: [220, 220, 220, 1], ghostwhite: [248, 248, 255, 1], gold: [255, 215, 0, 1], goldenrod: [218, 165, 32, 1], gray: [128, 128, 128, 1], green: [0, 128, 0, 1], greenyellow: [173, 255, 47, 1], grey: [128, 128, 128, 1], honeydew: [240, 255, 240, 1], hotpink: [255, 105, 180, 1], indianred: [205, 92, 92, 1], indigo: [75, 0, 130, 1], ivory: [255, 255, 240, 1], khaki: [240, 230, 140, 1], lavender: [230, 230, 250, 1], lavenderblush: [255, 240, 245, 1], lawngreen: [124, 252, 0, 1], lemonchiffon: [255, 250, 205, 1], lightblue: [173, 216, 230, 1], lightcoral: [240, 128, 128, 1], lightcyan: [224, 255, 255, 1], lightgoldenrodyellow: [250, 250, 210, 1], lightgray: [211, 211, 211, 1], lightgreen: [144, 238, 144, 1], lightgrey: [211, 211, 211, 1], lightpink: [255, 182, 193, 1], lightsalmon: [255, 160, 122, 1], lightseagreen: [32, 178, 170, 1], lightskyblue: [135, 206, 250, 1], lightslategray: [119, 136, 153, 1], lightslategrey: [119, 136, 153, 1], lightsteelblue: [176, 196, 222, 1], lightyellow: [255, 255, 224, 1], lime: [0, 255, 0, 1], limegreen: [50, 205, 50, 1], linen: [250, 240, 230, 1], magenta: [255, 0, 255, 1], maroon: [128, 0, 0, 1], mediumaquamarine: [102, 205, 170, 1], mediumblue: [0, 0, 205, 1], mediumorchid: [186, 85, 211, 1], mediumpurple: [147, 112, 219, 1], mediumseagreen: [60, 179, 113, 1], mediumslateblue: [123, 104, 238, 1], mediumspringgreen: [0, 250, 154, 1], mediumturquoise: [72, 209, 204, 1], mediumvioletred: [199, 21, 133, 1], midnightblue: [25, 25, 112, 1], mintcream: [245, 255, 250, 1], mistyrose: [255, 228, 225, 1], moccasin: [255, 228, 181, 1], navajowhite: [255, 222, 173, 1], navy: [0, 0, 128, 1], oldlace: [253, 245, 230, 1], olive: [128, 128, 0, 1], olivedrab: [107, 142, 35, 1], orange: [255, 165, 0, 1], orangered: [255, 69, 0, 1], orchid: [218, 112, 214, 1], palegoldenrod: [238, 232, 170, 1], palegreen: [152, 251, 152, 1], paleturquoise: [175, 238, 238, 1], palevioletred: [219, 112, 147, 1], papayawhip: [255, 239, 213, 1], peachpuff: [255, 218, 185, 1], peru: [205, 133, 63, 1], pink: [255, 192, 203, 1], plum: [221, 160, 221, 1], powderblue: [176, 224, 230, 1], purple: [128, 0, 128, 1], red: [255, 0, 0, 1], rosybrown: [188, 143, 143, 1], royalblue: [65, 105, 225, 1], saddlebrown: [139, 69, 19, 1], salmon: [250, 128, 114, 1], sandybrown: [244, 164, 96, 1], seagreen: [46, 139, 87, 1], seashell: [255, 245, 238, 1], sienna: [160, 82, 45, 1], silver: [192, 192, 192, 1], skyblue: [135, 206, 235, 1], slateblue: [106, 90, 205, 1], slategray: [112, 128, 144, 1], slategrey: [112, 128, 144, 1], snow: [255, 250, 250, 1], springgreen: [0, 255, 127, 1], steelblue: [70, 130, 180, 1], tan: [210, 180, 140, 1], teal: [0, 128, 128, 1], thistle: [216, 191, 216, 1], tomato: [255, 99, 71, 1], turquoise: [64, 224, 208, 1], violet: [238, 130, 238, 1], wheat: [245, 222, 179, 1], white: [255, 255, 255, 1], whitesmoke: [245, 245, 245, 1], yellow: [255, 255, 0, 1], yellowgreen: [154, 205, 50, 1] }; function _s(n) { return n = Math.round(n), n < 0 ? 0 : n > 255 ? 255 : n } function $$e(n) { return n = Math.round(n), n < 0 ? 0 : n > 360 ? 360 : n } function f_(n) { return n < 0 ? 0 : n > 1 ? 1 : n } function cM(n) { var e = n; return e.length && e.charAt(e.length - 1) === "%" ? _s(parseFloat(e) / 100 * 255) : _s(parseInt(e, 10)) } function wh(n) { var e = n; return e.length && e.charAt(e.length - 1) === "%" ? f_(parseFloat(e) / 100) : f_(parseFloat(e)) } function uM(n, e, t) { return t < 0 ? t += 1 : t > 1 && (t -= 1), t * 6 < 1 ? n + (e - n) * t * 6 : t * 2 < 1 ? e : t * 3 < 2 ? n + (e - n) * (2 / 3 - t) * 6 : n } function Ku(n, e, t) { return n + (e - n) * t } function ho(n, e, t, r, i) { return n[0] = e, n[1] = t, n[2] = r, n[3] = i, n } function OP(n, e) { return n[0] = e[0], n[1] = e[1], n[2] = e[2], n[3] = e[3], n } var Iee = new _b(20), Ew = null; function zp(n, e) { Ew && OP(Ew, e), Ew = Iee.put(n, Ew || e.slice()) } function Ha(n, e) { if (n) { e = e || []; var t = Iee.get(n); if (t) return OP(e, t); n = n + ""; var r = n.replace(/ /g, "").toLowerCase(); if (r in B6) return OP(e, B6[r]), zp(n, e), e; var i = r.length; if (r.charAt(0) === "#") { if (i === 4 || i === 5) { var a = parseInt(r.slice(1, 4), 16); if (!(a >= 0 && a <= 4095)) { ho(e, 0, 0, 0, 1); return } return ho(e, (a & 3840) >> 4 | (a & 3840) >> 8, a & 240 | (a & 240) >> 4, a & 15 | (a & 15) << 4, i === 5 ? parseInt(r.slice(4), 16) / 15 : 1), zp(n, e), e } else if (i === 7 || i === 9) { var a = parseInt(r.slice(1, 7), 16); if (!(a >= 0 && a <= 16777215)) { ho(e, 0, 0, 0, 1); return } return ho(e, (a & 16711680) >> 16, (a & 65280) >> 8, a & 255, i === 9 ? parseInt(r.slice(7), 16) / 255 : 1), zp(n, e), e } return } var o = r.indexOf("("), s = r.indexOf(")"); if (o !== -1 && s + 1 === i) { var l = r.substr(0, o), c = r.substr(o + 1, s - (o + 1)).split(","), u = 1; switch (l) { case "rgba": if (c.length !== 4) return c.length === 3 ? ho(e, +c[0], +c[1], +c[2], 1) : ho(e, 0, 0, 0, 1); u = wh(c.pop()); case "rgb": if (c.length >= 3) return ho(e, cM(c[0]), cM(c[1]), cM(c[2]), c.length === 3 ? u : wh(c[3])), zp(n, e), e; ho(e, 0, 0, 0, 1); return; case "hsla": if (c.length !== 4) { ho(e, 0, 0, 0, 1); return } return c[3] = wh(c[3]), DP(c, e), zp(n, e), e; case "hsl": if (c.length !== 3) { ho(e, 0, 0, 0, 1); return } return DP(c, e), zp(n, e), e; default: return } } ho(e, 0, 0, 0, 1) } } function DP(n, e) { var t = (parseFloat(n[0]) % 360 + 360) % 360 / 360, r = wh(n[1]), i = wh(n[2]), a = i <= .5 ? i * (r + 1) : i + r - i * r, o = i * 2 - a; return e = e || [], ho(e, _s(uM(o, a, t + 1 / 3) * 255), _s(uM(o, a, t) * 255), _s(uM(o, a, t - 1 / 3) * 255), 1), n.length === 4 && (e[3] = n[3]), e } function F$e(n) { if (n) { var e = n[0] / 255, t = n[1] / 255, r = n[2] / 255, i = Math.min(e, t, r), a = Math.max(e, t, r), o = a - i, s = (a + i) / 2, l, c; if (o === 0) l = 0, c = 0; else { s < .5 ? c = o / (a + i) : c = o / (2 - a - i); var u = ((a - e) / 6 + o / 2) / o, d = ((a - t) / 6 + o / 2) / o, f = ((a - r) / 6 + o / 2) / o; e === a ? l = f - d : t === a ? l = 1 / 3 + u - f : r === a && (l = 2 / 3 + d - u), l < 0 && (l += 1), l > 1 && (l -= 1) } var h = [l * 360, c, s]; return n[3] != null && h.push(n[3]), h } } function jP(n, e) { var t = Ha(n); if (t) { for (var r = 0; r < 3; r++)e < 0 ? t[r] = t[r] * (1 - e) | 0 : t[r] = (255 - t[r]) * e + t[r] | 0, t[r] > 255 ? t[r] = 255 : t[r] < 0 && (t[r] = 0); return wc(t, t.length === 4 ? "rgba" : "rgb") } } function dM(n, e, t) { if (!(!(e && e.length) || !(n >= 0 && n <= 1))) { t = t || []; var r = n * (e.length - 1), i = Math.floor(r), a = Math.ceil(r), o = e[i], s = e[a], l = r - i; return t[0] = _s(Ku(o[0], s[0], l)), t[1] = _s(Ku(o[1], s[1], l)), t[2] = _s(Ku(o[2], s[2], l)), t[3] = f_(Ku(o[3], s[3], l)), t } } function z$e(n, e, t) { if (!(!(e && e.length) || !(n >= 0 && n <= 1))) { var r = n * (e.length - 1), i = Math.floor(r), a = Math.ceil(r), o = Ha(e[i]), s = Ha(e[a]), l = r - i, c = wc([_s(Ku(o[0], s[0], l)), _s(Ku(o[1], s[1], l)), _s(Ku(o[2], s[2], l)), f_(Ku(o[3], s[3], l))], "rgba"); return t ? { color: c, leftIndex: i, rightIndex: a, value: r } : c } } function u0(n, e, t, r) { var i = Ha(n); if (n) return i = F$e(i), e != null && (i[0] = $$e(e)), t != null && (i[1] = wh(t)), r != null && (i[2] = wh(r)), wc(DP(i), "rgba") } function G2(n, e) { var t = Ha(n); if (t && e != null) return t[3] = f_(e), wc(t, "rgba") } function wc(n, e) { if (!(!n || !n.length)) { var t = n[0] + "," + n[1] + "," + n[2]; return (e === "rgba" || e === "hsva" || e === "hsla") && (t += "," + n[3]), e + "(" + t + ")" } } function W2(n, e) { var t = Ha(n); return t ? (.299 * t[0] + .587 * t[1] + .114 * t[2]) * t[3] / 255 + (1 - t[3]) * e : 0 } var $6 = new _b(100); function PP(n) { if (Fe(n)) { var e = $6.get(n); return e || (e = jP(n, -.1), $6.put(n, e)), e } else if (Wk(n)) { var t = be({}, n); return t.colorStops = Ae(n.colorStops, function (r) { return { offset: r.offset, color: jP(r.color, -.1) } }), t } return n } var K2 = Math.round; function h_(n) { var e; if (!n || n === "transparent") n = "none"; else if (typeof n == "string" && n.indexOf("rgba") > -1) { var t = Ha(n); t && (n = "rgb(" + t[0] + "," + t[1] + "," + t[2] + ")", e = t[3]) } return { color: n, opacity: e ?? 1 } } var F6 = 1e-4; function qu(n) { return n < F6 && n > -F6 } function Mw(n) { return K2(n * 1e3) / 1e3 } function IP(n) { return K2(n * 1e4) / 1e4 } function V$e(n) { return "matrix(" + Mw(n[0]) + "," + Mw(n[1]) + "," + Mw(n[2]) + "," + Mw(n[3]) + "," + IP(n[4]) + "," + IP(n[5]) + ")" } var H$e = { left: "start", right: "end", center: "middle", middle: "middle" }; function U$e(n, e, t) { return t === "top" ? n += e / 2 : t === "bottom" && (n -= e / 2), n } function G$e(n) { return n && (n.shadowBlur || n.shadowOffsetX || n.shadowOffsetY) } function W$e(n) { var e = n.style, t = n.getGlobalScale(); return [e.shadowColor, (e.shadowBlur || 0).toFixed(2), (e.shadowOffsetX || 0).toFixed(2), (e.shadowOffsetY || 0).toFixed(2), t[0], t[1]].join(",") } function Lee(n) { return n && !!n.image } function K$e(n) { return n && !!n.svgElement } function AN(n) { return Lee(n) || K$e(n) } function Ree(n) { return n.type === "linear" } function Nee(n) { return n.type === "radial" } function Bee(n) { return n && (n.type === "linear" || n.type === "radial") } function Yk(n) { return "url(#" + n + ")" } function $ee(n) { var e = n.getGlobalScale(), t = Math.max(e[0], e[1]); return Math.max(Math.ceil(Math.log(t) / Math.log(10)), 1) } function Fee(n) { var e = n.x || 0, t = n.y || 0, r = (n.rotation || 0) * Wx, i = yt(n.scaleX, 1), a = yt(n.scaleY, 1), o = n.skewX || 0, s = n.skewY || 0, l = []; return (e || t) && l.push("translate(" + e + "px," + t + "px)"), r && l.push("rotate(" + r + ")"), (i !== 1 || a !== 1) && l.push("scale(" + i + "," + a + ")"), (o || s) && l.push("skew(" + K2(o * Wx) + "deg, " + K2(s * Wx) + "deg)"), l.join(" ") } var q$e = function () { return en.hasGlobalWindow && tt(window.btoa) ? function (n) { return window.btoa(unescape(encodeURIComponent(n))) } : typeof Buffer < "u" ? function (n) { return Buffer.from(n).toString("base64") } : function (n) { return null } }(), LP = Array.prototype.slice; function ic(n, e, t) { return (e - n) * t + n } function fM(n, e, t, r) { for (var i = e.length, a = 0; a < i; a++)n[a] = ic(e[a], t[a], r); return n } function Y$e(n, e, t, r) { for (var i = e.length, a = i && e[0].length, o = 0; o < i; o++) { n[o] || (n[o] = []); for (var s = 0; s < a; s++)n[o][s] = ic(e[o][s], t[o][s], r) } return n } function Ow(n, e, t, r) { for (var i = e.length, a = 0; a < i; a++)n[a] = e[a] + t[a] * r; return n } function z6(n, e, t, r) { for (var i = e.length, a = i && e[0].length, o = 0; o < i; o++) { n[o] || (n[o] = []); for (var s = 0; s < a; s++)n[o][s] = e[o][s] + t[o][s] * r } return n } function Z$e(n, e) { for (var t = n.length, r = e.length, i = t > r ? e : n, a = Math.min(t, r), o = i[a - 1] || { color: [0, 0, 0, 0], offset: 0 }, s = a; s < Math.max(t, r); s++)i.push({ offset: o.offset, color: o.color.slice() }) } function X$e(n, e, t) { var r = n, i = e; if (!(!r.push || !i.push)) { var a = r.length, o = i.length; if (a !== o) { var s = a > o; if (s) r.length = o; else for (var l = a; l < o; l++)r.push(t === 1 ? i[l] : LP.call(i[l])) } for (var c = r[0] && r[0].length, l = 0; l < r.length; l++)if (t === 1) isNaN(r[l]) && (r[l] = i[l]); else for (var u = 0; u < c; u++)isNaN(r[l][u]) && (r[l][u] = i[l][u]) } } function d0(n) { if (Ii(n)) { var e = n.length; if (Ii(n[0])) { for (var t = [], r = 0; r < e; r++)t.push(LP.call(n[r])); return t } return LP.call(n) } return n } function Xx(n) { return n[0] = Math.floor(n[0]) || 0, n[1] = Math.floor(n[1]) || 0, n[2] = Math.floor(n[2]) || 0, n[3] = n[3] == null ? 1 : n[3], "rgba(" + n.join(",") + ")" } function J$e(n) { return Ii(n && n[0]) ? 2 : 1 } var Dw = 0, Jx = 1, zee = 2, Ty = 3, RP = 4, NP = 5, V6 = 6; function H6(n) { return n === RP || n === NP } function jw(n) { return n === Jx || n === zee } var Uv = [0, 0, 0, 0], Q$e = function () { function n(e) { this.keyframes = [], this.discrete = !1, this._invalid = !1, this._needsSort = !1, this._lastFr = 0, this._lastFrP = 0, this.propName = e } return n.prototype.isFinished = function () { return this._finished }, n.prototype.setFinished = function () { this._finished = !0, this._additiveTrack && this._additiveTrack.setFinished() }, n.prototype.needsAnimate = function () { return this.keyframes.length >= 1 }, n.prototype.getAdditiveTrack = function () { return this._additiveTrack }, n.prototype.addKeyframe = function (e, t, r) { this._needsSort = !0; var i = this.keyframes, a = i.length, o = !1, s = V6, l = t; if (Ii(t)) { var c = J$e(t); s = c, (c === 1 && !nn(t[0]) || c === 2 && !nn(t[0][0])) && (o = !0) } else if (nn(t) && !c_(t)) s = Dw; else if (Fe(t)) if (!isNaN(+t)) s = Dw; else { var u = Ha(t); u && (l = u, s = Ty) } else if (Wk(t)) { var d = be({}, l); d.colorStops = Ae(t.colorStops, function (h) { return { offset: h.offset, color: Ha(h.color) } }), Ree(t) ? s = RP : Nee(t) && (s = NP), l = d } a === 0 ? this.valType = s : (s !== this.valType || s === V6) && (o = !0), this.discrete = this.discrete || o; var f = { time: e, value: l, rawValue: t, percent: 0 }; return r && (f.easing = r, f.easingFunc = tt(r) ? r : Cee[r] || CN(r)), i.push(f), f }, n.prototype.prepare = function (e, t) { var r = this.keyframes; this._needsSort && r.sort(function (m, g) { return m.time - g.time }); for (var i = this.valType, a = r.length, o = r[a - 1], s = this.discrete, l = jw(i), c = H6(i), u = 0; u < a; u++) { var d = r[u], f = d.value, h = o.value; d.percent = d.time / e, s || (l && u !== a - 1 ? X$e(f, h, i) : c && Z$e(f.colorStops, h.colorStops)) } if (!s && i !== NP && t && this.needsAnimate() && t.needsAnimate() && i === t.valType && !t._finished) { this._additiveTrack = t; for (var p = r[0].value, u = 0; u < a; u++)i === Dw ? r[u].additiveValue = r[u].value - p : i === Ty ? r[u].additiveValue = Ow([], r[u].value, p, -1) : jw(i) && (r[u].additiveValue = i === Jx ? Ow([], r[u].value, p, -1) : z6([], r[u].value, p, -1)) } }, n.prototype.step = function (e, t) { if (!this._finished) { this._additiveTrack && this._additiveTrack._finished && (this._additiveTrack = null); var r = this._additiveTrack != null, i = r ? "additiveValue" : "value", a = this.valType, o = this.keyframes, s = o.length, l = this.propName, c = a === Ty, u, d = this._lastFr, f = Math.min, h, p; if (s === 1) h = p = o[0]; else { if (t < 0) u = 0; else if (t < this._lastFrP) { var m = f(d + 1, s - 1); for (u = m; u >= 0 && !(o[u].percent <= t); u--); u = f(u, s - 2) } else { for (u = d; u < s && !(o[u].percent > t); u++); u = f(u - 1, s - 2) } p = o[u + 1], h = o[u] } if (h && p) { this._lastFr = u, this._lastFrP = t; var g = p.percent - h.percent, y = g === 0 ? 1 : f((t - h.percent) / g, 1); p.easingFunc && (y = p.easingFunc(y)); var b = r ? this._additiveValue : c ? Uv : e[l]; if ((jw(a) || c) && !b && (b = this._additiveValue = []), this.discrete) e[l] = y < 1 ? h.rawValue : p.rawValue; else if (jw(a)) a === Jx ? fM(b, h[i], p[i], y) : Y$e(b, h[i], p[i], y); else if (H6(a)) { var w = h[i], v = p[i], S = a === RP; e[l] = { type: S ? "linear" : "radial", x: ic(w.x, v.x, y), y: ic(w.y, v.y, y), colorStops: Ae(w.colorStops, function (k, A) { var C = v.colorStops[A]; return { offset: ic(k.offset, C.offset, y), color: Xx(fM([], k.color, C.color, y)) } }), global: v.global }, S ? (e[l].x2 = ic(w.x2, v.x2, y), e[l].y2 = ic(w.y2, v.y2, y)) : e[l].r = ic(w.r, v.r, y) } else if (c) fM(b, h[i], p[i], y), r || (e[l] = Xx(b)); else { var x = ic(h[i], p[i], y); r ? this._additiveValue = x : e[l] = x } r && this._addToTarget(e) } } }, n.prototype._addToTarget = function (e) { var t = this.valType, r = this.propName, i = this._additiveValue; t === Dw ? e[r] = e[r] + i : t === Ty ? (Ha(e[r], Uv), Ow(Uv, Uv, i, 1), e[r] = Xx(Uv)) : t === Jx ? Ow(e[r], e[r], i, 1) : t === zee && z6(e[r], e[r], i, 1) }, n }(), EN = function () { function n(e, t, r, i) { if (this._tracks = {}, this._trackKeys = [], this._maxTime = 0, this._started = 0, this._clip = null, this._target = e, this._loop = t, t && i) { _N("Can' use additive animation on looped animation."); return } this._additiveAnimators = i, this._allowDiscrete = r } return n.prototype.getMaxTime = function () { return this._maxTime }, n.prototype.getDelay = function () { return this._delay }, n.prototype.getLoop = function () { return this._loop }, n.prototype.getTarget = function () { return this._target }, n.prototype.changeTarget = function (e) { this._target = e }, n.prototype.when = function (e, t, r) { return this.whenWithKeys(e, t, Bt(t), r) }, n.prototype.whenWithKeys = function (e, t, r, i) { for (var a = this._tracks, o = 0; o < r.length; o++) { var s = r[o], l = a[s]; if (!l) { l = a[s] = new Q$e(s); var c = void 0, u = this._getAdditiveTrack(s); if (u) { var d = u.keyframes, f = d[d.length - 1]; c = f && f.value, u.valType === Ty && c && (c = Xx(c)) } else c = this._target[s]; if (c == null) continue; e > 0 && l.addKeyframe(0, d0(c), i), this._trackKeys.push(s) } l.addKeyframe(e, d0(t[s]), i) } return this._maxTime = Math.max(this._maxTime, e), this }, n.prototype.pause = function () { this._clip.pause(), this._paused = !0 }, n.prototype.resume = function () { this._clip.resume(), this._paused = !1 }, n.prototype.isPaused = function () { return !!this._paused }, n.prototype.duration = function (e) { return this._maxTime = e, this._force = !0, this }, n.prototype._doneCallback = function () { this._setTracksFinished(), this._clip = null; var e = this._doneCbs; if (e) for (var t = e.length, r = 0; r < t; r++)e[r].call(this) }, n.prototype._abortedCallback = function () { this._setTracksFinished(); var e = this.animation, t = this._abortedCbs; if (e && e.removeClip(this._clip), this._clip = null, t) for (var r = 0; r < t.length; r++)t[r].call(this) }, n.prototype._setTracksFinished = function () { for (var e = this._tracks, t = this._trackKeys, r = 0; r < t.length; r++)e[t[r]].setFinished() }, n.prototype._getAdditiveTrack = function (e) { var t, r = this._additiveAnimators; if (r) for (var i = 0; i < r.length; i++) { var a = r[i].getTrack(e); a && (t = a) } return t }, n.prototype.start = function (e) { if (!(this._started > 0)) { this._started = 1; for (var t = this, r = [], i = this._maxTime || 0, a = 0; a < this._trackKeys.length; a++) { var o = this._trackKeys[a], s = this._tracks[o], l = this._getAdditiveTrack(o), c = s.keyframes, u = c.length; if (s.prepare(i, l), s.needsAnimate()) if (!this._allowDiscrete && s.discrete) { var d = c[u - 1]; d && (t._target[s.propName] = d.rawValue), s.setFinished() } else r.push(s) } if (r.length || this._force) { var f = new R$e({ life: i, loop: this._loop, delay: this._delay || 0, onframe: function (h) { t._started = 2; var p = t._additiveAnimators; if (p) { for (var m = !1, g = 0; g < p.length; g++)if (p[g]._clip) { m = !0; break } m || (t._additiveAnimators = null) } for (var g = 0; g < r.length; g++)r[g].step(t._target, h); var y = t._onframeCbs; if (y) for (var g = 0; g < y.length; g++)y[g](t._target, h) }, ondestroy: function () { t._doneCallback() } }); this._clip = f, this.animation && this.animation.addClip(f), e && f.setEasing(e) } else this._doneCallback(); return this } }, n.prototype.stop = function (e) { if (this._clip) { var t = this._clip; e && t.onframe(1), this._abortedCallback() } }, n.prototype.delay = function (e) { return this._delay = e, this }, n.prototype.during = function (e) { return e && (this._onframeCbs || (this._onframeCbs = []), this._onframeCbs.push(e)), this }, n.prototype.done = function (e) { return e && (this._doneCbs || (this._doneCbs = []), this._doneCbs.push(e)), this }, n.prototype.aborted = function (e) { return e && (this._abortedCbs || (this._abortedCbs = []), this._abortedCbs.push(e)), this }, n.prototype.getClip = function () { return this._clip }, n.prototype.getTrack = function (e) { return this._tracks[e] }, n.prototype.getTracks = function () { var e = this; return Ae(this._trackKeys, function (t) { return e._tracks[t] }) }, n.prototype.stopTracks = function (e, t) { if (!e.length || !this._clip) return !0; for (var r = this._tracks, i = this._trackKeys, a = 0; a < e.length; a++) { var o = r[e[a]]; o && !o.isFinished() && (t ? o.step(this._target, 1) : this._started === 1 && o.step(this._target, 0), o.setFinished()) } for (var s = !0, a = 0; a < i.length; a++)if (!r[i[a]].isFinished()) { s = !1; break } return s && this._abortedCallback(), s }, n.prototype.saveTo = function (e, t, r) { if (e) { t = t || this._trackKeys; for (var i = 0; i < t.length; i++) { var a = t[i], o = this._tracks[a]; if (!(!o || o.isFinished())) { var s = o.keyframes, l = s[r ? 0 : s.length - 1]; l && (e[a] = d0(l.rawValue)) } } } }, n.prototype.__changeFinalValue = function (e, t) { t = t || Bt(e); for (var r = 0; r < t.length; r++) { var i = t[r], a = this._tracks[i]; if (a) { var o = a.keyframes; if (o.length > 1) { var s = o.pop(); a.addKeyframe(s.time, e[i]), a.prepare(this._maxTime, a.getAdditiveTrack()) } } } }, n }(); function jm() { return new Date().getTime() } var eFe = function (n) { te(e, n); function e(t) { var r = n.call(this) || this; return r._running = !1, r._time = 0, r._pausedTime = 0, r._pauseStart = 0, r._paused = !1, t = t || {}, r.stage = t.stage || {}, r } return e.prototype.addClip = function (t) { t.animation && this.removeClip(t), this._head ? (this._tail.next = t, t.prev = this._tail, t.next = null, this._tail = t) : this._head = this._tail = t, t.animation = this }, e.prototype.addAnimator = function (t) { t.animation = this; var r = t.getClip(); r && this.addClip(r) }, e.prototype.removeClip = function (t) { if (t.animation) { var r = t.prev, i = t.next; r ? r.next = i : this._head = i, i ? i.prev = r : this._tail = r, t.next = t.prev = t.animation = null } }, e.prototype.removeAnimator = function (t) { var r = t.getClip(); r && this.removeClip(r), t.animation = null }, e.prototype.update = function (t) { for (var r = jm() - this._pausedTime, i = r - this._time, a = this._head; a;) { var o = a.next, s = a.step(r, i); s && (a.ondestroy(), this.removeClip(a)), a = o } this._time = r, t || (this.trigger("frame", i), this.stage.update && this.stage.update()) }, e.prototype._startLoop = function () { var t = this; this._running = !0; function r() { t._running && (EP(r), !t._paused && t.update()) } EP(r) }, e.prototype.start = function () { this._running || (this._time = jm(), this._pausedTime = 0, this._startLoop()) }, e.prototype.stop = function () { this._running = !1 }, e.prototype.pause = function () { this._paused || (this._pauseStart = jm(), this._paused = !0) }, e.prototype.resume = function () { this._paused && (this._pausedTime += jm() - this._pauseStart, this._paused = !1) }, e.prototype.clear = function () { for (var t = this._head; t;) { var r = t.next; t.prev = t.next = t.animation = null, t = r } this._head = this._tail = null }, e.prototype.isFinished = function () { return this._head == null }, e.prototype.animate = function (t, r) { r = r || {}, this.start(); var i = new EN(t, r.loop); return this.addAnimator(i), i }, e }(Go); const tFe = eFe; var nFe = 300, hM = en.domSupported, pM = function () { var n = ["click", "dblclick", "mousewheel", "wheel", "mouseout", "mouseup", "mousedown", "mousemove", "contextmenu"], e = ["touchstart", "touchend", "touchmove"], t = { pointerdown: 1, pointerup: 1, pointermove: 1, pointerout: 1 }, r = Ae(n, function (i) { var a = i.replace("mouse", "pointer"); return t.hasOwnProperty(a) ? a : i }); return { mouse: n, touch: e, pointer: r } }(), U6 = { mouse: ["mousemove", "mouseup"], pointer: ["pointermove", "pointerup"] }, G6 = !1; function BP(n) { var e = n.pointerType; return e === "pen" || e === "touch" } function rFe(n) { n.touching = !0, n.touchTimer != null && (clearTimeout(n.touchTimer), n.touchTimer = null), n.touchTimer = setTimeout(function () { n.touching = !1, n.touchTimer = null }, 700) } function mM(n) { n && (n.zrByTouch = !0) } function iFe(n, e) { return po(n.dom, new aFe(n, e), !0) } function Vee(n, e) { for (var t = e, r = !1; t && t.nodeType !== 9 && !(r = t.domBelongToZr || t !== e && t === n.painterRoot);)t = t.parentNode; return r } var aFe = function () { function n(e, t) { this.stopPropagation = gr, this.stopImmediatePropagation = gr, this.preventDefault = gr, this.type = t.type, this.target = this.currentTarget = e.dom, this.pointerType = t.pointerType, this.clientX = t.clientX, this.clientY = t.clientY } return n }(), rs = { mousedown: function (n) { n = po(this.dom, n), this.__mayPointerCapture = [n.zrX, n.zrY], this.trigger("mousedown", n) }, mousemove: function (n) { n = po(this.dom, n); var e = this.__mayPointerCapture; e && (n.zrX !== e[0] || n.zrY !== e[1]) && this.__togglePointerCapture(!0), this.trigger("mousemove", n) }, mouseup: function (n) { n = po(this.dom, n), this.__togglePointerCapture(!1), this.trigger("mouseup", n) }, mouseout: function (n) { n = po(this.dom, n); var e = n.toElement || n.relatedTarget; Vee(this, e) || (this.__pointerCapturing && (n.zrEventControl = "no_globalout"), this.trigger("mouseout", n)) }, wheel: function (n) { G6 = !0, n = po(this.dom, n), this.trigger("mousewheel", n) }, mousewheel: function (n) { G6 || (n = po(this.dom, n), this.trigger("mousewheel", n)) }, touchstart: function (n) { n = po(this.dom, n), mM(n), this.__lastTouchMoment = new Date, this.handler.processGesture(n, "start"), rs.mousemove.call(this, n), rs.mousedown.call(this, n) }, touchmove: function (n) { n = po(this.dom, n), mM(n), this.handler.processGesture(n, "change"), rs.mousemove.call(this, n) }, touchend: function (n) { n = po(this.dom, n), mM(n), this.handler.processGesture(n, "end"), rs.mouseup.call(this, n), +new Date - +this.__lastTouchMoment < nFe && rs.click.call(this, n) }, pointerdown: function (n) { rs.mousedown.call(this, n) }, pointermove: function (n) { BP(n) || rs.mousemove.call(this, n) }, pointerup: function (n) { rs.mouseup.call(this, n) }, pointerout: function (n) { BP(n) || rs.mouseout.call(this, n) } }; $(["click", "dblclick", "contextmenu"], function (n) { rs[n] = function (e) { e = po(this.dom, e), this.trigger(n, e) } }); var $P = { pointermove: function (n) { BP(n) || $P.mousemove.call(this, n) }, pointerup: function (n) { $P.mouseup.call(this, n) }, mousemove: function (n) { this.trigger("mousemove", n) }, mouseup: function (n) { var e = this.__pointerCapturing; this.__togglePointerCapture(!1), this.trigger("mouseup", n), e && (n.zrEventControl = "only_globalout", this.trigger("mouseout", n)) } }; function oFe(n, e) { var t = e.domHandlers; en.pointerEventsSupported ? $(pM.pointer, function (r) { Qx(e, r, function (i) { t[r].call(n, i) }) }) : (en.touchEventsSupported && $(pM.touch, function (r) { Qx(e, r, function (i) { t[r].call(n, i), rFe(e) }) }), $(pM.mouse, function (r) { Qx(e, r, function (i) { i = SN(i), e.touching || t[r].call(n, i) }) })) } function sFe(n, e) { en.pointerEventsSupported ? $(U6.pointer, t) : en.touchEventsSupported || $(U6.mouse, t); function t(r) { function i(a) { a = SN(a), Vee(n, a.target) || (a = iFe(n, a), e.domHandlers[r].call(n, a)) } Qx(e, r, i, { capture: !0 }) } } function Qx(n, e, t, r) { n.mounted[e] = t, n.listenerOpts[e] = r, AP(n.domTarget, e, t, r) } function gM(n) { var e = n.mounted; for (var t in e) e.hasOwnProperty(t) && p$e(n.domTarget, t, e[t], n.listenerOpts[t]); n.mounted = {} } var W6 = function () { function n(e, t) { this.mounted = {}, this.listenerOpts = {}, this.touching = !1, this.domTarget = e, this.domHandlers = t } return n }(), lFe = function (n) { te(e, n); function e(t, r) { var i = n.call(this) || this; return i.__pointerCapturing = !1, i.dom = t, i.painterRoot = r, i._localHandlerScope = new W6(t, rs), hM && (i._globalHandlerScope = new W6(document, $P)), oFe(i, i._localHandlerScope), i } return e.prototype.dispose = function () { gM(this._localHandlerScope), hM && gM(this._globalHandlerScope) }, e.prototype.setCursor = function (t) { this.dom.style && (this.dom.style.cursor = t || "default") }, e.prototype.__togglePointerCapture = function (t) { if (this.__mayPointerCapture = null, hM && +this.__pointerCapturing ^ +t) { this.__pointerCapturing = t; var r = this._globalHandlerScope; t ? sFe(this, r) : gM(r) } }, e }(Go); const cFe = lFe; var Hee = 1; en.hasGlobalWindow && (Hee = Math.max(window.devicePixelRatio || window.screen && window.screen.deviceXDPI / window.screen.logicalXDPI || 1, 1)); var q2 = Hee, FP = .4, zP = "#333", VP = "#ccc", uFe = "#eee", K6 = qk, q6 = 5e-5; function hf(n) { return n > q6 || n < -q6 } var pf = [], Vp = [], vM = Va(), yM = Math.abs, dFe = function () { function n() { } return n.prototype.getLocalTransform = function (e) { return n.getLocalTransform(this, e) }, n.prototype.setPosition = function (e) { this.x = e[0], this.y = e[1] }, n.prototype.setScale = function (e) { this.scaleX = e[0], this.scaleY = e[1] }, n.prototype.setSkew = function (e) { this.skewX = e[0], this.skewY = e[1] }, n.prototype.setOrigin = function (e) { this.originX = e[0], this.originY = e[1] }, n.prototype.needLocalTransform = function () { return hf(this.rotation) || hf(this.x) || hf(this.y) || hf(this.scaleX - 1) || hf(this.scaleY - 1) || hf(this.skewX) || hf(this.skewY) }, n.prototype.updateTransform = function () { var e = this.parent && this.parent.transform, t = this.needLocalTransform(), r = this.transform; if (!(t || e)) { r && (K6(r), this.invTransform = null); return } r = r || Va(), t ? this.getLocalTransform(r) : K6(r), e && (t ? bc(r, e, r) : TN(r, e)), this.transform = r, this._resolveGlobalScaleRatio(r) }, n.prototype._resolveGlobalScaleRatio = function (e) { var t = this.globalScaleRatio; if (t != null && t !== 1) { this.getGlobalScale(pf); var r = pf[0] < 0 ? -1 : 1, i = pf[1] < 0 ? -1 : 1, a = ((pf[0] - r) * t + r) / pf[0] || 0, o = ((pf[1] - i) * t + i) / pf[1] || 0; e[0] *= a, e[1] *= a, e[2] *= o, e[3] *= o } this.invTransform = this.invTransform || Va(), qg(this.invTransform, e) }, n.prototype.getComputedTransform = function () { for (var e = this, t = []; e;)t.push(e), e = e.parent; for (; e = t.pop();)e.updateTransform(); return this.transform }, n.prototype.setLocalTransform = function (e) { if (e) { var t = e[0] * e[0] + e[1] * e[1], r = e[2] * e[2] + e[3] * e[3], i = Math.atan2(e[1], e[0]), a = Math.PI / 2 + i - Math.atan2(e[3], e[2]); r = Math.sqrt(r) * Math.cos(a), t = Math.sqrt(t), this.skewX = a, this.skewY = 0, this.rotation = -i, this.x = +e[4], this.y = +e[5], this.scaleX = t, this.scaleY = r, this.originX = 0, this.originY = 0 } }, n.prototype.decomposeTransform = function () { if (this.transform) { var e = this.parent, t = this.transform; e && e.transform && (e.invTransform = e.invTransform || Va(), bc(Vp, e.invTransform, t), t = Vp); var r = this.originX, i = this.originY; (r || i) && (vM[4] = r, vM[5] = i, bc(Vp, t, vM), Vp[4] -= r, Vp[5] -= i, t = Vp), this.setLocalTransform(t) } }, n.prototype.getGlobalScale = function (e) { var t = this.transform; return e = e || [], t ? (e[0] = Math.sqrt(t[0] * t[0] + t[1] * t[1]), e[1] = Math.sqrt(t[2] * t[2] + t[3] * t[3]), t[0] < 0 && (e[0] = -e[0]), t[3] < 0 && (e[1] = -e[1]), e) : (e[0] = 1, e[1] = 1, e) }, n.prototype.transformCoordToLocal = function (e, t) { var r = [e, t], i = this.invTransform; return i && fi(r, r, i), r }, n.prototype.transformCoordToGlobal = function (e, t) { var r = [e, t], i = this.transform; return i && fi(r, r, i), r }, n.prototype.getLineScale = function () { var e = this.transform; return e && yM(e[0] - 1) > 1e-10 && yM(e[3] - 1) > 1e-10 ? Math.sqrt(yM(e[0] * e[3] - e[2] * e[1])) : 1 }, n.prototype.copyTransform = function (e) { Uee(this, e) }, n.getLocalTransform = function (e, t) { t = t || []; var r = e.originX || 0, i = e.originY || 0, a = e.scaleX, o = e.scaleY, s = e.anchorX, l = e.anchorY, c = e.rotation || 0, u = e.x, d = e.y, f = e.skewX ? Math.tan(e.skewX) : 0, h = e.skewY ? Math.tan(-e.skewY) : 0; if (r || i || s || l) { var p = r + s, m = i + l; t[4] = -p * a - f * m * o, t[5] = -m * o - h * p * a } else t[4] = t[5] = 0; return t[0] = a, t[3] = o, t[1] = h * a, t[2] = f * o, c && rp(t, t, c), t[4] += r + u, t[5] += i + d, t }, n.initDefaultProps = function () { var e = n.prototype; e.scaleX = e.scaleY = e.globalScaleRatio = 1, e.x = e.y = e.originX = e.originY = e.skewX = e.skewY = e.rotation = e.anchorX = e.anchorY = 0 }(), n }(), Tl = ["x", "y", "originX", "originY", "anchorX", "anchorY", "rotation", "scaleX", "scaleY", "skewX", "skewY"]; function Uee(n, e) { for (var t = 0; t < Tl.length; t++) { var r = Tl[t]; n[r] = e[r] } } const mc = dFe; var Y6 = {}; function Ua(n, e) { e = e || Td; var t = Y6[e]; t || (t = Y6[e] = new _b(500)); var r = t.get(n); return r == null && (r = kd.measureText(n, e).width, t.put(n, r)), r } function Z6(n, e, t, r) { var i = Ua(n, e), a = Zk(e), o = ky(0, i, t), s = xm(0, a, r), l = new kt(o, s, i, a); return l } function bb(n, e, t, r) {
  var i = ((n || "") + "").split(`
`), a = i.length; if (a === 1) return Z6(i[0], e, t, r); for (var o = new kt(0, 0, 0, 0), s = 0; s < i.length; s++) { var l = Z6(i[s], e, t, r); s === 0 ? o.copy(l) : o.union(l) } return o
} function ky(n, e, t) { return t === "right" ? n -= e : t === "center" && (n -= e / 2), n } function xm(n, e, t) { return t === "middle" ? n -= e / 2 : t === "bottom" && (n -= e), n } function Zk(n) { return Ua("", n) } function Es(n, e) { return typeof n == "string" ? n.lastIndexOf("%") >= 0 ? parseFloat(n) / 100 * e : parseFloat(n) : n } function Y2(n, e, t) { var r = e.position || "inside", i = e.distance != null ? e.distance : 5, a = t.height, o = t.width, s = a / 2, l = t.x, c = t.y, u = "left", d = "top"; if (r instanceof Array) l += Es(r[0], t.width), c += Es(r[1], t.height), u = null, d = null; else switch (r) { case "left": l -= i, c += s, u = "right", d = "middle"; break; case "right": l += i + o, c += s, d = "middle"; break; case "top": l += o / 2, c -= i, u = "center", d = "bottom"; break; case "bottom": l += o / 2, c += a + i, u = "center"; break; case "inside": l += o / 2, c += s, u = "center", d = "middle"; break; case "insideLeft": l += i, c += s, d = "middle"; break; case "insideRight": l += o - i, c += s, u = "right", d = "middle"; break; case "insideTop": l += o / 2, c += i, u = "center"; break; case "insideBottom": l += o / 2, c += a - i, u = "center", d = "bottom"; break; case "insideTopLeft": l += i, c += i; break; case "insideTopRight": l += o - i, c += i, u = "right"; break; case "insideBottomLeft": l += i, c += a - i, d = "bottom"; break; case "insideBottomRight": l += o - i, c += a - i, u = "right", d = "bottom"; break }return n = n || {}, n.x = l, n.y = c, n.align = u, n.verticalAlign = d, n } var _M = "__zr_normal__", bM = Tl.concat(["ignore"]), fFe = xl(Tl, function (n, e) { return n[e] = !0, n }, { ignore: !1 }), Hp = {}, hFe = new kt(0, 0, 0, 0), MN = function () { function n(e) { this.id = gee(), this.animators = [], this.currentStates = [], this.states = {}, this._init(e) } return n.prototype._init = function (e) { this.attr(e) }, n.prototype.drift = function (e, t, r) { switch (this.draggable) { case "horizontal": t = 0; break; case "vertical": e = 0; break }var i = this.transform; i || (i = this.transform = [1, 0, 0, 1, 0, 0]), i[4] += e, i[5] += t, this.decomposeTransform(), this.markRedraw() }, n.prototype.beforeUpdate = function () { }, n.prototype.afterUpdate = function () { }, n.prototype.update = function () { this.updateTransform(), this.__dirty && this.updateInnerText() }, n.prototype.updateInnerText = function (e) { var t = this._textContent; if (t && (!t.ignore || e)) { this.textConfig || (this.textConfig = {}); var r = this.textConfig, i = r.local, a = t.innerTransformable, o = void 0, s = void 0, l = !1; a.parent = i ? this : null; var c = !1; if (a.copyTransform(t), r.position != null) { var u = hFe; r.layoutRect ? u.copy(r.layoutRect) : u.copy(this.getBoundingRect()), i || u.applyTransform(this.transform), this.calculateTextPosition ? this.calculateTextPosition(Hp, r, u) : Y2(Hp, r, u), a.x = Hp.x, a.y = Hp.y, o = Hp.align, s = Hp.verticalAlign; var d = r.origin; if (d && r.rotation != null) { var f = void 0, h = void 0; d === "center" ? (f = u.width * .5, h = u.height * .5) : (f = Es(d[0], u.width), h = Es(d[1], u.height)), c = !0, a.originX = -a.x + f + (i ? 0 : u.x), a.originY = -a.y + h + (i ? 0 : u.y) } } r.rotation != null && (a.rotation = r.rotation); var p = r.offset; p && (a.x += p[0], a.y += p[1], c || (a.originX = -p[0], a.originY = -p[1])); var m = r.inside == null ? typeof r.position == "string" && r.position.indexOf("inside") >= 0 : r.inside, g = this._innerTextDefaultStyle || (this._innerTextDefaultStyle = {}), y = void 0, b = void 0, w = void 0; m && this.canBeInsideText() ? (y = r.insideFill, b = r.insideStroke, (y == null || y === "auto") && (y = this.getInsideTextFill()), (b == null || b === "auto") && (b = this.getInsideTextStroke(y), w = !0)) : (y = r.outsideFill, b = r.outsideStroke, (y == null || y === "auto") && (y = this.getOutsideFill()), (b == null || b === "auto") && (b = this.getOutsideStroke(y), w = !0)), y = y || "#000", (y !== g.fill || b !== g.stroke || w !== g.autoStroke || o !== g.align || s !== g.verticalAlign) && (l = !0, g.fill = y, g.stroke = b, g.autoStroke = w, g.align = o, g.verticalAlign = s, t.setDefaultTextStyle(g)), t.__dirty |= Ba, l && t.dirtyStyle(!0) } }, n.prototype.canBeInsideText = function () { return !0 }, n.prototype.getInsideTextFill = function () { return "#fff" }, n.prototype.getInsideTextStroke = function (e) { return "#000" }, n.prototype.getOutsideFill = function () { return this.__zr && this.__zr.isDarkMode() ? VP : zP }, n.prototype.getOutsideStroke = function (e) { var t = this.__zr && this.__zr.getBackgroundColor(), r = typeof t == "string" && Ha(t); r || (r = [255, 255, 255, 1]); for (var i = r[3], a = this.__zr.isDarkMode(), o = 0; o < 3; o++)r[o] = r[o] * i + (a ? 0 : 255) * (1 - i); return r[3] = 1, wc(r, "rgba") }, n.prototype.traverse = function (e, t) { }, n.prototype.attrKV = function (e, t) { e === "textConfig" ? this.setTextConfig(t) : e === "textContent" ? this.setTextContent(t) : e === "clipPath" ? this.setClipPath(t) : e === "extra" ? (this.extra = this.extra || {}, be(this.extra, t)) : this[e] = t }, n.prototype.hide = function () { this.ignore = !0, this.markRedraw() }, n.prototype.show = function () { this.ignore = !1, this.markRedraw() }, n.prototype.attr = function (e, t) { if (typeof e == "string") this.attrKV(e, t); else if (ot(e)) for (var r = e, i = Bt(r), a = 0; a < i.length; a++) { var o = i[a]; this.attrKV(o, e[o]) } return this.markRedraw(), this }, n.prototype.saveCurrentToNormalState = function (e) { this._innerSaveToNormal(e); for (var t = this._normalState, r = 0; r < this.animators.length; r++) { var i = this.animators[r], a = i.__fromStateTransition; if (!(i.getLoop() || a && a !== _M)) { var o = i.targetName, s = o ? t[o] : t; i.saveTo(s) } } }, n.prototype._innerSaveToNormal = function (e) { var t = this._normalState; t || (t = this._normalState = {}), e.textConfig && !t.textConfig && (t.textConfig = this.textConfig), this._savePrimaryToNormal(e, t, bM) }, n.prototype._savePrimaryToNormal = function (e, t, r) { for (var i = 0; i < r.length; i++) { var a = r[i]; e[a] != null && !(a in t) && (t[a] = this[a]) } }, n.prototype.hasState = function () { return this.currentStates.length > 0 }, n.prototype.getState = function (e) { return this.states[e] }, n.prototype.ensureState = function (e) { var t = this.states; return t[e] || (t[e] = {}), t[e] }, n.prototype.clearStates = function (e) { this.useState(_M, !1, e) }, n.prototype.useState = function (e, t, r, i) { var a = e === _M, o = this.hasState(); if (!(!o && a)) { var s = this.currentStates, l = this.stateTransition; if (!(Et(s, e) >= 0 && (t || s.length === 1))) { var c; if (this.stateProxy && !a && (c = this.stateProxy(e)), c || (c = this.states && this.states[e]), !c && !a) { _N("State " + e + " not exists."); return } a || this.saveCurrentToNormalState(c); var u = !!(c && c.hoverLayer || i); u && this._toggleHoverLayerFlag(!0), this._applyStateObj(e, c, this._normalState, t, !r && !this.__inHover && l && l.duration > 0, l); var d = this._textContent, f = this._textGuide; return d && d.useState(e, t, r, u), f && f.useState(e, t, r, u), a ? (this.currentStates = [], this._normalState = {}) : t ? this.currentStates.push(e) : this.currentStates = [e], this._updateAnimationTargets(), this.markRedraw(), !u && this.__inHover && (this._toggleHoverLayerFlag(!1), this.__dirty &= ~Ba), c } } }, n.prototype.useStates = function (e, t, r) { if (!e.length) this.clearStates(); else { var i = [], a = this.currentStates, o = e.length, s = o === a.length; if (s) { for (var l = 0; l < o; l++)if (e[l] !== a[l]) { s = !1; break } } if (s) return; for (var l = 0; l < o; l++) { var c = e[l], u = void 0; this.stateProxy && (u = this.stateProxy(c, e)), u || (u = this.states[c]), u && i.push(u) } var d = i[o - 1], f = !!(d && d.hoverLayer || r); f && this._toggleHoverLayerFlag(!0); var h = this._mergeStates(i), p = this.stateTransition; this.saveCurrentToNormalState(h), this._applyStateObj(e.join(","), h, this._normalState, !1, !t && !this.__inHover && p && p.duration > 0, p); var m = this._textContent, g = this._textGuide; m && m.useStates(e, t, f), g && g.useStates(e, t, f), this._updateAnimationTargets(), this.currentStates = e.slice(), this.markRedraw(), !f && this.__inHover && (this._toggleHoverLayerFlag(!1), this.__dirty &= ~Ba) } }, n.prototype.isSilent = function () { for (var e = this.silent, t = this.parent; !e && t;) { if (t.silent) { e = !0; break } t = t.parent } return e }, n.prototype._updateAnimationTargets = function () { for (var e = 0; e < this.animators.length; e++) { var t = this.animators[e]; t.targetName && t.changeTarget(this[t.targetName]) } }, n.prototype.removeState = function (e) { var t = Et(this.currentStates, e); if (t >= 0) { var r = this.currentStates.slice(); r.splice(t, 1), this.useStates(r) } }, n.prototype.replaceState = function (e, t, r) { var i = this.currentStates.slice(), a = Et(i, e), o = Et(i, t) >= 0; a >= 0 ? o ? i.splice(a, 1) : i[a] = t : r && !o && i.push(t), this.useStates(i) }, n.prototype.toggleState = function (e, t) { t ? this.useState(e, !0) : this.removeState(e) }, n.prototype._mergeStates = function (e) { for (var t = {}, r, i = 0; i < e.length; i++) { var a = e[i]; be(t, a), a.textConfig && (r = r || {}, be(r, a.textConfig)) } return r && (t.textConfig = r), t }, n.prototype._applyStateObj = function (e, t, r, i, a, o) { var s = !(t && i); t && t.textConfig ? (this.textConfig = be({}, i ? this.textConfig : r.textConfig), be(this.textConfig, t.textConfig)) : s && r.textConfig && (this.textConfig = r.textConfig); for (var l = {}, c = !1, u = 0; u < bM.length; u++) { var d = bM[u], f = a && fFe[d]; t && t[d] != null ? f ? (c = !0, l[d] = t[d]) : this[d] = t[d] : s && r[d] != null && (f ? (c = !0, l[d] = r[d]) : this[d] = r[d]) } if (!a) for (var u = 0; u < this.animators.length; u++) { var h = this.animators[u], p = h.targetName; h.getLoop() || h.__changeFinalValue(p ? (t || r)[p] : t || r) } c && this._transitionState(e, l, o) }, n.prototype._attachComponent = function (e) { if (!(e.__zr && !e.__hostTarget) && e !== this) { var t = this.__zr; t && e.addSelfToZr(t), e.__zr = t, e.__hostTarget = this } }, n.prototype._detachComponent = function (e) { e.__zr && e.removeSelfFromZr(e.__zr), e.__zr = null, e.__hostTarget = null }, n.prototype.getClipPath = function () { return this._clipPath }, n.prototype.setClipPath = function (e) { this._clipPath && this._clipPath !== e && this.removeClipPath(), this._attachComponent(e), this._clipPath = e, this.markRedraw() }, n.prototype.removeClipPath = function () { var e = this._clipPath; e && (this._detachComponent(e), this._clipPath = null, this.markRedraw()) }, n.prototype.getTextContent = function () { return this._textContent }, n.prototype.setTextContent = function (e) { var t = this._textContent; t !== e && (t && t !== e && this.removeTextContent(), e.innerTransformable = new mc, this._attachComponent(e), this._textContent = e, this.markRedraw()) }, n.prototype.setTextConfig = function (e) { this.textConfig || (this.textConfig = {}), be(this.textConfig, e), this.markRedraw() }, n.prototype.removeTextConfig = function () { this.textConfig = null, this.markRedraw() }, n.prototype.removeTextContent = function () { var e = this._textContent; e && (e.innerTransformable = null, this._detachComponent(e), this._textContent = null, this._innerTextDefaultStyle = null, this.markRedraw()) }, n.prototype.getTextGuideLine = function () { return this._textGuide }, n.prototype.setTextGuideLine = function (e) { this._textGuide && this._textGuide !== e && this.removeTextGuideLine(), this._attachComponent(e), this._textGuide = e, this.markRedraw() }, n.prototype.removeTextGuideLine = function () { var e = this._textGuide; e && (this._detachComponent(e), this._textGuide = null, this.markRedraw()) }, n.prototype.markRedraw = function () { this.__dirty |= Ba; var e = this.__zr; e && (this.__inHover ? e.refreshHover() : e.refresh()), this.__hostTarget && this.__hostTarget.markRedraw() }, n.prototype.dirty = function () { this.markRedraw() }, n.prototype._toggleHoverLayerFlag = function (e) { this.__inHover = e; var t = this._textContent, r = this._textGuide; t && (t.__inHover = e), r && (r.__inHover = e) }, n.prototype.addSelfToZr = function (e) { if (this.__zr !== e) { this.__zr = e; var t = this.animators; if (t) for (var r = 0; r < t.length; r++)e.animation.addAnimator(t[r]); this._clipPath && this._clipPath.addSelfToZr(e), this._textContent && this._textContent.addSelfToZr(e), this._textGuide && this._textGuide.addSelfToZr(e) } }, n.prototype.removeSelfFromZr = function (e) { if (this.__zr) { this.__zr = null; var t = this.animators; if (t) for (var r = 0; r < t.length; r++)e.animation.removeAnimator(t[r]); this._clipPath && this._clipPath.removeSelfFromZr(e), this._textContent && this._textContent.removeSelfFromZr(e), this._textGuide && this._textGuide.removeSelfFromZr(e) } }, n.prototype.animate = function (e, t, r) { var i = e ? this[e] : this, a = new EN(i, t, r); return e && (a.targetName = e), this.addAnimator(a, e), a }, n.prototype.addAnimator = function (e, t) { var r = this.__zr, i = this; e.during(function () { i.updateDuringAnimation(t) }).done(function () { var a = i.animators, o = Et(a, e); o >= 0 && a.splice(o, 1) }), this.animators.push(e), r && r.animation.addAnimator(e), r && r.wakeUp() }, n.prototype.updateDuringAnimation = function (e) { this.markRedraw() }, n.prototype.stopAnimation = function (e, t) { for (var r = this.animators, i = r.length, a = [], o = 0; o < i; o++) { var s = r[o]; !e || e === s.scope ? s.stop(t) : a.push(s) } return this.animators = a, this }, n.prototype.animateTo = function (e, t, r) { wM(this, e, t, r) }, n.prototype.animateFrom = function (e, t, r) { wM(this, e, t, r, !0) }, n.prototype._transitionState = function (e, t, r, i) { for (var a = wM(this, t, r, i), o = 0; o < a.length; o++)a[o].__fromStateTransition = e }, n.prototype.getBoundingRect = function () { return null }, n.prototype.getPaintRect = function () { return null }, n.initDefaultProps = function () { var e = n.prototype; e.type = "element", e.name = "", e.ignore = e.silent = e.isGroup = e.draggable = e.dragging = e.ignoreClip = e.__inHover = !1, e.__dirty = Ba; function t(r, i, a, o) { Object.defineProperty(e, r, { get: function () { if (!this[i]) { var l = this[i] = []; s(this, l) } return this[i] }, set: function (l) { this[a] = l[0], this[o] = l[1], this[i] = l, s(this, l) } }); function s(l, c) { Object.defineProperty(c, 0, { get: function () { return l[a] }, set: function (u) { l[a] = u } }), Object.defineProperty(c, 1, { get: function () { return l[o] }, set: function (u) { l[o] = u } }) } } Object.defineProperty && (t("position", "_legacyPos", "x", "y"), t("scale", "_legacyScale", "scaleX", "scaleY"), t("origin", "_legacyOrigin", "originX", "originY")) }(), n }(); Cr(MN, Go); Cr(MN, mc); function wM(n, e, t, r, i) { t = t || {}; var a = []; Gee(n, "", n, e, t, r, a, i); var o = a.length, s = !1, l = t.done, c = t.aborted, u = function () { s = !0, o--, o <= 0 && (s ? l && l() : c && c()) }, d = function () { o--, o <= 0 && (s ? l && l() : c && c()) }; o || l && l(), a.length > 0 && t.during && a[0].during(function (p, m) { t.during(m) }); for (var f = 0; f < a.length; f++) { var h = a[f]; u && h.done(u), d && h.aborted(d), t.force && h.duration(t.duration), h.start(t.easing) } return a } function xM(n, e, t) { for (var r = 0; r < t; r++)n[r] = e[r] } function pFe(n) { return Ii(n[0]) } function mFe(n, e, t) { if (Ii(e[t])) if (Ii(n[t]) || (n[t] = []), ka(e[t])) { var r = e[t].length; n[t].length !== r && (n[t] = new e[t].constructor(r), xM(n[t], e[t], r)) } else { var i = e[t], a = n[t], o = i.length; if (pFe(i)) for (var s = i[0].length, l = 0; l < o; l++)a[l] ? xM(a[l], i[l], s) : a[l] = Array.prototype.slice.call(i[l]); else xM(a, i, o); a.length = i.length } else n[t] = e[t] } function gFe(n, e) { return n === e || Ii(n) && Ii(e) && vFe(n, e) } function vFe(n, e) { var t = n.length; if (t !== e.length) return !1; for (var r = 0; r < t; r++)if (n[r] !== e[r]) return !1; return !0 } function Gee(n, e, t, r, i, a, o, s) { for (var l = Bt(r), c = i.duration, u = i.delay, d = i.additive, f = i.setToFinal, h = !ot(a), p = n.animators, m = [], g = 0; g < l.length; g++) { var y = l[g], b = r[y]; if (b != null && t[y] != null && (h || a[y])) if (ot(b) && !Ii(b) && !Wk(b)) { if (e) { s || (t[y] = b, n.updateDuringAnimation(e)); continue } Gee(n, y, t[y], b, i, a && a[y], o, s) } else m.push(y); else s || (t[y] = b, n.updateDuringAnimation(e), m.push(y)) } var w = m.length; if (!d && w) for (var v = 0; v < p.length; v++) { var S = p[v]; if (S.targetName === e) { var x = S.stopTracks(m); if (x) { var k = Et(p, S); p.splice(k, 1) } } } if (i.force || (m = pn(m, function (O) { return !gFe(r[O], t[O]) }), w = m.length), w > 0 || i.force && !o.length) { var A = void 0, C = void 0, E = void 0; if (s) { C = {}, f && (A = {}); for (var v = 0; v < w; v++) { var y = m[v]; C[y] = t[y], f ? A[y] = r[y] : t[y] = r[y] } } else if (f) { E = {}; for (var v = 0; v < w; v++) { var y = m[v]; E[y] = d0(t[y]), mFe(t, r, y) } } var S = new EN(t, !1, !1, d ? pn(p, function (j) { return j.targetName === e }) : null); S.targetName = e, i.scope && (S.scope = i.scope), f && A && S.whenWithKeys(0, A, m), E && S.whenWithKeys(0, E, m), S.whenWithKeys(c ?? 500, s ? C : r, m).delay(u || 0), n.addAnimator(S, e), o.push(S) } } const Wee = MN; var Kee = function (n) { te(e, n); function e(t) { var r = n.call(this) || this; return r.isGroup = !0, r._children = [], r.attr(t), r } return e.prototype.childrenRef = function () { return this._children }, e.prototype.children = function () { return this._children.slice() }, e.prototype.childAt = function (t) { return this._children[t] }, e.prototype.childOfName = function (t) { for (var r = this._children, i = 0; i < r.length; i++)if (r[i].name === t) return r[i] }, e.prototype.childCount = function () { return this._children.length }, e.prototype.add = function (t) { return t && t !== this && t.parent !== this && (this._children.push(t), this._doAdd(t)), this }, e.prototype.addBefore = function (t, r) { if (t && t !== this && t.parent !== this && r && r.parent === this) { var i = this._children, a = i.indexOf(r); a >= 0 && (i.splice(a, 0, t), this._doAdd(t)) } return this }, e.prototype.replace = function (t, r) { var i = Et(this._children, t); return i >= 0 && this.replaceAt(r, i), this }, e.prototype.replaceAt = function (t, r) { var i = this._children, a = i[r]; if (t && t !== this && t.parent !== this && t !== a) { i[r] = t, a.parent = null; var o = this.__zr; o && a.removeSelfFromZr(o), this._doAdd(t) } return this }, e.prototype._doAdd = function (t) { t.parent && t.parent.remove(t), t.parent = this; var r = this.__zr; r && r !== t.__zr && t.addSelfToZr(r), r && r.refresh() }, e.prototype.remove = function (t) { var r = this.__zr, i = this._children, a = Et(i, t); return a < 0 ? this : (i.splice(a, 1), t.parent = null, r && t.removeSelfFromZr(r), r && r.refresh(), this) }, e.prototype.removeAll = function () { for (var t = this._children, r = this.__zr, i = 0; i < t.length; i++) { var a = t[i]; r && a.removeSelfFromZr(r), a.parent = null } return t.length = 0, this }, e.prototype.eachChild = function (t, r) { for (var i = this._children, a = 0; a < i.length; a++) { var o = i[a]; t.call(r, o, a) } return this }, e.prototype.traverse = function (t, r) { for (var i = 0; i < this._children.length; i++) { var a = this._children[i], o = t.call(r, a); a.isGroup && !o && a.traverse(t, r) } return this }, e.prototype.addSelfToZr = function (t) { n.prototype.addSelfToZr.call(this, t); for (var r = 0; r < this._children.length; r++) { var i = this._children[r]; i.addSelfToZr(t) } }, e.prototype.removeSelfFromZr = function (t) { n.prototype.removeSelfFromZr.call(this, t); for (var r = 0; r < this._children.length; r++) { var i = this._children[r]; i.removeSelfFromZr(t) } }, e.prototype.getBoundingRect = function (t) { for (var r = new kt(0, 0, 0, 0), i = t || this._children, a = [], o = null, s = 0; s < i.length; s++) { var l = i[s]; if (!(l.ignore || l.invisible)) { var c = l.getBoundingRect(), u = l.getLocalTransform(a); u ? (kt.applyTransform(r, c, u), o = o || r.clone(), o.union(r)) : (o = o || c.clone(), o.union(c)) } } return o || r }, e }(Wee); Kee.prototype.type = "group"; const ft = Kee;/*!
* ZRender, a high performance 2d drawing library.
*
* Copyright (c) 2013, Baidu Inc.
* All rights reserved.
*
* LICENSE
* https://github.com/ecomfe/zrender/blob/master/LICENSE.txt
*/var eS = {}, qee = {}; function yFe(n) { delete qee[n] } function _Fe(n) { if (!n) return !1; if (typeof n == "string") return W2(n, 1) < FP; if (n.colorStops) { for (var e = n.colorStops, t = 0, r = e.length, i = 0; i < r; i++)t += W2(e[i].color, 1); return t /= r, t < FP } return !1 } var bFe = function () { function n(e, t, r) { var i = this; this._sleepAfterStill = 10, this._stillFrameAccum = 0, this._needsRefresh = !0, this._needsRefreshHover = !0, this._darkMode = !1, r = r || {}, this.dom = t, this.id = e; var a = new O$e, o = r.renderer || "canvas"; eS[o] || (o = Bt(eS)[0]), r.useDirtyRect = r.useDirtyRect == null ? !1 : r.useDirtyRect; var s = new eS[o](t, a, r, e), l = r.ssr || s.ssrOnly; this.storage = a, this.painter = s; var c = !en.node && !en.worker && !l ? new cFe(s.getViewportRoot(), s.root) : null, u = r.useCoarsePointer, d = u == null || u === "auto" ? en.touchEventsSupported : !!u, f = 44, h; d && (h = yt(r.pointerSize, f)), this.handler = new k$e(a, s, c, s.root, h), this.animation = new tFe({ stage: { update: l ? null : function () { return i._flush(!0) } } }), l || this.animation.start() } return n.prototype.add = function (e) { this._disposed || !e || (this.storage.addRoot(e), e.addSelfToZr(this), this.refresh()) }, n.prototype.remove = function (e) { this._disposed || !e || (this.storage.delRoot(e), e.removeSelfFromZr(this), this.refresh()) }, n.prototype.configLayer = function (e, t) { this._disposed || (this.painter.configLayer && this.painter.configLayer(e, t), this.refresh()) }, n.prototype.setBackgroundColor = function (e) { this._disposed || (this.painter.setBackgroundColor && this.painter.setBackgroundColor(e), this.refresh(), this._backgroundColor = e, this._darkMode = _Fe(e)) }, n.prototype.getBackgroundColor = function () { return this._backgroundColor }, n.prototype.setDarkMode = function (e) { this._darkMode = e }, n.prototype.isDarkMode = function () { return this._darkMode }, n.prototype.refreshImmediately = function (e) { this._disposed || (e || this.animation.update(!0), this._needsRefresh = !1, this.painter.refresh(), this._needsRefresh = !1) }, n.prototype.refresh = function () { this._disposed || (this._needsRefresh = !0, this.animation.start()) }, n.prototype.flush = function () { this._disposed || this._flush(!1) }, n.prototype._flush = function (e) { var t, r = jm(); this._needsRefresh && (t = !0, this.refreshImmediately(e)), this._needsRefreshHover && (t = !0, this.refreshHoverImmediately()); var i = jm(); t ? (this._stillFrameAccum = 0, this.trigger("rendered", { elapsedTime: i - r })) : this._sleepAfterStill > 0 && (this._stillFrameAccum++, this._stillFrameAccum > this._sleepAfterStill && this.animation.stop()) }, n.prototype.setSleepAfterStill = function (e) { this._sleepAfterStill = e }, n.prototype.wakeUp = function () { this._disposed || (this.animation.start(), this._stillFrameAccum = 0) }, n.prototype.refreshHover = function () { this._needsRefreshHover = !0 }, n.prototype.refreshHoverImmediately = function () { this._disposed || (this._needsRefreshHover = !1, this.painter.refreshHover && this.painter.getType() === "canvas" && this.painter.refreshHover()) }, n.prototype.resize = function (e) { this._disposed || (e = e || {}, this.painter.resize(e.width, e.height), this.handler.resize()) }, n.prototype.clearAnimation = function () { this._disposed || this.animation.clear() }, n.prototype.getWidth = function () { if (!this._disposed) return this.painter.getWidth() }, n.prototype.getHeight = function () { if (!this._disposed) return this.painter.getHeight() }, n.prototype.setCursorStyle = function (e) { this._disposed || this.handler.setCursorStyle(e) }, n.prototype.findHover = function (e, t) { if (!this._disposed) return this.handler.findHover(e, t) }, n.prototype.on = function (e, t, r) { return this._disposed || this.handler.on(e, t, r), this }, n.prototype.off = function (e, t) { this._disposed || this.handler.off(e, t) }, n.prototype.trigger = function (e, t) { this._disposed || this.handler.trigger(e, t) }, n.prototype.clear = function () { if (!this._disposed) { for (var e = this.storage.getRoots(), t = 0; t < e.length; t++)e[t] instanceof ft && e[t].removeSelfFromZr(this); this.storage.delAllRoots(), this.painter.clear() } }, n.prototype.dispose = function () { this._disposed || (this.animation.stop(), this.clear(), this.storage.dispose(), this.painter.dispose(), this.handler.dispose(), this.animation = this.storage = this.painter = this.handler = null, this._disposed = !0, yFe(this.id)) }, n }(); function X6(n, e) { var t = new bFe(gee(), n, e); return qee[t.id] = t, t } function wFe(n, e) { eS[n] = e } var HP; function xFe(n) { if (typeof HP == "function") return HP(n) } function SFe(n) { HP = n } var J6 = 1e-4, Yee = 20; function TFe(n) { return n.replace(/^\s+|\s+$/g, "") } function vn(n, e, t, r) { var i = e[0], a = e[1], o = t[0], s = t[1], l = a - i, c = s - o; if (l === 0) return c === 0 ? o : (o + s) / 2; if (r) if (l > 0) { if (n <= i) return o; if (n >= a) return s } else { if (n >= i) return o; if (n <= a) return s } else { if (n === i) return o; if (n === a) return s } return (n - i) / l * c + o } function Ne(n, e) { switch (n) { case "center": case "middle": n = "50%"; break; case "left": case "top": n = "0%"; break; case "right": case "bottom": n = "100%"; break }return Fe(n) ? TFe(n).match(/%$/) ? parseFloat(n) / 100 * e : parseFloat(n) : n == null ? NaN : +n } function lr(n, e, t) { return e == null && (e = 10), e = Math.min(Math.max(0, e), Yee), n = (+n).toFixed(e), t ? n : +n } function Oo(n) { return n.sort(function (e, t) { return e - t }), n } function ol(n) { if (n = +n, isNaN(n)) return 0; if (n > 1e-14) { for (var e = 1, t = 0; t < 15; t++, e *= 10)if (Math.round(n * e) / e === n) return t } return kFe(n) } function kFe(n) { var e = n.toString().toLowerCase(), t = e.indexOf("e"), r = t > 0 ? +e.slice(t + 1) : 0, i = t > 0 ? t : e.length, a = e.indexOf("."), o = a < 0 ? 0 : i - 1 - a; return Math.max(0, o - r) } function Zee(n, e) { var t = Math.log, r = Math.LN10, i = Math.floor(t(n[1] - n[0]) / r), a = Math.round(t(Math.abs(e[1] - e[0])) / r), o = Math.min(Math.max(-i + a, 0), 20); return isFinite(o) ? o : 20 } function CFe(n, e) { var t = xl(n, function (h, p) { return h + (isNaN(p) ? 0 : p) }, 0); if (t === 0) return []; for (var r = Math.pow(10, e), i = Ae(n, function (h) { return (isNaN(h) ? 0 : h) / t * r * 100 }), a = r * 100, o = Ae(i, function (h) { return Math.floor(h) }), s = xl(o, function (h, p) { return h + p }, 0), l = Ae(i, function (h, p) { return h - o[p] }); s < a;) { for (var c = Number.NEGATIVE_INFINITY, u = null, d = 0, f = l.length; d < f; ++d)l[d] > c && (c = l[d], u = d); ++o[u], l[u] = 0, ++s } return Ae(o, function (h) { return h / r }) } function AFe(n, e) { var t = Math.max(ol(n), ol(e)), r = n + e; return t > Yee ? r : lr(r, t) } var Q6 = 9007199254740991; function Xee(n) { var e = Math.PI * 2; return (n % e + e) % e } function p_(n) { return n > -J6 && n < J6 } var EFe = /^(?:(\d{4})(?:[-\/](\d{1,2})(?:[-\/](\d{1,2})(?:[T ](\d{1,2})(?::(\d{1,2})(?::(\d{1,2})(?:[.,](\d+))?)?)?(Z|[\+\-]\d\d:?\d\d)?)?)?)?)?$/; function kl(n) { if (n instanceof Date) return n; if (Fe(n)) { var e = EFe.exec(n); if (!e) return new Date(NaN); if (e[8]) { var t = +e[4] || 0; return e[8].toUpperCase() !== "Z" && (t -= +e[8].slice(0, 3)), new Date(Date.UTC(+e[1], +(e[2] || 1) - 1, +e[3] || 1, t, +(e[5] || 0), +e[6] || 0, e[7] ? +e[7].substring(0, 3) : 0)) } else return new Date(+e[1], +(e[2] || 1) - 1, +e[3] || 1, +e[4] || 0, +(e[5] || 0), +e[6] || 0, e[7] ? +e[7].substring(0, 3) : 0) } else if (n == null) return new Date(NaN); return new Date(Math.round(n)) } function MFe(n) { return Math.pow(10, ON(n)) } function ON(n) { if (n === 0) return 0; var e = Math.floor(Math.log(n) / Math.LN10); return n / Math.pow(10, e) >= 10 && e++, e } function Jee(n, e) { var t = ON(n), r = Math.pow(10, t), i = n / r, a; return e ? i < 1.5 ? a = 1 : i < 2.5 ? a = 2 : i < 4 ? a = 3 : i < 7 ? a = 5 : a = 10 : i < 1 ? a = 1 : i < 2 ? a = 2 : i < 3 ? a = 3 : i < 5 ? a = 5 : a = 10, n = a * r, t >= -20 ? +n.toFixed(t < 0 ? -t : 0) : n } function SM(n, e) { var t = (n.length - 1) * e + 1, r = Math.floor(t), i = +n[r - 1], a = t - r; return a ? i + a * (n[r] - i) : i } function eV(n) { n.sort(function (l, c) { return s(l, c, 0) ? -1 : 1 }); for (var e = -1 / 0, t = 1, r = 0; r < n.length;) { for (var i = n[r].interval, a = n[r].close, o = 0; o < 2; o++)i[o] <= e && (i[o] = e, a[o] = o ? 1 : 1 - t), e = i[o], t = a[o]; i[0] === i[1] && a[0] * a[1] !== 1 ? n.splice(r, 1) : r++ } return n; function s(l, c, u) { return l.interval[u] < c.interval[u] || l.interval[u] === c.interval[u] && (l.close[u] - c.close[u] === (u ? -1 : 1) || !u && s(l, c, 1)) } } function jc(n) { var e = parseFloat(n); return e == n && (e !== 0 || !Fe(n) || n.indexOf("x") <= 0) ? e : NaN } function Qee(n) { return !isNaN(jc(n)) } function ete() { return Math.round(Math.random() * 9) } function tte(n, e) { return e === 0 ? n : tte(e, n % e) } function tV(n, e) { return n == null ? e : e == null ? n : n * e / tte(n, e) } function hn(n) { throw new Error(n) } function nV(n, e, t) { return (e - n) * t + n } var nte = "series\0", rte = "\0_ec_\0"; function Cn(n) { return n instanceof Array ? n : n == null ? [] : [n] } function Vh(n, e, t) { if (n) { n[e] = n[e] || {}, n.emphasis = n.emphasis || {}, n.emphasis[e] = n.emphasis[e] || {}; for (var r = 0, i = t.length; r < i; r++) { var a = t[r]; !n.emphasis[e].hasOwnProperty(a) && n[e].hasOwnProperty(a) && (n.emphasis[e][a] = n[e][a]) } } } var rV = ["fontStyle", "fontWeight", "fontSize", "fontFamily", "rich", "tag", "color", "textBorderColor", "textBorderWidth", "width", "height", "lineHeight", "align", "verticalAlign", "baseline", "shadowColor", "shadowBlur", "shadowOffsetX", "shadowOffsetY", "textShadowColor", "textShadowBlur", "textShadowOffsetX", "textShadowOffsetY", "backgroundColor", "borderColor", "borderWidth", "borderRadius", "padding"]; function Yg(n) { return ot(n) && !ke(n) && !(n instanceof Date) ? n.value : n } function OFe(n) { return ot(n) && !(n instanceof Array) } function ite(n, e, t) { var r = t === "normalMerge", i = t === "replaceMerge", a = t === "replaceAll"; n = n || [], e = (e || []).slice(); var o = Ze(); $(e, function (l, c) { if (!ot(l)) { e[c] = null; return } }); var s = DFe(n, o, t); return (r || i) && jFe(s, n, o, e), r && PFe(s, e), r || i ? IFe(s, e, i) : a && LFe(s, e), RFe(s), s } function DFe(n, e, t) { var r = []; if (t === "replaceAll") return r; for (var i = 0; i < n.length; i++) { var a = n[i]; a && a.id != null && e.set(a.id, i), r.push({ existing: t === "replaceMerge" || m_(a) ? null : a, newOption: null, keyInfo: null, brandNew: null }) } return r } function jFe(n, e, t, r) { $(r, function (i, a) { if (!(!i || i.id == null)) { var o = f0(i.id), s = t.get(o); if (s != null) { var l = n[s]; na(!l.newOption, 'Duplicated option on id "' + o + '".'), l.newOption = i, l.existing = e[s], r[a] = null } } }) } function PFe(n, e) { $(e, function (t, r) { if (!(!t || t.name == null)) for (var i = 0; i < n.length; i++) { var a = n[i].existing; if (!n[i].newOption && a && (a.id == null || t.id == null) && !m_(t) && !m_(a) && ate("name", a, t)) { n[i].newOption = t, e[r] = null; return } } }) } function IFe(n, e, t) { $(e, function (r) { if (r) { for (var i, a = 0; (i = n[a]) && (i.newOption || m_(i.existing) || i.existing && r.id != null && !ate("id", r, i.existing));)a++; i ? (i.newOption = r, i.brandNew = t) : n.push({ newOption: r, brandNew: t, existing: null, keyInfo: null }), a++ } }) } function LFe(n, e) { $(e, function (t) { n.push({ newOption: t, brandNew: !0, existing: null, keyInfo: null }) }) } function RFe(n) { var e = Ze(); $(n, function (t) { var r = t.existing; r && e.set(r.id, t) }), $(n, function (t) { var r = t.newOption; na(!r || r.id == null || !e.get(r.id) || e.get(r.id) === t, "id duplicates: " + (r && r.id)), r && r.id != null && e.set(r.id, t), !t.keyInfo && (t.keyInfo = {}) }), $(n, function (t, r) { var i = t.existing, a = t.newOption, o = t.keyInfo; if (ot(a)) { if (o.name = a.name != null ? f0(a.name) : i ? i.name : nte + r, i) o.id = f0(i.id); else if (a.id != null) o.id = f0(a.id); else { var s = 0; do o.id = "\0" + o.name + "\0" + s++; while (e.get(o.id)) } e.set(o.id, t) } }) } function ate(n, e, t) { var r = Er(e[n], null), i = Er(t[n], null); return r != null && i != null && r === i } function f0(n) { return Er(n, "") } function Er(n, e) { return n == null ? e : Fe(n) ? n : nn(n) || bP(n) ? n + "" : e } function DN(n) { var e = n.name; return !!(e && e.indexOf(nte)) } function m_(n) { return n && n.id != null && f0(n.id).indexOf(rte) === 0 } function NFe(n) { return rte + n } function BFe(n, e, t) { $(n, function (r) { var i = r.newOption; ot(i) && (r.keyInfo.mainType = e, r.keyInfo.subType = $Fe(e, i, r.existing, t)) }) } function $Fe(n, e, t, r) { var i = e.type ? e.type : t ? t.subType : r.determineSubType(n, e); return i } function FFe(n, e) { var t = {}, r = {}; return i(n || [], t), i(e || [], r, t), [a(t), a(r)]; function i(o, s, l) { for (var c = 0, u = o.length; c < u; c++) { var d = Er(o[c].seriesId, null); if (d == null) return; for (var f = Cn(o[c].dataIndex), h = l && l[d], p = 0, m = f.length; p < m; p++) { var g = f[p]; h && h[g] ? h[g] = null : (s[d] || (s[d] = {}))[g] = 1 } } } function a(o, s) { var l = []; for (var c in o) if (o.hasOwnProperty(c) && o[c] != null) if (s) l.push(+c); else { var u = a(o[c], !0); u.length && l.push({ seriesId: c, dataIndex: u }) } return l } } function Hh(n, e) { if (e.dataIndexInside != null) return e.dataIndexInside; if (e.dataIndex != null) return ke(e.dataIndex) ? Ae(e.dataIndex, function (t) { return n.indexOfRawIndex(t) }) : n.indexOfRawIndex(e.dataIndex); if (e.name != null) return ke(e.name) ? Ae(e.name, function (t) { return n.indexOfName(t) }) : n.indexOfName(e.name) } function Kt() { var n = "__ec_inner_" + zFe++; return function (e) { return e[n] || (e[n] = {}) } } var zFe = ete(); function h0(n, e, t) { var r = jN(e, t), i = r.mainTypeSpecified, a = r.queryOptionMap, o = r.others, s = o, l = t ? t.defaultMainType : null; return !i && l && a.set(l, {}), a.each(function (c, u) { var d = wb(n, u, c, { useDefault: l === u, enableAll: t && t.enableAll != null ? t.enableAll : !0, enableNone: t && t.enableNone != null ? t.enableNone : !0 }); s[u + "Models"] = d.models, s[u + "Model"] = d.models[0] }), s } function jN(n, e) { var t; if (Fe(n)) { var r = {}; r[n + "Index"] = 0, t = r } else t = n; var i = Ze(), a = {}, o = !1; return $(t, function (s, l) { if (l === "dataIndex" || l === "dataIndexInside") { a[l] = s; return } var c = l.match(/^(\w+)(Index|Id|Name)$/) || [], u = c[1], d = (c[2] || "").toLowerCase(); if (!(!u || !d || e && e.includeMainTypes && Et(e.includeMainTypes, u) < 0)) { o = o || !!u; var f = i.get(u) || i.set(u, {}); f[d] = s } }), { mainTypeSpecified: o, queryOptionMap: i, others: a } } var xr = { useDefault: !0, enableAll: !1, enableNone: !1 }, VFe = { useDefault: !1, enableAll: !0, enableNone: !0 }; function wb(n, e, t, r) { r = r || xr; var i = t.index, a = t.id, o = t.name, s = { models: null, specified: i != null || a != null || o != null }; if (!s.specified) { var l = void 0; return s.models = r.useDefault && (l = n.getComponent(e)) ? [l] : [], s } return i === "none" || i === !1 ? (na(r.enableNone, '`"none"` or `false` is not a valid value on index option.'), s.models = [], s) : (i === "all" && (na(r.enableAll, '`"all"` is not a valid value on index option.'), i = a = o = null), s.models = n.queryComponents({ mainType: e, index: i, id: a, name: o }), s) } function ote(n, e, t) { n.setAttribute ? n.setAttribute(e, t) : n[e] = t } function HFe(n, e) { return n.getAttribute ? n.getAttribute(e) : n[e] } function UFe(n) { return n === "auto" ? en.domSupported ? "html" : "richText" : n || "html" } function UP(n, e) { var t = Ze(), r = []; return $(n, function (i) { var a = e(i); (t.get(a) || (r.push(a), t.set(a, []))).push(i) }), { keys: r, buckets: t } } function ste(n, e, t, r, i) { var a = e == null || e === "auto"; if (r == null) return r; if (nn(r)) { var o = nV(t || 0, r, i); return lr(o, a ? Math.max(ol(t || 0), ol(r)) : e) } else { if (Fe(r)) return i < 1 ? t : r; for (var s = [], l = t, c = r, u = Math.max(l ? l.length : 0, c.length), d = 0; d < u; ++d) { var f = n.getDimensionInfo(d); if (f && f.type === "ordinal") s[d] = (i < 1 && l ? l : c)[d]; else { var h = l && l[d] ? l[d] : 0, p = c[d], o = nV(h, p, i); s[d] = lr(o, a ? Math.max(ol(h), ol(p)) : e) } } return s } } var GFe = ".", mf = "___EC__COMPONENT__CONTAINER___", lte = "___EC__EXTENDED_CLASS___"; function sl(n) { var e = { main: "", sub: "" }; if (n) { var t = n.split(GFe); e.main = t[0] || "", e.sub = t[1] || "" } return e } function WFe(n) { na(/^[a-zA-Z0-9_]+([.][a-zA-Z0-9_]+)?$/.test(n), 'componentType "' + n + '" illegal') } function KFe(n) { return !!(n && n[lte]) } function PN(n, e) { n.$constructor = n, n.extend = function (t) { var r = this, i; return qFe(r) ? i = function (a) { te(o, a); function o() { return a.apply(this, arguments) || this } return o }(r) : (i = function () { (t.$constructor || r).apply(this, arguments) }, G4e(i, this)), be(i.prototype, t), i[lte] = !0, i.extend = this.extend, i.superCall = XFe, i.superApply = JFe, i.superClass = r, i } } function qFe(n) { return tt(n) && /^class\s/.test(Function.prototype.toString.call(n)) } function cte(n, e) { n.extend = e.extend } var YFe = Math.round(Math.random() * 10); function ZFe(n) { var e = ["__\0is_clz", YFe++].join("_"); n.prototype[e] = !0, n.isInstance = function (t) { return !!(t && t[e]) } } function XFe(n, e) { for (var t = [], r = 2; r < arguments.length; r++)t[r - 2] = arguments[r]; return this.superClass.prototype[e].apply(n, t) } function JFe(n, e, t) { return this.superClass.prototype[e].apply(n, t) } function Xk(n) { var e = {}; n.registerClass = function (r) { var i = r.type || r.prototype.type; if (i) { WFe(i), r.prototype.type = i; var a = sl(i); if (!a.sub) e[a.main] = r; else if (a.sub !== mf) { var o = t(a); o[a.sub] = r } } return r }, n.getClass = function (r, i, a) { var o = e[r]; if (o && o[mf] && (o = i ? o[i] : null), a && !o) throw new Error(i ? "Component " + r + "." + (i || "") + " is used but not imported." : r + ".type should be specified."); return o }, n.getClassesByMainType = function (r) { var i = sl(r), a = [], o = e[i.main]; return o && o[mf] ? $(o, function (s, l) { l !== mf && a.push(s) }) : a.push(o), a }, n.hasClass = function (r) { var i = sl(r); return !!e[i.main] }, n.getAllClassMainTypes = function () { var r = []; return $(e, function (i, a) { r.push(a) }), r }, n.hasSubTypes = function (r) { var i = sl(r), a = e[i.main]; return a && a[mf] }; function t(r) { var i = e[r.main]; return (!i || !i[mf]) && (i = e[r.main] = {}, i[mf] = !0), i } } function Uh(n, e) { for (var t = 0; t < n.length; t++)n[t][1] || (n[t][1] = n[t][0]); return e = e || !1, function (r, i, a) { for (var o = {}, s = 0; s < n.length; s++) { var l = n[s][1]; if (!(i && Et(i, l) >= 0 || a && Et(a, l) < 0)) { var c = r.getShallow(l, e); c != null && (o[n[s][0]] = c) } } return o } } var QFe = [["fill", "color"], ["shadowBlur"], ["shadowOffsetX"], ["shadowOffsetY"], ["opacity"], ["shadowColor"]], eze = Uh(QFe), tze = function () { function n() { } return n.prototype.getAreaStyle = function (e, t) { return eze(this, e, t) }, n }(), GP = new _b(50); function nze(n) { if (typeof n == "string") { var e = GP.get(n); return e && e.image } else return n } function IN(n, e, t, r, i) { if (n) if (typeof n == "string") { if (e && e.__zrImageSrc === n || !t) return e; var a = GP.get(n), o = { hostEl: t, cb: r, cbPayload: i }; return a ? (e = a.image, !Jk(e) && a.pending.push(o)) : (e = kd.loadImage(n, iV, iV), e.__zrImageSrc = n, GP.put(n, e.__cachedImgObj = { image: e, pending: [o] })), e } else return n; else return e } function iV() { var n = this.__cachedImgObj; this.onload = this.onerror = this.__cachedImgObj = null; for (var e = 0; e < n.pending.length; e++) { var t = n.pending[e], r = t.cb; r && r(this, t.cbPayload), t.hostEl.dirty() } n.pending.length = 0 } function Jk(n) { return n && n.width && n.height } var TM = /\{([a-zA-Z0-9_]+)\|([^}]*)\}/g; function rze(n, e, t, r, i, a) {
  if (!t) { n.text = "", n.isTruncated = !1; return } var o = (e + "").split(`
`); a = ute(t, r, i, a); for (var s = !1, l = {}, c = 0, u = o.length; c < u; c++)dte(l, o[c], a), o[c] = l.textLine, s = s || l.isTruncated; n.text = o.join(`
`), n.isTruncated = s
} function ute(n, e, t, r) { r = r || {}; var i = be({}, r); i.font = e, t = yt(t, "..."), i.maxIterations = yt(r.maxIterations, 2); var a = i.minChar = yt(r.minChar, 0); i.cnCharWidth = Ua("", e); var o = i.ascCharWidth = Ua("a", e); i.placeholder = yt(r.placeholder, ""); for (var s = n = Math.max(0, n - 1), l = 0; l < a && s >= o; l++)s -= o; var c = Ua(t, e); return c > s && (t = "", c = 0), s = n - c, i.ellipsis = t, i.ellipsisWidth = c, i.contentWidth = s, i.containerWidth = n, i } function dte(n, e, t) { var r = t.containerWidth, i = t.font, a = t.contentWidth; if (!r) { n.textLine = "", n.isTruncated = !1; return } var o = Ua(e, i); if (o <= r) { n.textLine = e, n.isTruncated = !1; return } for (var s = 0; ; s++) { if (o <= a || s >= t.maxIterations) { e += t.ellipsis; break } var l = s === 0 ? ize(e, a, t.ascCharWidth, t.cnCharWidth) : o > 0 ? Math.floor(e.length * a / o) : 0; e = e.substr(0, l), o = Ua(e, i) } e === "" && (e = t.placeholder), n.textLine = e, n.isTruncated = !0 } function ize(n, e, t, r) { for (var i = 0, a = 0, o = n.length; a < o && i < e; a++) { var s = n.charCodeAt(a); i += 0 <= s && s <= 127 ? t : r } return a } function aze(n, e) {
  n != null && (n += ""); var t = e.overflow, r = e.padding, i = e.font, a = t === "truncate", o = Zk(i), s = yt(e.lineHeight, o), l = !!e.backgroundColor, c = e.lineOverflow === "truncate", u = !1, d = e.width, f; d != null && (t === "break" || t === "breakAll") ? f = n ? fte(n, e.font, d, t === "breakAll", 0).lines : [] : f = n ? n.split(`
`) : []; var h = f.length * s, p = yt(e.height, h); if (h > p && c) { var m = Math.floor(p / s); u = u || f.length > m, f = f.slice(0, m) } if (n && a && d != null) for (var g = ute(d, i, e.ellipsis, { minChar: e.truncateMinChar, placeholder: e.placeholder }), y = {}, b = 0; b < f.length; b++)dte(y, f[b], g), f[b] = y.textLine, u = u || y.isTruncated; for (var w = p, v = 0, b = 0; b < f.length; b++)v = Math.max(Ua(f[b], i), v); d == null && (d = v); var S = v; return r && (w += r[0] + r[2], S += r[1] + r[3], d += r[1] + r[3]), l && (S = d), { lines: f, height: p, outerWidth: S, outerHeight: w, lineHeight: s, calculatedLineHeight: o, contentWidth: v, contentHeight: h, width: d, isTruncated: u }
} var oze = function () { function n() { } return n }(), aV = function () { function n(e) { this.tokens = [], e && (this.tokens = e) } return n }(), sze = function () { function n() { this.width = 0, this.height = 0, this.contentWidth = 0, this.contentHeight = 0, this.outerWidth = 0, this.outerHeight = 0, this.lines = [], this.isTruncated = !1 } return n }(); function lze(n, e) { var t = new sze; if (n != null && (n += ""), !n) return t; for (var r = e.width, i = e.height, a = e.overflow, o = (a === "break" || a === "breakAll") && r != null ? { width: r, accumWidth: 0, breakAll: a === "breakAll" } : null, s = TM.lastIndex = 0, l; (l = TM.exec(n)) != null;) { var c = l.index; c > s && kM(t, n.substring(s, c), e, o), kM(t, l[2], e, o, l[1]), s = TM.lastIndex } s < n.length && kM(t, n.substring(s, n.length), e, o); var u = [], d = 0, f = 0, h = e.padding, p = a === "truncate", m = e.lineOverflow === "truncate", g = {}; function y(K, V, W) { K.width = V, K.lineHeight = W, d += W, f = Math.max(f, V) } e: for (var b = 0; b < t.lines.length; b++) { for (var w = t.lines[b], v = 0, S = 0, x = 0; x < w.tokens.length; x++) { var k = w.tokens[x], A = k.styleName && e.rich[k.styleName] || {}, C = k.textPadding = A.padding, E = C ? C[1] + C[3] : 0, O = k.font = A.font || e.font; k.contentHeight = Zk(O); var j = yt(A.height, k.contentHeight); if (k.innerHeight = j, C && (j += C[0] + C[2]), k.height = j, k.lineHeight = pl(A.lineHeight, e.lineHeight, j), k.align = A && A.align || e.align, k.verticalAlign = A && A.verticalAlign || "middle", m && i != null && d + k.lineHeight > i) { var I = t.lines.length; x > 0 ? (w.tokens = w.tokens.slice(0, x), y(w, S, v), t.lines = t.lines.slice(0, b + 1)) : t.lines = t.lines.slice(0, b), t.isTruncated = t.isTruncated || t.lines.length < I; break e } var L = A.width, R = L == null || L === "auto"; if (typeof L == "string" && L.charAt(L.length - 1) === "%") k.percentWidth = L, u.push(k), k.contentWidth = Ua(k.text, O); else { if (R) { var D = A.backgroundColor, P = D && D.image; P && (P = nze(P), Jk(P) && (k.width = Math.max(k.width, P.width * j / P.height))) } var B = p && r != null ? r - S : null; B != null && B < k.width ? !R || B < E ? (k.text = "", k.width = k.contentWidth = 0) : (rze(g, k.text, B - E, O, e.ellipsis, { minChar: e.truncateMinChar }), k.text = g.text, t.isTruncated = t.isTruncated || g.isTruncated, k.width = k.contentWidth = Ua(k.text, O)) : k.contentWidth = Ua(k.text, O) } k.width += E, S += k.width, A && (v = Math.max(v, k.lineHeight)) } y(w, S, v) } t.outerWidth = t.width = yt(r, f), t.outerHeight = t.height = yt(i, d), t.contentHeight = d, t.contentWidth = f, h && (t.outerWidth += h[1] + h[3], t.outerHeight += h[0] + h[2]); for (var b = 0; b < u.length; b++) { var k = u[b], F = k.percentWidth; k.width = parseInt(F, 10) / 100 * t.width } return t } function kM(n, e, t, r, i) {
  var a = e === "", o = i && t.rich[i] || {}, s = n.lines, l = o.font || t.font, c = !1, u, d; if (r) {
    var f = o.padding, h = f ? f[1] + f[3] : 0; if (o.width != null && o.width !== "auto") {
      var p = Es(o.width, r.width) + h; s.length > 0 && p + r.accumWidth > r.width && (u = e.split(`
`), c = !0), r.accumWidth = p
    } else { var m = fte(e, l, r.width, r.breakAll, r.accumWidth); r.accumWidth = m.accumWidth + h, d = m.linesWidths, u = m.lines }
  } else u = e.split(`
`); for (var g = 0; g < u.length; g++) { var y = u[g], b = new oze; if (b.styleName = i, b.text = y, b.isLineHolder = !y && !a, typeof o.width == "number" ? b.width = o.width : b.width = d ? d[g] : Ua(y, l), !g && !c) { var w = (s[s.length - 1] || (s[0] = new aV)).tokens, v = w.length; v === 1 && w[0].isLineHolder ? w[0] = b : (y || !v || a) && w.push(b) } else s.push(new aV([b])) }
} function cze(n) { var e = n.charCodeAt(0); return e >= 32 && e <= 591 || e >= 880 && e <= 4351 || e >= 4608 && e <= 5119 || e >= 7680 && e <= 8303 } var uze = xl(",&?/;] ".split(""), function (n, e) { return n[e] = !0, n }, {}); function dze(n) { return cze(n) ? !!uze[n] : !0 } function fte(n, e, t, r, i) {
  for (var a = [], o = [], s = "", l = "", c = 0, u = 0, d = 0; d < n.length; d++) {
    var f = n.charAt(d); if (f === `
`) { l && (s += l, u += c), a.push(s), o.push(u), s = "", l = "", c = 0, u = 0; continue } var h = Ua(f, e), p = r ? !1 : !dze(f); if (a.length ? u + h > t : i + u + h > t) { u ? (s || l) && (p ? (s || (s = l, l = "", c = 0, u = c), a.push(s), o.push(u - c), l += f, c += h, s = "", u = c) : (l && (s += l, l = "", c = 0), a.push(s), o.push(u), s = f, u = h)) : p ? (a.push(l), o.push(c), l = f, c = h) : (a.push(f), o.push(h)); continue } u += h, p ? (l += f, c += h) : (l && (s += l, l = "", c = 0), s += f)
  } return !a.length && !s && (s = n, l = "", c = 0), l && (s += l), s && (a.push(s), o.push(u)), a.length === 1 && (u += i), { accumWidth: u, lines: a, linesWidths: o }
} var WP = "__zr_style_" + Math.round(Math.random() * 10), xh = { shadowBlur: 0, shadowOffsetX: 0, shadowOffsetY: 0, shadowColor: "#000", opacity: 1, blend: "source-over" }, Qk = { style: { shadowBlur: !0, shadowOffsetX: !0, shadowOffsetY: !0, shadowColor: !0, opacity: !0 } }; xh[WP] = !0; var oV = ["z", "z2", "invisible"], fze = ["invisible"], hze = function (n) { te(e, n); function e(t) { return n.call(this, t) || this } return e.prototype._init = function (t) { for (var r = Bt(t), i = 0; i < r.length; i++) { var a = r[i]; a === "style" ? this.useStyle(t[a]) : n.prototype.attrKV.call(this, a, t[a]) } this.style || this.useStyle({}) }, e.prototype.beforeBrush = function () { }, e.prototype.afterBrush = function () { }, e.prototype.innerBeforeBrush = function () { }, e.prototype.innerAfterBrush = function () { }, e.prototype.shouldBePainted = function (t, r, i, a) { var o = this.transform; if (this.ignore || this.invisible || this.style.opacity === 0 || this.culling && pze(this, t, r) || o && !o[0] && !o[3]) return !1; if (i && this.__clipPaths) { for (var s = 0; s < this.__clipPaths.length; ++s)if (this.__clipPaths[s].isZeroArea()) return !1 } if (a && this.parent) for (var l = this.parent; l;) { if (l.ignore) return !1; l = l.parent } return !0 }, e.prototype.contain = function (t, r) { return this.rectContain(t, r) }, e.prototype.traverse = function (t, r) { t.call(r, this) }, e.prototype.rectContain = function (t, r) { var i = this.transformCoordToLocal(t, r), a = this.getBoundingRect(); return a.contain(i[0], i[1]) }, e.prototype.getPaintRect = function () { var t = this._paintRect; if (!this._paintRect || this.__dirty) { var r = this.transform, i = this.getBoundingRect(), a = this.style, o = a.shadowBlur || 0, s = a.shadowOffsetX || 0, l = a.shadowOffsetY || 0; t = this._paintRect || (this._paintRect = new kt(0, 0, 0, 0)), r ? kt.applyTransform(t, i, r) : t.copy(i), (o || s || l) && (t.width += o * 2 + Math.abs(s), t.height += o * 2 + Math.abs(l), t.x = Math.min(t.x, t.x + s - o), t.y = Math.min(t.y, t.y + l - o)); var c = this.dirtyRectTolerance; t.isZero() || (t.x = Math.floor(t.x - c), t.y = Math.floor(t.y - c), t.width = Math.ceil(t.width + 1 + c * 2), t.height = Math.ceil(t.height + 1 + c * 2)) } return t }, e.prototype.setPrevPaintRect = function (t) { t ? (this._prevPaintRect = this._prevPaintRect || new kt(0, 0, 0, 0), this._prevPaintRect.copy(t)) : this._prevPaintRect = null }, e.prototype.getPrevPaintRect = function () { return this._prevPaintRect }, e.prototype.animateStyle = function (t) { return this.animate("style", t) }, e.prototype.updateDuringAnimation = function (t) { t === "style" ? this.dirtyStyle() : this.markRedraw() }, e.prototype.attrKV = function (t, r) { t !== "style" ? n.prototype.attrKV.call(this, t, r) : this.style ? this.setStyle(r) : this.useStyle(r) }, e.prototype.setStyle = function (t, r) { return typeof t == "string" ? this.style[t] = r : be(this.style, t), this.dirtyStyle(), this }, e.prototype.dirtyStyle = function (t) { t || this.markRedraw(), this.__dirty |= Sy, this._rect && (this._rect = null) }, e.prototype.dirty = function () { this.dirtyStyle() }, e.prototype.styleChanged = function () { return !!(this.__dirty & Sy) }, e.prototype.styleUpdated = function () { this.__dirty &= ~Sy }, e.prototype.createStyle = function (t) { return Kk(xh, t) }, e.prototype.useStyle = function (t) { t[WP] || (t = this.createStyle(t)), this.__inHover ? this.__hoverStyle = t : this.style = t, this.dirtyStyle() }, e.prototype.isStyleObject = function (t) { return t[WP] }, e.prototype._innerSaveToNormal = function (t) { n.prototype._innerSaveToNormal.call(this, t); var r = this._normalState; t.style && !r.style && (r.style = this._mergeStyle(this.createStyle(), this.style)), this._savePrimaryToNormal(t, r, oV) }, e.prototype._applyStateObj = function (t, r, i, a, o, s) { n.prototype._applyStateObj.call(this, t, r, i, a, o, s); var l = !(r && a), c; if (r && r.style ? o ? a ? c = r.style : (c = this._mergeStyle(this.createStyle(), i.style), this._mergeStyle(c, r.style)) : (c = this._mergeStyle(this.createStyle(), a ? this.style : i.style), this._mergeStyle(c, r.style)) : l && (c = i.style), c) if (o) { var u = this.style; if (this.style = this.createStyle(l ? {} : u), l) for (var d = Bt(u), f = 0; f < d.length; f++) { var h = d[f]; h in c && (c[h] = c[h], this.style[h] = u[h]) } for (var p = Bt(c), f = 0; f < p.length; f++) { var h = p[f]; this.style[h] = this.style[h] } this._transitionState(t, { style: c }, s, this.getAnimationStyleProps()) } else this.useStyle(c); for (var m = this.__inHover ? fze : oV, f = 0; f < m.length; f++) { var h = m[f]; r && r[h] != null ? this[h] = r[h] : l && i[h] != null && (this[h] = i[h]) } }, e.prototype._mergeStates = function (t) { for (var r = n.prototype._mergeStates.call(this, t), i, a = 0; a < t.length; a++) { var o = t[a]; o.style && (i = i || {}, this._mergeStyle(i, o.style)) } return i && (r.style = i), r }, e.prototype._mergeStyle = function (t, r) { return be(t, r), t }, e.prototype.getAnimationStyleProps = function () { return Qk }, e.initDefaultProps = function () { var t = e.prototype; t.type = "displayable", t.invisible = !1, t.z = 0, t.z2 = 0, t.zlevel = 0, t.culling = !1, t.cursor = "pointer", t.rectHover = !1, t.incremental = !1, t._rect = null, t.dirtyRectTolerance = 0, t.__dirty = Ba | Sy }(), e }(Wee), CM = new kt(0, 0, 0, 0), AM = new kt(0, 0, 0, 0); function pze(n, e, t) { return CM.copy(n.getBoundingRect()), n.transform && CM.applyTransform(n.transform), AM.width = e, AM.height = t, !CM.intersect(AM) } const Ho = hze; var va = Math.min, ya = Math.max, EM = Math.sin, MM = Math.cos, gf = Math.PI * 2, Pw = np(), Iw = np(), Lw = np(); function eC(n, e, t) { if (n.length !== 0) { for (var r = n[0], i = r[0], a = r[0], o = r[1], s = r[1], l = 1; l < n.length; l++)r = n[l], i = va(i, r[0]), a = ya(a, r[0]), o = va(o, r[1]), s = ya(s, r[1]); e[0] = i, e[1] = o, t[0] = a, t[1] = s } } function sV(n, e, t, r, i, a) { i[0] = va(n, t), i[1] = va(e, r), a[0] = ya(n, t), a[1] = ya(e, r) } var lV = [], cV = []; function mze(n, e, t, r, i, a, o, s, l, c) { var u = Mee, d = Nr, f = u(n, t, i, o, lV); l[0] = 1 / 0, l[1] = 1 / 0, c[0] = -1 / 0, c[1] = -1 / 0; for (var h = 0; h < f; h++) { var p = d(n, t, i, o, lV[h]); l[0] = va(p, l[0]), c[0] = ya(p, c[0]) } f = u(e, r, a, s, cV); for (var h = 0; h < f; h++) { var m = d(e, r, a, s, cV[h]); l[1] = va(m, l[1]), c[1] = ya(m, c[1]) } l[0] = va(n, l[0]), c[0] = ya(n, c[0]), l[0] = va(o, l[0]), c[0] = ya(o, c[0]), l[1] = va(e, l[1]), c[1] = ya(e, c[1]), l[1] = va(s, l[1]), c[1] = ya(s, c[1]) } function gze(n, e, t, r, i, a, o, s) { var l = Dee, c = qr, u = ya(va(l(n, t, i), 1), 0), d = ya(va(l(e, r, a), 1), 0), f = c(n, t, i, u), h = c(e, r, a, d); o[0] = va(n, i, f), o[1] = va(e, a, h), s[0] = ya(n, i, f), s[1] = ya(e, a, h) } function vze(n, e, t, r, i, a, o, s, l) { var c = Uu, u = Gu, d = Math.abs(i - a); if (d % gf < 1e-4 && d > 1e-4) { s[0] = n - t, s[1] = e - r, l[0] = n + t, l[1] = e + r; return } if (Pw[0] = MM(i) * t + n, Pw[1] = EM(i) * r + e, Iw[0] = MM(a) * t + n, Iw[1] = EM(a) * r + e, c(s, Pw, Iw), u(l, Pw, Iw), i = i % gf, i < 0 && (i = i + gf), a = a % gf, a < 0 && (a = a + gf), i > a && !o ? a += gf : i < a && o && (i += gf), o) { var f = a; a = i, i = f } for (var h = 0; h < a; h += Math.PI / 2)h > i && (Lw[0] = MM(h) * t + n, Lw[1] = EM(h) * r + e, c(s, Lw, s), u(l, Lw, l)) } var Mn = { M: 1, L: 2, C: 3, Q: 4, A: 5, Z: 6, R: 7 }, vf = [], yf = [], Ns = [], iu = [], Bs = [], $s = [], OM = Math.min, DM = Math.max, _f = Math.cos, bf = Math.sin, Zl = Math.abs, KP = Math.PI, gu = KP * 2, jM = typeof Float32Array < "u", Gv = []; function PM(n) { var e = Math.round(n / KP * 1e8) / 1e8; return e % 2 * KP } function LN(n, e) { var t = PM(n[0]); t < 0 && (t += gu); var r = t - n[0], i = n[1]; i += r, !e && i - t >= gu ? i = t + gu : e && t - i >= gu ? i = t - gu : !e && t > i ? i = t + (gu - PM(t - i)) : e && t < i && (i = t - (gu - PM(i - t))), n[0] = t, n[1] = i } var Cl = function () { function n(e) { this.dpr = 1, this._xi = 0, this._yi = 0, this._x0 = 0, this._y0 = 0, this._len = 0, e && (this._saveData = !1), this._saveData && (this.data = []) } return n.prototype.increaseVersion = function () { this._version++ }, n.prototype.getVersion = function () { return this._version }, n.prototype.setScale = function (e, t, r) { r = r || 0, r > 0 && (this._ux = Zl(r / q2 / e) || 0, this._uy = Zl(r / q2 / t) || 0) }, n.prototype.setDPR = function (e) { this.dpr = e }, n.prototype.setContext = function (e) { this._ctx = e }, n.prototype.getContext = function () { return this._ctx }, n.prototype.beginPath = function () { return this._ctx && this._ctx.beginPath(), this.reset(), this }, n.prototype.reset = function () { this._saveData && (this._len = 0), this._pathSegLen && (this._pathSegLen = null, this._pathLen = 0), this._version++ }, n.prototype.moveTo = function (e, t) { return this._drawPendingPt(), this.addData(Mn.M, e, t), this._ctx && this._ctx.moveTo(e, t), this._x0 = e, this._y0 = t, this._xi = e, this._yi = t, this }, n.prototype.lineTo = function (e, t) { var r = Zl(e - this._xi), i = Zl(t - this._yi), a = r > this._ux || i > this._uy; if (this.addData(Mn.L, e, t), this._ctx && a && this._ctx.lineTo(e, t), a) this._xi = e, this._yi = t, this._pendingPtDist = 0; else { var o = r * r + i * i; o > this._pendingPtDist && (this._pendingPtX = e, this._pendingPtY = t, this._pendingPtDist = o) } return this }, n.prototype.bezierCurveTo = function (e, t, r, i, a, o) { return this._drawPendingPt(), this.addData(Mn.C, e, t, r, i, a, o), this._ctx && this._ctx.bezierCurveTo(e, t, r, i, a, o), this._xi = a, this._yi = o, this }, n.prototype.quadraticCurveTo = function (e, t, r, i) { return this._drawPendingPt(), this.addData(Mn.Q, e, t, r, i), this._ctx && this._ctx.quadraticCurveTo(e, t, r, i), this._xi = r, this._yi = i, this }, n.prototype.arc = function (e, t, r, i, a, o) { this._drawPendingPt(), Gv[0] = i, Gv[1] = a, LN(Gv, o), i = Gv[0], a = Gv[1]; var s = a - i; return this.addData(Mn.A, e, t, r, r, i, s, 0, o ? 0 : 1), this._ctx && this._ctx.arc(e, t, r, i, a, o), this._xi = _f(a) * r + e, this._yi = bf(a) * r + t, this }, n.prototype.arcTo = function (e, t, r, i, a) { return this._drawPendingPt(), this._ctx && this._ctx.arcTo(e, t, r, i, a), this }, n.prototype.rect = function (e, t, r, i) { return this._drawPendingPt(), this._ctx && this._ctx.rect(e, t, r, i), this.addData(Mn.R, e, t, r, i), this }, n.prototype.closePath = function () { this._drawPendingPt(), this.addData(Mn.Z); var e = this._ctx, t = this._x0, r = this._y0; return e && e.closePath(), this._xi = t, this._yi = r, this }, n.prototype.fill = function (e) { e && e.fill(), this.toStatic() }, n.prototype.stroke = function (e) { e && e.stroke(), this.toStatic() }, n.prototype.len = function () { return this._len }, n.prototype.setData = function (e) { var t = e.length; !(this.data && this.data.length === t) && jM && (this.data = new Float32Array(t)); for (var r = 0; r < t; r++)this.data[r] = e[r]; this._len = t }, n.prototype.appendPath = function (e) { e instanceof Array || (e = [e]); for (var t = e.length, r = 0, i = this._len, a = 0; a < t; a++)r += e[a].len(); jM && this.data instanceof Float32Array && (this.data = new Float32Array(i + r)); for (var a = 0; a < t; a++)for (var o = e[a].data, s = 0; s < o.length; s++)this.data[i++] = o[s]; this._len = i }, n.prototype.addData = function (e, t, r, i, a, o, s, l, c) { if (this._saveData) { var u = this.data; this._len + arguments.length > u.length && (this._expandData(), u = this.data); for (var d = 0; d < arguments.length; d++)u[this._len++] = arguments[d] } }, n.prototype._drawPendingPt = function () { this._pendingPtDist > 0 && (this._ctx && this._ctx.lineTo(this._pendingPtX, this._pendingPtY), this._pendingPtDist = 0) }, n.prototype._expandData = function () { if (!(this.data instanceof Array)) { for (var e = [], t = 0; t < this._len; t++)e[t] = this.data[t]; this.data = e } }, n.prototype.toStatic = function () { if (this._saveData) { this._drawPendingPt(); var e = this.data; e instanceof Array && (e.length = this._len, jM && this._len > 11 && (this.data = new Float32Array(e))) } }, n.prototype.getBoundingRect = function () { Ns[0] = Ns[1] = Bs[0] = Bs[1] = Number.MAX_VALUE, iu[0] = iu[1] = $s[0] = $s[1] = -Number.MAX_VALUE; var e = this.data, t = 0, r = 0, i = 0, a = 0, o; for (o = 0; o < this._len;) { var s = e[o++], l = o === 1; switch (l && (t = e[o], r = e[o + 1], i = t, a = r), s) { case Mn.M: t = i = e[o++], r = a = e[o++], Bs[0] = i, Bs[1] = a, $s[0] = i, $s[1] = a; break; case Mn.L: sV(t, r, e[o], e[o + 1], Bs, $s), t = e[o++], r = e[o++]; break; case Mn.C: mze(t, r, e[o++], e[o++], e[o++], e[o++], e[o], e[o + 1], Bs, $s), t = e[o++], r = e[o++]; break; case Mn.Q: gze(t, r, e[o++], e[o++], e[o], e[o + 1], Bs, $s), t = e[o++], r = e[o++]; break; case Mn.A: var c = e[o++], u = e[o++], d = e[o++], f = e[o++], h = e[o++], p = e[o++] + h; o += 1; var m = !e[o++]; l && (i = _f(h) * d + c, a = bf(h) * f + u), vze(c, u, d, f, h, p, m, Bs, $s), t = _f(p) * d + c, r = bf(p) * f + u; break; case Mn.R: i = t = e[o++], a = r = e[o++]; var g = e[o++], y = e[o++]; sV(i, a, i + g, a + y, Bs, $s); break; case Mn.Z: t = i, r = a; break }Uu(Ns, Ns, Bs), Gu(iu, iu, $s) } return o === 0 && (Ns[0] = Ns[1] = iu[0] = iu[1] = 0), new kt(Ns[0], Ns[1], iu[0] - Ns[0], iu[1] - Ns[1]) }, n.prototype._calculateLength = function () { var e = this.data, t = this._len, r = this._ux, i = this._uy, a = 0, o = 0, s = 0, l = 0; this._pathSegLen || (this._pathSegLen = []); for (var c = this._pathSegLen, u = 0, d = 0, f = 0; f < t;) { var h = e[f++], p = f === 1; p && (a = e[f], o = e[f + 1], s = a, l = o); var m = -1; switch (h) { case Mn.M: a = s = e[f++], o = l = e[f++]; break; case Mn.L: { var g = e[f++], y = e[f++], b = g - a, w = y - o; (Zl(b) > r || Zl(w) > i || f === t - 1) && (m = Math.sqrt(b * b + w * w), a = g, o = y); break } case Mn.C: { var v = e[f++], S = e[f++], g = e[f++], y = e[f++], x = e[f++], k = e[f++]; m = D$e(a, o, v, S, g, y, x, k, 10), a = x, o = k; break } case Mn.Q: { var v = e[f++], S = e[f++], g = e[f++], y = e[f++]; m = P$e(a, o, v, S, g, y, 10), a = g, o = y; break } case Mn.A: var A = e[f++], C = e[f++], E = e[f++], O = e[f++], j = e[f++], I = e[f++], L = I + j; f += 1, p && (s = _f(j) * E + A, l = bf(j) * O + C), m = DM(E, O) * OM(gu, Math.abs(I)), a = _f(L) * E + A, o = bf(L) * O + C; break; case Mn.R: { s = a = e[f++], l = o = e[f++]; var R = e[f++], D = e[f++]; m = R * 2 + D * 2; break } case Mn.Z: { var b = s - a, w = l - o; m = Math.sqrt(b * b + w * w), a = s, o = l; break } }m >= 0 && (c[d++] = m, u += m) } return this._pathLen = u, u }, n.prototype.rebuildPath = function (e, t) { var r = this.data, i = this._ux, a = this._uy, o = this._len, s, l, c, u, d, f, h = t < 1, p, m, g = 0, y = 0, b, w = 0, v, S; if (!(h && (this._pathSegLen || this._calculateLength(), p = this._pathSegLen, m = this._pathLen, b = t * m, !b))) e: for (var x = 0; x < o;) { var k = r[x++], A = x === 1; switch (A && (c = r[x], u = r[x + 1], s = c, l = u), k !== Mn.L && w > 0 && (e.lineTo(v, S), w = 0), k) { case Mn.M: s = c = r[x++], l = u = r[x++], e.moveTo(c, u); break; case Mn.L: { d = r[x++], f = r[x++]; var C = Zl(d - c), E = Zl(f - u); if (C > i || E > a) { if (h) { var O = p[y++]; if (g + O > b) { var j = (b - g) / O; e.lineTo(c * (1 - j) + d * j, u * (1 - j) + f * j); break e } g += O } e.lineTo(d, f), c = d, u = f, w = 0 } else { var I = C * C + E * E; I > w && (v = d, S = f, w = I) } break } case Mn.C: { var L = r[x++], R = r[x++], D = r[x++], P = r[x++], B = r[x++], F = r[x++]; if (h) { var O = p[y++]; if (g + O > b) { var j = (b - g) / O; Cd(c, L, D, B, j, vf), Cd(u, R, P, F, j, yf), e.bezierCurveTo(vf[1], yf[1], vf[2], yf[2], vf[3], yf[3]); break e } g += O } e.bezierCurveTo(L, R, D, P, B, F), c = B, u = F; break } case Mn.Q: { var L = r[x++], R = r[x++], D = r[x++], P = r[x++]; if (h) { var O = p[y++]; if (g + O > b) { var j = (b - g) / O; d_(c, L, D, j, vf), d_(u, R, P, j, yf), e.quadraticCurveTo(vf[1], yf[1], vf[2], yf[2]); break e } g += O } e.quadraticCurveTo(L, R, D, P), c = D, u = P; break } case Mn.A: var K = r[x++], V = r[x++], W = r[x++], J = r[x++], ie = r[x++], le = r[x++], De = r[x++], ae = !r[x++], pe = W > J ? W : J, se = Zl(W - J) > .001, ge = ie + le, _e = !1; if (h) { var O = p[y++]; g + O > b && (ge = ie + le * (b - g) / O, _e = !0), g += O } if (se && e.ellipse ? e.ellipse(K, V, W, J, De, ie, ge, ae) : e.arc(K, V, pe, ie, ge, ae), _e) break e; A && (s = _f(ie) * W + K, l = bf(ie) * J + V), c = _f(ge) * W + K, u = bf(ge) * J + V; break; case Mn.R: s = c = r[x], l = u = r[x + 1], d = r[x++], f = r[x++]; var je = r[x++], U = r[x++]; if (h) { var O = p[y++]; if (g + O > b) { var q = b - g; e.moveTo(d, f), e.lineTo(d + OM(q, je), f), q -= je, q > 0 && e.lineTo(d + je, f + OM(q, U)), q -= U, q > 0 && e.lineTo(d + DM(je - q, 0), f + U), q -= je, q > 0 && e.lineTo(d, f + DM(U - q, 0)); break e } g += O } e.rect(d, f, je, U); break; case Mn.Z: if (h) { var O = p[y++]; if (g + O > b) { var j = (b - g) / O; e.lineTo(c * (1 - j) + s * j, u * (1 - j) + l * j); break e } g += O } e.closePath(), c = s, u = l } } }, n.prototype.clone = function () { var e = new n, t = this.data; return e.data = t.slice ? t.slice() : Array.prototype.slice.call(t), e._len = this._len, e }, n.CMD = Mn, n.initDefaultProps = function () { var e = n.prototype; e._saveData = !0, e._ux = 0, e._uy = 0, e._pendingPtDist = 0, e._version = 0 }(), n }(); function Au(n, e, t, r, i, a, o) { if (i === 0) return !1; var s = i, l = 0, c = n; if (o > e + s && o > r + s || o < e - s && o < r - s || a > n + s && a > t + s || a < n - s && a < t - s) return !1; if (n !== t) l = (e - r) / (n - t), c = (n * r - t * e) / (n - t); else return Math.abs(a - n) <= s / 2; var u = l * a - o + c, d = u * u / (l * l + 1); return d <= s / 2 * s / 2 } function yze(n, e, t, r, i, a, o, s, l, c, u) { if (l === 0) return !1; var d = l; if (u > e + d && u > r + d && u > a + d && u > s + d || u < e - d && u < r - d && u < a - d && u < s - d || c > n + d && c > t + d && c > i + d && c > o + d || c < n - d && c < t - d && c < i - d && c < o - d) return !1; var f = Oee(n, e, t, r, i, a, o, s, c, u, null); return f <= d / 2 } function hte(n, e, t, r, i, a, o, s, l) { if (o === 0) return !1; var c = o; if (l > e + c && l > r + c && l > a + c || l < e - c && l < r - c && l < a - c || s > n + c && s > t + c && s > i + c || s < n - c && s < t - c && s < i - c) return !1; var u = jee(n, e, t, r, i, a, s, l, null); return u <= c / 2 } var uV = Math.PI * 2; function $a(n) { return n %= uV, n < 0 && (n += uV), n } var Wv = Math.PI * 2; function _ze(n, e, t, r, i, a, o, s, l) { if (o === 0) return !1; var c = o; s -= n, l -= e; var u = Math.sqrt(s * s + l * l); if (u - c > t || u + c < t) return !1; if (Math.abs(r - i) % Wv < 1e-4) return !0; if (a) { var d = r; r = $a(i), i = $a(d) } else r = $a(r), i = $a(i); r > i && (i += Wv); var f = Math.atan2(l, s); return f < 0 && (f += Wv), f >= r && f <= i || f + Wv >= r && f + Wv <= i } function ac(n, e, t, r, i, a) { if (a > e && a > r || a < e && a < r || r === e) return 0; var o = (a - e) / (r - e), s = r < e ? 1 : -1; (o === 1 || o === 0) && (s = r < e ? .5 : -.5); var l = o * (t - n) + n; return l === i ? 1 / 0 : l > i ? s : 0 } var au = Cl.CMD, wf = Math.PI * 2, bze = 1e-4; function wze(n, e) { return Math.abs(n - e) < bze } var Ki = [-1, -1, -1], go = [-1, -1]; function xze() { var n = go[0]; go[0] = go[1], go[1] = n } function Sze(n, e, t, r, i, a, o, s, l, c) { if (c > e && c > r && c > a && c > s || c < e && c < r && c < a && c < s) return 0; var u = U2(e, r, a, s, c, Ki); if (u === 0) return 0; for (var d = 0, f = -1, h = void 0, p = void 0, m = 0; m < u; m++) { var g = Ki[m], y = g === 0 || g === 1 ? .5 : 1, b = Nr(n, t, i, o, g); b < l || (f < 0 && (f = Mee(e, r, a, s, go), go[1] < go[0] && f > 1 && xze(), h = Nr(e, r, a, s, go[0]), f > 1 && (p = Nr(e, r, a, s, go[1]))), f === 2 ? g < go[0] ? d += h < e ? y : -y : g < go[1] ? d += p < h ? y : -y : d += s < p ? y : -y : g < go[0] ? d += h < e ? y : -y : d += s < h ? y : -y) } return d } function Tze(n, e, t, r, i, a, o, s) { if (s > e && s > r && s > a || s < e && s < r && s < a) return 0; var l = j$e(e, r, a, s, Ki); if (l === 0) return 0; var c = Dee(e, r, a); if (c >= 0 && c <= 1) { for (var u = 0, d = qr(e, r, a, c), f = 0; f < l; f++) { var h = Ki[f] === 0 || Ki[f] === 1 ? .5 : 1, p = qr(n, t, i, Ki[f]); p < o || (Ki[f] < c ? u += d < e ? h : -h : u += a < d ? h : -h) } return u } else { var h = Ki[0] === 0 || Ki[0] === 1 ? .5 : 1, p = qr(n, t, i, Ki[0]); return p < o ? 0 : a < e ? h : -h } } function kze(n, e, t, r, i, a, o, s) { if (s -= e, s > t || s < -t) return 0; var l = Math.sqrt(t * t - s * s); Ki[0] = -l, Ki[1] = l; var c = Math.abs(r - i); if (c < 1e-4) return 0; if (c >= wf - 1e-4) { r = 0, i = wf; var u = a ? 1 : -1; return o >= Ki[0] + n && o <= Ki[1] + n ? u : 0 } if (r > i) { var d = r; r = i, i = d } r < 0 && (r += wf, i += wf); for (var f = 0, h = 0; h < 2; h++) { var p = Ki[h]; if (p + n > o) { var m = Math.atan2(s, p), u = a ? 1 : -1; m < 0 && (m = wf + m), (m >= r && m <= i || m + wf >= r && m + wf <= i) && (m > Math.PI / 2 && m < Math.PI * 1.5 && (u = -u), f += u) } } return f } function pte(n, e, t, r, i) { for (var a = n.data, o = n.len(), s = 0, l = 0, c = 0, u = 0, d = 0, f, h, p = 0; p < o;) { var m = a[p++], g = p === 1; switch (m === au.M && p > 1 && (t || (s += ac(l, c, u, d, r, i))), g && (l = a[p], c = a[p + 1], u = l, d = c), m) { case au.M: u = a[p++], d = a[p++], l = u, c = d; break; case au.L: if (t) { if (Au(l, c, a[p], a[p + 1], e, r, i)) return !0 } else s += ac(l, c, a[p], a[p + 1], r, i) || 0; l = a[p++], c = a[p++]; break; case au.C: if (t) { if (yze(l, c, a[p++], a[p++], a[p++], a[p++], a[p], a[p + 1], e, r, i)) return !0 } else s += Sze(l, c, a[p++], a[p++], a[p++], a[p++], a[p], a[p + 1], r, i) || 0; l = a[p++], c = a[p++]; break; case au.Q: if (t) { if (hte(l, c, a[p++], a[p++], a[p], a[p + 1], e, r, i)) return !0 } else s += Tze(l, c, a[p++], a[p++], a[p], a[p + 1], r, i) || 0; l = a[p++], c = a[p++]; break; case au.A: var y = a[p++], b = a[p++], w = a[p++], v = a[p++], S = a[p++], x = a[p++]; p += 1; var k = !!(1 - a[p++]); f = Math.cos(S) * w + y, h = Math.sin(S) * v + b, g ? (u = f, d = h) : s += ac(l, c, f, h, r, i); var A = (r - y) * v / w + y; if (t) { if (_ze(y, b, v, S, S + x, k, e, A, i)) return !0 } else s += kze(y, b, v, S, S + x, k, A, i); l = Math.cos(S + x) * w + y, c = Math.sin(S + x) * v + b; break; case au.R: u = l = a[p++], d = c = a[p++]; var C = a[p++], E = a[p++]; if (f = u + C, h = d + E, t) { if (Au(u, d, f, d, e, r, i) || Au(f, d, f, h, e, r, i) || Au(f, h, u, h, e, r, i) || Au(u, h, u, d, e, r, i)) return !0 } else s += ac(f, d, f, h, r, i), s += ac(u, h, u, d, r, i); break; case au.Z: if (t) { if (Au(l, c, u, d, e, r, i)) return !0 } else s += ac(l, c, u, d, r, i); l = u, c = d; break } } return !t && !wze(c, d) && (s += ac(l, c, u, d, r, i) || 0), s !== 0 } function Cze(n, e, t) { return pte(n, 0, !1, e, t) } function Aze(n, e, t, r) { return pte(n, e, !0, t, r) } var Z2 = rt({ fill: "#000", stroke: null, strokePercent: 1, fillOpacity: 1, strokeOpacity: 1, lineDashOffset: 0, lineWidth: 1, lineCap: "butt", miterLimit: 10, strokeNoScale: !1, strokeFirst: !1 }, xh), Eze = { style: rt({ fill: !0, stroke: !0, strokePercent: !0, fillOpacity: !0, strokeOpacity: !0, lineDashOffset: !0, lineWidth: !0, miterLimit: !0 }, Qk.style) }, IM = Tl.concat(["invisible", "culling", "z", "z2", "zlevel", "parent"]), Mze = function (n) { te(e, n); function e(t) { return n.call(this, t) || this } return e.prototype.update = function () { var t = this; n.prototype.update.call(this); var r = this.style; if (r.decal) { var i = this._decalEl = this._decalEl || new e; i.buildPath === e.prototype.buildPath && (i.buildPath = function (l) { t.buildPath(l, t.shape) }), i.silent = !0; var a = i.style; for (var o in r) a[o] !== r[o] && (a[o] = r[o]); a.fill = r.fill ? r.decal : null, a.decal = null, a.shadowColor = null, r.strokeFirst && (a.stroke = null); for (var s = 0; s < IM.length; ++s)i[IM[s]] = this[IM[s]]; i.__dirty |= Ba } else this._decalEl && (this._decalEl = null) }, e.prototype.getDecalElement = function () { return this._decalEl }, e.prototype._init = function (t) { var r = Bt(t); this.shape = this.getDefaultShape(); var i = this.getDefaultStyle(); i && this.useStyle(i); for (var a = 0; a < r.length; a++) { var o = r[a], s = t[o]; o === "style" ? this.style ? be(this.style, s) : this.useStyle(s) : o === "shape" ? be(this.shape, s) : n.prototype.attrKV.call(this, o, s) } this.style || this.useStyle({}) }, e.prototype.getDefaultStyle = function () { return null }, e.prototype.getDefaultShape = function () { return {} }, e.prototype.canBeInsideText = function () { return this.hasFill() }, e.prototype.getInsideTextFill = function () { var t = this.style.fill; if (t !== "none") { if (Fe(t)) { var r = W2(t, 0); return r > .5 ? zP : r > .2 ? uFe : VP } else if (t) return VP } return zP }, e.prototype.getInsideTextStroke = function (t) { var r = this.style.fill; if (Fe(r)) { var i = this.__zr, a = !!(i && i.isDarkMode()), o = W2(t, 0) < FP; if (a === o) return r } }, e.prototype.buildPath = function (t, r, i) { }, e.prototype.pathUpdated = function () { this.__dirty &= ~wm }, e.prototype.getUpdatedPathProxy = function (t) { return !this.path && this.createPathProxy(), this.path.beginPath(), this.buildPath(this.path, this.shape, t), this.path }, e.prototype.createPathProxy = function () { this.path = new Cl(!1) }, e.prototype.hasStroke = function () { var t = this.style, r = t.stroke; return !(r == null || r === "none" || !(t.lineWidth > 0)) }, e.prototype.hasFill = function () { var t = this.style, r = t.fill; return r != null && r !== "none" }, e.prototype.getBoundingRect = function () { var t = this._rect, r = this.style, i = !t; if (i) { var a = !1; this.path || (a = !0, this.createPathProxy()); var o = this.path; (a || this.__dirty & wm) && (o.beginPath(), this.buildPath(o, this.shape, !1), this.pathUpdated()), t = o.getBoundingRect() } if (this._rect = t, this.hasStroke() && this.path && this.path.len() > 0) { var s = this._rectStroke || (this._rectStroke = t.clone()); if (this.__dirty || i) { s.copy(t); var l = r.strokeNoScale ? this.getLineScale() : 1, c = r.lineWidth; if (!this.hasFill()) { var u = this.strokeContainThreshold; c = Math.max(c, u ?? 4) } l > 1e-10 && (s.width += c / l, s.height += c / l, s.x -= c / l / 2, s.y -= c / l / 2) } return s } return t }, e.prototype.contain = function (t, r) { var i = this.transformCoordToLocal(t, r), a = this.getBoundingRect(), o = this.style; if (t = i[0], r = i[1], a.contain(t, r)) { var s = this.path; if (this.hasStroke()) { var l = o.lineWidth, c = o.strokeNoScale ? this.getLineScale() : 1; if (c > 1e-10 && (this.hasFill() || (l = Math.max(l, this.strokeContainThreshold)), Aze(s, l / c, t, r))) return !0 } if (this.hasFill()) return Cze(s, t, r) } return !1 }, e.prototype.dirtyShape = function () { this.__dirty |= wm, this._rect && (this._rect = null), this._decalEl && this._decalEl.dirtyShape(), this.markRedraw() }, e.prototype.dirty = function () { this.dirtyStyle(), this.dirtyShape() }, e.prototype.animateShape = function (t) { return this.animate("shape", t) }, e.prototype.updateDuringAnimation = function (t) { t === "style" ? this.dirtyStyle() : t === "shape" ? this.dirtyShape() : this.markRedraw() }, e.prototype.attrKV = function (t, r) { t === "shape" ? this.setShape(r) : n.prototype.attrKV.call(this, t, r) }, e.prototype.setShape = function (t, r) { var i = this.shape; return i || (i = this.shape = {}), typeof t == "string" ? i[t] = r : be(i, t), this.dirtyShape(), this }, e.prototype.shapeChanged = function () { return !!(this.__dirty & wm) }, e.prototype.createStyle = function (t) { return Kk(Z2, t) }, e.prototype._innerSaveToNormal = function (t) { n.prototype._innerSaveToNormal.call(this, t); var r = this._normalState; t.shape && !r.shape && (r.shape = be({}, this.shape)) }, e.prototype._applyStateObj = function (t, r, i, a, o, s) { n.prototype._applyStateObj.call(this, t, r, i, a, o, s); var l = !(r && a), c; if (r && r.shape ? o ? a ? c = r.shape : (c = be({}, i.shape), be(c, r.shape)) : (c = be({}, a ? this.shape : i.shape), be(c, r.shape)) : l && (c = i.shape), c) if (o) { this.shape = be({}, this.shape); for (var u = {}, d = Bt(c), f = 0; f < d.length; f++) { var h = d[f]; typeof c[h] == "object" ? this.shape[h] = c[h] : u[h] = c[h] } this._transitionState(t, { shape: u }, s) } else this.shape = c, this.dirtyShape() }, e.prototype._mergeStates = function (t) { for (var r = n.prototype._mergeStates.call(this, t), i, a = 0; a < t.length; a++) { var o = t[a]; o.shape && (i = i || {}, this._mergeStyle(i, o.shape)) } return i && (r.shape = i), r }, e.prototype.getAnimationStyleProps = function () { return Eze }, e.prototype.isZeroArea = function () { return !1 }, e.extend = function (t) { var r = function (a) { te(o, a); function o(s) { var l = a.call(this, s) || this; return t.init && t.init.call(l, s), l } return o.prototype.getDefaultStyle = function () { return lt(t.style) }, o.prototype.getDefaultShape = function () { return lt(t.shape) }, o }(e); for (var i in t) typeof t[i] == "function" && (r.prototype[i] = t[i]); return r }, e.initDefaultProps = function () { var t = e.prototype; t.type = "path", t.strokeContainThreshold = 5, t.segmentIgnoreThreshold = 0, t.subPixelOptimize = !1, t.autoBatch = !1, t.__dirty = Ba | Sy | wm }(), e }(Ho); const Nt = Mze; var Oze = rt({ strokeFirst: !0, font: Td, x: 0, y: 0, textAlign: "left", textBaseline: "top", miterLimit: 2 }, Z2), mte = function (n) { te(e, n); function e() { return n !== null && n.apply(this, arguments) || this } return e.prototype.hasStroke = function () { var t = this.style, r = t.stroke; return r != null && r !== "none" && t.lineWidth > 0 }, e.prototype.hasFill = function () { var t = this.style, r = t.fill; return r != null && r !== "none" }, e.prototype.createStyle = function (t) { return Kk(Oze, t) }, e.prototype.setBoundingRect = function (t) { this._rect = t }, e.prototype.getBoundingRect = function () { var t = this.style; if (!this._rect) { var r = t.text; r != null ? r += "" : r = ""; var i = bb(r, t.font, t.textAlign, t.textBaseline); if (i.x += t.x || 0, i.y += t.y || 0, this.hasStroke()) { var a = t.lineWidth; i.x -= a / 2, i.y -= a / 2, i.width += a, i.height += a } this._rect = i } return this._rect }, e.initDefaultProps = function () { var t = e.prototype; t.dirtyRectTolerance = 10 }(), e }(Ho); mte.prototype.type = "tspan"; const g_ = mte; var Dze = rt({ x: 0, y: 0 }, xh), jze = { style: rt({ x: !0, y: !0, width: !0, height: !0, sx: !0, sy: !0, sWidth: !0, sHeight: !0 }, Qk.style) }; function Pze(n) { return !!(n && typeof n != "string" && n.width && n.height) } var gte = function (n) { te(e, n); function e() { return n !== null && n.apply(this, arguments) || this } return e.prototype.createStyle = function (t) { return Kk(Dze, t) }, e.prototype._getSize = function (t) { var r = this.style, i = r[t]; if (i != null) return i; var a = Pze(r.image) ? r.image : this.__image; if (!a) return 0; var o = t === "width" ? "height" : "width", s = r[o]; return s == null ? a[t] : a[t] / a[o] * s }, e.prototype.getWidth = function () { return this._getSize("width") }, e.prototype.getHeight = function () { return this._getSize("height") }, e.prototype.getAnimationStyleProps = function () { return jze }, e.prototype.getBoundingRect = function () { var t = this.style; return this._rect || (this._rect = new kt(t.x || 0, t.y || 0, this.getWidth(), this.getHeight())), this._rect }, e }(Ho); gte.prototype.type = "image"; const gi = gte; function Ize(n, e) { var t = e.x, r = e.y, i = e.width, a = e.height, o = e.r, s, l, c, u; i < 0 && (t = t + i, i = -i), a < 0 && (r = r + a, a = -a), typeof o == "number" ? s = l = c = u = o : o instanceof Array ? o.length === 1 ? s = l = c = u = o[0] : o.length === 2 ? (s = c = o[0], l = u = o[1]) : o.length === 3 ? (s = o[0], l = u = o[1], c = o[2]) : (s = o[0], l = o[1], c = o[2], u = o[3]) : s = l = c = u = 0; var d; s + l > i && (d = s + l, s *= i / d, l *= i / d), c + u > i && (d = c + u, c *= i / d, u *= i / d), l + c > a && (d = l + c, l *= a / d, c *= a / d), s + u > a && (d = s + u, s *= a / d, u *= a / d), n.moveTo(t + s, r), n.lineTo(t + i - l, r), l !== 0 && n.arc(t + i - l, r + l, l, -Math.PI / 2, 0), n.lineTo(t + i, r + a - c), c !== 0 && n.arc(t + i - c, r + a - c, c, 0, Math.PI / 2), n.lineTo(t + u, r + a), u !== 0 && n.arc(t + u, r + a - u, u, Math.PI / 2, Math.PI), n.lineTo(t, r + s), s !== 0 && n.arc(t + s, r + s, s, Math.PI, Math.PI * 1.5) } var Pm = Math.round; function vte(n, e, t) { if (e) { var r = e.x1, i = e.x2, a = e.y1, o = e.y2; n.x1 = r, n.x2 = i, n.y1 = a, n.y2 = o; var s = t && t.lineWidth; return s && (Pm(r * 2) === Pm(i * 2) && (n.x1 = n.x2 = eh(r, s, !0)), Pm(a * 2) === Pm(o * 2) && (n.y1 = n.y2 = eh(a, s, !0))), n } } function yte(n, e, t) { if (e) { var r = e.x, i = e.y, a = e.width, o = e.height; n.x = r, n.y = i, n.width = a, n.height = o; var s = t && t.lineWidth; return s && (n.x = eh(r, s, !0), n.y = eh(i, s, !0), n.width = Math.max(eh(r + a, s, !1) - n.x, a === 0 ? 0 : 1), n.height = Math.max(eh(i + o, s, !1) - n.y, o === 0 ? 0 : 1)), n } } function eh(n, e, t) { if (!e) return n; var r = Pm(n * 2); return (r + Pm(e)) % 2 === 0 ? r / 2 : (r + (t ? 1 : -1)) / 2 } var Lze = function () { function n() { this.x = 0, this.y = 0, this.width = 0, this.height = 0 } return n }(), Rze = {}, _te = function (n) { te(e, n); function e(t) { return n.call(this, t) || this } return e.prototype.getDefaultShape = function () { return new Lze }, e.prototype.buildPath = function (t, r) { var i, a, o, s; if (this.subPixelOptimize) { var l = yte(Rze, r, this.style); i = l.x, a = l.y, o = l.width, s = l.height, l.r = r.r, r = l } else i = r.x, a = r.y, o = r.width, s = r.height; r.r ? Ize(t, r) : t.rect(i, a, o, s) }, e.prototype.isZeroArea = function () { return !this.shape.width || !this.shape.height }, e }(Nt); _te.prototype.type = "rect"; const Yt = _te; var dV = { fill: "#000" }, fV = 2, Nze = { style: rt({ fill: !0, stroke: !0, fillOpacity: !0, strokeOpacity: !0, lineWidth: !0, fontSize: !0, lineHeight: !0, width: !0, height: !0, textShadowColor: !0, textShadowBlur: !0, textShadowOffsetX: !0, textShadowOffsetY: !0, backgroundColor: !0, padding: !0, borderColor: !0, borderWidth: !0, borderRadius: !0 }, Qk.style) }, bte = function (n) { te(e, n); function e(t) { var r = n.call(this) || this; return r.type = "text", r._children = [], r._defaultStyle = dV, r.attr(t), r } return e.prototype.childrenRef = function () { return this._children }, e.prototype.update = function () { n.prototype.update.call(this), this.styleChanged() && this._updateSubTexts(); for (var t = 0; t < this._children.length; t++) { var r = this._children[t]; r.zlevel = this.zlevel, r.z = this.z, r.z2 = this.z2, r.culling = this.culling, r.cursor = this.cursor, r.invisible = this.invisible } }, e.prototype.updateTransform = function () { var t = this.innerTransformable; t ? (t.updateTransform(), t.transform && (this.transform = t.transform)) : n.prototype.updateTransform.call(this) }, e.prototype.getLocalTransform = function (t) { var r = this.innerTransformable; return r ? r.getLocalTransform(t) : n.prototype.getLocalTransform.call(this, t) }, e.prototype.getComputedTransform = function () { return this.__hostTarget && (this.__hostTarget.getComputedTransform(), this.__hostTarget.updateInnerText(!0)), n.prototype.getComputedTransform.call(this) }, e.prototype._updateSubTexts = function () { this._childCursor = 0, Fze(this.style), this.style.rich ? this._updateRichTexts() : this._updatePlainTexts(), this._children.length = this._childCursor, this.styleUpdated() }, e.prototype.addSelfToZr = function (t) { n.prototype.addSelfToZr.call(this, t); for (var r = 0; r < this._children.length; r++)this._children[r].__zr = t }, e.prototype.removeSelfFromZr = function (t) { n.prototype.removeSelfFromZr.call(this, t); for (var r = 0; r < this._children.length; r++)this._children[r].__zr = null }, e.prototype.getBoundingRect = function () { if (this.styleChanged() && this._updateSubTexts(), !this._rect) { for (var t = new kt(0, 0, 0, 0), r = this._children, i = [], a = null, o = 0; o < r.length; o++) { var s = r[o], l = s.getBoundingRect(), c = s.getLocalTransform(i); c ? (t.copy(l), t.applyTransform(c), a = a || t.clone(), a.union(t)) : (a = a || l.clone(), a.union(l)) } this._rect = a || t } return this._rect }, e.prototype.setDefaultTextStyle = function (t) { this._defaultStyle = t || dV }, e.prototype.setTextContent = function (t) { }, e.prototype._mergeStyle = function (t, r) { if (!r) return t; var i = r.rich, a = t.rich || i && {}; return be(t, r), i && a ? (this._mergeRich(a, i), t.rich = a) : a && (t.rich = a), t }, e.prototype._mergeRich = function (t, r) { for (var i = Bt(r), a = 0; a < i.length; a++) { var o = i[a]; t[o] = t[o] || {}, be(t[o], r[o]) } }, e.prototype.getAnimationStyleProps = function () { return Nze }, e.prototype._getOrCreateChild = function (t) { var r = this._children[this._childCursor]; return (!r || !(r instanceof t)) && (r = new t), this._children[this._childCursor++] = r, r.__zr = this.__zr, r.parent = this, r }, e.prototype._updatePlainTexts = function () { var t = this.style, r = t.font || Td, i = t.padding, a = _V(t), o = aze(a, t), s = LM(t), l = !!t.backgroundColor, c = o.outerHeight, u = o.outerWidth, d = o.contentWidth, f = o.lines, h = o.lineHeight, p = this._defaultStyle; this.isTruncated = !!o.isTruncated; var m = t.x || 0, g = t.y || 0, y = t.align || p.align || "left", b = t.verticalAlign || p.verticalAlign || "top", w = m, v = xm(g, o.contentHeight, b); if (s || i) { var S = ky(m, u, y), x = xm(g, c, b); s && this._renderBackground(t, t, S, x, u, c) } v += h / 2, i && (w = yV(m, y, i), b === "top" ? v += i[0] : b === "bottom" && (v -= i[2])); for (var k = 0, A = !1, C = vV("fill" in t ? t.fill : (A = !0, p.fill)), E = gV("stroke" in t ? t.stroke : !l && (!p.autoStroke || A) ? (k = fV, p.stroke) : null), O = t.textShadowBlur > 0, j = t.width != null && (t.overflow === "truncate" || t.overflow === "break" || t.overflow === "breakAll"), I = o.calculatedLineHeight, L = 0; L < f.length; L++) { var R = this._getOrCreateChild(g_), D = R.createStyle(); R.useStyle(D), D.text = f[L], D.x = w, D.y = v, y && (D.textAlign = y), D.textBaseline = "middle", D.opacity = t.opacity, D.strokeFirst = !0, O && (D.shadowBlur = t.textShadowBlur || 0, D.shadowColor = t.textShadowColor || "transparent", D.shadowOffsetX = t.textShadowOffsetX || 0, D.shadowOffsetY = t.textShadowOffsetY || 0), D.stroke = E, D.fill = C, E && (D.lineWidth = t.lineWidth || k, D.lineDash = t.lineDash, D.lineDashOffset = t.lineDashOffset || 0), D.font = r, pV(D, t), v += h, j && R.setBoundingRect(new kt(ky(D.x, d, D.textAlign), xm(D.y, I, D.textBaseline), d, I)) } }, e.prototype._updateRichTexts = function () { var t = this.style, r = _V(t), i = lze(r, t), a = i.width, o = i.outerWidth, s = i.outerHeight, l = t.padding, c = t.x || 0, u = t.y || 0, d = this._defaultStyle, f = t.align || d.align, h = t.verticalAlign || d.verticalAlign; this.isTruncated = !!i.isTruncated; var p = ky(c, o, f), m = xm(u, s, h), g = p, y = m; l && (g += l[3], y += l[0]); var b = g + a; LM(t) && this._renderBackground(t, t, p, m, o, s); for (var w = !!t.backgroundColor, v = 0; v < i.lines.length; v++) { for (var S = i.lines[v], x = S.tokens, k = x.length, A = S.lineHeight, C = S.width, E = 0, O = g, j = b, I = k - 1, L = void 0; E < k && (L = x[E], !L.align || L.align === "left");)this._placeToken(L, t, A, y, O, "left", w), C -= L.width, O += L.width, E++; for (; I >= 0 && (L = x[I], L.align === "right");)this._placeToken(L, t, A, y, j, "right", w), C -= L.width, j -= L.width, I--; for (O += (a - (O - g) - (b - j) - C) / 2; E <= I;)L = x[E], this._placeToken(L, t, A, y, O + L.width / 2, "center", w), O += L.width, E++; y += A } }, e.prototype._placeToken = function (t, r, i, a, o, s, l) { var c = r.rich[t.styleName] || {}; c.text = t.text; var u = t.verticalAlign, d = a + i / 2; u === "top" ? d = a + t.height / 2 : u === "bottom" && (d = a + i - t.height / 2); var f = !t.isLineHolder && LM(c); f && this._renderBackground(c, r, s === "right" ? o - t.width : s === "center" ? o - t.width / 2 : o, d - t.height / 2, t.width, t.height); var h = !!c.backgroundColor, p = t.textPadding; p && (o = yV(o, s, p), d -= t.height / 2 - p[0] - t.innerHeight / 2); var m = this._getOrCreateChild(g_), g = m.createStyle(); m.useStyle(g); var y = this._defaultStyle, b = !1, w = 0, v = vV("fill" in c ? c.fill : "fill" in r ? r.fill : (b = !0, y.fill)), S = gV("stroke" in c ? c.stroke : "stroke" in r ? r.stroke : !h && !l && (!y.autoStroke || b) ? (w = fV, y.stroke) : null), x = c.textShadowBlur > 0 || r.textShadowBlur > 0; g.text = t.text, g.x = o, g.y = d, x && (g.shadowBlur = c.textShadowBlur || r.textShadowBlur || 0, g.shadowColor = c.textShadowColor || r.textShadowColor || "transparent", g.shadowOffsetX = c.textShadowOffsetX || r.textShadowOffsetX || 0, g.shadowOffsetY = c.textShadowOffsetY || r.textShadowOffsetY || 0), g.textAlign = s, g.textBaseline = "middle", g.font = t.font || Td, g.opacity = pl(c.opacity, r.opacity, 1), pV(g, c), S && (g.lineWidth = pl(c.lineWidth, r.lineWidth, w), g.lineDash = yt(c.lineDash, r.lineDash), g.lineDashOffset = r.lineDashOffset || 0, g.stroke = S), v && (g.fill = v); var k = t.contentWidth, A = t.contentHeight; m.setBoundingRect(new kt(ky(g.x, k, g.textAlign), xm(g.y, A, g.textBaseline), k, A)) }, e.prototype._renderBackground = function (t, r, i, a, o, s) { var l = t.backgroundColor, c = t.borderWidth, u = t.borderColor, d = l && l.image, f = l && !d, h = t.borderRadius, p = this, m, g; if (f || t.lineHeight || c && u) { m = this._getOrCreateChild(Yt), m.useStyle(m.createStyle()), m.style.fill = null; var y = m.shape; y.x = i, y.y = a, y.width = o, y.height = s, y.r = h, m.dirtyShape() } if (f) { var b = m.style; b.fill = l || null, b.fillOpacity = yt(t.fillOpacity, 1) } else if (d) { g = this._getOrCreateChild(gi), g.onload = function () { p.dirtyStyle() }; var w = g.style; w.image = l.image, w.x = i, w.y = a, w.width = o, w.height = s } if (c && u) { var b = m.style; b.lineWidth = c, b.stroke = u, b.strokeOpacity = yt(t.strokeOpacity, 1), b.lineDash = t.borderDash, b.lineDashOffset = t.borderDashOffset || 0, m.strokeContainThreshold = 0, m.hasFill() && m.hasStroke() && (b.strokeFirst = !0, b.lineWidth *= 2) } var v = (m || g).style; v.shadowBlur = t.shadowBlur || 0, v.shadowColor = t.shadowColor || "transparent", v.shadowOffsetX = t.shadowOffsetX || 0, v.shadowOffsetY = t.shadowOffsetY || 0, v.opacity = pl(t.opacity, r.opacity, 1) }, e.makeFont = function (t) { var r = ""; return xte(t) && (r = [t.fontStyle, t.fontWeight, wte(t.fontSize), t.fontFamily || "sans-serif"].join(" ")), r && ps(r) || t.textFont || t.font }, e }(Ho), Bze = { left: !0, right: 1, center: 1 }, $ze = { top: 1, bottom: 1, middle: 1 }, hV = ["fontStyle", "fontWeight", "fontSize", "fontFamily"]; function wte(n) { return typeof n == "string" && (n.indexOf("px") !== -1 || n.indexOf("rem") !== -1 || n.indexOf("em") !== -1) ? n : isNaN(+n) ? gN + "px" : n + "px" } function pV(n, e) { for (var t = 0; t < hV.length; t++) { var r = hV[t], i = e[r]; i != null && (n[r] = i) } } function xte(n) { return n.fontSize != null || n.fontFamily || n.fontWeight } function Fze(n) { return mV(n), $(n.rich, mV), n } function mV(n) { if (n) { n.font = bte.makeFont(n); var e = n.align; e === "middle" && (e = "center"), n.align = e == null || Bze[e] ? e : "left"; var t = n.verticalAlign; t === "center" && (t = "middle"), n.verticalAlign = t == null || $ze[t] ? t : "top"; var r = n.padding; r && (n.padding = xN(n.padding)) } } function gV(n, e) { return n == null || e <= 0 || n === "transparent" || n === "none" ? null : n.image || n.colorStops ? "#000" : n } function vV(n) { return n == null || n === "none" ? null : n.image || n.colorStops ? "#000" : n } function yV(n, e, t) { return e === "right" ? n - t[1] : e === "center" ? n + t[3] / 2 - t[1] / 2 : n + t[3] } function _V(n) { var e = n.text; return e != null && (e += ""), e } function LM(n) { return !!(n.backgroundColor || n.lineHeight || n.borderWidth && n.borderColor) } const tn = bte; var pt = Kt(), qP = function (n, e, t, r) { if (r) { var i = pt(r); i.dataIndex = t, i.dataType = e, i.seriesIndex = n, i.ssrType = "chart", r.type === "group" && r.traverse(function (a) { var o = pt(a); o.seriesIndex = n, o.dataIndex = t, o.dataType = e, o.ssrType = "chart" }) } }, bV = 1, wV = {}, Ste = Kt(), RN = Kt(), NN = 0, xb = 1, tC = 2, ra = ["emphasis", "blur", "select"], v_ = ["normal", "emphasis", "blur", "select"], Zg = 10, zze = 9, Sh = "highlight", tS = "downplay", p0 = "select", nS = "unselect", m0 = "toggleSelect"; function Up(n) { return n != null && n !== "none" } function nC(n, e, t) { n.onHoverStateChange && (n.hoverState || 0) !== t && n.onHoverStateChange(e), n.hoverState = t } function Tte(n) { nC(n, "emphasis", tC) } function kte(n) { n.hoverState === tC && nC(n, "normal", NN) } function BN(n) { nC(n, "blur", xb) } function Cte(n) { n.hoverState === xb && nC(n, "normal", NN) } function Vze(n) { n.selected = !0 } function Hze(n) { n.selected = !1 } function xV(n, e, t) { e(n, t) } function Vc(n, e, t) { xV(n, e, t), n.isGroup && n.traverse(function (r) { xV(r, e, t) }) } function X2(n, e) { switch (e) { case "emphasis": n.hoverState = tC; break; case "normal": n.hoverState = NN; break; case "blur": n.hoverState = xb; break; case "select": n.selected = !0 } } function Uze(n, e, t, r) { for (var i = n.style, a = {}, o = 0; o < e.length; o++) { var s = e[o], l = i[s]; a[s] = l ?? (r && r[s]) } for (var o = 0; o < n.animators.length; o++) { var c = n.animators[o]; c.__fromStateTransition && c.__fromStateTransition.indexOf(t) < 0 && c.targetName === "style" && c.saveTo(a, e) } return a } function Gze(n, e, t, r) { var i = t && Et(t, "select") >= 0, a = !1; if (n instanceof Nt) { var o = Ste(n), s = i && o.selectFill || o.normalFill, l = i && o.selectStroke || o.normalStroke; if (Up(s) || Up(l)) { r = r || {}; var c = r.style || {}; c.fill === "inherit" ? (a = !0, r = be({}, r), c = be({}, c), c.fill = s) : !Up(c.fill) && Up(s) ? (a = !0, r = be({}, r), c = be({}, c), c.fill = PP(s)) : !Up(c.stroke) && Up(l) && (a || (r = be({}, r), c = be({}, c)), c.stroke = PP(l)), r.style = c } } if (r && r.z2 == null) { a || (r = be({}, r)); var u = n.z2EmphasisLift; r.z2 = n.z2 + (u ?? Zg) } return r } function Wze(n, e, t) { if (t && t.z2 == null) { t = be({}, t); var r = n.z2SelectLift; t.z2 = n.z2 + (r ?? zze) } return t } function Kze(n, e, t) { var r = Et(n.currentStates, e) >= 0, i = n.style.opacity, a = r ? null : Uze(n, ["opacity"], e, { opacity: 1 }); t = t || {}; var o = t.style || {}; return o.opacity == null && (t = be({}, t), o = be({ opacity: r ? i : a.opacity * .1 }, o), t.style = o), t } function RM(n, e) { var t = this.states[n]; if (this.style) { if (n === "emphasis") return Gze(this, n, e, t); if (n === "blur") return Kze(this, n, t); if (n === "select") return Wze(this, n, t) } return t } function Gh(n) { n.stateProxy = RM; var e = n.getTextContent(), t = n.getTextGuideLine(); e && (e.stateProxy = RM), t && (t.stateProxy = RM) } function SV(n, e) { !Ote(n, e) && !n.__highByOuter && Vc(n, Tte) } function TV(n, e) { !Ote(n, e) && !n.__highByOuter && Vc(n, kte) } function Pc(n, e) { n.__highByOuter |= 1 << (e || 0), Vc(n, Tte) } function Ic(n, e) { !(n.__highByOuter &= ~(1 << (e || 0))) && Vc(n, kte) } function Ate(n) { Vc(n, BN) } function $N(n) { Vc(n, Cte) } function Ete(n) { Vc(n, Vze) } function Mte(n) { Vc(n, Hze) } function Ote(n, e) { return n.__highDownSilentOnTouch && e.zrByTouch } function Dte(n) { var e = n.getModel(), t = [], r = []; e.eachComponent(function (i, a) { var o = RN(a), s = i === "series", l = s ? n.getViewOfSeriesModel(a) : n.getViewOfComponentModel(a); !s && r.push(l), o.isBlured && (l.group.traverse(function (c) { Cte(c) }), s && t.push(a)), o.isBlured = !1 }), $(r, function (i) { i && i.toggleBlurSeries && i.toggleBlurSeries(t, !1, e) }) } function YP(n, e, t, r) { var i = r.getModel(); t = t || "coordinateSystem"; function a(c, u) { for (var d = 0; d < u.length; d++) { var f = c.getItemGraphicEl(u[d]); f && $N(f) } } if (n != null && !(!e || e === "none")) { var o = i.getSeriesByIndex(n), s = o.coordinateSystem; s && s.master && (s = s.master); var l = []; i.eachSeries(function (c) { var u = o === c, d = c.coordinateSystem; d && d.master && (d = d.master); var f = d && s ? d === s : u; if (!(t === "series" && !u || t === "coordinateSystem" && !f || e === "series" && u)) { var h = r.getViewOfSeriesModel(c); if (h.group.traverse(function (g) { g.__highByOuter && u && e === "self" || BN(g) }), Ii(e)) a(c.getData(), e); else if (ot(e)) for (var p = Bt(e), m = 0; m < p.length; m++)a(c.getData(p[m]), e[p[m]]); l.push(c), RN(c).isBlured = !0 } }), i.eachComponent(function (c, u) { if (c !== "series") { var d = r.getViewOfComponentModel(u); d && d.toggleBlurSeries && d.toggleBlurSeries(l, !0, i) } }) } } function ZP(n, e, t) { if (!(n == null || e == null)) { var r = t.getModel().getComponent(n, e); if (r) { RN(r).isBlured = !0; var i = t.getViewOfComponentModel(r); !i || !i.focusBlurEnabled || i.group.traverse(function (a) { BN(a) }) } } } function qze(n, e, t) { var r = n.seriesIndex, i = n.getData(e.dataType); if (i) { var a = Hh(i, e); a = (ke(a) ? a[0] : a) || 0; var o = i.getItemGraphicEl(a); if (!o) for (var s = i.count(), l = 0; !o && l < s;)o = i.getItemGraphicEl(l++); if (o) { var c = pt(o); YP(r, c.focus, c.blurScope, t) } else { var u = n.get(["emphasis", "focus"]), d = n.get(["emphasis", "blurScope"]); u != null && YP(r, u, d, t) } } } function FN(n, e, t, r) { var i = { focusSelf: !1, dispatchers: null }; if (n == null || n === "series" || e == null || t == null) return i; var a = r.getModel().getComponent(n, e); if (!a) return i; var o = r.getViewOfComponentModel(a); if (!o || !o.findHighDownDispatchers) return i; for (var s = o.findHighDownDispatchers(t), l, c = 0; c < s.length; c++)if (pt(s[c]).focus === "self") { l = !0; break } return { focusSelf: l, dispatchers: s } } function Yze(n, e, t) { var r = pt(n), i = FN(r.componentMainType, r.componentIndex, r.componentHighDownName, t), a = i.dispatchers, o = i.focusSelf; a ? (o && ZP(r.componentMainType, r.componentIndex, t), $(a, function (s) { return SV(s, e) })) : (YP(r.seriesIndex, r.focus, r.blurScope, t), r.focus === "self" && ZP(r.componentMainType, r.componentIndex, t), SV(n, e)) } function Zze(n, e, t) { Dte(t); var r = pt(n), i = FN(r.componentMainType, r.componentIndex, r.componentHighDownName, t).dispatchers; i ? $(i, function (a) { return TV(a, e) }) : TV(n, e) } function Xze(n, e, t) { if (JP(e)) { var r = e.dataType, i = n.getData(r), a = Hh(i, e); ke(a) || (a = [a]), n[e.type === m0 ? "toggleSelect" : e.type === p0 ? "select" : "unselect"](a, r) } } function kV(n) { var e = n.getAllData(); $(e, function (t) { var r = t.data, i = t.type; r.eachItemGraphicEl(function (a, o) { n.isSelected(o, i) ? Ete(a) : Mte(a) }) }) } function Jze(n) { var e = []; return n.eachSeries(function (t) { var r = t.getAllData(); $(r, function (i) { i.data; var a = i.type, o = t.getSelectedDataIndices(); if (o.length > 0) { var s = { dataIndex: o, seriesIndex: t.seriesIndex }; a != null && (s.dataType = a), e.push(s) } }) }), e } function Th(n, e, t) { th(n, !0), Vc(n, Gh), XP(n, e, t) } function Qze(n) { th(n, !1) } function Qn(n, e, t, r) { r ? Qze(n) : Th(n, e, t) } function XP(n, e, t) { var r = pt(n); e != null ? (r.focus = e, r.blurScope = t) : r.focus && (r.focus = null) } var CV = ["emphasis", "blur", "select"], e6e = { itemStyle: "getItemStyle", lineStyle: "getLineStyle", areaStyle: "getAreaStyle" }; function pi(n, e, t, r) { t = t || "itemStyle"; for (var i = 0; i < CV.length; i++) { var a = CV[i], o = e.getModel([a, t]), s = n.ensureState(a); s.style = r ? r(o) : o[e6e[t]]() } } function th(n, e) { var t = e === !1, r = n; n.highDownSilentOnTouch && (r.__highDownSilentOnTouch = n.highDownSilentOnTouch), (!t || r.__highDownDispatcher) && (r.__highByOuter = r.__highByOuter || 0, r.__highDownDispatcher = !t) } function y_(n) { return !!(n && n.__highDownDispatcher) } function t6e(n, e, t) { var r = pt(n); r.componentMainType = e.mainType, r.componentIndex = e.componentIndex, r.componentHighDownName = t } function n6e(n) { var e = wV[n]; return e == null && bV <= 32 && (e = wV[n] = bV++), e } function JP(n) { var e = n.type; return e === p0 || e === nS || e === m0 } function AV(n) { var e = n.type; return e === Sh || e === tS } function r6e(n) { var e = Ste(n); e.normalFill = n.style.fill, e.normalStroke = n.style.stroke; var t = n.states.select || {}; e.selectFill = t.style && t.style.fill || null, e.selectStroke = t.style && t.style.stroke || null } var Gp = Cl.CMD, i6e = [[], [], []], EV = Math.sqrt, a6e = Math.atan2; function jte(n, e) { if (e) { var t = n.data, r = n.len(), i, a, o, s, l, c, u = Gp.M, d = Gp.C, f = Gp.L, h = Gp.R, p = Gp.A, m = Gp.Q; for (o = 0, s = 0; o < r;) { switch (i = t[o++], s = o, a = 0, i) { case u: a = 1; break; case f: a = 1; break; case d: a = 3; break; case m: a = 2; break; case p: var g = e[4], y = e[5], b = EV(e[0] * e[0] + e[1] * e[1]), w = EV(e[2] * e[2] + e[3] * e[3]), v = a6e(-e[1] / w, e[0] / b); t[o] *= b, t[o++] += g, t[o] *= w, t[o++] += y, t[o++] *= b, t[o++] *= w, t[o++] += v, t[o++] += v, o += 2, s = o; break; case h: c[0] = t[o++], c[1] = t[o++], fi(c, c, e), t[s++] = c[0], t[s++] = c[1], c[0] += t[o++], c[1] += t[o++], fi(c, c, e), t[s++] = c[0], t[s++] = c[1] }for (l = 0; l < a; l++) { var S = i6e[l]; S[0] = t[o++], S[1] = t[o++], fi(S, S, e), t[s++] = S[0], t[s++] = S[1] } } n.increaseVersion() } } var NM = Math.sqrt, Rw = Math.sin, Nw = Math.cos, Kv = Math.PI; function MV(n) { return Math.sqrt(n[0] * n[0] + n[1] * n[1]) } function QP(n, e) { return (n[0] * e[0] + n[1] * e[1]) / (MV(n) * MV(e)) } function OV(n, e) { return (n[0] * e[1] < n[1] * e[0] ? -1 : 1) * Math.acos(QP(n, e)) } function DV(n, e, t, r, i, a, o, s, l, c, u) { var d = l * (Kv / 180), f = Nw(d) * (n - t) / 2 + Rw(d) * (e - r) / 2, h = -1 * Rw(d) * (n - t) / 2 + Nw(d) * (e - r) / 2, p = f * f / (o * o) + h * h / (s * s); p > 1 && (o *= NM(p), s *= NM(p)); var m = (i === a ? -1 : 1) * NM((o * o * (s * s) - o * o * (h * h) - s * s * (f * f)) / (o * o * (h * h) + s * s * (f * f))) || 0, g = m * o * h / s, y = m * -s * f / o, b = (n + t) / 2 + Nw(d) * g - Rw(d) * y, w = (e + r) / 2 + Rw(d) * g + Nw(d) * y, v = OV([1, 0], [(f - g) / o, (h - y) / s]), S = [(f - g) / o, (h - y) / s], x = [(-1 * f - g) / o, (-1 * h - y) / s], k = OV(S, x); if (QP(S, x) <= -1 && (k = Kv), QP(S, x) >= 1 && (k = 0), k < 0) { var A = Math.round(k / Kv * 1e6) / 1e6; k = Kv * 2 + A % 2 * Kv } u.addData(c, b, w, o, s, v, k, d, a) } var o6e = /([mlvhzcqtsa])([^mlvhzcqtsa]*)/ig, s6e = /-?([0-9]*\.)?[0-9]+([eE]-?[0-9]+)?/g; function l6e(n) { var e = new Cl; if (!n) return e; var t = 0, r = 0, i = t, a = r, o, s = Cl.CMD, l = n.match(o6e); if (!l) return e; for (var c = 0; c < l.length; c++) { for (var u = l[c], d = u.charAt(0), f = void 0, h = u.match(s6e) || [], p = h.length, m = 0; m < p; m++)h[m] = parseFloat(h[m]); for (var g = 0; g < p;) { var y = void 0, b = void 0, w = void 0, v = void 0, S = void 0, x = void 0, k = void 0, A = t, C = r, E = void 0, O = void 0; switch (d) { case "l": t += h[g++], r += h[g++], f = s.L, e.addData(f, t, r); break; case "L": t = h[g++], r = h[g++], f = s.L, e.addData(f, t, r); break; case "m": t += h[g++], r += h[g++], f = s.M, e.addData(f, t, r), i = t, a = r, d = "l"; break; case "M": t = h[g++], r = h[g++], f = s.M, e.addData(f, t, r), i = t, a = r, d = "L"; break; case "h": t += h[g++], f = s.L, e.addData(f, t, r); break; case "H": t = h[g++], f = s.L, e.addData(f, t, r); break; case "v": r += h[g++], f = s.L, e.addData(f, t, r); break; case "V": r = h[g++], f = s.L, e.addData(f, t, r); break; case "C": f = s.C, e.addData(f, h[g++], h[g++], h[g++], h[g++], h[g++], h[g++]), t = h[g - 2], r = h[g - 1]; break; case "c": f = s.C, e.addData(f, h[g++] + t, h[g++] + r, h[g++] + t, h[g++] + r, h[g++] + t, h[g++] + r), t += h[g - 2], r += h[g - 1]; break; case "S": y = t, b = r, E = e.len(), O = e.data, o === s.C && (y += t - O[E - 4], b += r - O[E - 3]), f = s.C, A = h[g++], C = h[g++], t = h[g++], r = h[g++], e.addData(f, y, b, A, C, t, r); break; case "s": y = t, b = r, E = e.len(), O = e.data, o === s.C && (y += t - O[E - 4], b += r - O[E - 3]), f = s.C, A = t + h[g++], C = r + h[g++], t += h[g++], r += h[g++], e.addData(f, y, b, A, C, t, r); break; case "Q": A = h[g++], C = h[g++], t = h[g++], r = h[g++], f = s.Q, e.addData(f, A, C, t, r); break; case "q": A = h[g++] + t, C = h[g++] + r, t += h[g++], r += h[g++], f = s.Q, e.addData(f, A, C, t, r); break; case "T": y = t, b = r, E = e.len(), O = e.data, o === s.Q && (y += t - O[E - 4], b += r - O[E - 3]), t = h[g++], r = h[g++], f = s.Q, e.addData(f, y, b, t, r); break; case "t": y = t, b = r, E = e.len(), O = e.data, o === s.Q && (y += t - O[E - 4], b += r - O[E - 3]), t += h[g++], r += h[g++], f = s.Q, e.addData(f, y, b, t, r); break; case "A": w = h[g++], v = h[g++], S = h[g++], x = h[g++], k = h[g++], A = t, C = r, t = h[g++], r = h[g++], f = s.A, DV(A, C, t, r, x, k, w, v, S, f, e); break; case "a": w = h[g++], v = h[g++], S = h[g++], x = h[g++], k = h[g++], A = t, C = r, t += h[g++], r += h[g++], f = s.A, DV(A, C, t, r, x, k, w, v, S, f, e); break } } (d === "z" || d === "Z") && (f = s.Z, e.addData(f), t = i, r = a), o = f } return e.toStatic(), e } var Pte = function (n) { te(e, n); function e() { return n !== null && n.apply(this, arguments) || this } return e.prototype.applyTransform = function (t) { }, e }(Nt); function Ite(n) { return n.setData != null } function Lte(n, e) { var t = l6e(n), r = be({}, e); return r.buildPath = function (i) { if (Ite(i)) { i.setData(t.data); var a = i.getContext(); a && i.rebuildPath(a, 1) } else { var a = i; t.rebuildPath(a, 1) } }, r.applyTransform = function (i) { jte(t, i), this.dirtyShape() }, r } function Rte(n, e) { return new Pte(Lte(n, e)) } function c6e(n, e) { var t = Lte(n, e), r = function (i) { te(a, i); function a(o) { var s = i.call(this, o) || this; return s.applyTransform = t.applyTransform, s.buildPath = t.buildPath, s } return a }(Pte); return r } function u6e(n, e) { for (var t = [], r = n.length, i = 0; i < r; i++) { var a = n[i]; t.push(a.getUpdatedPathProxy(!0)) } var o = new Nt(e); return o.createPathProxy(), o.buildPath = function (s) { if (Ite(s)) { s.appendPath(t); var l = s.getContext(); l && s.rebuildPath(l, 1) } }, o } function zN(n, e) { e = e || {}; var t = new Nt; return n.shape && t.setShape(n.shape), t.setStyle(n.style), e.bakeTransform ? jte(t.path, n.getComputedTransform()) : e.toLocal ? t.setLocalTransform(n.getComputedTransform()) : t.copyTransform(n), t.buildPath = n.buildPath, t.applyTransform = t.applyTransform, t.z = n.z, t.z2 = n.z2, t.zlevel = n.zlevel, t } var d6e = function () { function n() { this.cx = 0, this.cy = 0, this.r = 0 } return n }(), Nte = function (n) { te(e, n); function e(t) { return n.call(this, t) || this } return e.prototype.getDefaultShape = function () { return new d6e }, e.prototype.buildPath = function (t, r) { t.moveTo(r.cx + r.r, r.cy), t.arc(r.cx, r.cy, r.r, 0, Math.PI * 2) }, e }(Nt); Nte.prototype.type = "circle"; const Ud = Nte; var f6e = function () { function n() { this.cx = 0, this.cy = 0, this.rx = 0, this.ry = 0 } return n }(), Bte = function (n) { te(e, n); function e(t) { return n.call(this, t) || this } return e.prototype.getDefaultShape = function () { return new f6e }, e.prototype.buildPath = function (t, r) { var i = .5522848, a = r.cx, o = r.cy, s = r.rx, l = r.ry, c = s * i, u = l * i; t.moveTo(a - s, o), t.bezierCurveTo(a - s, o - u, a - c, o - l, a, o - l), t.bezierCurveTo(a + c, o - l, a + s, o - u, a + s, o), t.bezierCurveTo(a + s, o + u, a + c, o + l, a, o + l), t.bezierCurveTo(a - c, o + l, a - s, o + u, a - s, o), t.closePath() }, e }(Nt); Bte.prototype.type = "ellipse"; const VN = Bte; var $te = Math.PI, BM = $te * 2, xf = Math.sin, Wp = Math.cos, h6e = Math.acos, _i = Math.atan2, jV = Math.abs, g0 = Math.sqrt, Cy = Math.max, Fs = Math.min, es = 1e-4; function p6e(n, e, t, r, i, a, o, s) { var l = t - n, c = r - e, u = o - i, d = s - a, f = d * l - u * c; if (!(f * f < es)) return f = (u * (e - a) - d * (n - i)) / f, [n + f * l, e + f * c] } function Bw(n, e, t, r, i, a, o) { var s = n - t, l = e - r, c = (o ? a : -a) / g0(s * s + l * l), u = c * l, d = -c * s, f = n + u, h = e + d, p = t + u, m = r + d, g = (f + p) / 2, y = (h + m) / 2, b = p - f, w = m - h, v = b * b + w * w, S = i - a, x = f * m - p * h, k = (w < 0 ? -1 : 1) * g0(Cy(0, S * S * v - x * x)), A = (x * w - b * k) / v, C = (-x * b - w * k) / v, E = (x * w + b * k) / v, O = (-x * b + w * k) / v, j = A - g, I = C - y, L = E - g, R = O - y; return j * j + I * I > L * L + R * R && (A = E, C = O), { cx: A, cy: C, x0: -u, y0: -d, x1: A * (i / S - 1), y1: C * (i / S - 1) } } function m6e(n) { var e; if (ke(n)) { var t = n.length; if (!t) return n; t === 1 ? e = [n[0], n[0], 0, 0] : t === 2 ? e = [n[0], n[0], n[1], n[1]] : t === 3 ? e = n.concat(n[2]) : e = n } else e = [n, n, n, n]; return e } function g6e(n, e) { var t, r = Cy(e.r, 0), i = Cy(e.r0 || 0, 0), a = r > 0, o = i > 0; if (!(!a && !o)) { if (a || (r = i, i = 0), i > r) { var s = r; r = i, i = s } var l = e.startAngle, c = e.endAngle; if (!(isNaN(l) || isNaN(c))) { var u = e.cx, d = e.cy, f = !!e.clockwise, h = jV(c - l), p = h > BM && h % BM; if (p > es && (h = p), !(r > es)) n.moveTo(u, d); else if (h > BM - es) n.moveTo(u + r * Wp(l), d + r * xf(l)), n.arc(u, d, r, l, c, !f), i > es && (n.moveTo(u + i * Wp(c), d + i * xf(c)), n.arc(u, d, i, c, l, f)); else { var m = void 0, g = void 0, y = void 0, b = void 0, w = void 0, v = void 0, S = void 0, x = void 0, k = void 0, A = void 0, C = void 0, E = void 0, O = void 0, j = void 0, I = void 0, L = void 0, R = r * Wp(l), D = r * xf(l), P = i * Wp(c), B = i * xf(c), F = h > es; if (F) { var K = e.cornerRadius; K && (t = m6e(K), m = t[0], g = t[1], y = t[2], b = t[3]); var V = jV(r - i) / 2; if (w = Fs(V, y), v = Fs(V, b), S = Fs(V, m), x = Fs(V, g), C = k = Cy(w, v), E = A = Cy(S, x), (k > es || A > es) && (O = r * Wp(c), j = r * xf(c), I = i * Wp(l), L = i * xf(l), h < $te)) { var W = p6e(R, D, I, L, O, j, P, B); if (W) { var J = R - W[0], ie = D - W[1], le = O - W[0], De = j - W[1], ae = 1 / xf(h6e((J * le + ie * De) / (g0(J * J + ie * ie) * g0(le * le + De * De))) / 2), pe = g0(W[0] * W[0] + W[1] * W[1]); C = Fs(k, (r - pe) / (ae + 1)), E = Fs(A, (i - pe) / (ae - 1)) } } } if (!F) n.moveTo(u + R, d + D); else if (C > es) { var se = Fs(y, C), ge = Fs(b, C), _e = Bw(I, L, R, D, r, se, f), je = Bw(O, j, P, B, r, ge, f); n.moveTo(u + _e.cx + _e.x0, d + _e.cy + _e.y0), C < k && se === ge ? n.arc(u + _e.cx, d + _e.cy, C, _i(_e.y0, _e.x0), _i(je.y0, je.x0), !f) : (se > 0 && n.arc(u + _e.cx, d + _e.cy, se, _i(_e.y0, _e.x0), _i(_e.y1, _e.x1), !f), n.arc(u, d, r, _i(_e.cy + _e.y1, _e.cx + _e.x1), _i(je.cy + je.y1, je.cx + je.x1), !f), ge > 0 && n.arc(u + je.cx, d + je.cy, ge, _i(je.y1, je.x1), _i(je.y0, je.x0), !f)) } else n.moveTo(u + R, d + D), n.arc(u, d, r, l, c, !f); if (!(i > es) || !F) n.lineTo(u + P, d + B); else if (E > es) { var se = Fs(m, E), ge = Fs(g, E), _e = Bw(P, B, O, j, i, -ge, f), je = Bw(R, D, I, L, i, -se, f); n.lineTo(u + _e.cx + _e.x0, d + _e.cy + _e.y0), E < A && se === ge ? n.arc(u + _e.cx, d + _e.cy, E, _i(_e.y0, _e.x0), _i(je.y0, je.x0), !f) : (ge > 0 && n.arc(u + _e.cx, d + _e.cy, ge, _i(_e.y0, _e.x0), _i(_e.y1, _e.x1), !f), n.arc(u, d, i, _i(_e.cy + _e.y1, _e.cx + _e.x1), _i(je.cy + je.y1, je.cx + je.x1), f), se > 0 && n.arc(u + je.cx, d + je.cy, se, _i(je.y1, je.x1), _i(je.y0, je.x0), !f)) } else n.lineTo(u + P, d + B), n.arc(u, d, i, c, l, f) } n.closePath() } } } var v6e = function () { function n() { this.cx = 0, this.cy = 0, this.r0 = 0, this.r = 0, this.startAngle = 0, this.endAngle = Math.PI * 2, this.clockwise = !0, this.cornerRadius = 0 } return n }(), Fte = function (n) { te(e, n); function e(t) { return n.call(this, t) || this } return e.prototype.getDefaultShape = function () { return new v6e }, e.prototype.buildPath = function (t, r) { g6e(t, r) }, e.prototype.isZeroArea = function () { return this.shape.startAngle === this.shape.endAngle || this.shape.r === this.shape.r0 }, e }(Nt); Fte.prototype.type = "sector"; const Ca = Fte; var y6e = function () { function n() { this.cx = 0, this.cy = 0, this.r = 0, this.r0 = 0 } return n }(), zte = function (n) { te(e, n); function e(t) { return n.call(this, t) || this } return e.prototype.getDefaultShape = function () { return new y6e }, e.prototype.buildPath = function (t, r) { var i = r.cx, a = r.cy, o = Math.PI * 2; t.moveTo(i + r.r, a), t.arc(i, a, r.r, 0, o, !1), t.moveTo(i + r.r0, a), t.arc(i, a, r.r0, 0, o, !0) }, e }(Nt); zte.prototype.type = "ring"; const rC = zte; function _6e(n, e, t, r) { var i = [], a = [], o = [], s = [], l, c, u, d; if (r) { u = [1 / 0, 1 / 0], d = [-1 / 0, -1 / 0]; for (var f = 0, h = n.length; f < h; f++)Uu(u, u, n[f]), Gu(d, d, n[f]); Uu(u, u, r[0]), Gu(d, d, r[1]) } for (var f = 0, h = n.length; f < h; f++) { var p = n[f]; if (t) l = n[f ? f - 1 : h - 1], c = n[(f + 1) % h]; else if (f === 0 || f === h - 1) { i.push(_c(n[f])); continue } else l = n[f - 1], c = n[f + 1]; Qf(a, c, l), Kx(a, a, e); var m = SP(p, l), g = SP(p, c), y = m + g; y !== 0 && (m /= y, g /= y), Kx(o, a, -m), Kx(s, a, g); var b = k6([], p, o), w = k6([], p, s); r && (Gu(b, b, u), Uu(b, b, d), Gu(w, w, u), Uu(w, w, d)), i.push(b), i.push(w) } return t && i.push(i.shift()), i } function Vte(n, e, t) { var r = e.smooth, i = e.points; if (i && i.length >= 2) { if (r) { var a = _6e(i, r, t, e.smoothConstraint); n.moveTo(i[0][0], i[0][1]); for (var o = i.length, s = 0; s < (t ? o : o - 1); s++) { var l = a[s * 2], c = a[s * 2 + 1], u = i[(s + 1) % o]; n.bezierCurveTo(l[0], l[1], c[0], c[1], u[0], u[1]) } } else { n.moveTo(i[0][0], i[0][1]); for (var s = 1, d = i.length; s < d; s++)n.lineTo(i[s][0], i[s][1]) } t && n.closePath() } } var b6e = function () { function n() { this.points = null, this.smooth = 0, this.smoothConstraint = null } return n }(), Hte = function (n) { te(e, n); function e(t) { return n.call(this, t) || this } return e.prototype.getDefaultShape = function () { return new b6e }, e.prototype.buildPath = function (t, r) { Vte(t, r, !0) }, e }(Nt); Hte.prototype.type = "polygon"; const Aa = Hte; var w6e = function () { function n() { this.points = null, this.percent = 1, this.smooth = 0, this.smoothConstraint = null } return n }(), Ute = function (n) { te(e, n); function e(t) { return n.call(this, t) || this } return e.prototype.getDefaultStyle = function () { return { stroke: "#000", fill: null } }, e.prototype.getDefaultShape = function () { return new w6e }, e.prototype.buildPath = function (t, r) { Vte(t, r, !1) }, e }(Nt); Ute.prototype.type = "polyline"; const Ea = Ute; var x6e = {}, S6e = function () { function n() { this.x1 = 0, this.y1 = 0, this.x2 = 0, this.y2 = 0, this.percent = 1 } return n }(), Gte = function (n) { te(e, n); function e(t) { return n.call(this, t) || this } return e.prototype.getDefaultStyle = function () { return { stroke: "#000", fill: null } }, e.prototype.getDefaultShape = function () { return new S6e }, e.prototype.buildPath = function (t, r) { var i, a, o, s; if (this.subPixelOptimize) { var l = vte(x6e, r, this.style); i = l.x1, a = l.y1, o = l.x2, s = l.y2 } else i = r.x1, a = r.y1, o = r.x2, s = r.y2; var c = r.percent; c !== 0 && (t.moveTo(i, a), c < 1 && (o = i * (1 - c) + o * c, s = a * (1 - c) + s * c), t.lineTo(o, s)) }, e.prototype.pointAt = function (t) { var r = this.shape; return [r.x1 * (1 - t) + r.x2 * t, r.y1 * (1 - t) + r.y2 * t] }, e }(Nt); Gte.prototype.type = "line"; const Jr = Gte; var fa = [], T6e = function () { function n() { this.x1 = 0, this.y1 = 0, this.x2 = 0, this.y2 = 0, this.cpx1 = 0, this.cpy1 = 0, this.percent = 1 } return n }(); function PV(n, e, t) { var r = n.cpx2, i = n.cpy2; return r != null || i != null ? [(t ? N6 : Nr)(n.x1, n.cpx1, n.cpx2, n.x2, e), (t ? N6 : Nr)(n.y1, n.cpy1, n.cpy2, n.y2, e)] : [(t ? MP : qr)(n.x1, n.cpx1, n.x2, e), (t ? MP : qr)(n.y1, n.cpy1, n.y2, e)] } var Wte = function (n) { te(e, n); function e(t) { return n.call(this, t) || this } return e.prototype.getDefaultStyle = function () { return { stroke: "#000", fill: null } }, e.prototype.getDefaultShape = function () { return new T6e }, e.prototype.buildPath = function (t, r) { var i = r.x1, a = r.y1, o = r.x2, s = r.y2, l = r.cpx1, c = r.cpy1, u = r.cpx2, d = r.cpy2, f = r.percent; f !== 0 && (t.moveTo(i, a), u == null || d == null ? (f < 1 && (d_(i, l, o, f, fa), l = fa[1], o = fa[2], d_(a, c, s, f, fa), c = fa[1], s = fa[2]), t.quadraticCurveTo(l, c, o, s)) : (f < 1 && (Cd(i, l, u, o, f, fa), l = fa[1], u = fa[2], o = fa[3], Cd(a, c, d, s, f, fa), c = fa[1], d = fa[2], s = fa[3]), t.bezierCurveTo(l, c, u, d, o, s))) }, e.prototype.pointAt = function (t) { return PV(this.shape, t, !1) }, e.prototype.tangentAt = function (t) { var r = PV(this.shape, t, !0); return Kg(r, r) }, e }(Nt); Wte.prototype.type = "bezier-curve"; const iC = Wte; var k6e = function () { function n() { this.cx = 0, this.cy = 0, this.r = 0, this.startAngle = 0, this.endAngle = Math.PI * 2, this.clockwise = !0 } return n }(), Kte = function (n) { te(e, n); function e(t) { return n.call(this, t) || this } return e.prototype.getDefaultStyle = function () { return { stroke: "#000", fill: null } }, e.prototype.getDefaultShape = function () { return new k6e }, e.prototype.buildPath = function (t, r) { var i = r.cx, a = r.cy, o = Math.max(r.r, 0), s = r.startAngle, l = r.endAngle, c = r.clockwise, u = Math.cos(s), d = Math.sin(s); t.moveTo(u * o + i, d * o + a), t.arc(i, a, o, s, l, !c) }, e }(Nt); Kte.prototype.type = "arc"; const HN = Kte; var C6e = function (n) { te(e, n); function e() { var t = n !== null && n.apply(this, arguments) || this; return t.type = "compound", t } return e.prototype._updatePathDirty = function () { for (var t = this.shape.paths, r = this.shapeChanged(), i = 0; i < t.length; i++)r = r || t[i].shapeChanged(); r && this.dirtyShape() }, e.prototype.beforeBrush = function () { this._updatePathDirty(); for (var t = this.shape.paths || [], r = this.getGlobalScale(), i = 0; i < t.length; i++)t[i].path || t[i].createPathProxy(), t[i].path.setScale(r[0], r[1], t[i].segmentIgnoreThreshold) }, e.prototype.buildPath = function (t, r) { for (var i = r.paths || [], a = 0; a < i.length; a++)i[a].buildPath(t, i[a].shape, !0) }, e.prototype.afterBrush = function () { for (var t = this.shape.paths || [], r = 0; r < t.length; r++)t[r].pathUpdated() }, e.prototype.getBoundingRect = function () { return this._updatePathDirty.call(this), Nt.prototype.getBoundingRect.call(this) }, e }(Nt); const UN = C6e; var A6e = function () { function n(e) { this.colorStops = e || [] } return n.prototype.addColorStop = function (e, t) { this.colorStops.push({ offset: e, color: t }) }, n }(); const qte = A6e; var E6e = function (n) { te(e, n); function e(t, r, i, a, o, s) { var l = n.call(this, o) || this; return l.x = t ?? 0, l.y = r ?? 0, l.x2 = i ?? 1, l.y2 = a ?? 0, l.type = "linear", l.global = s || !1, l } return e }(qte); const Sb = E6e; var M6e = function (n) { te(e, n); function e(t, r, i, a, o) { var s = n.call(this, a) || this; return s.x = t ?? .5, s.y = r ?? .5, s.r = i ?? .5, s.type = "radial", s.global = o || !1, s } return e }(qte); const Yte = M6e; var Sf = [0, 0], Tf = [0, 0], $w = new St, Fw = new St, O6e = function () { function n(e, t) { this._corners = [], this._axes = [], this._origin = [0, 0]; for (var r = 0; r < 4; r++)this._corners[r] = new St; for (var r = 0; r < 2; r++)this._axes[r] = new St; e && this.fromBoundingRect(e, t) } return n.prototype.fromBoundingRect = function (e, t) { var r = this._corners, i = this._axes, a = e.x, o = e.y, s = a + e.width, l = o + e.height; if (r[0].set(a, o), r[1].set(s, o), r[2].set(s, l), r[3].set(a, l), t) for (var c = 0; c < 4; c++)r[c].transform(t); St.sub(i[0], r[1], r[0]), St.sub(i[1], r[3], r[0]), i[0].normalize(), i[1].normalize(); for (var c = 0; c < 2; c++)this._origin[c] = i[c].dot(r[0]) }, n.prototype.intersect = function (e, t) { var r = !0, i = !t; return $w.set(1 / 0, 1 / 0), Fw.set(0, 0), !this._intersectCheckOneSide(this, e, $w, Fw, i, 1) && (r = !1, i) || !this._intersectCheckOneSide(e, this, $w, Fw, i, -1) && (r = !1, i) || i || St.copy(t, r ? $w : Fw), r }, n.prototype._intersectCheckOneSide = function (e, t, r, i, a, o) { for (var s = !0, l = 0; l < 2; l++) { var c = this._axes[l]; if (this._getProjMinMaxOnAxis(l, e._corners, Sf), this._getProjMinMaxOnAxis(l, t._corners, Tf), Sf[1] < Tf[0] || Sf[0] > Tf[1]) { if (s = !1, a) return s; var u = Math.abs(Tf[0] - Sf[1]), d = Math.abs(Sf[0] - Tf[1]); Math.min(u, d) > i.len() && (u < d ? St.scale(i, c, -u * o) : St.scale(i, c, d * o)) } else if (r) { var u = Math.abs(Tf[0] - Sf[1]), d = Math.abs(Sf[0] - Tf[1]); Math.min(u, d) < r.len() && (u < d ? St.scale(r, c, u * o) : St.scale(r, c, -d * o)) } } return s }, n.prototype._getProjMinMaxOnAxis = function (e, t, r) { for (var i = this._axes[e], a = this._origin, o = t[0].dot(i) + a[e], s = o, l = o, c = 1; c < t.length; c++) { var u = t[c].dot(i) + a[e]; s = Math.min(u, s), l = Math.max(u, l) } r[0] = s, r[1] = l }, n }(); const J2 = O6e; var D6e = [], j6e = function (n) { te(e, n); function e() { var t = n !== null && n.apply(this, arguments) || this; return t.notClear = !0, t.incremental = !0, t._displayables = [], t._temporaryDisplayables = [], t._cursor = 0, t } return e.prototype.traverse = function (t, r) { t.call(r, this) }, e.prototype.useStyle = function () { this.style = {} }, e.prototype.getCursor = function () { return this._cursor }, e.prototype.innerAfterBrush = function () { this._cursor = this._displayables.length }, e.prototype.clearDisplaybles = function () { this._displayables = [], this._temporaryDisplayables = [], this._cursor = 0, this.markRedraw(), this.notClear = !1 }, e.prototype.clearTemporalDisplayables = function () { this._temporaryDisplayables = [] }, e.prototype.addDisplayable = function (t, r) { r ? this._temporaryDisplayables.push(t) : this._displayables.push(t), this.markRedraw() }, e.prototype.addDisplayables = function (t, r) { r = r || !1; for (var i = 0; i < t.length; i++)this.addDisplayable(t[i], r) }, e.prototype.getDisplayables = function () { return this._displayables }, e.prototype.getTemporalDisplayables = function () { return this._temporaryDisplayables }, e.prototype.eachPendingDisplayable = function (t) { for (var r = this._cursor; r < this._displayables.length; r++)t && t(this._displayables[r]); for (var r = 0; r < this._temporaryDisplayables.length; r++)t && t(this._temporaryDisplayables[r]) }, e.prototype.update = function () { this.updateTransform(); for (var t = this._cursor; t < this._displayables.length; t++) { var r = this._displayables[t]; r.parent = this, r.update(), r.parent = null } for (var t = 0; t < this._temporaryDisplayables.length; t++) { var r = this._temporaryDisplayables[t]; r.parent = this, r.update(), r.parent = null } }, e.prototype.getBoundingRect = function () { if (!this._rect) { for (var t = new kt(1 / 0, 1 / 0, -1 / 0, -1 / 0), r = 0; r < this._displayables.length; r++) { var i = this._displayables[r], a = i.getBoundingRect().clone(); i.needLocalTransform() && a.applyTransform(i.getLocalTransform(D6e)), t.union(a) } this._rect = t } return this._rect }, e.prototype.contain = function (t, r) { var i = this.transformCoordToLocal(t, r), a = this.getBoundingRect(); if (a.contain(i[0], i[1])) for (var o = 0; o < this._displayables.length; o++) { var s = this._displayables[o]; if (s.contain(t, r)) return !0 } return !1 }, e }(Ho); const P6e = j6e; var Zte = Kt(); function Xg(n, e, t, r, i) { var a; if (e && e.ecModel) { var o = e.ecModel.getUpdatePayload(); a = o && o.animation } var s = e && e.isAnimationEnabled(), l = n === "update"; if (s) { var c = void 0, u = void 0, d = void 0; r ? (c = yt(r.duration, 200), u = yt(r.easing, "cubicOut"), d = 0) : (c = e.getShallow(l ? "animationDurationUpdate" : "animationDuration"), u = e.getShallow(l ? "animationEasingUpdate" : "animationEasing"), d = e.getShallow(l ? "animationDelayUpdate" : "animationDelay")), a && (a.duration != null && (c = a.duration), a.easing != null && (u = a.easing), a.delay != null && (d = a.delay)), tt(d) && (d = d(t, i)), tt(c) && (c = c(t)); var f = { duration: c || 0, delay: d, easing: u }; return f } else return null } function GN(n, e, t, r, i, a, o) { var s = !1, l; tt(i) ? (o = a, a = i, i = null) : ot(i) && (a = i.cb, o = i.during, s = i.isFrom, l = i.removeOpt, i = i.dataIndex); var c = n === "leave"; c || e.stopAnimation("leave"); var u = Xg(n, r, i, c ? l || {} : null, r && r.getAnimationDelayParams ? r.getAnimationDelayParams(e, i) : null); if (u && u.duration > 0) { var d = u.duration, f = u.delay, h = u.easing, p = { duration: d, delay: f || 0, easing: h, done: a, force: !!a || !!o, setToFinal: !c, scope: n, during: o }; s ? e.animateFrom(t, p) : e.animateTo(t, p) } else e.stopAnimation(), !s && e.attr(t), o && o(1), a && a() } function on(n, e, t, r, i, a) { GN("update", n, e, t, r, i, a) } function Un(n, e, t, r, i, a) { GN("enter", n, e, t, r, i, a) } function qm(n) { if (!n.__zr) return !0; for (var e = 0; e < n.animators.length; e++) { var t = n.animators[e]; if (t.scope === "leave") return !0 } return !1 } function Ad(n, e, t, r, i, a) { qm(n) || GN("leave", n, e, t, r, i, a) } function IV(n, e, t, r) { n.removeTextContent(), n.removeTextGuideLine(), Ad(n, { style: { opacity: 0 } }, e, t, r) } function __(n, e, t) { function r() { n.parent && n.parent.remove(n) } n.isGroup ? n.traverse(function (i) { i.isGroup || IV(i, e, t, r) }) : IV(n, e, t, r) } function Ms(n) { Zte(n).oldStyle = n.style } function I6e(n) { return Zte(n).oldStyle } var Q2 = Math.max, eT = Math.min, eI = {}; function L6e(n) { return Nt.extend(n) } var R6e = c6e; function N6e(n, e) { return R6e(n, e) } function js(n, e) { eI[n] = e } function WN(n) { if (eI.hasOwnProperty(n)) return eI[n] } function aC(n, e, t, r) { var i = Rte(n, e); return t && (r === "center" && (t = Jte(t, i.getBoundingRect())), Qte(i, t)), i } function Xte(n, e, t) { var r = new gi({ style: { image: n, x: e.x, y: e.y, width: e.width, height: e.height }, onload: function (i) { if (t === "center") { var a = { width: i.width, height: i.height }; r.setStyle(Jte(e, a)) } } }); return r } function Jte(n, e) { var t = e.width / e.height, r = n.height * t, i; r <= n.width ? i = n.height : (r = n.width, i = r / t); var a = n.x + n.width / 2, o = n.y + n.height / 2; return { x: a - r / 2, y: o - i / 2, width: r, height: i } } var Co = u6e; function Qte(n, e) { if (n.applyTransform) { var t = n.getBoundingRect(), r = t.calculateTransform(e); n.applyTransform(r) } } function kg(n, e) { return vte(n, n, { lineWidth: e }), n } function B6e(n) { return yte(n.shape, n.shape, n.style), n } var rS = eh; function kh(n, e) { for (var t = qk([]); n && n !== e;)bc(t, n.getLocalTransform(), t), n = n.parent; return t } function bs(n, e, t) { return e && !Ii(e) && (e = mc.getLocalTransform(e)), t && (e = qg([], e)), fi([], n, e) } function oC(n, e, t) { var r = e[4] === 0 || e[5] === 0 || e[0] === 0 ? 1 : Math.abs(2 * e[4] / e[0]), i = e[4] === 0 || e[5] === 0 || e[2] === 0 ? 1 : Math.abs(2 * e[4] / e[2]), a = [n === "left" ? -r : n === "right" ? r : 0, n === "top" ? -i : n === "bottom" ? i : 0]; return a = bs(a, e, t), Math.abs(a[0]) > Math.abs(a[1]) ? a[0] > 0 ? "right" : "left" : a[1] > 0 ? "bottom" : "top" } function LV(n) { return !n.isGroup } function $6e(n) { return n.shape != null } function Tb(n, e, t) { if (!n || !e) return; function r(o) { var s = {}; return o.traverse(function (l) { LV(l) && l.anid && (s[l.anid] = l) }), s } function i(o) { var s = { x: o.x, y: o.y, rotation: o.rotation }; return $6e(o) && (s.shape = be({}, o.shape)), s } var a = r(n); e.traverse(function (o) { if (LV(o) && o.anid) { var s = a[o.anid]; if (s) { var l = i(o); o.attr(i(s)), on(o, l, t, pt(o).dataIndex) } } }) } function ene(n, e) { return Ae(n, function (t) { var r = t[0]; r = Q2(r, e.x), r = eT(r, e.x + e.width); var i = t[1]; return i = Q2(i, e.y), i = eT(i, e.y + e.height), [r, i] }) } function F6e(n, e) { var t = Q2(n.x, e.x), r = eT(n.x + n.width, e.x + e.width), i = Q2(n.y, e.y), a = eT(n.y + n.height, e.y + e.height); if (r >= t && a >= i) return { x: t, y: i, width: r - t, height: a - i } } function kb(n, e, t) { var r = be({ rectHover: !0 }, e), i = r.style = { strokeNoScale: !0 }; if (t = t || { x: -1, y: -1, width: 2, height: 2 }, n) return n.indexOf("image://") === 0 ? (i.image = n.slice(8), rt(i, t), new gi(r)) : aC(n.replace("path://", ""), r, t, "center") } function Ay(n, e, t, r, i) { for (var a = 0, o = i[i.length - 1]; a < i.length; a++) { var s = i[a]; if (tne(n, e, t, r, s[0], s[1], o[0], o[1])) return !0; o = s } } function tne(n, e, t, r, i, a, o, s) { var l = t - n, c = r - e, u = o - i, d = s - a, f = $M(u, d, l, c); if (z6e(f)) return !1; var h = n - i, p = e - a, m = $M(h, p, l, c) / f; if (m < 0 || m > 1) return !1; var g = $M(h, p, u, d) / f; return !(g < 0 || g > 1) } function $M(n, e, t, r) { return n * r - t * e } function z6e(n) { return n <= 1e-6 && n >= -1e-6 } function ip(n) { var e = n.itemTooltipOption, t = n.componentModel, r = n.itemName, i = Fe(e) ? { formatter: e } : e, a = t.mainType, o = t.componentIndex, s = { componentType: a, name: r, $vars: ["name"] }; s[a + "Index"] = o; var l = n.formatterParamsExtra; l && $(Bt(l), function (u) { Ge(s, u) || (s[u] = l[u], s.$vars.push(u)) }); var c = pt(n.el); c.componentMainType = a, c.componentIndex = o, c.tooltipConfig = { name: r, option: rt({ content: r, encodeHTMLContent: !0, formatterParams: s }, i) } } function RV(n, e) { var t; n.isGroup && (t = e(n)), t || n.traverse(e) } function Gd(n, e) { if (n) if (ke(n)) for (var t = 0; t < n.length; t++)RV(n[t], e); else RV(n, e) } js("circle", Ud); js("ellipse", VN); js("sector", Ca); js("ring", rC); js("polygon", Aa); js("polyline", Ea); js("rect", Yt); js("line", Jr); js("bezierCurve", iC); js("arc", HN); const ap = Object.freeze(Object.defineProperty({ __proto__: null, Arc: HN, BezierCurve: iC, BoundingRect: kt, Circle: Ud, CompoundPath: UN, Ellipse: VN, Group: ft, Image: gi, IncrementalDisplayable: P6e, Line: Jr, LinearGradient: Sb, OrientedBoundingRect: J2, Path: Nt, Point: St, Polygon: Aa, Polyline: Ea, RadialGradient: Yte, Rect: Yt, Ring: rC, Sector: Ca, Text: tn, applyTransform: bs, clipPointsByRect: ene, clipRectByRect: F6e, createIcon: kb, extendPath: N6e, extendShape: L6e, getShapeClass: WN, getTransform: kh, groupTransition: Tb, initProps: Un, isElementRemoved: qm, lineLineIntersect: tne, linePolygonIntersect: Ay, makeImage: Xte, makePath: aC, mergePath: Co, registerShape: js, removeElement: Ad, removeElementWithFadeOut: __, resizePath: Qte, setTooltipConfig: ip, subPixelOptimize: rS, subPixelOptimizeLine: kg, subPixelOptimizeRect: B6e, transformDirection: oC, traverseElements: Gd, updateProps: on }, Symbol.toStringTag, { value: "Module" })); var sC = {}; function nne(n, e) { for (var t = 0; t < ra.length; t++) { var r = ra[t], i = e[r], a = n.ensureState(r); a.style = a.style || {}, a.style.text = i } var o = n.currentStates.slice(); n.clearStates(!0), n.setStyle({ text: e.normal }), n.useStates(o, !0) } function tI(n, e, t) { var r = n.labelFetcher, i = n.labelDataIndex, a = n.labelDimIndex, o = e.normal, s; r && (s = r.getFormattedLabel(i, "normal", null, a, o && o.get("formatter"), t != null ? { interpolatedValue: t } : null)), s == null && (s = tt(n.defaultText) ? n.defaultText(i, n, t) : n.defaultText); for (var l = { normal: s }, c = 0; c < ra.length; c++) { var u = ra[c], d = e[u]; l[u] = yt(r ? r.getFormattedLabel(i, u, null, a, d && d.get("formatter")) : null, s) } return l } function mi(n, e, t, r) { t = t || sC; for (var i = n instanceof tn, a = !1, o = 0; o < v_.length; o++) { var s = e[v_[o]]; if (s && s.getShallow("show")) { a = !0; break } } var l = i ? n : n.getTextContent(); if (a) { i || (l || (l = new tn, n.setTextContent(l)), n.stateProxy && (l.stateProxy = n.stateProxy)); var c = tI(t, e), u = e.normal, d = !!u.getShallow("show"), f = Ln(u, r && r.normal, t, !1, !i); f.text = c.normal, i || n.setTextConfig(tT(u, t, !1)); for (var o = 0; o < ra.length; o++) { var h = ra[o], s = e[h]; if (s) { var p = l.ensureState(h), m = !!yt(s.getShallow("show"), d); if (m !== d && (p.ignore = !m), p.style = Ln(s, r && r[h], t, !0, !i), p.style.text = c[h], !i) { var g = n.ensureState(h); g.textConfig = tT(s, t, !0) } } } l.silent = !!u.getShallow("silent"), l.style.x != null && (f.x = l.style.x), l.style.y != null && (f.y = l.style.y), l.ignore = !d, l.useStyle(f), l.dirty(), t.enableTextSetter && (Jg(l).setLabelText = function (y) { var b = tI(t, e, y); nne(l, b) }) } else l && (l.ignore = !0); n.dirty() } function Ur(n, e) { e = e || "label"; for (var t = { normal: n.getModel(e) }, r = 0; r < ra.length; r++) { var i = ra[r]; t[i] = n.getModel([i, e]) } return t } function Ln(n, e, t, r, i) { var a = {}; return V6e(a, n, t, r, i), e && be(a, e), a } function tT(n, e, t) { e = e || {}; var r = {}, i, a = n.getShallow("rotate"), o = yt(n.getShallow("distance"), t ? null : 5), s = n.getShallow("offset"); return i = n.getShallow("position") || (t ? null : "inside"), i === "outside" && (i = e.defaultOutsidePosition || "top"), i != null && (r.position = i), s != null && (r.offset = s), a != null && (a *= Math.PI / 180, r.rotation = a), o != null && (r.distance = o), r.outsideFill = n.get("color") === "inherit" ? e.inheritColor || null : "auto", r } function V6e(n, e, t, r, i) { t = t || sC; var a = e.ecModel, o = a && a.option.textStyle, s = H6e(e), l; if (s) { l = {}; for (var c in s) if (s.hasOwnProperty(c)) { var u = e.getModel(["rich", c]); FV(l[c] = {}, u, o, t, r, i, !1, !0) } } l && (n.rich = l); var d = e.get("overflow"); d && (n.overflow = d); var f = e.get("minMargin"); f != null && (n.margin = f), FV(n, e, o, t, r, i, !0, !1) } function H6e(n) { for (var e; n && n !== n.ecModel;) { var t = (n.option || sC).rich; if (t) { e = e || {}; for (var r = Bt(t), i = 0; i < r.length; i++) { var a = r[i]; e[a] = 1 } } n = n.parentModel } return e } var NV = ["fontStyle", "fontWeight", "fontSize", "fontFamily", "textShadowColor", "textShadowBlur", "textShadowOffsetX", "textShadowOffsetY"], BV = ["align", "lineHeight", "width", "height", "tag", "verticalAlign", "ellipsis"], $V = ["padding", "borderWidth", "borderRadius", "borderDashOffset", "backgroundColor", "borderColor", "shadowColor", "shadowBlur", "shadowOffsetX", "shadowOffsetY"]; function FV(n, e, t, r, i, a, o, s) { t = !i && t || sC; var l = r && r.inheritColor, c = e.getShallow("color"), u = e.getShallow("textBorderColor"), d = yt(e.getShallow("opacity"), t.opacity); (c === "inherit" || c === "auto") && (l ? c = l : c = null), (u === "inherit" || u === "auto") && (l ? u = l : u = null), a || (c = c || t.color, u = u || t.textBorderColor), c != null && (n.fill = c), u != null && (n.stroke = u); var f = yt(e.getShallow("textBorderWidth"), t.textBorderWidth); f != null && (n.lineWidth = f); var h = yt(e.getShallow("textBorderType"), t.textBorderType); h != null && (n.lineDash = h); var p = yt(e.getShallow("textBorderDashOffset"), t.textBorderDashOffset); p != null && (n.lineDashOffset = p), !i && d == null && !s && (d = r && r.defaultOpacity), d != null && (n.opacity = d), !i && !a && n.fill == null && r.inheritColor && (n.fill = r.inheritColor); for (var m = 0; m < NV.length; m++) { var g = NV[m], y = yt(e.getShallow(g), t[g]); y != null && (n[g] = y) } for (var m = 0; m < BV.length; m++) { var g = BV[m], y = e.getShallow(g); y != null && (n[g] = y) } if (n.verticalAlign == null) { var b = e.getShallow("baseline"); b != null && (n.verticalAlign = b) } if (!o || !r.disableBox) { for (var m = 0; m < $V.length; m++) { var g = $V[m], y = e.getShallow(g); y != null && (n[g] = y) } var w = e.getShallow("borderType"); w != null && (n.borderDash = w), (n.backgroundColor === "auto" || n.backgroundColor === "inherit") && l && (n.backgroundColor = l), (n.borderColor === "auto" || n.borderColor === "inherit") && l && (n.borderColor = l) } } function KN(n, e) { var t = e && e.getModel("textStyle"); return ps([n.fontStyle || t && t.getShallow("fontStyle") || "", n.fontWeight || t && t.getShallow("fontWeight") || "", (n.fontSize || t && t.getShallow("fontSize") || 12) + "px", n.fontFamily || t && t.getShallow("fontFamily") || "sans-serif"].join(" ")) } var Jg = Kt(); function rne(n, e, t, r) { if (n) { var i = Jg(n); i.prevValue = i.value, i.value = t; var a = e.normal; i.valueAnimation = a.get("valueAnimation"), i.valueAnimation && (i.precision = a.get("precision"), i.defaultInterpolatedText = r, i.statesModels = e) } } function ine(n, e, t, r, i) { var a = Jg(n); if (!a.valueAnimation || a.prevValue === a.value) return; var o = a.defaultInterpolatedText, s = yt(a.interpolatedValue, a.prevValue), l = a.value; function c(u) { var d = ste(t, a.precision, s, l, u); a.interpolatedValue = u === 1 ? null : d; var f = tI({ labelDataIndex: e, labelFetcher: i, defaultText: o ? o(d) : d + "" }, a.statesModels, d); nne(n, f) } n.percent = 0, (a.prevValue == null ? Un : on)(n, { percent: 1 }, r, e, null, c) } var U6e = ["textStyle", "color"], FM = ["fontStyle", "fontWeight", "fontSize", "fontFamily", "padding", "lineHeight", "rich", "width", "height", "overflow"], zM = new tn, G6e = function () { function n() { } return n.prototype.getTextColor = function (e) { var t = this.ecModel; return this.getShallow("color") || (!e && t ? t.get(U6e) : null) }, n.prototype.getFont = function () { return KN({ fontStyle: this.getShallow("fontStyle"), fontWeight: this.getShallow("fontWeight"), fontSize: this.getShallow("fontSize"), fontFamily: this.getShallow("fontFamily") }, this.ecModel) }, n.prototype.getTextRect = function (e) { for (var t = { text: e, verticalAlign: this.getShallow("verticalAlign") || this.getShallow("baseline") }, r = 0; r < FM.length; r++)t[FM[r]] = this.getShallow(FM[r]); return zM.useStyle(t), zM.update(), zM.getBoundingRect() }, n }(); const W6e = G6e; var ane = [["lineWidth", "width"], ["stroke", "color"], ["opacity"], ["shadowBlur"], ["shadowOffsetX"], ["shadowOffsetY"], ["shadowColor"], ["lineDash", "type"], ["lineDashOffset", "dashOffset"], ["lineCap", "cap"], ["lineJoin", "join"], ["miterLimit"]], K6e = Uh(ane), q6e = function () { function n() { } return n.prototype.getLineStyle = function (e) { return K6e(this, e) }, n }(), one = [["fill", "color"], ["stroke", "borderColor"], ["lineWidth", "borderWidth"], ["opacity"], ["shadowBlur"], ["shadowOffsetX"], ["shadowOffsetY"], ["shadowColor"], ["lineDash", "borderType"], ["lineDashOffset", "borderDashOffset"], ["lineCap", "borderCap"], ["lineJoin", "borderJoin"], ["miterLimit", "borderMiterLimit"]], Y6e = Uh(one), Z6e = function () { function n() { } return n.prototype.getItemStyle = function (e, t) { return Y6e(this, e, t) }, n }(), op = function () { function n(e, t, r) { this.parentModel = t, this.ecModel = r, this.option = e } return n.prototype.init = function (e, t, r) { }, n.prototype.mergeOption = function (e, t) { xt(this.option, e, !0) }, n.prototype.get = function (e, t) { return e == null ? this.option : this._doGet(this.parsePath(e), !t && this.parentModel) }, n.prototype.getShallow = function (e, t) { var r = this.option, i = r == null ? r : r[e]; if (i == null && !t) { var a = this.parentModel; a && (i = a.getShallow(e)) } return i }, n.prototype.getModel = function (e, t) { var r = e != null, i = r ? this.parsePath(e) : null, a = r ? this._doGet(i) : this.option; return t = t || this.parentModel && this.parentModel.getModel(this.resolveParentPath(i)), new n(a, t, this.ecModel) }, n.prototype.isEmpty = function () { return this.option == null }, n.prototype.restoreData = function () { }, n.prototype.clone = function () { var e = this.constructor; return new e(lt(this.option)) }, n.prototype.parsePath = function (e) { return typeof e == "string" ? e.split(".") : e }, n.prototype.resolveParentPath = function (e) { return e }, n.prototype.isAnimationEnabled = function () { if (!en.node && this.option) { if (this.option.animation != null) return !!this.option.animation; if (this.parentModel) return this.parentModel.isAnimationEnabled() } }, n.prototype._doGet = function (e, t) { var r = this.option; if (!e) return r; for (var i = 0; i < e.length && !(e[i] && (r = r && typeof r == "object" ? r[e[i]] : null, r == null)); i++); return r == null && t && (r = t._doGet(this.resolveParentPath(e), t.parentModel)), r }, n }(); PN(op); ZFe(op); Cr(op, q6e); Cr(op, Z6e); Cr(op, tze); Cr(op, W6e); const Rn = op; var X6e = Math.round(Math.random() * 10); function Qg(n) { return [n || "", X6e++].join("_") } function J6e(n) { var e = {}; n.registerSubTypeDefaulter = function (t, r) { var i = sl(t); e[i.main] = r }, n.determineSubType = function (t, r) { var i = r.type; if (!i) { var a = sl(t).main; n.hasSubTypes(t) && e[a] && (i = e[a](r)) } return i } } function Q6e(n, e) { n.topologicalTravel = function (a, o, s, l) { if (!a.length) return; var c = t(o), u = c.graph, d = c.noEntryList, f = {}; for ($(a, function (b) { f[b] = !0 }); d.length;) { var h = d.pop(), p = u[h], m = !!f[h]; m && (s.call(l, h, p.originalDeps.slice()), delete f[h]), $(p.successor, m ? y : g) } $(f, function () { var b = ""; throw new Error(b) }); function g(b) { u[b].entryCount--, u[b].entryCount === 0 && d.push(b) } function y(b) { f[b] = !0, g(b) } }; function t(a) { var o = {}, s = []; return $(a, function (l) { var c = r(o, l), u = c.originalDeps = e(l), d = i(u, a); c.entryCount = d.length, c.entryCount === 0 && s.push(l), $(d, function (f) { Et(c.predecessor, f) < 0 && c.predecessor.push(f); var h = r(o, f); Et(h.successor, f) < 0 && h.successor.push(l) }) }), { graph: o, noEntryList: s } } function r(a, o) { return a[o] || (a[o] = { predecessor: [], successor: [] }), a[o] } function i(a, o) { var s = []; return $(a, function (l) { Et(o, l) >= 0 && s.push(l) }), s } } function Wd(n, e) { return xt(xt({}, n, !0), e, !0) } const eVe = { time: { month: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"], monthAbbr: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"], dayOfWeek: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"], dayOfWeekAbbr: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"] }, legend: { selector: { all: "All", inverse: "Inv" } }, toolbox: { brush: { title: { rect: "Box Select", polygon: "Lasso Select", lineX: "Horizontally Select", lineY: "Vertically Select", keep: "Keep Selections", clear: "Clear Selections" } }, dataView: { title: "Data View", lang: ["Data View", "Close", "Refresh"] }, dataZoom: { title: { zoom: "Zoom", back: "Zoom Reset" } }, magicType: { title: { line: "Switch to Line Chart", bar: "Switch to Bar Chart", stack: "Stack", tiled: "Tile" } }, restore: { title: "Restore" }, saveAsImage: { title: "Save as Image", lang: ["Right Click to Save Image"] } }, series: { typeNames: { pie: "Pie chart", bar: "Bar chart", line: "Line chart", scatter: "Scatter plot", effectScatter: "Ripple scatter plot", radar: "Radar chart", tree: "Tree", treemap: "Treemap", boxplot: "Boxplot", candlestick: "Candlestick", k: "K line chart", heatmap: "Heat map", map: "Map", parallel: "Parallel coordinate map", lines: "Line graph", graph: "Relationship graph", sankey: "Sankey diagram", funnel: "Funnel chart", gauge: "Gauge", pictorialBar: "Pictorial bar", themeRiver: "Theme River Map", sunburst: "Sunburst", custom: "Custom chart", chart: "Chart" } }, aria: { general: { withTitle: 'This is a chart about "{title}"', withoutTitle: "This is a chart" }, series: { single: { prefix: "", withName: " with type {seriesType} named {seriesName}.", withoutName: " with type {seriesType}." }, multiple: { prefix: ". It consists of {seriesCount} series count.", withName: " The {seriesId} series is a {seriesType} representing {seriesName}.", withoutName: " The {seriesId} series is a {seriesType}.", separator: { middle: "", end: "" } } }, data: { allData: "The data is as follows: ", partialData: "The first {displayCnt} items are: ", withName: "the data for {name} is {value}", withoutName: "{value}", separator: { middle: ", ", end: ". " } } } }, tVe = { time: { month: ["", "", "", "", "", "", "", "", "", "", "", ""], monthAbbr: ["1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12"], dayOfWeek: ["", "", "", "", "", "", ""], dayOfWeekAbbr: ["", "", "", "", "", "", ""] }, legend: { selector: { all: "", inverse: "" } }, toolbox: { brush: { title: { rect: "", polygon: "", lineX: "", lineY: "", keep: "", clear: "" } }, dataView: { title: "", lang: ["", "", ""] }, dataZoom: { title: { zoom: "", back: "" } }, magicType: { title: { line: "", bar: "", stack: "", tiled: "" } }, restore: { title: "" }, saveAsImage: { title: "", lang: [""] } }, series: { typeNames: { pie: "", bar: "", line: "", scatter: "", effectScatter: "", radar: "", tree: "", treemap: "", boxplot: "", candlestick: "K", k: "K", heatmap: "", map: "", parallel: "", lines: "", graph: "", sankey: "", funnel: "", gauge: "", pictorialBar: "", themeRiver: "", sunburst: "", custom: "", chart: "" } }, aria: { general: { withTitle: "{title}", withoutTitle: "" }, series: { single: { prefix: "", withName: "{seriesType}{seriesName}", withoutName: "{seriesType}" }, multiple: { prefix: "{seriesCount}", withName: "{seriesId}{seriesName}{seriesType}", withoutName: "{seriesId}{seriesType}", separator: { middle: "", end: "" } } }, data: { allData: "", partialData: "{displayCnt}", withName: "{name}{value}", withoutName: "{value}", separator: { middle: "", end: "" } } } }; var nT = "ZH", qN = "EN", Ym = qN, iS = {}, YN = {}, sne = en.domSupported ? function () { var n = (document.documentElement.lang || navigator.language || navigator.browserLanguage || Ym).toUpperCase(); return n.indexOf(nT) > -1 ? nT : Ym }() : Ym; function lne(n, e) { n = n.toUpperCase(), YN[n] = new Rn(e), iS[n] = e } function nVe(n) { if (Fe(n)) { var e = iS[n.toUpperCase()] || {}; return n === nT || n === qN ? lt(e) : xt(lt(e), lt(iS[Ym]), !1) } else return xt(lt(n), lt(iS[Ym]), !1) } function nI(n) { return YN[n] } function rVe() { return YN[Ym] } lne(qN, eVe); lne(nT, tVe); var ZN = 1e3, XN = ZN * 60, v0 = XN * 60, Ao = v0 * 24, zV = Ao * 365, Ey = { year: "{yyyy}", month: "{MMM}", day: "{d}", hour: "{HH}:{mm}", minute: "{HH}:{mm}", second: "{HH}:{mm}:{ss}", millisecond: "{HH}:{mm}:{ss} {SSS}", none: "{yyyy}-{MM}-{dd} {HH}:{mm}:{ss} {SSS}" }, zw = "{yyyy}-{MM}-{dd}", VV = { year: "{yyyy}", month: "{yyyy}-{MM}", day: zw, hour: zw + " " + Ey.hour, minute: zw + " " + Ey.minute, second: zw + " " + Ey.second, millisecond: Ey.none }, VM = ["year", "month", "day", "hour", "minute", "second", "millisecond"], cne = ["year", "half-year", "quarter", "month", "week", "half-week", "day", "half-day", "quarter-day", "hour", "minute", "second", "millisecond"]; function ou(n, e) { return n += "", "0000".substr(0, e - n.length) + n } function Zm(n) { switch (n) { case "half-year": case "quarter": return "month"; case "week": case "half-week": return "day"; case "half-day": case "quarter-day": return "hour"; default: return n } } function iVe(n) { return n === Zm(n) } function aVe(n) { switch (n) { case "year": case "month": return "day"; case "millisecond": return "millisecond"; default: return "second" } } function lC(n, e, t, r) { var i = kl(n), a = i[JN(t)](), o = i[Xm(t)]() + 1, s = Math.floor((o - 1) / 3) + 1, l = i[cC(t)](), c = i["get" + (t ? "UTC" : "") + "Day"](), u = i[b_(t)](), d = (u - 1) % 12 + 1, f = i[uC(t)](), h = i[dC(t)](), p = i[fC(t)](), m = u >= 12 ? "pm" : "am", g = m.toUpperCase(), y = r instanceof Rn ? r : nI(r || sne) || rVe(), b = y.getModel("time"), w = b.get("month"), v = b.get("monthAbbr"), S = b.get("dayOfWeek"), x = b.get("dayOfWeekAbbr"); return (e || "").replace(/{a}/g, m + "").replace(/{A}/g, g + "").replace(/{yyyy}/g, a + "").replace(/{yy}/g, ou(a % 100 + "", 2)).replace(/{Q}/g, s + "").replace(/{MMMM}/g, w[o - 1]).replace(/{MMM}/g, v[o - 1]).replace(/{MM}/g, ou(o, 2)).replace(/{M}/g, o + "").replace(/{dd}/g, ou(l, 2)).replace(/{d}/g, l + "").replace(/{eeee}/g, S[c]).replace(/{ee}/g, x[c]).replace(/{e}/g, c + "").replace(/{HH}/g, ou(u, 2)).replace(/{H}/g, u + "").replace(/{hh}/g, ou(d + "", 2)).replace(/{h}/g, d + "").replace(/{mm}/g, ou(f, 2)).replace(/{m}/g, f + "").replace(/{ss}/g, ou(h, 2)).replace(/{s}/g, h + "").replace(/{SSS}/g, ou(p, 3)).replace(/{S}/g, p + "") } function oVe(n, e, t, r, i) { var a = null; if (Fe(t)) a = t; else if (tt(t)) a = t(n.value, e, { level: n.level }); else { var o = be({}, Ey); if (n.level > 0) for (var s = 0; s < VM.length; ++s)o[VM[s]] = "{primary|" + o[VM[s]] + "}"; var l = t ? t.inherit === !1 ? t : rt(t, o) : o, c = une(n.value, i); if (l[c]) a = l[c]; else if (l.inherit) { for (var u = cne.indexOf(c), s = u - 1; s >= 0; --s)if (l[c]) { a = l[c]; break } a = a || o.none } if (ke(a)) { var d = n.level == null ? 0 : n.level >= 0 ? n.level : a.length + n.level; d = Math.min(d, a.length - 1), a = a[d] } } return lC(new Date(n.value), a, i, r) } function une(n, e) { var t = kl(n), r = t[Xm(e)]() + 1, i = t[cC(e)](), a = t[b_(e)](), o = t[uC(e)](), s = t[dC(e)](), l = t[fC(e)](), c = l === 0, u = c && s === 0, d = u && o === 0, f = d && a === 0, h = f && i === 1, p = h && r === 1; return p ? "year" : h ? "month" : f ? "day" : d ? "hour" : u ? "minute" : c ? "second" : "millisecond" } function HV(n, e, t) { var r = nn(n) ? kl(n) : n; switch (e = e || une(n, t), e) { case "year": return r[JN(t)](); case "half-year": return r[Xm(t)]() >= 6 ? 1 : 0; case "quarter": return Math.floor((r[Xm(t)]() + 1) / 4); case "month": return r[Xm(t)](); case "day": return r[cC(t)](); case "half-day": return r[b_(t)]() / 24; case "hour": return r[b_(t)](); case "minute": return r[uC(t)](); case "second": return r[dC(t)](); case "millisecond": return r[fC(t)]() } } function JN(n) { return n ? "getUTCFullYear" : "getFullYear" } function Xm(n) { return n ? "getUTCMonth" : "getMonth" } function cC(n) { return n ? "getUTCDate" : "getDate" } function b_(n) { return n ? "getUTCHours" : "getHours" } function uC(n) { return n ? "getUTCMinutes" : "getMinutes" } function dC(n) { return n ? "getUTCSeconds" : "getSeconds" } function fC(n) { return n ? "getUTCMilliseconds" : "getMilliseconds" } function sVe(n) { return n ? "setUTCFullYear" : "setFullYear" } function dne(n) { return n ? "setUTCMonth" : "setMonth" } function fne(n) { return n ? "setUTCDate" : "setDate" } function hne(n) { return n ? "setUTCHours" : "setHours" } function pne(n) { return n ? "setUTCMinutes" : "setMinutes" } function mne(n) { return n ? "setUTCSeconds" : "setSeconds" } function gne(n) { return n ? "setUTCMilliseconds" : "setMilliseconds" } function vne(n) { if (!Qee(n)) return Fe(n) ? n : "-"; var e = (n + "").split("."); return e[0].replace(/(\d{1,3})(?=(?:\d{3})+(?!\d))/g, "$1,") + (e.length > 1 ? "." + e[1] : "") } function yne(n, e) { return n = (n || "").toLowerCase().replace(/-(.)/g, function (t, r) { return r.toUpperCase() }), e && n && (n = n.charAt(0).toUpperCase() + n.slice(1)), n } var ev = xN; function rI(n, e, t) { var r = "{yyyy}-{MM}-{dd} {HH}:{mm}:{ss}"; function i(u) { return u && ps(u) ? u : "-" } function a(u) { return !!(u != null && !isNaN(u) && isFinite(u)) } var o = e === "time", s = n instanceof Date; if (o || s) { var l = o ? kl(n) : n; if (isNaN(+l)) { if (s) return "-" } else return lC(l, r, t) } if (e === "ordinal") return bP(n) ? i(n) : nn(n) && a(n) ? n + "" : "-"; var c = jc(n); return a(c) ? vne(c) : bP(n) ? i(n) : typeof n == "boolean" ? n + "" : "-" } var UV = ["a", "b", "c", "d", "e", "f", "g"], HM = function (n, e) { return "{" + n + (e ?? "") + "}" }; function _ne(n, e, t) { ke(e) || (e = [e]); var r = e.length; if (!r) return ""; for (var i = e[0].$vars || [], a = 0; a < i.length; a++) { var o = UV[a]; n = n.replace(HM(o), HM(o, 0)) } for (var s = 0; s < r; s++)for (var l = 0; l < i.length; l++) { var c = e[s][i[l]]; n = n.replace(HM(UV[l], s), t ? Ai(c) : c) } return n } function lVe(n, e, t) { return $(e, function (r, i) { n = n.replace("{" + i + "}", t ? Ai(r) : r) }), n } function cVe(n, e) { var t = Fe(n) ? { color: n, extraCssText: e } : n || {}, r = t.color, i = t.type; e = t.extraCssText; var a = t.renderMode || "html"; if (!r) return ""; if (a === "html") return i === "subItem" ? '<span style="display:inline-block;vertical-align:middle;margin-right:8px;margin-left:3px;border-radius:4px;width:4px;height:4px;background-color:' + Ai(r) + ";" + (e || "") + '"></span>' : '<span style="display:inline-block;margin-right:4px;border-radius:10px;width:10px;height:10px;background-color:' + Ai(r) + ";" + (e || "") + '"></span>'; var o = t.markerId || "markerX"; return { renderMode: a, content: "{" + o + "|}  ", style: i === "subItem" ? { width: 4, height: 4, borderRadius: 2, backgroundColor: r } : { width: 10, height: 10, borderRadius: 5, backgroundColor: r } } } function Wh(n, e) { return e = e || "transparent", Fe(n) ? n : ot(n) && n.colorStops && (n.colorStops[0] || {}).color || e } function rT(n, e) { if (e === "_blank" || e === "blank") { var t = window.open(); t.opener = null, t.location.href = n } else window.open(n, e) } var aS = $, bne = ["left", "right", "top", "bottom", "width", "height"], nh = [["width", "left", "right"], ["height", "top", "bottom"]]; function QN(n, e, t, r, i) { var a = 0, o = 0; r == null && (r = 1 / 0), i == null && (i = 1 / 0); var s = 0; e.eachChild(function (l, c) { var u = l.getBoundingRect(), d = e.childAt(c + 1), f = d && d.getBoundingRect(), h, p; if (n === "horizontal") { var m = u.width + (f ? -f.x + u.x : 0); h = a + m, h > r || l.newline ? (a = 0, h = m, o += s + t, s = u.height) : s = Math.max(s, u.height) } else { var g = u.height + (f ? -f.y + u.y : 0); p = o + g, p > i || l.newline ? (a += s + t, o = 0, p = g, s = u.width) : s = Math.max(s, u.width) } l.newline || (l.x = a, l.y = o, l.markRedraw(), n === "horizontal" ? a = h + t : o = p + t) }) } var Ch = QN; wt(QN, "vertical"); wt(QN, "horizontal"); function uVe(n, e, t) { var r = e.width, i = e.height, a = Ne(n.left, r), o = Ne(n.top, i), s = Ne(n.right, r), l = Ne(n.bottom, i); return (isNaN(a) || isNaN(parseFloat(n.left))) && (a = 0), (isNaN(s) || isNaN(parseFloat(n.right))) && (s = r), (isNaN(o) || isNaN(parseFloat(n.top))) && (o = 0), (isNaN(l) || isNaN(parseFloat(n.bottom))) && (l = i), t = ev(t || 0), { width: Math.max(s - a - t[1] - t[3], 0), height: Math.max(l - o - t[0] - t[2], 0) } } function jr(n, e, t) { t = ev(t || 0); var r = e.width, i = e.height, a = Ne(n.left, r), o = Ne(n.top, i), s = Ne(n.right, r), l = Ne(n.bottom, i), c = Ne(n.width, r), u = Ne(n.height, i), d = t[2] + t[0], f = t[1] + t[3], h = n.aspect; switch (isNaN(c) && (c = r - s - f - a), isNaN(u) && (u = i - l - d - o), h != null && (isNaN(c) && isNaN(u) && (h > r / i ? c = r * .8 : u = i * .8), isNaN(c) && (c = h * u), isNaN(u) && (u = c / h)), isNaN(a) && (a = r - s - c - f), isNaN(o) && (o = i - l - u - d), n.left || n.right) { case "center": a = r / 2 - c / 2 - t[3]; break; case "right": a = r - c - f; break }switch (n.top || n.bottom) { case "middle": case "center": o = i / 2 - u / 2 - t[0]; break; case "bottom": o = i - u - d; break }a = a || 0, o = o || 0, isNaN(c) && (c = r - f - a - (s || 0)), isNaN(u) && (u = i - d - o - (l || 0)); var p = new kt(a + t[3], o + t[0], c, u); return p.margin = t, p } function hC(n, e, t, r, i, a) { var o = !i || !i.hv || i.hv[0], s = !i || !i.hv || i.hv[1], l = i && i.boundingMode || "all"; if (a = a || n, a.x = n.x, a.y = n.y, !o && !s) return !1; var c; if (l === "raw") c = n.type === "group" ? new kt(0, 0, +e.width || 0, +e.height || 0) : n.getBoundingRect(); else if (c = n.getBoundingRect(), n.needLocalTransform()) { var u = n.getLocalTransform(); c = c.clone(), c.applyTransform(u) } var d = jr(rt({ width: c.width, height: c.height }, e), t, r), f = o ? d.x - c.x : 0, h = s ? d.y - c.y : 0; return l === "raw" ? (a.x = f, a.y = h) : (a.x += f, a.y += h), a === n && n.markRedraw(), !0 } function dVe(n, e) { return n[nh[e][0]] != null || n[nh[e][1]] != null && n[nh[e][2]] != null } function w_(n) { var e = n.layoutMode || n.constructor.layoutMode; return ot(e) ? e : e ? { type: e } : null } function Ed(n, e, t) { var r = t && t.ignoreSize; !ke(r) && (r = [r, r]); var i = o(nh[0], 0), a = o(nh[1], 1); c(nh[0], n, i), c(nh[1], n, a); function o(u, d) { var f = {}, h = 0, p = {}, m = 0, g = 2; if (aS(u, function (w) { p[w] = n[w] }), aS(u, function (w) { s(e, w) && (f[w] = p[w] = e[w]), l(f, w) && h++, l(p, w) && m++ }), r[d]) return l(e, u[1]) ? p[u[2]] = null : l(e, u[2]) && (p[u[1]] = null), p; if (m === g || !h) return p; if (h >= g) return f; for (var y = 0; y < u.length; y++) { var b = u[y]; if (!s(f, b) && s(n, b)) { f[b] = n[b]; break } } return f } function s(u, d) { return u.hasOwnProperty(d) } function l(u, d) { return u[d] != null && u[d] !== "auto" } function c(u, d, f) { aS(u, function (h) { d[h] = f[h] }) } } function tv(n) { return wne({}, n) } function wne(n, e) { return e && n && aS(bne, function (t) { e.hasOwnProperty(t) && (n[t] = e[t]) }), n } var fVe = Kt(), nv = function (n) { te(e, n); function e(t, r, i) { var a = n.call(this, t, r, i) || this; return a.uid = Qg("ec_cpt_model"), a } return e.prototype.init = function (t, r, i) { this.mergeDefaultAndTheme(t, i) }, e.prototype.mergeDefaultAndTheme = function (t, r) { var i = w_(this), a = i ? tv(t) : {}, o = r.getTheme(); xt(t, o.get(this.mainType)), xt(t, this.getDefaultOption()), i && Ed(t, a, i) }, e.prototype.mergeOption = function (t, r) { xt(this.option, t, !0); var i = w_(this); i && Ed(this.option, t, i) }, e.prototype.optionUpdated = function (t, r) { }, e.prototype.getDefaultOption = function () { var t = this.constructor; if (!KFe(t)) return t.defaultOption; var r = fVe(this); if (!r.defaultOption) { for (var i = [], a = t; a;) { var o = a.prototype.defaultOption; o && i.push(o), a = a.superClass } for (var s = {}, l = i.length - 1; l >= 0; l--)s = xt(s, i[l], !0); r.defaultOption = s } return r.defaultOption }, e.prototype.getReferringComponents = function (t, r) { var i = t + "Index", a = t + "Id"; return wb(this.ecModel, t, { index: this.get(i, !0), id: this.get(a, !0) }, r) }, e.prototype.getBoxLayoutParams = function () { var t = this; return { left: t.get("left"), top: t.get("top"), right: t.get("right"), bottom: t.get("bottom"), width: t.get("width"), height: t.get("height") } }, e.prototype.getZLevelKey = function () { return "" }, e.prototype.setZLevel = function (t) { this.option.zlevel = t }, e.protoInitialize = function () { var t = e.prototype; t.type = "component", t.id = "", t.name = "", t.mainType = "", t.subType = "", t.componentIndex = 0 }(), e }(Rn); cte(nv, Rn); Xk(nv); J6e(nv); Q6e(nv, hVe); function hVe(n) { var e = []; return $(nv.getClassesByMainType(n), function (t) { e = e.concat(t.dependencies || t.prototype.dependencies || []) }), e = Ae(e, function (t) { return sl(t).main }), n !== "dataset" && Et(e, "dataset") <= 0 && e.unshift("dataset"), e } const Jt = nv; var xne = ""; typeof navigator < "u" && (xne = navigator.platform || ""); var Kp = "rgba(0, 0, 0, 0.2)"; const pVe = { darkMode: "auto", colorBy: "series", color: ["#5470c6", "#91cc75", "#fac858", "#ee6666", "#73c0de", "#3ba272", "#fc8452", "#9a60b4", "#ea7ccc"], gradientColor: ["#f6efa6", "#d88273", "#bf444c"], aria: { decal: { decals: [{ color: Kp, dashArrayX: [1, 0], dashArrayY: [2, 5], symbolSize: 1, rotation: Math.PI / 6 }, { color: Kp, symbol: "circle", dashArrayX: [[8, 8], [0, 8, 8, 0]], dashArrayY: [6, 0], symbolSize: .8 }, { color: Kp, dashArrayX: [1, 0], dashArrayY: [4, 3], rotation: -Math.PI / 4 }, { color: Kp, dashArrayX: [[6, 6], [0, 6, 6, 0]], dashArrayY: [6, 0] }, { color: Kp, dashArrayX: [[1, 0], [1, 6]], dashArrayY: [1, 0, 6, 0], rotation: Math.PI / 4 }, { color: Kp, symbol: "triangle", dashArrayX: [[9, 9], [0, 9, 9, 0]], dashArrayY: [7, 2], symbolSize: .75 }] } }, textStyle: { fontFamily: xne.match(/^Win/) ? "Microsoft YaHei" : "sans-serif", fontSize: 12, fontStyle: "normal", fontWeight: "normal" }, blendMode: null, stateAnimation: { duration: 300, easing: "cubicOut" }, animation: "auto", animationDuration: 1e3, animationDurationUpdate: 500, animationEasing: "cubicInOut", animationEasingUpdate: "cubicInOut", animationThreshold: 2e3, progressiveThreshold: 3e3, progressive: 400, hoverLayerThreshold: 3e3, useUTC: !1 }; var Sne = Ze(["tooltip", "label", "itemName", "itemId", "itemGroupId", "itemChildGroupId", "seriesName"]), Wo = "original", Li = "arrayRows", Ko = "objectRows", Il = "keyedColumns", sd = "typedArray", Tne = "unknown", ml = "column", rv = "row", oi = { Must: 1, Might: 2, Not: 3 }, kne = Kt(); function mVe(n) { kne(n).datasetMap = Ze() } function Cne(n, e, t) { var r = {}, i = t3(e); if (!i || !n) return r; var a = [], o = [], s = e.ecModel, l = kne(s).datasetMap, c = i.uid + "_" + t.seriesLayoutBy, u, d; n = n.slice(), $(n, function (m, g) { var y = ot(m) ? m : n[g] = { name: m }; y.type === "ordinal" && u == null && (u = g, d = p(y)), r[y.name] = [] }); var f = l.get(c) || l.set(c, { categoryWayDim: d, valueWayDim: 0 }); $(n, function (m, g) { var y = m.name, b = p(m); if (u == null) { var w = f.valueWayDim; h(r[y], w, b), h(o, w, b), f.valueWayDim += b } else if (u === g) h(r[y], 0, b), h(a, 0, b); else { var w = f.categoryWayDim; h(r[y], w, b), h(o, w, b), f.categoryWayDim += b } }); function h(m, g, y) { for (var b = 0; b < y; b++)m.push(g + b) } function p(m) { var g = m.dimsDef; return g ? g.length : 1 } return a.length && (r.itemName = a), o.length && (r.seriesName = o), r } function e3(n, e, t) { var r = {}, i = t3(n); if (!i) return r; var a = e.sourceFormat, o = e.dimensionsDefine, s; (a === Ko || a === Il) && $(o, function (u, d) { (ot(u) ? u.name : u) === "name" && (s = d) }); var l = function () { for (var u = {}, d = {}, f = [], h = 0, p = Math.min(5, t); h < p; h++) { var m = Ene(e.data, a, e.seriesLayoutBy, o, e.startIndex, h); f.push(m); var g = m === oi.Not; if (g && u.v == null && h !== s && (u.v = h), (u.n == null || u.n === u.v || !g && f[u.n] === oi.Not) && (u.n = h), y(u) && f[u.n] !== oi.Not) return u; g || (m === oi.Might && d.v == null && h !== s && (d.v = h), (d.n == null || d.n === d.v) && (d.n = h)) } function y(b) { return b.v != null && b.n != null } return y(u) ? u : y(d) ? d : null }(); if (l) { r.value = [l.v]; var c = s ?? l.n; r.itemName = [c], r.seriesName = [c] } return r } function t3(n) { var e = n.get("data", !0); if (!e) return wb(n.ecModel, "dataset", { index: n.get("datasetIndex", !0), id: n.get("datasetId", !0) }, xr).models[0] } function gVe(n) { return !n.get("transform", !0) && !n.get("fromTransformResult", !0) ? [] : wb(n.ecModel, "dataset", { index: n.get("fromDatasetIndex", !0), id: n.get("fromDatasetId", !0) }, xr).models } function Ane(n, e) { return Ene(n.data, n.sourceFormat, n.seriesLayoutBy, n.dimensionsDefine, n.startIndex, e) } function Ene(n, e, t, r, i, a) { var o, s = 5; if (ka(n)) return oi.Not; var l, c; if (r) { var u = r[a]; ot(u) ? (l = u.name, c = u.type) : Fe(u) && (l = u) } if (c != null) return c === "ordinal" ? oi.Must : oi.Not; if (e === Li) { var d = n; if (t === rv) { for (var f = d[a], h = 0; h < (f || []).length && h < s; h++)if ((o = v(f[i + h])) != null) return o } else for (var h = 0; h < d.length && h < s; h++) { var p = d[i + h]; if (p && (o = v(p[a])) != null) return o } } else if (e === Ko) { var m = n; if (!l) return oi.Not; for (var h = 0; h < m.length && h < s; h++) { var g = m[h]; if (g && (o = v(g[l])) != null) return o } } else if (e === Il) { var y = n; if (!l) return oi.Not; var f = y[l]; if (!f || ka(f)) return oi.Not; for (var h = 0; h < f.length && h < s; h++)if ((o = v(f[h])) != null) return o } else if (e === Wo) for (var b = n, h = 0; h < b.length && h < s; h++) { var g = b[h], w = Yg(g); if (!ke(w)) return oi.Not; if ((o = v(w[a])) != null) return o } function v(S) { var x = Fe(S); if (S != null && Number.isFinite(Number(S)) && S !== "") return x ? oi.Might : oi.Not; if (x && S !== "-") return oi.Must } return oi.Not } var iI = Ze(); function vVe(n, e) { na(iI.get(n) == null && e), iI.set(n, e) } function yVe(n, e, t) { var r = iI.get(e); if (!r) return t; var i = r(n); return i ? t.concat(i) : t } var GV = Kt(), _Ve = Kt(), n3 = function () { function n() { } return n.prototype.getColorFromPalette = function (e, t, r) { var i = Cn(this.get("color", !0)), a = this.get("colorLayer", !0); return Mne(this, GV, i, a, e, t, r) }, n.prototype.clearColorPalette = function () { wVe(this, GV) }, n }(); function aI(n, e, t, r) { var i = Cn(n.get(["aria", "decal", "decals"])); return Mne(n, _Ve, i, null, e, t, r) } function bVe(n, e) { for (var t = n.length, r = 0; r < t; r++)if (n[r].length > e) return n[r]; return n[t - 1] } function Mne(n, e, t, r, i, a, o) { a = a || n; var s = e(a), l = s.paletteIdx || 0, c = s.paletteNameMap = s.paletteNameMap || {}; if (c.hasOwnProperty(i)) return c[i]; var u = o == null || !r ? t : bVe(r, o); if (u = u || t, !(!u || !u.length)) { var d = u[l]; return i && (c[i] = d), s.paletteIdx = (l + 1) % u.length, d } } function wVe(n, e) { e(n).paletteIdx = 0, e(n).paletteNameMap = {} } var Vw, qv, WV, KV = "\0_ec_inner", xVe = 1, One = function (n) { te(e, n); function e() { return n !== null && n.apply(this, arguments) || this } return e.prototype.init = function (t, r, i, a, o, s) { a = a || {}, this.option = null, this._theme = new Rn(a), this._locale = new Rn(o), this._optionManager = s }, e.prototype.setOption = function (t, r, i) { var a = ZV(r); this._optionManager.setOption(t, i, a), this._resetOption(null, a) }, e.prototype.resetOption = function (t, r) { return this._resetOption(t, ZV(r)) }, e.prototype._resetOption = function (t, r) { var i = !1, a = this._optionManager; if (!t || t === "recreate") { var o = a.mountOption(t === "recreate"); !this.option || t === "recreate" ? WV(this, o) : (this.restoreData(), this._mergeOption(o, r)), i = !0 } if ((t === "timeline" || t === "media") && this.restoreData(), !t || t === "recreate" || t === "timeline") { var s = a.getTimelineOption(this); s && (i = !0, this._mergeOption(s, r)) } if (!t || t === "recreate" || t === "media") { var l = a.getMediaOption(this); l.length && $(l, function (c) { i = !0, this._mergeOption(c, r) }, this) } return i }, e.prototype.mergeOption = function (t) { this._mergeOption(t, null) }, e.prototype._mergeOption = function (t, r) { var i = this.option, a = this._componentsMap, o = this._componentsCount, s = [], l = Ze(), c = r && r.replaceMergeMainTypeMap; mVe(this), $(t, function (d, f) { d != null && (Jt.hasClass(f) ? f && (s.push(f), l.set(f, !0)) : i[f] = i[f] == null ? lt(d) : xt(i[f], d, !0)) }), c && c.each(function (d, f) { Jt.hasClass(f) && !l.get(f) && (s.push(f), l.set(f, !0)) }), Jt.topologicalTravel(s, Jt.getAllClassMainTypes(), u, this); function u(d) { var f = yVe(this, d, Cn(t[d])), h = a.get(d), p = h ? c && c.get(d) ? "replaceMerge" : "normalMerge" : "replaceAll", m = ite(h, f, p); BFe(m, d, Jt), i[d] = null, a.set(d, null), o.set(d, 0); var g = [], y = [], b = 0, w; $(m, function (v, S) { var x = v.existing, k = v.newOption; if (!k) x && (x.mergeOption({}, this), x.optionUpdated({}, !1)); else { var A = d === "series", C = Jt.getClass(d, v.keyInfo.subType, !A); if (!C) return; if (d === "tooltip") { if (w) return; w = !0 } if (x && x.constructor === C) x.name = v.keyInfo.name, x.mergeOption(k, this), x.optionUpdated(k, !1); else { var E = be({ componentIndex: S }, v.keyInfo); x = new C(k, this, this, E), be(x, E), v.brandNew && (x.__requireNewView = !0), x.init(k, this, this), x.optionUpdated(null, !0) } } x ? (g.push(x.option), y.push(x), b++) : (g.push(void 0), y.push(void 0)) }, this), i[d] = g, a.set(d, y), o.set(d, b), d === "series" && Vw(this) } this._seriesIndices || Vw(this) }, e.prototype.getOption = function () { var t = lt(this.option); return $(t, function (r, i) { if (Jt.hasClass(i)) { for (var a = Cn(r), o = a.length, s = !1, l = o - 1; l >= 0; l--)a[l] && !m_(a[l]) ? s = !0 : (a[l] = null, !s && o--); a.length = o, t[i] = a } }), delete t[KV], t }, e.prototype.getTheme = function () { return this._theme }, e.prototype.getLocaleModel = function () { return this._locale }, e.prototype.setUpdatePayload = function (t) { this._payload = t }, e.prototype.getUpdatePayload = function () { return this._payload }, e.prototype.getComponent = function (t, r) { var i = this._componentsMap.get(t); if (i) { var a = i[r || 0]; if (a) return a; if (r == null) { for (var o = 0; o < i.length; o++)if (i[o]) return i[o] } } }, e.prototype.queryComponents = function (t) { var r = t.mainType; if (!r) return []; var i = t.index, a = t.id, o = t.name, s = this._componentsMap.get(r); if (!s || !s.length) return []; var l; return i != null ? (l = [], $(Cn(i), function (c) { s[c] && l.push(s[c]) })) : a != null ? l = qV("id", a, s) : o != null ? l = qV("name", o, s) : l = pn(s, function (c) { return !!c }), YV(l, t) }, e.prototype.findComponents = function (t) { var r = t.query, i = t.mainType, a = s(r), o = a ? this.queryComponents(a) : pn(this._componentsMap.get(i), function (c) { return !!c }); return l(YV(o, t)); function s(c) { var u = i + "Index", d = i + "Id", f = i + "Name"; return c && (c[u] != null || c[d] != null || c[f] != null) ? { mainType: i, index: c[u], id: c[d], name: c[f] } : null } function l(c) { return t.filter ? pn(c, t.filter) : c } }, e.prototype.eachComponent = function (t, r, i) { var a = this._componentsMap; if (tt(t)) { var o = r, s = t; a.each(function (d, f) { for (var h = 0; d && h < d.length; h++) { var p = d[h]; p && s.call(o, f, p, p.componentIndex) } }) } else for (var l = Fe(t) ? a.get(t) : ot(t) ? this.findComponents(t) : null, c = 0; l && c < l.length; c++) { var u = l[c]; u && r.call(i, u, u.componentIndex) } }, e.prototype.getSeriesByName = function (t) { var r = Er(t, null); return pn(this._componentsMap.get("series"), function (i) { return !!i && r != null && i.name === r }) }, e.prototype.getSeriesByIndex = function (t) { return this._componentsMap.get("series")[t] }, e.prototype.getSeriesByType = function (t) { return pn(this._componentsMap.get("series"), function (r) { return !!r && r.subType === t }) }, e.prototype.getSeries = function () { return pn(this._componentsMap.get("series"), function (t) { return !!t }) }, e.prototype.getSeriesCount = function () { return this._componentsCount.get("series") }, e.prototype.eachSeries = function (t, r) { qv(this), $(this._seriesIndices, function (i) { var a = this._componentsMap.get("series")[i]; t.call(r, a, i) }, this) }, e.prototype.eachRawSeries = function (t, r) { $(this._componentsMap.get("series"), function (i) { i && t.call(r, i, i.componentIndex) }) }, e.prototype.eachSeriesByType = function (t, r, i) { qv(this), $(this._seriesIndices, function (a) { var o = this._componentsMap.get("series")[a]; o.subType === t && r.call(i, o, a) }, this) }, e.prototype.eachRawSeriesByType = function (t, r, i) { return $(this.getSeriesByType(t), r, i) }, e.prototype.isSeriesFiltered = function (t) { return qv(this), this._seriesIndicesMap.get(t.componentIndex) == null }, e.prototype.getCurrentSeriesIndices = function () { return (this._seriesIndices || []).slice() }, e.prototype.filterSeries = function (t, r) { qv(this); var i = []; $(this._seriesIndices, function (a) { var o = this._componentsMap.get("series")[a]; t.call(r, o, a) && i.push(a) }, this), this._seriesIndices = i, this._seriesIndicesMap = Ze(i) }, e.prototype.restoreData = function (t) { Vw(this); var r = this._componentsMap, i = []; r.each(function (a, o) { Jt.hasClass(o) && i.push(o) }), Jt.topologicalTravel(i, Jt.getAllClassMainTypes(), function (a) { $(r.get(a), function (o) { o && (a !== "series" || !SVe(o, t)) && o.restoreData() }) }) }, e.internalField = function () { Vw = function (t) { var r = t._seriesIndices = []; $(t._componentsMap.get("series"), function (i) { i && r.push(i.componentIndex) }), t._seriesIndicesMap = Ze(r) }, qv = function (t) { }, WV = function (t, r) { t.option = {}, t.option[KV] = xVe, t._componentsMap = Ze({ series: [] }), t._componentsCount = Ze(); var i = r.aria; ot(i) && i.enabled == null && (i.enabled = !0), TVe(r, t._theme.option), xt(r, pVe, !1), t._mergeOption(r, null) } }(), e }(Rn); function SVe(n, e) { if (e) { var t = e.seriesIndex, r = e.seriesId, i = e.seriesName; return t != null && n.componentIndex !== t || r != null && n.id !== r || i != null && n.name !== i } } function TVe(n, e) { var t = n.color && !n.colorLayer; $(e, function (r, i) { i === "colorLayer" && t || Jt.hasClass(i) || (typeof r == "object" ? n[i] = n[i] ? xt(n[i], r, !1) : lt(r) : n[i] == null && (n[i] = r)) }) } function qV(n, e, t) { if (ke(e)) { var r = Ze(); return $(e, function (a) { if (a != null) { var o = Er(a, null); o != null && r.set(a, !0) } }), pn(t, function (a) { return a && r.get(a[n]) }) } else { var i = Er(e, null); return pn(t, function (a) { return a && i != null && a[n] === i }) } } function YV(n, e) { return e.hasOwnProperty("subType") ? pn(n, function (t) { return t && t.subType === e.subType }) : n } function ZV(n) { var e = Ze(); return n && $(Cn(n.replaceMerge), function (t) { e.set(t, !0) }), { replaceMergeMainTypeMap: e } } Cr(One, n3); const Dne = One; var kVe = ["getDom", "getZr", "getWidth", "getHeight", "getDevicePixelRatio", "dispatchAction", "isSSR", "isDisposed", "on", "off", "getDataURL", "getConnectedDataURL", "getOption", "getId", "updateLabelLayout"], CVe = function () { function n(e) { $(kVe, function (t) { this[t] = He(e[t], e) }, this) } return n }(); const jne = CVe; var UM = {}, AVe = function () { function n() { this._coordinateSystems = [] } return n.prototype.create = function (e, t) { var r = []; $(UM, function (i, a) { var o = i.create(e, t); r = r.concat(o || []) }), this._coordinateSystems = r }, n.prototype.update = function (e, t) { $(this._coordinateSystems, function (r) { r.update && r.update(e, t) }) }, n.prototype.getCoordinateSystems = function () { return this._coordinateSystems.slice() }, n.register = function (e, t) { UM[e] = t }, n.get = function (e) { return UM[e] }, n }(); const Cb = AVe; var EVe = /^(min|max)?(.+)$/, MVe = function () { function n(e) { this._timelineOptions = [], this._mediaList = [], this._currentMediaIndices = [], this._api = e } return n.prototype.setOption = function (e, t, r) { e && ($(Cn(e.series), function (o) { o && o.data && ka(o.data) && V2(o.data) }), $(Cn(e.dataset), function (o) { o && o.source && ka(o.source) && V2(o.source) })), e = lt(e); var i = this._optionBackup, a = OVe(e, t, !i); this._newBaseOption = a.baseOption, i ? (a.timelineOptions.length && (i.timelineOptions = a.timelineOptions), a.mediaList.length && (i.mediaList = a.mediaList), a.mediaDefault && (i.mediaDefault = a.mediaDefault)) : this._optionBackup = a }, n.prototype.mountOption = function (e) { var t = this._optionBackup; return this._timelineOptions = t.timelineOptions, this._mediaList = t.mediaList, this._mediaDefault = t.mediaDefault, this._currentMediaIndices = [], lt(e ? t.baseOption : this._newBaseOption) }, n.prototype.getTimelineOption = function (e) { var t, r = this._timelineOptions; if (r.length) { var i = e.getComponent("timeline"); i && (t = lt(r[i.getCurrentIndex()])) } return t }, n.prototype.getMediaOption = function (e) { var t = this._api.getWidth(), r = this._api.getHeight(), i = this._mediaList, a = this._mediaDefault, o = [], s = []; if (!i.length && !a) return s; for (var l = 0, c = i.length; l < c; l++)DVe(i[l].query, t, r) && o.push(l); return !o.length && a && (o = [-1]), o.length && !PVe(o, this._currentMediaIndices) && (s = Ae(o, function (u) { return lt(u === -1 ? a.option : i[u].option) })), this._currentMediaIndices = o, s }, n }(); function OVe(n, e, t) { var r = [], i, a, o = n.baseOption, s = n.timeline, l = n.options, c = n.media, u = !!n.media, d = !!(l || s || o && o.timeline); o ? (a = o, a.timeline || (a.timeline = s)) : ((d || u) && (n.options = n.media = null), a = n), u && ke(c) && $(c, function (h) { h && h.option && (h.query ? r.push(h) : i || (i = h)) }), f(a), $(l, function (h) { return f(h) }), $(r, function (h) { return f(h.option) }); function f(h) { $(e, function (p) { p(h, t) }) } return { baseOption: a, timelineOptions: l || [], mediaDefault: i, mediaList: r } } function DVe(n, e, t) { var r = { width: e, height: t, aspectratio: e / t }, i = !0; return $(n, function (a, o) { var s = o.match(EVe); if (!(!s || !s[1] || !s[2])) { var l = s[1], c = s[2].toLowerCase(); jVe(r[c], a, l) || (i = !1) } }), i } function jVe(n, e, t) { return t === "min" ? n >= e : t === "max" ? n <= e : n === e } function PVe(n, e) { return n.join(",") === e.join(",") } const IVe = MVe; var Jo = $, x_ = ot, XV = ["areaStyle", "lineStyle", "nodeStyle", "linkStyle", "chordStyle", "label", "labelLine"]; function GM(n) { var e = n && n.itemStyle; if (e) for (var t = 0, r = XV.length; t < r; t++) { var i = XV[t], a = e.normal, o = e.emphasis; a && a[i] && (n[i] = n[i] || {}, n[i].normal ? xt(n[i].normal, a[i]) : n[i].normal = a[i], a[i] = null), o && o[i] && (n[i] = n[i] || {}, n[i].emphasis ? xt(n[i].emphasis, o[i]) : n[i].emphasis = o[i], o[i] = null) } } function ki(n, e, t) { if (n && n[e] && (n[e].normal || n[e].emphasis)) { var r = n[e].normal, i = n[e].emphasis; r && (t ? (n[e].normal = n[e].emphasis = null, rt(n[e], r)) : n[e] = r), i && (n.emphasis = n.emphasis || {}, n.emphasis[e] = i, i.focus && (n.emphasis.focus = i.focus), i.blurScope && (n.emphasis.blurScope = i.blurScope)) } } function My(n) { ki(n, "itemStyle"), ki(n, "lineStyle"), ki(n, "areaStyle"), ki(n, "label"), ki(n, "labelLine"), ki(n, "upperLabel"), ki(n, "edgeLabel") } function wr(n, e) { var t = x_(n) && n[e], r = x_(t) && t.textStyle; if (r) for (var i = 0, a = rV.length; i < a; i++) { var o = rV[i]; r.hasOwnProperty(o) && (t[o] = r[o]) } } function mo(n) { n && (My(n), wr(n, "label"), n.emphasis && wr(n.emphasis, "label")) } function LVe(n) { if (x_(n)) { GM(n), My(n), wr(n, "label"), wr(n, "upperLabel"), wr(n, "edgeLabel"), n.emphasis && (wr(n.emphasis, "label"), wr(n.emphasis, "upperLabel"), wr(n.emphasis, "edgeLabel")); var e = n.markPoint; e && (GM(e), mo(e)); var t = n.markLine; t && (GM(t), mo(t)); var r = n.markArea; r && mo(r); var i = n.data; if (n.type === "graph") { i = i || n.nodes; var a = n.links || n.edges; if (a && !ka(a)) for (var o = 0; o < a.length; o++)mo(a[o]); $(n.categories, function (c) { My(c) }) } if (i && !ka(i)) for (var o = 0; o < i.length; o++)mo(i[o]); if (e = n.markPoint, e && e.data) for (var s = e.data, o = 0; o < s.length; o++)mo(s[o]); if (t = n.markLine, t && t.data) for (var l = t.data, o = 0; o < l.length; o++)ke(l[o]) ? (mo(l[o][0]), mo(l[o][1])) : mo(l[o]); n.type === "gauge" ? (wr(n, "axisLabel"), wr(n, "title"), wr(n, "detail")) : n.type === "treemap" ? (ki(n.breadcrumb, "itemStyle"), $(n.levels, function (c) { My(c) })) : n.type === "tree" && My(n.leaves) } } function Xl(n) { return ke(n) ? n : n ? [n] : [] } function JV(n) { return (ke(n) ? n[0] : n) || {} } function RVe(n, e) { Jo(Xl(n.series), function (r) { x_(r) && LVe(r) }); var t = ["xAxis", "yAxis", "radiusAxis", "angleAxis", "singleAxis", "parallelAxis", "radar"]; e && t.push("valueAxis", "categoryAxis", "logAxis", "timeAxis"), Jo(t, function (r) { Jo(Xl(n[r]), function (i) { i && (wr(i, "axisLabel"), wr(i.axisPointer, "label")) }) }), Jo(Xl(n.parallel), function (r) { var i = r && r.parallelAxisDefault; wr(i, "axisLabel"), wr(i && i.axisPointer, "label") }), Jo(Xl(n.calendar), function (r) { ki(r, "itemStyle"), wr(r, "dayLabel"), wr(r, "monthLabel"), wr(r, "yearLabel") }), Jo(Xl(n.radar), function (r) { wr(r, "name"), r.name && r.axisName == null && (r.axisName = r.name, delete r.name), r.nameGap != null && r.axisNameGap == null && (r.axisNameGap = r.nameGap, delete r.nameGap) }), Jo(Xl(n.geo), function (r) { x_(r) && (mo(r), Jo(Xl(r.regions), function (i) { mo(i) })) }), Jo(Xl(n.timeline), function (r) { mo(r), ki(r, "label"), ki(r, "itemStyle"), ki(r, "controlStyle", !0); var i = r.data; ke(i) && $(i, function (a) { ot(a) && (ki(a, "label"), ki(a, "itemStyle")) }) }), Jo(Xl(n.toolbox), function (r) { ki(r, "iconStyle"), Jo(r.feature, function (i) { ki(i, "iconStyle") }) }), wr(JV(n.axisPointer), "label"), wr(JV(n.tooltip).axisPointer, "label") } function NVe(n, e) { for (var t = e.split(","), r = n, i = 0; i < t.length && (r = r && r[t[i]], r != null); i++); return r } function BVe(n, e, t, r) { for (var i = e.split(","), a = n, o, s = 0; s < i.length - 1; s++)o = i[s], a[o] == null && (a[o] = {}), a = a[o]; (r || a[i[s]] == null) && (a[i[s]] = t) } function QV(n) { n && $($Ve, function (e) { e[0] in n && !(e[1] in n) && (n[e[1]] = n[e[0]]) }) } var $Ve = [["x", "left"], ["y", "top"], ["x2", "right"], ["y2", "bottom"]], FVe = ["grid", "geo", "parallel", "legend", "toolbox", "title", "visualMap", "dataZoom", "timeline"], WM = [["borderRadius", "barBorderRadius"], ["borderColor", "barBorderColor"], ["borderWidth", "barBorderWidth"]]; function Yv(n) { var e = n && n.itemStyle; if (e) for (var t = 0; t < WM.length; t++) { var r = WM[t][1], i = WM[t][0]; e[r] != null && (e[i] = e[r]) } } function eH(n) { n && n.alignTo === "edge" && n.margin != null && n.edgeDistance == null && (n.edgeDistance = n.margin) } function tH(n) { n && n.downplay && !n.blur && (n.blur = n.downplay) } function zVe(n) { n && n.focusNodeAdjacency != null && (n.emphasis = n.emphasis || {}, n.emphasis.focus == null && (n.emphasis.focus = "adjacency")) } function Pne(n, e) { if (n) for (var t = 0; t < n.length; t++)e(n[t]), n[t] && Pne(n[t].children, e) } function Ine(n, e) { RVe(n, e), n.series = Cn(n.series), $(n.series, function (t) { if (ot(t)) { var r = t.type; if (r === "line") t.clipOverflow != null && (t.clip = t.clipOverflow); else if (r === "pie" || r === "gauge") { t.clockWise != null && (t.clockwise = t.clockWise), eH(t.label); var i = t.data; if (i && !ka(i)) for (var a = 0; a < i.length; a++)eH(i[a]); t.hoverOffset != null && (t.emphasis = t.emphasis || {}, (t.emphasis.scaleSize = null) && (t.emphasis.scaleSize = t.hoverOffset)) } else if (r === "gauge") { var o = NVe(t, "pointer.color"); o != null && BVe(t, "itemStyle.color", o) } else if (r === "bar") { Yv(t), Yv(t.backgroundStyle), Yv(t.emphasis); var i = t.data; if (i && !ka(i)) for (var a = 0; a < i.length; a++)typeof i[a] == "object" && (Yv(i[a]), Yv(i[a] && i[a].emphasis)) } else if (r === "sunburst") { var s = t.highlightPolicy; s && (t.emphasis = t.emphasis || {}, t.emphasis.focus || (t.emphasis.focus = s)), tH(t), Pne(t.data, tH) } else r === "graph" || r === "sankey" ? zVe(t) : r === "map" && (t.mapType && !t.map && (t.map = t.mapType), t.mapLocation && rt(t, t.mapLocation)); t.hoverAnimation != null && (t.emphasis = t.emphasis || {}, t.emphasis && t.emphasis.scale == null && (t.emphasis.scale = t.hoverAnimation)), QV(t) } }), n.dataRange && (n.visualMap = n.dataRange), $(FVe, function (t) { var r = n[t]; r && (ke(r) || (r = [r]), $(r, function (i) { QV(i) })) }) } function VVe(n) { var e = Ze(); n.eachSeries(function (t) { var r = t.get("stack"); if (r) { var i = e.get(r) || e.set(r, []), a = t.getData(), o = { stackResultDimension: a.getCalculationInfo("stackResultDimension"), stackedOverDimension: a.getCalculationInfo("stackedOverDimension"), stackedDimension: a.getCalculationInfo("stackedDimension"), stackedByDimension: a.getCalculationInfo("stackedByDimension"), isStackedByIndex: a.getCalculationInfo("isStackedByIndex"), data: a, seriesModel: t }; if (!o.stackedDimension || !(o.isStackedByIndex || o.stackedByDimension)) return; i.length && a.setCalculationInfo("stackedOnSeries", i[i.length - 1].seriesModel), i.push(o) } }), e.each(HVe) } function HVe(n) { $(n, function (e, t) { var r = [], i = [NaN, NaN], a = [e.stackResultDimension, e.stackedOverDimension], o = e.data, s = e.isStackedByIndex, l = e.seriesModel.get("stackStrategy") || "samesign"; o.modify(a, function (c, u, d) { var f = o.get(e.stackedDimension, d); if (isNaN(f)) return i; var h, p; s ? p = o.getRawIndex(d) : h = o.get(e.stackedByDimension, d); for (var m = NaN, g = t - 1; g >= 0; g--) { var y = n[g]; if (s || (p = y.data.rawIndexOf(y.stackedByDimension, h)), p >= 0) { var b = y.data.getByRawIndex(y.stackResultDimension, p); if (l === "all" || l === "positive" && b > 0 || l === "negative" && b < 0 || l === "samesign" && f >= 0 && b > 0 || l === "samesign" && f <= 0 && b < 0) { f = AFe(f, b), m = b; break } } } return r[0] = f, r[1] = m, r }) }) } var pC = function () { function n(e) { this.data = e.data || (e.sourceFormat === Il ? {} : []), this.sourceFormat = e.sourceFormat || Tne, this.seriesLayoutBy = e.seriesLayoutBy || ml, this.startIndex = e.startIndex || 0, this.dimensionsDetectedCount = e.dimensionsDetectedCount, this.metaRawOption = e.metaRawOption; var t = this.dimensionsDefine = e.dimensionsDefine; if (t) for (var r = 0; r < t.length; r++) { var i = t[r]; i.type == null && Ane(this, r) === oi.Must && (i.type = "ordinal") } } return n }(); function r3(n) { return n instanceof pC } function oI(n, e, t) { t = t || Lne(n); var r = e.seriesLayoutBy, i = GVe(n, t, r, e.sourceHeader, e.dimensions), a = new pC({ data: n, sourceFormat: t, seriesLayoutBy: r, dimensionsDefine: i.dimensionsDefine, startIndex: i.startIndex, dimensionsDetectedCount: i.dimensionsDetectedCount, metaRawOption: lt(e) }); return a } function i3(n) { return new pC({ data: n, sourceFormat: ka(n) ? sd : Wo }) } function UVe(n) { return new pC({ data: n.data, sourceFormat: n.sourceFormat, seriesLayoutBy: n.seriesLayoutBy, dimensionsDefine: lt(n.dimensionsDefine), startIndex: n.startIndex, dimensionsDetectedCount: n.dimensionsDetectedCount }) } function Lne(n) { var e = Tne; if (ka(n)) e = sd; else if (ke(n)) { n.length === 0 && (e = Li); for (var t = 0, r = n.length; t < r; t++) { var i = n[t]; if (i != null) { if (ke(i) || ka(i)) { e = Li; break } else if (ot(i)) { e = Ko; break } } } } else if (ot(n)) { for (var a in n) if (Ge(n, a) && Ii(n[a])) { e = Il; break } } return e } function GVe(n, e, t, r, i) { var a, o; if (!n) return { dimensionsDefine: nH(i), startIndex: o, dimensionsDetectedCount: a }; if (e === Li) { var s = n; r === "auto" || r == null ? rH(function (c) { c != null && c !== "-" && (Fe(c) ? o == null && (o = 1) : o = 0) }, t, s, 10) : o = nn(r) ? r : r ? 1 : 0, !i && o === 1 && (i = [], rH(function (c, u) { i[u] = c != null ? c + "" : "" }, t, s, 1 / 0)), a = i ? i.length : t === rv ? s.length : s[0] ? s[0].length : null } else if (e === Ko) i || (i = WVe(n)); else if (e === Il) i || (i = [], $(n, function (c, u) { i.push(u) })); else if (e === Wo) { var l = Yg(n[0]); a = ke(l) && l.length || 1 } return { startIndex: o, dimensionsDefine: nH(i), dimensionsDetectedCount: a } } function WVe(n) { for (var e = 0, t; e < n.length && !(t = n[e++]);); if (t) return Bt(t) } function nH(n) { if (n) { var e = Ze(); return Ae(n, function (t, r) { t = ot(t) ? t : { name: t }; var i = { name: t.name, displayName: t.displayName, type: t.type }; if (i.name == null) return i; i.name += "", i.displayName == null && (i.displayName = i.name); var a = e.get(i.name); return a ? i.name += "-" + a.count++ : e.set(i.name, { count: 1 }), i }) } } function rH(n, e, t, r) { if (e === rv) for (var i = 0; i < t.length && i < r; i++)n(t[i] ? t[i][0] : null, i); else for (var a = t[0] || [], i = 0; i < a.length && i < r; i++)n(a[i], i) } function Rne(n) { var e = n.sourceFormat; return e === Ko || e === Il } var kf, Cf, Af, iH, aH, Nne = function () { function n(e, t) { var r = r3(e) ? e : i3(e); this._source = r; var i = this._data = r.data; r.sourceFormat === sd && (this._offset = 0, this._dimSize = t, this._data = i), aH(this, i, r) } return n.prototype.getSource = function () { return this._source }, n.prototype.count = function () { return 0 }, n.prototype.getItem = function (e, t) { }, n.prototype.appendData = function (e) { }, n.prototype.clean = function () { }, n.protoInitialize = function () { var e = n.prototype; e.pure = !1, e.persistent = !0 }(), n.internalField = function () { var e; aH = function (o, s, l) { var c = l.sourceFormat, u = l.seriesLayoutBy, d = l.startIndex, f = l.dimensionsDefine, h = iH[a3(c, u)]; if (be(o, h), c === sd) o.getItem = t, o.count = i, o.fillStorage = r; else { var p = Bne(c, u); o.getItem = He(p, null, s, d, f); var m = $ne(c, u); o.count = He(m, null, s, d, f) } }; var t = function (o, s) { o = o - this._offset, s = s || []; for (var l = this._data, c = this._dimSize, u = c * o, d = 0; d < c; d++)s[d] = l[u + d]; return s }, r = function (o, s, l, c) { for (var u = this._data, d = this._dimSize, f = 0; f < d; f++) { for (var h = c[f], p = h[0] == null ? 1 / 0 : h[0], m = h[1] == null ? -1 / 0 : h[1], g = s - o, y = l[f], b = 0; b < g; b++) { var w = u[b * d + f]; y[o + b] = w, w < p && (p = w), w > m && (m = w) } h[0] = p, h[1] = m } }, i = function () { return this._data ? this._data.length / this._dimSize : 0 }; iH = (e = {}, e[Li + "_" + ml] = { pure: !0, appendData: a }, e[Li + "_" + rv] = { pure: !0, appendData: function () { throw new Error('Do not support appendData when set seriesLayoutBy: "row".') } }, e[Ko] = { pure: !0, appendData: a }, e[Il] = { pure: !0, appendData: function (o) { var s = this._data; $(o, function (l, c) { for (var u = s[c] || (s[c] = []), d = 0; d < (l || []).length; d++)u.push(l[d]) }) } }, e[Wo] = { appendData: a }, e[sd] = { persistent: !1, pure: !0, appendData: function (o) { this._data = o }, clean: function () { this._offset += this.count(), this._data = null } }, e); function a(o) { for (var s = 0; s < o.length; s++)this._data.push(o[s]) } }(), n }(), oH = function (n, e, t, r) { return n[r] }, KVe = (kf = {}, kf[Li + "_" + ml] = function (n, e, t, r) { return n[r + e] }, kf[Li + "_" + rv] = function (n, e, t, r, i) { r += e; for (var a = i || [], o = n, s = 0; s < o.length; s++) { var l = o[s]; a[s] = l ? l[r] : null } return a }, kf[Ko] = oH, kf[Il] = function (n, e, t, r, i) { for (var a = i || [], o = 0; o < t.length; o++) { var s = t[o].name, l = n[s]; a[o] = l ? l[r] : null } return a }, kf[Wo] = oH, kf); function Bne(n, e) { var t = KVe[a3(n, e)]; return t } var sH = function (n, e, t) { return n.length }, qVe = (Cf = {}, Cf[Li + "_" + ml] = function (n, e, t) { return Math.max(0, n.length - e) }, Cf[Li + "_" + rv] = function (n, e, t) { var r = n[0]; return r ? Math.max(0, r.length - e) : 0 }, Cf[Ko] = sH, Cf[Il] = function (n, e, t) { var r = t[0].name, i = n[r]; return i ? i.length : 0 }, Cf[Wo] = sH, Cf); function $ne(n, e) { var t = qVe[a3(n, e)]; return t } var KM = function (n, e, t) { return n[e] }, YVe = (Af = {}, Af[Li] = KM, Af[Ko] = function (n, e, t) { return n[t] }, Af[Il] = KM, Af[Wo] = function (n, e, t) { var r = Yg(n); return r instanceof Array ? r[e] : r }, Af[sd] = KM, Af); function Fne(n) { var e = YVe[n]; return e } function a3(n, e) { return n === Li ? n + "_" + e : n } function Cg(n, e, t) { if (n) { var r = n.getRawDataItem(e); if (r != null) { var i = n.getStore(), a = i.getSource().sourceFormat; if (t != null) { var o = n.getDimensionIndex(t), s = i.getDimensionProperty(o); return Fne(a)(r, o, s) } else { var l = r; return a === Wo && (l = Yg(r)), l } } } } var ZVe = /\{@(.+?)\}/g, mC = function () { function n() { } return n.prototype.getDataParams = function (e, t) { var r = this.getData(t), i = this.getRawValue(e, t), a = r.getRawIndex(e), o = r.getName(e), s = r.getRawDataItem(e), l = r.getItemVisual(e, "style"), c = l && l[r.getItemVisual(e, "drawType") || "fill"], u = l && l.stroke, d = this.mainType, f = d === "series", h = r.userOutput && r.userOutput.get(); return { componentType: d, componentSubType: this.subType, componentIndex: this.componentIndex, seriesType: f ? this.subType : null, seriesIndex: this.seriesIndex, seriesId: f ? this.id : null, seriesName: f ? this.name : null, name: o, dataIndex: a, data: s, dataType: t, value: i, color: c, borderColor: u, dimensionNames: h ? h.fullDimensions : null, encode: h ? h.encode : null, $vars: ["seriesName", "name", "value"] } }, n.prototype.getFormattedLabel = function (e, t, r, i, a, o) { t = t || "normal"; var s = this.getData(r), l = this.getDataParams(e, r); if (o && (l.value = o.interpolatedValue), i != null && ke(l.value) && (l.value = l.value[i]), !a) { var c = s.getItemModel(e); a = c.get(t === "normal" ? ["label", "formatter"] : [t, "label", "formatter"]) } if (tt(a)) return l.status = t, l.dimensionIndex = i, a(l); if (Fe(a)) { var u = _ne(a, l); return u.replace(ZVe, function (d, f) { var h = f.length, p = f; p.charAt(0) === "[" && p.charAt(h - 1) === "]" && (p = +p.slice(1, h - 1)); var m = Cg(s, e, p); if (o && ke(o.interpolatedValue)) { var g = s.getDimensionIndex(p); g >= 0 && (m = o.interpolatedValue[g]) } return m != null ? m + "" : "" }) } }, n.prototype.getRawValue = function (e, t) { return Cg(this.getData(t), e) }, n.prototype.formatTooltip = function (e, t, r) { }, n }(); function lH(n) { var e, t; return ot(n) ? n.type && (t = n) : e = n, { text: e, frag: t } } function y0(n) { return new XVe(n) } var XVe = function () { function n(e) { e = e || {}, this._reset = e.reset, this._plan = e.plan, this._count = e.count, this._onDirty = e.onDirty, this._dirty = !0 } return n.prototype.perform = function (e) { var t = this._upstream, r = e && e.skip; if (this._dirty && t) { var i = this.context; i.data = i.outputData = t.context.outputData } this.__pipeline && (this.__pipeline.currentTask = this); var a; this._plan && !r && (a = this._plan(this.context)); var o = u(this._modBy), s = this._modDataCount || 0, l = u(e && e.modBy), c = e && e.modDataCount || 0; (o !== l || s !== c) && (a = "reset"); function u(b) { return !(b >= 1) && (b = 1), b } var d; (this._dirty || a === "reset") && (this._dirty = !1, d = this._doReset(r)), this._modBy = l, this._modDataCount = c; var f = e && e.step; if (t ? this._dueEnd = t._outputDueEnd : this._dueEnd = this._count ? this._count(this.context) : 1 / 0, this._progress) { var h = this._dueIndex, p = Math.min(f != null ? this._dueIndex + f : 1 / 0, this._dueEnd); if (!r && (d || h < p)) { var m = this._progress; if (ke(m)) for (var g = 0; g < m.length; g++)this._doProgress(m[g], h, p, l, c); else this._doProgress(m, h, p, l, c) } this._dueIndex = p; var y = this._settedOutputEnd != null ? this._settedOutputEnd : p; this._outputDueEnd = y } else this._dueIndex = this._outputDueEnd = this._settedOutputEnd != null ? this._settedOutputEnd : this._dueEnd; return this.unfinished() }, n.prototype.dirty = function () { this._dirty = !0, this._onDirty && this._onDirty(this.context) }, n.prototype._doProgress = function (e, t, r, i, a) { cH.reset(t, r, i, a), this._callingProgress = e, this._callingProgress({ start: t, end: r, count: r - t, next: cH.next }, this.context) }, n.prototype._doReset = function (e) { this._dueIndex = this._outputDueEnd = this._dueEnd = 0, this._settedOutputEnd = null; var t, r; !e && this._reset && (t = this._reset(this.context), t && t.progress && (r = t.forceFirstProgress, t = t.progress), ke(t) && !t.length && (t = null)), this._progress = t, this._modBy = this._modDataCount = null; var i = this._downstream; return i && i.dirty(), r }, n.prototype.unfinished = function () { return this._progress && this._dueIndex < this._dueEnd }, n.prototype.pipe = function (e) { (this._downstream !== e || this._dirty) && (this._downstream = e, e._upstream = this, e.dirty()) }, n.prototype.dispose = function () { this._disposed || (this._upstream && (this._upstream._downstream = null), this._downstream && (this._downstream._upstream = null), this._dirty = !1, this._disposed = !0) }, n.prototype.getUpstream = function () { return this._upstream }, n.prototype.getDownstream = function () { return this._downstream }, n.prototype.setOutputEnd = function (e) { this._outputDueEnd = this._settedOutputEnd = e }, n }(), cH = function () { var n, e, t, r, i, a = { reset: function (l, c, u, d) { e = l, n = c, t = u, r = d, i = Math.ceil(r / t), a.next = t > 1 && r > 0 ? s : o } }; return a; function o() { return e < n ? e++ : null } function s() { var l = e % i * t + Math.ceil(e / i), c = e >= n ? null : l < r ? l : e; return e++, c } }(); function ld(n, e) { var t = e && e.type; return t === "ordinal" ? n : (t === "time" && !nn(n) && n != null && n !== "-" && (n = +kl(n)), n == null || n === "" ? NaN : Number(n)) } var JVe = Ze({ number: function (n) { return parseFloat(n) }, time: function (n) { return +kl(n) }, trim: function (n) { return Fe(n) ? ps(n) : n } }); function zne(n) { return JVe.get(n) } var Vne = { lt: function (n, e) { return n < e }, lte: function (n, e) { return n <= e }, gt: function (n, e) { return n > e }, gte: function (n, e) { return n >= e } }, QVe = function () { function n(e, t) { if (!nn(t)) { var r = ""; hn(r) } this._opFn = Vne[e], this._rvalFloat = jc(t) } return n.prototype.evaluate = function (e) { return nn(e) ? this._opFn(e, this._rvalFloat) : this._opFn(jc(e), this._rvalFloat) }, n }(), Hne = function () { function n(e, t) { var r = e === "desc"; this._resultLT = r ? 1 : -1, t == null && (t = r ? "min" : "max"), this._incomparable = t === "min" ? -1 / 0 : 1 / 0 } return n.prototype.evaluate = function (e, t) { var r = nn(e) ? e : jc(e), i = nn(t) ? t : jc(t), a = isNaN(r), o = isNaN(i); if (a && (r = this._incomparable), o && (i = this._incomparable), a && o) { var s = Fe(e), l = Fe(t); s && (r = l ? e : 0), l && (i = s ? t : 0) } return r < i ? this._resultLT : r > i ? -this._resultLT : 0 }, n }(), eHe = function () { function n(e, t) { this._rval = t, this._isEQ = e, this._rvalTypeof = typeof t, this._rvalFloat = jc(t) } return n.prototype.evaluate = function (e) { var t = e === this._rval; if (!t) { var r = typeof e; r !== this._rvalTypeof && (r === "number" || this._rvalTypeof === "number") && (t = jc(e) === this._rvalFloat) } return this._isEQ ? t : !t }, n }(); function tHe(n, e) { return n === "eq" || n === "ne" ? new eHe(n === "eq", e) : Ge(Vne, n) ? new QVe(n, e) : null } var nHe = function () { function n() { } return n.prototype.getRawData = function () { throw new Error("not supported") }, n.prototype.getRawDataItem = function (e) { throw new Error("not supported") }, n.prototype.cloneRawData = function () { }, n.prototype.getDimensionInfo = function (e) { }, n.prototype.cloneAllDimensionInfo = function () { }, n.prototype.count = function () { }, n.prototype.retrieveValue = function (e, t) { }, n.prototype.retrieveValueFromItem = function (e, t) { }, n.prototype.convertValue = function (e, t) { return ld(e, t) }, n }(); function rHe(n, e) { var t = new nHe, r = n.data, i = t.sourceFormat = n.sourceFormat, a = n.startIndex, o = ""; n.seriesLayoutBy !== ml && hn(o); var s = [], l = {}, c = n.dimensionsDefine; if (c) $(c, function (m, g) { var y = m.name, b = { index: g, name: y, displayName: m.displayName }; if (s.push(b), y != null) { var w = ""; Ge(l, y) && hn(w), l[y] = b } }); else for (var u = 0; u < n.dimensionsDetectedCount; u++)s.push({ index: u }); var d = Bne(i, ml); e.__isBuiltIn && (t.getRawDataItem = function (m) { return d(r, a, s, m) }, t.getRawData = He(iHe, null, n)), t.cloneRawData = He(aHe, null, n); var f = $ne(i, ml); t.count = He(f, null, r, a, s); var h = Fne(i); t.retrieveValue = function (m, g) { var y = d(r, a, s, m); return p(y, g) }; var p = t.retrieveValueFromItem = function (m, g) { if (m != null) { var y = s[g]; if (y) return h(m, g, y.name) } }; return t.getDimensionInfo = He(oHe, null, s, l), t.cloneAllDimensionInfo = He(sHe, null, s), t } function iHe(n) { var e = n.sourceFormat; if (!o3(e)) { var t = ""; hn(t) } return n.data } function aHe(n) { var e = n.sourceFormat, t = n.data; if (!o3(e)) { var r = ""; hn(r) } if (e === Li) { for (var i = [], a = 0, o = t.length; a < o; a++)i.push(t[a].slice()); return i } else if (e === Ko) { for (var i = [], a = 0, o = t.length; a < o; a++)i.push(be({}, t[a])); return i } } function oHe(n, e, t) { if (t != null) { if (nn(t) || !isNaN(t) && !Ge(e, t)) return n[t]; if (Ge(e, t)) return e[t] } } function sHe(n) { return lt(n) } var Une = Ze(); function lHe(n) { n = lt(n); var e = n.type, t = ""; e || hn(t); var r = e.split(":"); r.length !== 2 && hn(t); var i = !1; r[0] === "echarts" && (e = r[1], i = !0), n.__isBuiltIn = i, Une.set(e, n) } function cHe(n, e, t) { var r = Cn(n), i = r.length, a = ""; i || hn(a); for (var o = 0, s = i; o < s; o++) { var l = r[o]; e = uHe(l, e), o !== s - 1 && (e.length = Math.max(e.length, 1)) } return e } function uHe(n, e, t, r) { var i = ""; e.length || hn(i), ot(n) || hn(i); var a = n.type, o = Une.get(a); o || hn(i); var s = Ae(e, function (c) { return rHe(c, o) }), l = Cn(o.transform({ upstream: s[0], upstreamList: s, config: lt(n.config) })); return Ae(l, function (c, u) { var d = ""; ot(c) || hn(d), c.data || hn(d); var f = Lne(c.data); o3(f) || hn(d); var h, p = e[0]; if (p && u === 0 && !c.dimensions) { var m = p.startIndex; m && (c.data = p.data.slice(0, m).concat(c.data)), h = { seriesLayoutBy: ml, sourceHeader: m, dimensions: p.metaRawOption.dimensions } } else h = { seriesLayoutBy: ml, sourceHeader: 0, dimensions: c.dimensions }; return oI(c.data, h, null) }) } function o3(n) { return n === Li || n === Ko } var gC = "undefined", dHe = typeof Uint32Array === gC ? Array : Uint32Array, fHe = typeof Uint16Array === gC ? Array : Uint16Array, Gne = typeof Int32Array === gC ? Array : Int32Array, uH = typeof Float64Array === gC ? Array : Float64Array, Wne = { float: uH, int: Gne, ordinal: Array, number: Array, time: uH }, qM; function qp(n) { return n > 65535 ? dHe : fHe } function Yp() { return [1 / 0, -1 / 0] } function hHe(n) { var e = n.constructor; return e === Array ? n.slice() : new e(n) } function dH(n, e, t, r, i) { var a = Wne[t || "float"]; if (i) { var o = n[e], s = o && o.length; if (s !== r) { for (var l = new a(r), c = 0; c < s; c++)l[c] = o[c]; n[e] = l } } else n[e] = new a(r) } var sI = function () { function n() { this._chunks = [], this._rawExtent = [], this._extent = [], this._count = 0, this._rawCount = 0, this._calcDimNameToIdx = Ze() } return n.prototype.initData = function (e, t, r) { this._provider = e, this._chunks = [], this._indices = null, this.getRawIndex = this._getRawIdxIdentity; var i = e.getSource(), a = this.defaultDimValueGetter = qM[i.sourceFormat]; this._dimValueGetter = r || a, this._rawExtent = [], Rne(i), this._dimensions = Ae(t, function (o) { return { type: o.type, property: o.property } }), this._initDataFromProvider(0, e.count()) }, n.prototype.getProvider = function () { return this._provider }, n.prototype.getSource = function () { return this._provider.getSource() }, n.prototype.ensureCalculationDimension = function (e, t) { var r = this._calcDimNameToIdx, i = this._dimensions, a = r.get(e); if (a != null) { if (i[a].type === t) return a } else a = i.length; return i[a] = { type: t }, r.set(e, a), this._chunks[a] = new Wne[t || "float"](this._rawCount), this._rawExtent[a] = Yp(), a }, n.prototype.collectOrdinalMeta = function (e, t) { var r = this._chunks[e], i = this._dimensions[e], a = this._rawExtent, o = i.ordinalOffset || 0, s = r.length; o === 0 && (a[e] = Yp()); for (var l = a[e], c = o; c < s; c++) { var u = r[c] = t.parseAndCollect(r[c]); isNaN(u) || (l[0] = Math.min(u, l[0]), l[1] = Math.max(u, l[1])) } i.ordinalMeta = t, i.ordinalOffset = s, i.type = "ordinal" }, n.prototype.getOrdinalMeta = function (e) { var t = this._dimensions[e], r = t.ordinalMeta; return r }, n.prototype.getDimensionProperty = function (e) { var t = this._dimensions[e]; return t && t.property }, n.prototype.appendData = function (e) { var t = this._provider, r = this.count(); t.appendData(e); var i = t.count(); return t.persistent || (i += r), r < i && this._initDataFromProvider(r, i, !0), [r, i] }, n.prototype.appendValues = function (e, t) { for (var r = this._chunks, i = this._dimensions, a = i.length, o = this._rawExtent, s = this.count(), l = s + Math.max(e.length, t || 0), c = 0; c < a; c++) { var u = i[c]; dH(r, c, u.type, l, !0) } for (var d = [], f = s; f < l; f++)for (var h = f - s, p = 0; p < a; p++) { var u = i[p], m = qM.arrayRows.call(this, e[h] || d, u.property, h, p); r[p][f] = m; var g = o[p]; m < g[0] && (g[0] = m), m > g[1] && (g[1] = m) } return this._rawCount = this._count = l, { start: s, end: l } }, n.prototype._initDataFromProvider = function (e, t, r) { for (var i = this._provider, a = this._chunks, o = this._dimensions, s = o.length, l = this._rawExtent, c = Ae(o, function (b) { return b.property }), u = 0; u < s; u++) { var d = o[u]; l[u] || (l[u] = Yp()), dH(a, u, d.type, t, r) } if (i.fillStorage) i.fillStorage(e, t, a, l); else for (var f = [], h = e; h < t; h++) { f = i.getItem(h, f); for (var p = 0; p < s; p++) { var m = a[p], g = this._dimValueGetter(f, c[p], h, p); m[h] = g; var y = l[p]; g < y[0] && (y[0] = g), g > y[1] && (y[1] = g) } } !i.persistent && i.clean && i.clean(), this._rawCount = this._count = t, this._extent = [] }, n.prototype.count = function () { return this._count }, n.prototype.get = function (e, t) { if (!(t >= 0 && t < this._count)) return NaN; var r = this._chunks[e]; return r ? r[this.getRawIndex(t)] : NaN }, n.prototype.getValues = function (e, t) { var r = [], i = []; if (t == null) { t = e, e = []; for (var a = 0; a < this._dimensions.length; a++)i.push(a) } else i = e; for (var a = 0, o = i.length; a < o; a++)r.push(this.get(i[a], t)); return r }, n.prototype.getByRawIndex = function (e, t) { if (!(t >= 0 && t < this._rawCount)) return NaN; var r = this._chunks[e]; return r ? r[t] : NaN }, n.prototype.getSum = function (e) { var t = this._chunks[e], r = 0; if (t) for (var i = 0, a = this.count(); i < a; i++) { var o = this.get(e, i); isNaN(o) || (r += o) } return r }, n.prototype.getMedian = function (e) { var t = []; this.each([e], function (a) { isNaN(a) || t.push(a) }); var r = t.sort(function (a, o) { return a - o }), i = this.count(); return i === 0 ? 0 : i % 2 === 1 ? r[(i - 1) / 2] : (r[i / 2] + r[i / 2 - 1]) / 2 }, n.prototype.indexOfRawIndex = function (e) { if (e >= this._rawCount || e < 0) return -1; if (!this._indices) return e; var t = this._indices, r = t[e]; if (r != null && r < this._count && r === e) return e; for (var i = 0, a = this._count - 1; i <= a;) { var o = (i + a) / 2 | 0; if (t[o] < e) i = o + 1; else if (t[o] > e) a = o - 1; else return o } return -1 }, n.prototype.indicesOfNearest = function (e, t, r) { var i = this._chunks, a = i[e], o = []; if (!a) return o; r == null && (r = 1 / 0); for (var s = 1 / 0, l = -1, c = 0, u = 0, d = this.count(); u < d; u++) { var f = this.getRawIndex(u), h = t - a[f], p = Math.abs(h); p <= r && ((p < s || p === s && h >= 0 && l < 0) && (s = p, l = h, c = 0), h === l && (o[c++] = u)) } return o.length = c, o }, n.prototype.getIndices = function () { var e, t = this._indices; if (t) { var r = t.constructor, i = this._count; if (r === Array) { e = new r(i); for (var a = 0; a < i; a++)e[a] = t[a] } else e = new r(t.buffer, 0, i) } else { var r = qp(this._rawCount); e = new r(this.count()); for (var a = 0; a < e.length; a++)e[a] = a } return e }, n.prototype.filter = function (e, t) { if (!this._count) return this; for (var r = this.clone(), i = r.count(), a = qp(r._rawCount), o = new a(i), s = [], l = e.length, c = 0, u = e[0], d = r._chunks, f = 0; f < i; f++) { var h = void 0, p = r.getRawIndex(f); if (l === 0) h = t(f); else if (l === 1) { var m = d[u][p]; h = t(m, f) } else { for (var g = 0; g < l; g++)s[g] = d[e[g]][p]; s[g] = f, h = t.apply(null, s) } h && (o[c++] = p) } return c < i && (r._indices = o), r._count = c, r._extent = [], r._updateGetRawIdx(), r }, n.prototype.selectRange = function (e) { var t = this.clone(), r = t._count; if (!r) return this; var i = Bt(e), a = i.length; if (!a) return this; var o = t.count(), s = qp(t._rawCount), l = new s(o), c = 0, u = i[0], d = e[u][0], f = e[u][1], h = t._chunks, p = !1; if (!t._indices) { var m = 0; if (a === 1) { for (var g = h[i[0]], y = 0; y < r; y++) { var b = g[y]; (b >= d && b <= f || isNaN(b)) && (l[c++] = m), m++ } p = !0 } else if (a === 2) { for (var g = h[i[0]], w = h[i[1]], v = e[i[1]][0], S = e[i[1]][1], y = 0; y < r; y++) { var b = g[y], x = w[y]; (b >= d && b <= f || isNaN(b)) && (x >= v && x <= S || isNaN(x)) && (l[c++] = m), m++ } p = !0 } } if (!p) if (a === 1) for (var y = 0; y < o; y++) { var k = t.getRawIndex(y), b = h[i[0]][k]; (b >= d && b <= f || isNaN(b)) && (l[c++] = k) } else for (var y = 0; y < o; y++) { for (var A = !0, k = t.getRawIndex(y), C = 0; C < a; C++) { var E = i[C], b = h[E][k]; (b < e[E][0] || b > e[E][1]) && (A = !1) } A && (l[c++] = t.getRawIndex(y)) } return c < o && (t._indices = l), t._count = c, t._extent = [], t._updateGetRawIdx(), t }, n.prototype.map = function (e, t) { var r = this.clone(e); return this._updateDims(r, e, t), r }, n.prototype.modify = function (e, t) { this._updateDims(this, e, t) }, n.prototype._updateDims = function (e, t, r) { for (var i = e._chunks, a = [], o = t.length, s = e.count(), l = [], c = e._rawExtent, u = 0; u < t.length; u++)c[t[u]] = Yp(); for (var d = 0; d < s; d++) { for (var f = e.getRawIndex(d), h = 0; h < o; h++)l[h] = i[t[h]][f]; l[o] = d; var p = r && r.apply(null, l); if (p != null) { typeof p != "object" && (a[0] = p, p = a); for (var u = 0; u < p.length; u++) { var m = t[u], g = p[u], y = c[m], b = i[m]; b && (b[f] = g), g < y[0] && (y[0] = g), g > y[1] && (y[1] = g) } } } }, n.prototype.lttbDownSample = function (e, t) { var r = this.clone([e], !0), i = r._chunks, a = i[e], o = this.count(), s = 0, l = Math.floor(1 / t), c = this.getRawIndex(0), u, d, f, h = new (qp(this._rawCount))(Math.min((Math.ceil(o / l) + 2) * 2, o)); h[s++] = c; for (var p = 1; p < o - 1; p += l) { for (var m = Math.min(p + l, o - 1), g = Math.min(p + l * 2, o), y = (g + m) / 2, b = 0, w = m; w < g; w++) { var v = this.getRawIndex(w), S = a[v]; isNaN(S) || (b += S) } b /= g - m; var x = p, k = Math.min(p + l, o), A = p - 1, C = a[c]; u = -1, f = x; for (var E = -1, O = 0, w = x; w < k; w++) { var v = this.getRawIndex(w), S = a[v]; if (isNaN(S)) { O++, E < 0 && (E = v); continue } d = Math.abs((A - y) * (S - C) - (A - w) * (b - C)), d > u && (u = d, f = v) } O > 0 && O < k - x && (h[s++] = Math.min(E, f), f = Math.max(E, f)), h[s++] = f, c = f } return h[s++] = this.getRawIndex(o - 1), r._count = s, r._indices = h, r.getRawIndex = this._getRawIdx, r }, n.prototype.minmaxDownSample = function (e, t) { for (var r = this.clone([e], !0), i = r._chunks, a = Math.floor(1 / t), o = i[e], s = this.count(), l = new (qp(this._rawCount))(Math.ceil(s / a) * 2), c = 0, u = 0; u < s; u += a) { var d = u, f = o[this.getRawIndex(d)], h = u, p = o[this.getRawIndex(h)], m = a; u + a > s && (m = s - u); for (var g = 0; g < m; g++) { var y = this.getRawIndex(u + g), b = o[y]; b < f && (f = b, d = u + g), b > p && (p = b, h = u + g) } var w = this.getRawIndex(d), v = this.getRawIndex(h); d < h ? (l[c++] = w, l[c++] = v) : (l[c++] = v, l[c++] = w) } return r._count = c, r._indices = l, r._updateGetRawIdx(), r }, n.prototype.downSample = function (e, t, r, i) { for (var a = this.clone([e], !0), o = a._chunks, s = [], l = Math.floor(1 / t), c = o[e], u = this.count(), d = a._rawExtent[e] = Yp(), f = new (qp(this._rawCount))(Math.ceil(u / l)), h = 0, p = 0; p < u; p += l) { l > u - p && (l = u - p, s.length = l); for (var m = 0; m < l; m++) { var g = this.getRawIndex(p + m); s[m] = c[g] } var y = r(s), b = this.getRawIndex(Math.min(p + i(s, y) || 0, u - 1)); c[b] = y, y < d[0] && (d[0] = y), y > d[1] && (d[1] = y), f[h++] = b } return a._count = h, a._indices = f, a._updateGetRawIdx(), a }, n.prototype.each = function (e, t) { if (this._count) for (var r = e.length, i = this._chunks, a = 0, o = this.count(); a < o; a++) { var s = this.getRawIndex(a); switch (r) { case 0: t(a); break; case 1: t(i[e[0]][s], a); break; case 2: t(i[e[0]][s], i[e[1]][s], a); break; default: for (var l = 0, c = []; l < r; l++)c[l] = i[e[l]][s]; c[l] = a, t.apply(null, c) } } }, n.prototype.getDataExtent = function (e) { var t = this._chunks[e], r = Yp(); if (!t) return r; var i = this.count(), a = !this._indices, o; if (a) return this._rawExtent[e].slice(); if (o = this._extent[e], o) return o.slice(); o = r; for (var s = o[0], l = o[1], c = 0; c < i; c++) { var u = this.getRawIndex(c), d = t[u]; d < s && (s = d), d > l && (l = d) } return o = [s, l], this._extent[e] = o, o }, n.prototype.getRawDataItem = function (e) { var t = this.getRawIndex(e); if (this._provider.persistent) return this._provider.getItem(t); for (var r = [], i = this._chunks, a = 0; a < i.length; a++)r.push(i[a][t]); return r }, n.prototype.clone = function (e, t) { var r = new n, i = this._chunks, a = e && xl(e, function (s, l) { return s[l] = !0, s }, {}); if (a) for (var o = 0; o < i.length; o++)r._chunks[o] = a[o] ? hHe(i[o]) : i[o]; else r._chunks = i; return this._copyCommonProps(r), t || (r._indices = this._cloneIndices()), r._updateGetRawIdx(), r }, n.prototype._copyCommonProps = function (e) { e._count = this._count, e._rawCount = this._rawCount, e._provider = this._provider, e._dimensions = this._dimensions, e._extent = lt(this._extent), e._rawExtent = lt(this._rawExtent) }, n.prototype._cloneIndices = function () { if (this._indices) { var e = this._indices.constructor, t = void 0; if (e === Array) { var r = this._indices.length; t = new e(r); for (var i = 0; i < r; i++)t[i] = this._indices[i] } else t = new e(this._indices); return t } return null }, n.prototype._getRawIdxIdentity = function (e) { return e }, n.prototype._getRawIdx = function (e) { return e < this._count && e >= 0 ? this._indices[e] : -1 }, n.prototype._updateGetRawIdx = function () { this.getRawIndex = this._indices ? this._getRawIdx : this._getRawIdxIdentity }, n.internalField = function () { function e(t, r, i, a) { return ld(t[a], this._dimensions[a]) } qM = { arrayRows: e, objectRows: function (t, r, i, a) { return ld(t[r], this._dimensions[a]) }, keyedColumns: e, original: function (t, r, i, a) { var o = t && (t.value == null ? t : t.value); return ld(o instanceof Array ? o[a] : o, this._dimensions[a]) }, typedArray: function (t, r, i, a) { return t[a] } } }(), n }(), Kne = function () { function n(e) { this._sourceList = [], this._storeList = [], this._upstreamSignList = [], this._versionSignBase = 0, this._dirty = !0, this._sourceHost = e } return n.prototype.dirty = function () { this._setLocalSource([], []), this._storeList = [], this._dirty = !0 }, n.prototype._setLocalSource = function (e, t) { this._sourceList = e, this._upstreamSignList = t, this._versionSignBase++, this._versionSignBase > 9e10 && (this._versionSignBase = 0) }, n.prototype._getVersionSign = function () { return this._sourceHost.uid + "_" + this._versionSignBase }, n.prototype.prepareSource = function () { this._isDirty() && (this._createSource(), this._dirty = !1) }, n.prototype._createSource = function () { this._setLocalSource([], []); var e = this._sourceHost, t = this._getUpstreamSourceManagers(), r = !!t.length, i, a; if (Hw(e)) { var o = e, s = void 0, l = void 0, c = void 0; if (r) { var u = t[0]; u.prepareSource(), c = u.getSource(), s = c.data, l = c.sourceFormat, a = [u._getVersionSign()] } else s = o.get("data", !0), l = ka(s) ? sd : Wo, a = []; var d = this._getSourceMetaRawOption() || {}, f = c && c.metaRawOption || {}, h = yt(d.seriesLayoutBy, f.seriesLayoutBy) || null, p = yt(d.sourceHeader, f.sourceHeader), m = yt(d.dimensions, f.dimensions), g = h !== f.seriesLayoutBy || !!p != !!f.sourceHeader || m; i = g ? [oI(s, { seriesLayoutBy: h, sourceHeader: p, dimensions: m }, l)] : [] } else { var y = e; if (r) { var b = this._applyTransform(t); i = b.sourceList, a = b.upstreamSignList } else { var w = y.get("source", !0); i = [oI(w, this._getSourceMetaRawOption(), null)], a = [] } } this._setLocalSource(i, a) }, n.prototype._applyTransform = function (e) { var t = this._sourceHost, r = t.get("transform", !0), i = t.get("fromTransformResult", !0); if (i != null) { var a = ""; e.length !== 1 && hH(a) } var o, s = [], l = []; return $(e, function (c) { c.prepareSource(); var u = c.getSource(i || 0), d = ""; i != null && !u && hH(d), s.push(u), l.push(c._getVersionSign()) }), r ? o = cHe(r, s, { datasetIndex: t.componentIndex }) : i != null && (o = [UVe(s[0])]), { sourceList: o, upstreamSignList: l } }, n.prototype._isDirty = function () { if (this._dirty) return !0; for (var e = this._getUpstreamSourceManagers(), t = 0; t < e.length; t++) { var r = e[t]; if (r._isDirty() || this._upstreamSignList[t] !== r._getVersionSign()) return !0 } }, n.prototype.getSource = function (e) { e = e || 0; var t = this._sourceList[e]; if (!t) { var r = this._getUpstreamSourceManagers(); return r[0] && r[0].getSource(e) } return t }, n.prototype.getSharedDataStore = function (e) { var t = e.makeStoreSchema(); return this._innerGetDataStore(t.dimensions, e.source, t.hash) }, n.prototype._innerGetDataStore = function (e, t, r) { var i = 0, a = this._storeList, o = a[i]; o || (o = a[i] = {}); var s = o[r]; if (!s) { var l = this._getUpstreamSourceManagers()[0]; Hw(this._sourceHost) && l ? s = l._innerGetDataStore(e, t, r) : (s = new sI, s.initData(new Nne(t, e.length), e)), o[r] = s } return s }, n.prototype._getUpstreamSourceManagers = function () { var e = this._sourceHost; if (Hw(e)) { var t = t3(e); return t ? [t.getSourceManager()] : [] } else return Ae(gVe(e), function (r) { return r.getSourceManager() }) }, n.prototype._getSourceMetaRawOption = function () { var e = this._sourceHost, t, r, i; if (Hw(e)) t = e.get("seriesLayoutBy", !0), r = e.get("sourceHeader", !0), i = e.get("dimensions", !0); else if (!this._getUpstreamSourceManagers().length) { var a = e; t = a.get("seriesLayoutBy", !0), r = a.get("sourceHeader", !0), i = a.get("dimensions", !0) } return { seriesLayoutBy: t, sourceHeader: r, dimensions: i } }, n }(); function fH(n) { var e = n.option.transform; e && V2(n.option.transform) } function Hw(n) { return n.mainType === "series" } function hH(n) { throw new Error(n) } var pHe = "line-height:1"; function qne(n) { var e = n.lineHeight; return e == null ? pHe : "line-height:" + Ai(e + "") + "px" } function Yne(n, e) { var t = n.color || "#6e7079", r = n.fontSize || 12, i = n.fontWeight || "400", a = n.color || "#464646", o = n.fontSize || 14, s = n.fontWeight || "900"; return e === "html" ? { nameStyle: "font-size:" + Ai(r + "") + "px;color:" + Ai(t) + ";font-weight:" + Ai(i + ""), valueStyle: "font-size:" + Ai(o + "") + "px;color:" + Ai(a) + ";font-weight:" + Ai(s + "") } : { nameStyle: { fontSize: r, fill: t, fontWeight: i }, valueStyle: { fontSize: o, fill: a, fontWeight: s } } } var mHe = [0, 10, 20, 30], gHe = ["", `
`, `

`, `


`]; function Gr(n, e) { return e.type = n, e } function lI(n) { return n.type === "section" } function Zne(n) { return lI(n) ? vHe : yHe } function Xne(n) { if (lI(n)) { var e = 0, t = n.blocks.length, r = t > 1 || t > 0 && !n.noHeader; return $(n.blocks, function (i) { var a = Xne(i); a >= e && (e = a + +(r && (!a || lI(i) && !i.noHeader))) }), e } return 0 } function vHe(n, e, t, r) { var i = e.noHeader, a = _He(Xne(e)), o = [], s = e.blocks || []; na(!s || ke(s)), s = s || []; var l = n.orderMode; if (e.sortBlocks && l) { s = s.slice(); var c = { valueAsc: "asc", valueDesc: "desc" }; if (Ge(c, l)) { var u = new Hne(c[l], null); s.sort(function (m, g) { return u.evaluate(m.sortParam, g.sortParam) }) } else l === "seriesDesc" && s.reverse() } $(s, function (m, g) { var y = e.valueFormatter, b = Zne(m)(y ? be(be({}, n), { valueFormatter: y }) : n, m, g > 0 ? a.html : 0, r); b != null && o.push(b) }); var d = n.renderMode === "richText" ? o.join(a.richText) : cI(r, o.join(""), i ? t : a.html); if (i) return d; var f = rI(e.header, "ordinal", n.useUTC), h = Yne(r, n.renderMode).nameStyle, p = qne(r); return n.renderMode === "richText" ? Jne(n, f, h) + a.richText + d : cI(r, '<div style="' + h + ";" + p + ';">' + Ai(f) + "</div>" + d, t) } function yHe(n, e, t, r) { var i = n.renderMode, a = e.noName, o = e.noValue, s = !e.markerType, l = e.name, c = n.useUTC, u = e.valueFormatter || n.valueFormatter || function (v) { return v = ke(v) ? v : [v], Ae(v, function (S, x) { return rI(S, ke(h) ? h[x] : h, c) }) }; if (!(a && o)) { var d = s ? "" : n.markupStyleCreator.makeTooltipMarker(e.markerType, e.markerColor || "#333", i), f = a ? "" : rI(l, "ordinal", c), h = e.valueType, p = o ? [] : u(e.value, e.dataIndex), m = !s || !a, g = !s && a, y = Yne(r, i), b = y.nameStyle, w = y.valueStyle; return i === "richText" ? (s ? "" : d) + (a ? "" : Jne(n, f, b)) + (o ? "" : xHe(n, p, m, g, w)) : cI(r, (s ? "" : d) + (a ? "" : bHe(f, !s, b)) + (o ? "" : wHe(p, m, g, w)), t) } } function pH(n, e, t, r, i, a) { if (n) { var o = Zne(n), s = { useUTC: i, renderMode: t, orderMode: r, markupStyleCreator: e, valueFormatter: n.valueFormatter }; return o(s, n, 0, a) } } function _He(n) { return { html: mHe[n], richText: gHe[n] } } function cI(n, e, t) { var r = '<div style="clear:both"></div>', i = "margin: " + t + "px 0 0", a = qne(n); return '<div style="' + i + ";" + a + ';">' + e + r + "</div>" } function bHe(n, e, t) { var r = e ? "margin-left:2px" : ""; return '<span style="' + t + ";" + r + '">' + Ai(n) + "</span>" } function wHe(n, e, t, r) { var i = t ? "10px" : "20px", a = e ? "float:right;margin-left:" + i : ""; return n = ke(n) ? n : [n], '<span style="' + a + ";" + r + '">' + Ae(n, function (o) { return Ai(o) }).join("&nbsp;&nbsp;") + "</span>" } function Jne(n, e, t) { return n.markupStyleCreator.wrapRichTextStyle(e, t) } function xHe(n, e, t, r, i) { var a = [i], o = r ? 10 : 20; return t && a.push({ padding: [0, 0, 0, o], align: "right" }), n.markupStyleCreator.wrapRichTextStyle(ke(e) ? e.join("  ") : e, a) } function Qne(n, e) { var t = n.getData().getItemVisual(e, "style"), r = t[n.visualDrawType]; return Wh(r) } function ere(n, e) { var t = n.get("padding"); return t ?? (e === "richText" ? [8, 10] : 10) } var YM = function () { function n() { this.richTextStyles = {}, this._nextStyleNameId = ete() } return n.prototype._generateStyleName = function () { return "__EC_aUTo_" + this._nextStyleNameId++ }, n.prototype.makeTooltipMarker = function (e, t, r) { var i = r === "richText" ? this._generateStyleName() : null, a = cVe({ color: t, type: e, renderMode: r, markerId: i }); return Fe(a) ? a : (this.richTextStyles[i] = a.style, a.content) }, n.prototype.wrapRichTextStyle = function (e, t) { var r = {}; ke(t) ? $(t, function (a) { return be(r, a) }) : be(r, t); var i = this._generateStyleName(); return this.richTextStyles[i] = r, "{" + i + "|" + e + "}" }, n }(); function tre(n) { var e = n.series, t = n.dataIndex, r = n.multipleSeries, i = e.getData(), a = i.mapDimensionsAll("defaultedTooltip"), o = a.length, s = e.getRawValue(t), l = ke(s), c = Qne(e, t), u, d, f, h; if (o > 1 || l && !o) { var p = SHe(s, e, t, a, c); u = p.inlineValues, d = p.inlineValueTypes, f = p.blocks, h = p.inlineValues[0] } else if (o) { var m = i.getDimensionInfo(a[0]); h = u = Cg(i, t, a[0]), d = m.type } else h = u = l ? s[0] : s; var g = DN(e), y = g && e.name || "", b = i.getName(t), w = r ? y : b; return Gr("section", { header: y, noHeader: r || !g, sortParam: h, blocks: [Gr("nameValue", { markerType: "item", markerColor: c, name: w, noName: !ps(w), value: u, valueType: d, dataIndex: t })].concat(f || []) }) } function SHe(n, e, t, r, i) { var a = e.getData(), o = xl(n, function (d, f, h) { var p = a.getDimensionInfo(h); return d = d || p && p.tooltip !== !1 && p.displayName != null }, !1), s = [], l = [], c = []; r.length ? $(r, function (d) { u(Cg(a, t, d), d) }) : $(n, u); function u(d, f) { var h = a.getDimensionInfo(f); !h || h.otherDims.tooltip === !1 || (o ? c.push(Gr("nameValue", { markerType: "subItem", markerColor: i, name: h.displayName, value: d, valueType: h.type })) : (s.push(d), l.push(h.type))) } return { inlineValues: s, inlineValueTypes: l, blocks: c } } var su = Kt(); function Uw(n, e) { return n.getName(e) || n.getId(e) } var oS = "__universalTransitionEnabled", vC = function (n) { te(e, n); function e() { var t = n !== null && n.apply(this, arguments) || this; return t._selectedDataIndicesMap = {}, t } return e.prototype.init = function (t, r, i) { this.seriesIndex = this.componentIndex, this.dataTask = y0({ count: kHe, reset: CHe }), this.dataTask.context = { model: this }, this.mergeDefaultAndTheme(t, i); var a = su(this).sourceManager = new Kne(this); a.prepareSource(); var o = this.getInitialData(t, i); gH(o, this), this.dataTask.context.data = o, su(this).dataBeforeProcessed = o, mH(this), this._initSelectedMapFromData(o) }, e.prototype.mergeDefaultAndTheme = function (t, r) { var i = w_(this), a = i ? tv(t) : {}, o = this.subType; Jt.hasClass(o) && (o += "Series"), xt(t, r.getTheme().get(this.subType)), xt(t, this.getDefaultOption()), Vh(t, "label", ["show"]), this.fillDataTextStyle(t.data), i && Ed(t, a, i) }, e.prototype.mergeOption = function (t, r) { t = xt(this.option, t, !0), this.fillDataTextStyle(t.data); var i = w_(this); i && Ed(this.option, t, i); var a = su(this).sourceManager; a.dirty(), a.prepareSource(); var o = this.getInitialData(t, r); gH(o, this), this.dataTask.dirty(), this.dataTask.context.data = o, su(this).dataBeforeProcessed = o, mH(this), this._initSelectedMapFromData(o) }, e.prototype.fillDataTextStyle = function (t) { if (t && !ka(t)) for (var r = ["show"], i = 0; i < t.length; i++)t[i] && t[i].label && Vh(t[i], "label", r) }, e.prototype.getInitialData = function (t, r) { }, e.prototype.appendData = function (t) { var r = this.getRawData(); r.appendData(t.data) }, e.prototype.getData = function (t) { var r = uI(this); if (r) { var i = r.context.data; return t == null || !i.getLinkedData ? i : i.getLinkedData(t) } else return su(this).data }, e.prototype.getAllData = function () { var t = this.getData(); return t && t.getLinkedDataAll ? t.getLinkedDataAll() : [{ data: t }] }, e.prototype.setData = function (t) { var r = uI(this); if (r) { var i = r.context; i.outputData = t, r !== this.dataTask && (i.data = t) } su(this).data = t }, e.prototype.getEncode = function () { var t = this.get("encode", !0); if (t) return Ze(t) }, e.prototype.getSourceManager = function () { return su(this).sourceManager }, e.prototype.getSource = function () { return this.getSourceManager().getSource() }, e.prototype.getRawData = function () { return su(this).dataBeforeProcessed }, e.prototype.getColorBy = function () { var t = this.get("colorBy"); return t || "series" }, e.prototype.isColorBySeries = function () { return this.getColorBy() === "series" }, e.prototype.getBaseAxis = function () { var t = this.coordinateSystem; return t && t.getBaseAxis && t.getBaseAxis() }, e.prototype.formatTooltip = function (t, r, i) { return tre({ series: this, dataIndex: t, multipleSeries: r }) }, e.prototype.isAnimationEnabled = function () { var t = this.ecModel; if (en.node && !(t && t.ssr)) return !1; var r = this.getShallow("animation"); return r && this.getData().count() > this.getShallow("animationThreshold") && (r = !1), !!r }, e.prototype.restoreData = function () { this.dataTask.dirty() }, e.prototype.getColorFromPalette = function (t, r, i) { var a = this.ecModel, o = n3.prototype.getColorFromPalette.call(this, t, r, i); return o || (o = a.getColorFromPalette(t, r, i)), o }, e.prototype.coordDimToDataDim = function (t) { return this.getRawData().mapDimensionsAll(t) }, e.prototype.getProgressive = function () { return this.get("progressive") }, e.prototype.getProgressiveThreshold = function () { return this.get("progressiveThreshold") }, e.prototype.select = function (t, r) { this._innerSelect(this.getData(r), t) }, e.prototype.unselect = function (t, r) { var i = this.option.selectedMap; if (i) { var a = this.option.selectedMode, o = this.getData(r); if (a === "series" || i === "all") { this.option.selectedMap = {}, this._selectedDataIndicesMap = {}; return } for (var s = 0; s < t.length; s++) { var l = t[s], c = Uw(o, l); i[c] = !1, this._selectedDataIndicesMap[c] = -1 } } }, e.prototype.toggleSelect = function (t, r) { for (var i = [], a = 0; a < t.length; a++)i[0] = t[a], this.isSelected(t[a], r) ? this.unselect(i, r) : this.select(i, r) }, e.prototype.getSelectedDataIndices = function () { if (this.option.selectedMap === "all") return [].slice.call(this.getData().getIndices()); for (var t = this._selectedDataIndicesMap, r = Bt(t), i = [], a = 0; a < r.length; a++) { var o = t[r[a]]; o >= 0 && i.push(o) } return i }, e.prototype.isSelected = function (t, r) { var i = this.option.selectedMap; if (!i) return !1; var a = this.getData(r); return (i === "all" || i[Uw(a, t)]) && !a.getItemModel(t).get(["select", "disabled"]) }, e.prototype.isUniversalTransitionEnabled = function () { if (this[oS]) return !0; var t = this.option.universalTransition; return t ? t === !0 ? !0 : t && t.enabled : !1 }, e.prototype._innerSelect = function (t, r) { var i, a, o = this.option, s = o.selectedMode, l = r.length; if (!(!s || !l)) { if (s === "series") o.selectedMap = "all"; else if (s === "multiple") { ot(o.selectedMap) || (o.selectedMap = {}); for (var c = o.selectedMap, u = 0; u < l; u++) { var d = r[u], f = Uw(t, d); c[f] = !0, this._selectedDataIndicesMap[f] = t.getRawIndex(d) } } else if (s === "single" || s === !0) { var h = r[l - 1], f = Uw(t, h); o.selectedMap = (i = {}, i[f] = !0, i), this._selectedDataIndicesMap = (a = {}, a[f] = t.getRawIndex(h), a) } } }, e.prototype._initSelectedMapFromData = function (t) { if (!this.option.selectedMap) { var r = []; t.hasItemOption && t.each(function (i) { var a = t.getRawDataItem(i); a && a.selected && r.push(i) }), r.length > 0 && this._innerSelect(t, r) } }, e.registerClass = function (t) { return Jt.registerClass(t) }, e.protoInitialize = function () { var t = e.prototype; t.type = "series.__base__", t.seriesIndex = 0, t.ignoreStyleOnData = !1, t.hasSymbolVisual = !1, t.defaultSymbol = "circle", t.visualStyleAccessPath = "itemStyle", t.visualDrawType = "fill" }(), e }(Jt); Cr(vC, mC); Cr(vC, n3); cte(vC, Jt); function mH(n) { var e = n.name; DN(n) || (n.name = THe(n) || e) } function THe(n) { var e = n.getRawData(), t = e.mapDimensionsAll("seriesName"), r = []; return $(t, function (i) { var a = e.getDimensionInfo(i); a.displayName && r.push(a.displayName) }), r.join(" ") } function kHe(n) { return n.model.getRawData().count() } function CHe(n) { var e = n.model; return e.setData(e.getRawData().cloneShallow()), AHe } function AHe(n, e) { e.outputData && n.end > e.outputData.count() && e.model.getRawData().cloneShallow(e.outputData) } function gH(n, e) { $(u_(n.CHANGABLE_METHODS, n.DOWNSAMPLE_METHODS), function (t) { n.wrapMethod(t, wt(EHe, e)) }) } function EHe(n, e) { var t = uI(n); return t && t.setOutputEnd((e || this).count()), e } function uI(n) { var e = (n.ecModel || {}).scheduler, t = e && e.getPipeline(n.uid); if (t) { var r = t.currentTask; if (r) { var i = r.agentStubMap; i && (r = i.get(n.uid)) } return r } } const Yn = vC; var s3 = function () { function n() { this.group = new ft, this.uid = Qg("viewComponent") } return n.prototype.init = function (e, t) { }, n.prototype.render = function (e, t, r, i) { }, n.prototype.dispose = function (e, t) { }, n.prototype.updateView = function (e, t, r, i) { }, n.prototype.updateLayout = function (e, t, r, i) { }, n.prototype.updateVisual = function (e, t, r, i) { }, n.prototype.toggleBlurSeries = function (e, t, r) { }, n.prototype.eachRendered = function (e) { var t = this.group; t && t.traverse(e) }, n }(); PN(s3); Xk(s3); const nr = s3; function iv() { var n = Kt(); return function (e) { var t = n(e), r = e.pipelineContext, i = !!t.large, a = !!t.progressiveRender, o = t.large = !!(r && r.large), s = t.progressiveRender = !!(r && r.progressiveRender); return (i !== o || a !== s) && "reset" } } var nre = Kt(), MHe = iv(), l3 = function () { function n() { this.group = new ft, this.uid = Qg("viewChart"), this.renderTask = y0({ plan: OHe, reset: DHe }), this.renderTask.context = { view: this } } return n.prototype.init = function (e, t) { }, n.prototype.render = function (e, t, r, i) { }, n.prototype.highlight = function (e, t, r, i) { var a = e.getData(i && i.dataType); a && yH(a, i, "emphasis") }, n.prototype.downplay = function (e, t, r, i) { var a = e.getData(i && i.dataType); a && yH(a, i, "normal") }, n.prototype.remove = function (e, t) { this.group.removeAll() }, n.prototype.dispose = function (e, t) { }, n.prototype.updateView = function (e, t, r, i) { this.render(e, t, r, i) }, n.prototype.updateLayout = function (e, t, r, i) { this.render(e, t, r, i) }, n.prototype.updateVisual = function (e, t, r, i) { this.render(e, t, r, i) }, n.prototype.eachRendered = function (e) { Gd(this.group, e) }, n.markUpdateMethod = function (e, t) { nre(e).updateMethod = t }, n.protoInitialize = function () { var e = n.prototype; e.type = "chart" }(), n }(); function vH(n, e, t) { n && y_(n) && (e === "emphasis" ? Pc : Ic)(n, t) } function yH(n, e, t) { var r = Hh(n, e), i = e && e.highlightKey != null ? n6e(e.highlightKey) : null; r != null ? $(Cn(r), function (a) { vH(n.getItemGraphicEl(a), t, i) }) : n.eachItemGraphicEl(function (a) { vH(a, t, i) }) } PN(l3); Xk(l3); function OHe(n) { return MHe(n.model) } function DHe(n) { var e = n.model, t = n.ecModel, r = n.api, i = n.payload, a = e.pipelineContext.progressiveRender, o = n.view, s = i && nre(i).updateMethod, l = a ? "incrementalPrepareRender" : s && o[s] ? s : "render"; return l !== "render" && o[l](e, t, r, i), jHe[l] } var jHe = { incrementalPrepareRender: { progress: function (n, e) { e.view.incrementalRender(n, e.model, e.ecModel, e.api, e.payload) } }, render: { forceFirstProgress: !0, progress: function (n, e) { e.view.render(e.model, e.ecModel, e.api, e.payload) } } }; const Nn = l3; var iT = "\0__throttleOriginMethod", _H = "\0__throttleRate", bH = "\0__throttleType"; function c3(n, e, t) { var r, i = 0, a = 0, o = null, s, l, c, u; e = e || 0; function d() { a = new Date().getTime(), o = null, n.apply(l, c || []) } var f = function () { for (var h = [], p = 0; p < arguments.length; p++)h[p] = arguments[p]; r = new Date().getTime(), l = this, c = h; var m = u || e, g = u || t; u = null, s = r - (g ? i : a) - m, clearTimeout(o), g ? o = setTimeout(d, m) : s >= 0 ? d() : o = setTimeout(d, -s), i = r }; return f.clear = function () { o && (clearTimeout(o), o = null) }, f.debounceNextCall = function (h) { u = h }, f } function av(n, e, t, r) { var i = n[e]; if (i) { var a = i[iT] || i, o = i[bH], s = i[_H]; if (s !== t || o !== r) { if (t == null || !r) return n[e] = a; i = n[e] = c3(a, t, r === "debounce"), i[iT] = a, i[bH] = r, i[_H] = t } return i } } function S_(n, e) { var t = n[e]; t && t[iT] && (t.clear && t.clear(), n[e] = t[iT]) } var wH = Kt(), xH = { itemStyle: Uh(one, !0), lineStyle: Uh(ane, !0) }, PHe = { lineStyle: "stroke", itemStyle: "fill" }; function rre(n, e) { var t = n.visualStyleMapper || xH[e]; return t || (console.warn("Unknown style type '" + e + "'."), xH.itemStyle) } function ire(n, e) { var t = n.visualDrawType || PHe[e]; return t || (console.warn("Unknown style type '" + e + "'."), "fill") } var IHe = { createOnAllSeries: !0, performRawSeries: !0, reset: function (n, e) { var t = n.getData(), r = n.visualStyleAccessPath || "itemStyle", i = n.getModel(r), a = rre(n, r), o = a(i), s = i.getShallow("decal"); s && (t.setVisual("decal", s), s.dirty = !0); var l = ire(n, r), c = o[l], u = tt(c) ? c : null, d = o.fill === "auto" || o.stroke === "auto"; if (!o[l] || u || d) { var f = n.getColorFromPalette(n.name, null, e.getSeriesCount()); o[l] || (o[l] = f, t.setVisual("colorFromPalette", !0)), o.fill = o.fill === "auto" || tt(o.fill) ? f : o.fill, o.stroke = o.stroke === "auto" || tt(o.stroke) ? f : o.stroke } if (t.setVisual("style", o), t.setVisual("drawType", l), !e.isSeriesFiltered(n) && u) return t.setVisual("colorFromPalette", !1), { dataEach: function (h, p) { var m = n.getDataParams(p), g = be({}, o); g[l] = u(m), h.setItemVisual(p, "style", g) } } } }, Zv = new Rn, LHe = { createOnAllSeries: !0, performRawSeries: !0, reset: function (n, e) { if (!(n.ignoreStyleOnData || e.isSeriesFiltered(n))) { var t = n.getData(), r = n.visualStyleAccessPath || "itemStyle", i = rre(n, r), a = t.getVisual("drawType"); return { dataEach: t.hasItemOption ? function (o, s) { var l = o.getRawDataItem(s); if (l && l[r]) { Zv.option = l[r]; var c = i(Zv), u = o.ensureUniqueItemVisual(s, "style"); be(u, c), Zv.option.decal && (o.setItemVisual(s, "decal", Zv.option.decal), Zv.option.decal.dirty = !0), a in c && o.setItemVisual(s, "colorFromPalette", !1) } } : null } } } }, RHe = { performRawSeries: !0, overallReset: function (n) { var e = Ze(); n.eachSeries(function (t) { var r = t.getColorBy(); if (!t.isColorBySeries()) { var i = t.type + "-" + r, a = e.get(i); a || (a = {}, e.set(i, a)), wH(t).scope = a } }), n.eachSeries(function (t) { if (!(t.isColorBySeries() || n.isSeriesFiltered(t))) { var r = t.getRawData(), i = {}, a = t.getData(), o = wH(t).scope, s = t.visualStyleAccessPath || "itemStyle", l = ire(t, s); a.each(function (c) { var u = a.getRawIndex(c); i[u] = c }), r.each(function (c) { var u = i[c], d = a.getItemVisual(u, "colorFromPalette"); if (d) { var f = a.ensureUniqueItemVisual(u, "style"), h = r.getName(c) || c + "", p = r.count(); f[l] = t.getColorFromPalette(h, o, p) } }) } }) } }, Gw = Math.PI; function NHe(n, e) { e = e || {}, rt(e, { text: "loading", textColor: "#000", fontSize: 12, fontWeight: "normal", fontStyle: "normal", fontFamily: "sans-serif", maskColor: "rgba(255, 255, 255, 0.8)", showSpinner: !0, color: "#5470c6", spinnerRadius: 10, lineWidth: 5, zlevel: 0 }); var t = new ft, r = new Yt({ style: { fill: e.maskColor }, zlevel: e.zlevel, z: 1e4 }); t.add(r); var i = new tn({ style: { text: e.text, fill: e.textColor, fontSize: e.fontSize, fontWeight: e.fontWeight, fontStyle: e.fontStyle, fontFamily: e.fontFamily }, zlevel: e.zlevel, z: 10001 }), a = new Yt({ style: { fill: "none" }, textContent: i, textConfig: { position: "right", distance: 10 }, zlevel: e.zlevel, z: 10001 }); t.add(a); var o; return e.showSpinner && (o = new HN({ shape: { startAngle: -Gw / 2, endAngle: -Gw / 2 + .1, r: e.spinnerRadius }, style: { stroke: e.color, lineCap: "round", lineWidth: e.lineWidth }, zlevel: e.zlevel, z: 10001 }), o.animateShape(!0).when(1e3, { endAngle: Gw * 3 / 2 }).start("circularInOut"), o.animateShape(!0).when(1e3, { startAngle: Gw * 3 / 2 }).delay(300).start("circularInOut"), t.add(o)), t.resize = function () { var s = i.getBoundingRect().width, l = e.showSpinner ? e.spinnerRadius : 0, c = (n.getWidth() - l * 2 - (e.showSpinner && s ? 10 : 0) - s) / 2 - (e.showSpinner && s ? 0 : 5 + s / 2) + (e.showSpinner ? 0 : s / 2) + (s ? 0 : l), u = n.getHeight() / 2; e.showSpinner && o.setShape({ cx: c, cy: u }), a.setShape({ x: c - l, y: u - l, width: l * 2, height: l * 2 }), r.setShape({ x: 0, y: 0, width: n.getWidth(), height: n.getHeight() }) }, t.resize(), t } var BHe = function () { function n(e, t, r, i) { this._stageTaskMap = Ze(), this.ecInstance = e, this.api = t, r = this._dataProcessorHandlers = r.slice(), i = this._visualHandlers = i.slice(), this._allHandlers = r.concat(i) } return n.prototype.restoreData = function (e, t) { e.restoreData(t), this._stageTaskMap.each(function (r) { var i = r.overallTask; i && i.dirty() }) }, n.prototype.getPerformArgs = function (e, t) { if (e.__pipeline) { var r = this._pipelineMap.get(e.__pipeline.id), i = r.context, a = !t && r.progressiveEnabled && (!i || i.progressiveRender) && e.__idxInPipeline > r.blockIndex, o = a ? r.step : null, s = i && i.modDataCount, l = s != null ? Math.ceil(s / o) : null; return { step: o, modBy: l, modDataCount: s } } }, n.prototype.getPipeline = function (e) { return this._pipelineMap.get(e) }, n.prototype.updateStreamModes = function (e, t) { var r = this._pipelineMap.get(e.uid), i = e.getData(), a = i.count(), o = r.progressiveEnabled && t.incrementalPrepareRender && a >= r.threshold, s = e.get("large") && a >= e.get("largeThreshold"), l = e.get("progressiveChunkMode") === "mod" ? a : null; e.pipelineContext = r.context = { progressiveRender: o, modDataCount: l, large: s } }, n.prototype.restorePipelines = function (e) { var t = this, r = t._pipelineMap = Ze(); e.eachSeries(function (i) { var a = i.getProgressive(), o = i.uid; r.set(o, { id: o, head: null, tail: null, threshold: i.getProgressiveThreshold(), progressiveEnabled: a && !(i.preventIncremental && i.preventIncremental()), blockIndex: -1, step: Math.round(a || 700), count: 0 }), t._pipe(i, i.dataTask) }) }, n.prototype.prepareStageTasks = function () { var e = this._stageTaskMap, t = this.api.getModel(), r = this.api; $(this._allHandlers, function (i) { var a = e.get(i.uid) || e.set(i.uid, {}), o = ""; na(!(i.reset && i.overallReset), o), i.reset && this._createSeriesStageTask(i, a, t, r), i.overallReset && this._createOverallStageTask(i, a, t, r) }, this) }, n.prototype.prepareView = function (e, t, r, i) { var a = e.renderTask, o = a.context; o.model = t, o.ecModel = r, o.api = i, a.__block = !e.incrementalPrepareRender, this._pipe(t, a) }, n.prototype.performDataProcessorTasks = function (e, t) { this._performStageTasks(this._dataProcessorHandlers, e, t, { block: !0 }) }, n.prototype.performVisualTasks = function (e, t, r) { this._performStageTasks(this._visualHandlers, e, t, r) }, n.prototype._performStageTasks = function (e, t, r, i) { i = i || {}; var a = !1, o = this; $(e, function (l, c) { if (!(i.visualType && i.visualType !== l.visualType)) { var u = o._stageTaskMap.get(l.uid), d = u.seriesTaskMap, f = u.overallTask; if (f) { var h, p = f.agentStubMap; p.each(function (g) { s(i, g) && (g.dirty(), h = !0) }), h && f.dirty(), o.updatePayload(f, r); var m = o.getPerformArgs(f, i.block); p.each(function (g) { g.perform(m) }), f.perform(m) && (a = !0) } else d && d.each(function (g, y) { s(i, g) && g.dirty(); var b = o.getPerformArgs(g, i.block); b.skip = !l.performRawSeries && t.isSeriesFiltered(g.context.model), o.updatePayload(g, r), g.perform(b) && (a = !0) }) } }); function s(l, c) { return l.setDirty && (!l.dirtyMap || l.dirtyMap.get(c.__pipeline.id)) } this.unfinished = a || this.unfinished }, n.prototype.performSeriesTasks = function (e) { var t; e.eachSeries(function (r) { t = r.dataTask.perform() || t }), this.unfinished = t || this.unfinished }, n.prototype.plan = function () { this._pipelineMap.each(function (e) { var t = e.tail; do { if (t.__block) { e.blockIndex = t.__idxInPipeline; break } t = t.getUpstream() } while (t) }) }, n.prototype.updatePayload = function (e, t) { t !== "remain" && (e.context.payload = t) }, n.prototype._createSeriesStageTask = function (e, t, r, i) { var a = this, o = t.seriesTaskMap, s = t.seriesTaskMap = Ze(), l = e.seriesType, c = e.getTargetSeries; e.createOnAllSeries ? r.eachRawSeries(u) : l ? r.eachRawSeriesByType(l, u) : c && c(r, i).each(u); function u(d) { var f = d.uid, h = s.set(f, o && o.get(f) || y0({ plan: HHe, reset: UHe, count: WHe })); h.context = { model: d, ecModel: r, api: i, useClearVisual: e.isVisual && !e.isLayout, plan: e.plan, reset: e.reset, scheduler: a }, a._pipe(d, h) } }, n.prototype._createOverallStageTask = function (e, t, r, i) { var a = this, o = t.overallTask = t.overallTask || y0({ reset: $He }); o.context = { ecModel: r, api: i, overallReset: e.overallReset, scheduler: a }; var s = o.agentStubMap, l = o.agentStubMap = Ze(), c = e.seriesType, u = e.getTargetSeries, d = !0, f = !1, h = ""; na(!e.createOnAllSeries, h), c ? r.eachRawSeriesByType(c, p) : u ? u(r, i).each(p) : (d = !1, $(r.getSeries(), p)); function p(m) { var g = m.uid, y = l.set(g, s && s.get(g) || (f = !0, y0({ reset: FHe, onDirty: VHe }))); y.context = { model: m, overallProgress: d }, y.agent = o, y.__block = d, a._pipe(m, y) } f && o.dirty() }, n.prototype._pipe = function (e, t) { var r = e.uid, i = this._pipelineMap.get(r); !i.head && (i.head = t), i.tail && i.tail.pipe(t), i.tail = t, t.__idxInPipeline = i.count++, t.__pipeline = i }, n.wrapStageHandler = function (e, t) { return tt(e) && (e = { overallReset: e, seriesType: KHe(e) }), e.uid = Qg("stageHandler"), t && (e.visualType = t), e }, n }(); function $He(n) { n.overallReset(n.ecModel, n.api, n.payload) } function FHe(n) { return n.overallProgress && zHe } function zHe() { this.agent.dirty(), this.getDownstream().dirty() } function VHe() { this.agent && this.agent.dirty() } function HHe(n) { return n.plan ? n.plan(n.model, n.ecModel, n.api, n.payload) : null } function UHe(n) { n.useClearVisual && n.data.clearAllVisual(); var e = n.resetDefines = Cn(n.reset(n.model, n.ecModel, n.api, n.payload)); return e.length > 1 ? Ae(e, function (t, r) { return are(r) }) : GHe } var GHe = are(0); function are(n) { return function (e, t) { var r = t.data, i = t.resetDefines[n]; if (i && i.dataEach) for (var a = e.start; a < e.end; a++)i.dataEach(r, a); else i && i.progress && i.progress(e, r) } } function WHe(n) { return n.data.count() } function KHe(n) { aT = null; try { n(T_, ore) } catch { } return aT } var T_ = {}, ore = {}, aT; sre(T_, Dne); sre(ore, jne); T_.eachSeriesByType = T_.eachRawSeriesByType = function (n) { aT = n }; T_.eachComponent = function (n) { n.mainType === "series" && n.subType && (aT = n.subType) }; function sre(n, e) { for (var t in e.prototype) n[t] = gr } const lre = BHe; var SH = ["#37A2DA", "#32C5E9", "#67E0E3", "#9FE6B8", "#FFDB5C", "#ff9f7f", "#fb7293", "#E062AE", "#E690D1", "#e7bcf3", "#9d96f5", "#8378EA", "#96BFFF"]; const qHe = { color: SH, colorLayer: [["#37A2DA", "#ffd85c", "#fd7b5f"], ["#37A2DA", "#67E0E3", "#FFDB5C", "#ff9f7f", "#E062AE", "#9d96f5"], ["#37A2DA", "#32C5E9", "#9FE6B8", "#FFDB5C", "#ff9f7f", "#fb7293", "#e7bcf3", "#8378EA", "#96BFFF"], SH] }; var wi = "#B9B8CE", TH = "#100C2A", Ww = function () { return { axisLine: { lineStyle: { color: wi } }, splitLine: { lineStyle: { color: "#484753" } }, splitArea: { areaStyle: { color: ["rgba(255,255,255,0.02)", "rgba(255,255,255,0.05)"] } }, minorSplitLine: { lineStyle: { color: "#20203B" } } } }, kH = ["#4992ff", "#7cffb2", "#fddd60", "#ff6e76", "#58d9f9", "#05c091", "#ff8a45", "#8d48e3", "#dd79ff"], cre = { darkMode: !0, color: kH, backgroundColor: TH, axisPointer: { lineStyle: { color: "#817f91" }, crossStyle: { color: "#817f91" }, label: { color: "#fff" } }, legend: { textStyle: { color: wi }, pageTextStyle: { color: wi } }, textStyle: { color: wi }, title: { textStyle: { color: "#EEF1FA" }, subtextStyle: { color: "#B9B8CE" } }, toolbox: { iconStyle: { borderColor: wi } }, dataZoom: { borderColor: "#71708A", textStyle: { color: wi }, brushStyle: { color: "rgba(135,163,206,0.3)" }, handleStyle: { color: "#353450", borderColor: "#C5CBE3" }, moveHandleStyle: { color: "#B0B6C3", opacity: .3 }, fillerColor: "rgba(135,163,206,0.2)", emphasis: { handleStyle: { borderColor: "#91B7F2", color: "#4D587D" }, moveHandleStyle: { color: "#636D9A", opacity: .7 } }, dataBackground: { lineStyle: { color: "#71708A", width: 1 }, areaStyle: { color: "#71708A" } }, selectedDataBackground: { lineStyle: { color: "#87A3CE" }, areaStyle: { color: "#87A3CE" } } }, visualMap: { textStyle: { color: wi } }, timeline: { lineStyle: { color: wi }, label: { color: wi }, controlStyle: { color: wi, borderColor: wi } }, calendar: { itemStyle: { color: TH }, dayLabel: { color: wi }, monthLabel: { color: wi }, yearLabel: { color: wi } }, timeAxis: Ww(), logAxis: Ww(), valueAxis: Ww(), categoryAxis: Ww(), line: { symbol: "circle" }, graph: { color: kH }, gauge: { title: { color: wi }, axisLine: { lineStyle: { color: [[1, "rgba(207,212,219,0.2)"]] } }, axisLabel: { color: wi }, detail: { color: "#EEF1FA" } }, candlestick: { itemStyle: { color: "#f64e56", color0: "#54ea92", borderColor: "#f64e56", borderColor0: "#54ea92" } } }; cre.categoryAxis.splitLine.show = !1; const YHe = cre; var ZHe = function () { function n() { } return n.prototype.normalizeQuery = function (e) { var t = {}, r = {}, i = {}; if (Fe(e)) { var a = sl(e); t.mainType = a.main || null, t.subType = a.sub || null } else { var o = ["Index", "Name", "Id"], s = { name: 1, dataIndex: 1, dataType: 1 }; $(e, function (l, c) { for (var u = !1, d = 0; d < o.length; d++) { var f = o[d], h = c.lastIndexOf(f); if (h > 0 && h === c.length - f.length) { var p = c.slice(0, h); p !== "data" && (t.mainType = p, t[f.toLowerCase()] = l, u = !0) } } s.hasOwnProperty(c) && (r[c] = l, u = !0), u || (i[c] = l) }) } return { cptQuery: t, dataQuery: r, otherQuery: i } }, n.prototype.filter = function (e, t) { var r = this.eventInfo; if (!r) return !0; var i = r.targetEl, a = r.packedEvent, o = r.model, s = r.view; if (!o || !s) return !0; var l = t.cptQuery, c = t.dataQuery; return u(l, o, "mainType") && u(l, o, "subType") && u(l, o, "index", "componentIndex") && u(l, o, "name") && u(l, o, "id") && u(c, a, "name") && u(c, a, "dataIndex") && u(c, a, "dataType") && (!s.filterForExposedEvent || s.filterForExposedEvent(e, t.otherQuery, i, a)); function u(d, f, h, p) { return d[h] == null || f[p || h] === d[h] } }, n.prototype.afterTrigger = function () { this.eventInfo = null }, n }(), dI = ["symbol", "symbolSize", "symbolRotate", "symbolOffset"], CH = dI.concat(["symbolKeepAspect"]), XHe = { createOnAllSeries: !0, performRawSeries: !0, reset: function (n, e) { var t = n.getData(); if (n.legendIcon && t.setVisual("legendIcon", n.legendIcon), !n.hasSymbolVisual) return; for (var r = {}, i = {}, a = !1, o = 0; o < dI.length; o++) { var s = dI[o], l = n.get(s); tt(l) ? (a = !0, i[s] = l) : r[s] = l } if (r.symbol = r.symbol || n.defaultSymbol, t.setVisual(be({ legendIcon: n.legendIcon || r.symbol, symbolKeepAspect: n.get("symbolKeepAspect") }, r)), e.isSeriesFiltered(n)) return; var c = Bt(i); function u(d, f) { for (var h = n.getRawValue(f), p = n.getDataParams(f), m = 0; m < c.length; m++) { var g = c[m]; d.setItemVisual(f, g, i[g](h, p)) } } return { dataEach: a ? u : null } } }, JHe = { createOnAllSeries: !0, performRawSeries: !0, reset: function (n, e) { if (!n.hasSymbolVisual || e.isSeriesFiltered(n)) return; var t = n.getData(); function r(i, a) { for (var o = i.getItemModel(a), s = 0; s < CH.length; s++) { var l = CH[s], c = o.getShallow(l, !0); c != null && i.setItemVisual(a, l, c) } } return { dataEach: t.hasItemOption ? r : null } } }; function u3(n, e, t) { switch (t) { case "color": var r = n.getItemVisual(e, "style"); return r[n.getVisual("drawType")]; case "opacity": return n.getItemVisual(e, "style").opacity; case "symbol": case "symbolSize": case "liftZ": return n.getItemVisual(e, t) } } function Ab(n, e) { switch (e) { case "color": var t = n.getVisual("style"); return t[n.getVisual("drawType")]; case "opacity": return n.getVisual("style").opacity; case "symbol": case "symbolSize": case "liftZ": return n.getVisual(e) } } function ure(n, e, t, r) { switch (t) { case "color": var i = n.ensureUniqueItemVisual(e, "style"); i[n.getVisual("drawType")] = r, n.setItemVisual(e, "colorFromPalette", !1); break; case "opacity": n.ensureUniqueItemVisual(e, "style").opacity = r; break; case "symbol": case "symbolSize": case "liftZ": n.setItemVisual(e, t, r); break } } function dre(n, e) { function t(r, i) { var a = []; return r.eachComponent({ mainType: "series", subType: n, query: i }, function (o) { a.push(o.seriesIndex) }), a } $([[n + "ToggleSelect", "toggleSelect"], [n + "Select", "select"], [n + "UnSelect", "unselect"]], function (r) { e(r[0], function (i, a, o) { i = be({}, i), o.dispatchAction(be(i, { type: r[1], seriesIndex: t(a, i) })) }) }) } function Zp(n, e, t, r, i) { var a = n + e; t.isSilent(a) || r.eachComponent({ mainType: "series", subType: "pie" }, function (o) { for (var s = o.seriesIndex, l = o.option.selectedMap, c = i.selected, u = 0; u < c.length; u++)if (c[u].seriesIndex === s) { var d = o.getData(), f = Hh(d, i.fromActionPayload); t.trigger(a, { type: a, seriesId: o.id, name: ke(f) ? d.getName(f[0]) : d.getName(f), selected: Fe(l) ? l : be({}, l) }) } }) } function QHe(n, e, t) { n.on("selectchanged", function (r) { var i = t.getModel(); r.isFromClick ? (Zp("map", "selectchanged", e, i, r), Zp("pie", "selectchanged", e, i, r)) : r.fromAction === "select" ? (Zp("map", "selected", e, i, r), Zp("pie", "selected", e, i, r)) : r.fromAction === "unselect" && (Zp("map", "unselected", e, i, r), Zp("pie", "unselected", e, i, r)) }) } function rh(n, e, t) { for (var r; n && !(e(n) && (r = n, t));)n = n.__hostTarget || n.parent; return r } var e9e = Math.round(Math.random() * 9), t9e = typeof Object.defineProperty == "function", n9e = function () { function n() { this._id = "__ec_inner_" + e9e++ } return n.prototype.get = function (e) { return this._guard(e)[this._id] }, n.prototype.set = function (e, t) { var r = this._guard(e); return t9e ? Object.defineProperty(r, this._id, { value: t, enumerable: !1, configurable: !0 }) : r[this._id] = t, this }, n.prototype.delete = function (e) { return this.has(e) ? (delete this._guard(e)[this._id], !0) : !1 }, n.prototype.has = function (e) { return !!this._guard(e)[this._id] }, n.prototype._guard = function (e) { if (e !== Object(e)) throw TypeError("Value of WeakMap is not a non-null object."); return e }, n }(); const r9e = n9e; var i9e = Nt.extend({ type: "triangle", shape: { cx: 0, cy: 0, width: 0, height: 0 }, buildPath: function (n, e) { var t = e.cx, r = e.cy, i = e.width / 2, a = e.height / 2; n.moveTo(t, r - a), n.lineTo(t + i, r + a), n.lineTo(t - i, r + a), n.closePath() } }), a9e = Nt.extend({ type: "diamond", shape: { cx: 0, cy: 0, width: 0, height: 0 }, buildPath: function (n, e) { var t = e.cx, r = e.cy, i = e.width / 2, a = e.height / 2; n.moveTo(t, r - a), n.lineTo(t + i, r), n.lineTo(t, r + a), n.lineTo(t - i, r), n.closePath() } }), o9e = Nt.extend({ type: "pin", shape: { x: 0, y: 0, width: 0, height: 0 }, buildPath: function (n, e) { var t = e.x, r = e.y, i = e.width / 5 * 3, a = Math.max(i, e.height), o = i / 2, s = o * o / (a - o), l = r - a + o + s, c = Math.asin(s / o), u = Math.cos(c) * o, d = Math.sin(c), f = Math.cos(c), h = o * .6, p = o * .7; n.moveTo(t - u, l + s), n.arc(t, l, o, Math.PI - c, Math.PI * 2 + c), n.bezierCurveTo(t + u - d * h, l + s + f * h, t, r - p, t, r), n.bezierCurveTo(t, r - p, t - u + d * h, l + s + f * h, t - u, l + s), n.closePath() } }), s9e = Nt.extend({ type: "arrow", shape: { x: 0, y: 0, width: 0, height: 0 }, buildPath: function (n, e) { var t = e.height, r = e.width, i = e.x, a = e.y, o = r / 3 * 2; n.moveTo(i, a), n.lineTo(i + o, a + t), n.lineTo(i, a + t / 4 * 3), n.lineTo(i - o, a + t), n.lineTo(i, a), n.closePath() } }), l9e = { line: Jr, rect: Yt, roundRect: Yt, square: Yt, circle: Ud, diamond: a9e, pin: o9e, arrow: s9e, triangle: i9e }, c9e = { line: function (n, e, t, r, i) { i.x1 = n, i.y1 = e + r / 2, i.x2 = n + t, i.y2 = e + r / 2 }, rect: function (n, e, t, r, i) { i.x = n, i.y = e, i.width = t, i.height = r }, roundRect: function (n, e, t, r, i) { i.x = n, i.y = e, i.width = t, i.height = r, i.r = Math.min(t, r) / 4 }, square: function (n, e, t, r, i) { var a = Math.min(t, r); i.x = n, i.y = e, i.width = a, i.height = a }, circle: function (n, e, t, r, i) { i.cx = n + t / 2, i.cy = e + r / 2, i.r = Math.min(t, r) / 2 }, diamond: function (n, e, t, r, i) { i.cx = n + t / 2, i.cy = e + r / 2, i.width = t, i.height = r }, pin: function (n, e, t, r, i) { i.x = n + t / 2, i.y = e + r / 2, i.width = t, i.height = r }, arrow: function (n, e, t, r, i) { i.x = n + t / 2, i.y = e + r / 2, i.width = t, i.height = r }, triangle: function (n, e, t, r, i) { i.cx = n + t / 2, i.cy = e + r / 2, i.width = t, i.height = r } }, oT = {}; $(l9e, function (n, e) { oT[e] = new n }); var u9e = Nt.extend({ type: "symbol", shape: { symbolType: "", x: 0, y: 0, width: 0, height: 0 }, calculateTextPosition: function (n, e, t) { var r = Y2(n, e, t), i = this.shape; return i && i.symbolType === "pin" && e.position === "inside" && (r.y = t.y + t.height * .4), r }, buildPath: function (n, e, t) { var r = e.symbolType; if (r !== "none") { var i = oT[r]; i || (r = "rect", i = oT[r]), c9e[r](e.x, e.y, e.width, e.height, i.shape), i.buildPath(n, i.shape, t) } } }); function d9e(n, e) { if (this.type !== "image") { var t = this.style; this.__isEmptyBrush ? (t.stroke = n, t.fill = e || "#fff", t.lineWidth = 2) : this.shape.symbolType === "line" ? t.stroke = n : t.fill = n, this.markRedraw() } } function Tr(n, e, t, r, i, a, o) { var s = n.indexOf("empty") === 0; s && (n = n.substr(5, 1).toLowerCase() + n.substr(6)); var l; return n.indexOf("image://") === 0 ? l = Xte(n.slice(8), new kt(e, t, r, i), o ? "center" : "cover") : n.indexOf("path://") === 0 ? l = aC(n.slice(7), {}, new kt(e, t, r, i), o ? "center" : "cover") : l = new u9e({ shape: { symbolType: n, x: e, y: t, width: r, height: i } }), l.__isEmptyBrush = s, l.setColor = d9e, a && l.setColor(a), l } function ov(n) { return ke(n) || (n = [+n, +n]), [n[0] || 0, n[1] || 0] } function sp(n, e) { if (n != null) return ke(n) || (n = [n, n]), [Ne(n[0], e[0]) || 0, Ne(yt(n[1], n[0]), e[1]) || 0] } function ih(n) { return isFinite(n) } function f9e(n, e, t) { var r = e.x == null ? 0 : e.x, i = e.x2 == null ? 1 : e.x2, a = e.y == null ? 0 : e.y, o = e.y2 == null ? 0 : e.y2; e.global || (r = r * t.width + t.x, i = i * t.width + t.x, a = a * t.height + t.y, o = o * t.height + t.y), r = ih(r) ? r : 0, i = ih(i) ? i : 1, a = ih(a) ? a : 0, o = ih(o) ? o : 0; var s = n.createLinearGradient(r, a, i, o); return s } function h9e(n, e, t) { var r = t.width, i = t.height, a = Math.min(r, i), o = e.x == null ? .5 : e.x, s = e.y == null ? .5 : e.y, l = e.r == null ? .5 : e.r; e.global || (o = o * r + t.x, s = s * i + t.y, l = l * a), o = ih(o) ? o : .5, s = ih(s) ? s : .5, l = l >= 0 && ih(l) ? l : .5; var c = n.createRadialGradient(o, s, 0, o, s, l); return c } function fI(n, e, t) { for (var r = e.type === "radial" ? h9e(n, e, t) : f9e(n, e, t), i = e.colorStops, a = 0; a < i.length; a++)r.addColorStop(i[a].offset, i[a].color); return r } function p9e(n, e) { if (n === e || !n && !e) return !1; if (!n || !e || n.length !== e.length) return !0; for (var t = 0; t < n.length; t++)if (n[t] !== e[t]) return !0; return !1 } function Kw(n) { return parseInt(n, 10) } function Im(n, e, t) { var r = ["width", "height"][e], i = ["clientWidth", "clientHeight"][e], a = ["paddingLeft", "paddingTop"][e], o = ["paddingRight", "paddingBottom"][e]; if (t[r] != null && t[r] !== "auto") return parseFloat(t[r]); var s = document.defaultView.getComputedStyle(n); return (n[i] || Kw(s[r]) || Kw(n.style[r])) - (Kw(s[a]) || 0) - (Kw(s[o]) || 0) | 0 } function m9e(n, e) { return !n || n === "solid" || !(e > 0) ? null : n === "dashed" ? [4 * e, 2 * e] : n === "dotted" ? [e] : nn(n) ? [n] : ke(n) ? n : null } function d3(n) { var e = n.style, t = e.lineDash && e.lineWidth > 0 && m9e(e.lineDash, e.lineWidth), r = e.lineDashOffset; if (t) { var i = e.strokeNoScale && n.getLineScale ? n.getLineScale() : 1; i && i !== 1 && (t = Ae(t, function (a) { return a / i }), r /= i) } return [t, r] } var g9e = new Cl(!0); function sT(n) { var e = n.stroke; return !(e == null || e === "none" || !(n.lineWidth > 0)) } function AH(n) { return typeof n == "string" && n !== "none" } function lT(n) { var e = n.fill; return e != null && e !== "none" } function EH(n, e) { if (e.fillOpacity != null && e.fillOpacity !== 1) { var t = n.globalAlpha; n.globalAlpha = e.fillOpacity * e.opacity, n.fill(), n.globalAlpha = t } else n.fill() } function MH(n, e) { if (e.strokeOpacity != null && e.strokeOpacity !== 1) { var t = n.globalAlpha; n.globalAlpha = e.strokeOpacity * e.opacity, n.stroke(), n.globalAlpha = t } else n.stroke() } function hI(n, e, t) { var r = IN(e.image, e.__image, t); if (Jk(r)) { var i = n.createPattern(r, e.repeat || "repeat"); if (typeof DOMMatrix == "function" && i && i.setTransform) { var a = new DOMMatrix; a.translateSelf(e.x || 0, e.y || 0), a.rotateSelf(0, 0, (e.rotation || 0) * Wx), a.scaleSelf(e.scaleX || 1, e.scaleY || 1), i.setTransform(a) } return i } } function v9e(n, e, t, r) { var i, a = sT(t), o = lT(t), s = t.strokePercent, l = s < 1, c = !e.path; (!e.silent || l) && c && e.createPathProxy(); var u = e.path || g9e, d = e.__dirty; if (!r) { var f = t.fill, h = t.stroke, p = o && !!f.colorStops, m = a && !!h.colorStops, g = o && !!f.image, y = a && !!h.image, b = void 0, w = void 0, v = void 0, S = void 0, x = void 0; (p || m) && (x = e.getBoundingRect()), p && (b = d ? fI(n, f, x) : e.__canvasFillGradient, e.__canvasFillGradient = b), m && (w = d ? fI(n, h, x) : e.__canvasStrokeGradient, e.__canvasStrokeGradient = w), g && (v = d || !e.__canvasFillPattern ? hI(n, f, e) : e.__canvasFillPattern, e.__canvasFillPattern = v), y && (S = d || !e.__canvasStrokePattern ? hI(n, h, e) : e.__canvasStrokePattern, e.__canvasStrokePattern = v), p ? n.fillStyle = b : g && (v ? n.fillStyle = v : o = !1), m ? n.strokeStyle = w : y && (S ? n.strokeStyle = S : a = !1) } var k = e.getGlobalScale(); u.setScale(k[0], k[1], e.segmentIgnoreThreshold); var A, C; n.setLineDash && t.lineDash && (i = d3(e), A = i[0], C = i[1]); var E = !0; (c || d & wm) && (u.setDPR(n.dpr), l ? u.setContext(null) : (u.setContext(n), E = !1), u.reset(), e.buildPath(u, e.shape, r), u.toStatic(), e.pathUpdated()), E && u.rebuildPath(n, l ? s : 1), A && (n.setLineDash(A), n.lineDashOffset = C), r || (t.strokeFirst ? (a && MH(n, t), o && EH(n, t)) : (o && EH(n, t), a && MH(n, t))), A && n.setLineDash([]) } function y9e(n, e, t) { var r = e.__image = IN(t.image, e.__image, e, e.onload); if (!(!r || !Jk(r))) { var i = t.x || 0, a = t.y || 0, o = e.getWidth(), s = e.getHeight(), l = r.width / r.height; if (o == null && s != null ? o = s * l : s == null && o != null ? s = o / l : o == null && s == null && (o = r.width, s = r.height), t.sWidth && t.sHeight) { var c = t.sx || 0, u = t.sy || 0; n.drawImage(r, c, u, t.sWidth, t.sHeight, i, a, o, s) } else if (t.sx && t.sy) { var c = t.sx, u = t.sy, d = o - c, f = s - u; n.drawImage(r, c, u, d, f, i, a, o, s) } else n.drawImage(r, i, a, o, s) } } function _9e(n, e, t) { var r, i = t.text; if (i != null && (i += ""), i) { n.font = t.font || Td, n.textAlign = t.textAlign, n.textBaseline = t.textBaseline; var a = void 0, o = void 0; n.setLineDash && t.lineDash && (r = d3(e), a = r[0], o = r[1]), a && (n.setLineDash(a), n.lineDashOffset = o), t.strokeFirst ? (sT(t) && n.strokeText(i, t.x, t.y), lT(t) && n.fillText(i, t.x, t.y)) : (lT(t) && n.fillText(i, t.x, t.y), sT(t) && n.strokeText(i, t.x, t.y)), a && n.setLineDash([]) } } var OH = ["shadowBlur", "shadowOffsetX", "shadowOffsetY"], DH = [["lineCap", "butt"], ["lineJoin", "miter"], ["miterLimit", 10]]; function fre(n, e, t, r, i) { var a = !1; if (!r && (t = t || {}, e === t)) return !1; if (r || e.opacity !== t.opacity) { _a(n, i), a = !0; var o = Math.max(Math.min(e.opacity, 1), 0); n.globalAlpha = isNaN(o) ? xh.opacity : o } (r || e.blend !== t.blend) && (a || (_a(n, i), a = !0), n.globalCompositeOperation = e.blend || xh.blend); for (var s = 0; s < OH.length; s++) { var l = OH[s]; (r || e[l] !== t[l]) && (a || (_a(n, i), a = !0), n[l] = n.dpr * (e[l] || 0)) } return (r || e.shadowColor !== t.shadowColor) && (a || (_a(n, i), a = !0), n.shadowColor = e.shadowColor || xh.shadowColor), a } function jH(n, e, t, r, i) { var a = k_(e, i.inHover), o = r ? null : t && k_(t, i.inHover) || {}; if (a === o) return !1; var s = fre(n, a, o, r, i); if ((r || a.fill !== o.fill) && (s || (_a(n, i), s = !0), AH(a.fill) && (n.fillStyle = a.fill)), (r || a.stroke !== o.stroke) && (s || (_a(n, i), s = !0), AH(a.stroke) && (n.strokeStyle = a.stroke)), (r || a.opacity !== o.opacity) && (s || (_a(n, i), s = !0), n.globalAlpha = a.opacity == null ? 1 : a.opacity), e.hasStroke()) { var l = a.lineWidth, c = l / (a.strokeNoScale && e.getLineScale ? e.getLineScale() : 1); n.lineWidth !== c && (s || (_a(n, i), s = !0), n.lineWidth = c) } for (var u = 0; u < DH.length; u++) { var d = DH[u], f = d[0]; (r || a[f] !== o[f]) && (s || (_a(n, i), s = !0), n[f] = a[f] || d[1]) } return s } function b9e(n, e, t, r, i) { return fre(n, k_(e, i.inHover), t && k_(t, i.inHover), r, i) } function hre(n, e) { var t = e.transform, r = n.dpr || 1; t ? n.setTransform(r * t[0], r * t[1], r * t[2], r * t[3], r * t[4], r * t[5]) : n.setTransform(r, 0, 0, r, 0, 0) } function w9e(n, e, t) { for (var r = !1, i = 0; i < n.length; i++) { var a = n[i]; r = r || a.isZeroArea(), hre(e, a), e.beginPath(), a.buildPath(e, a.shape), e.clip() } t.allClipped = r } function x9e(n, e) { return n && e ? n[0] !== e[0] || n[1] !== e[1] || n[2] !== e[2] || n[3] !== e[3] || n[4] !== e[4] || n[5] !== e[5] : !(!n && !e) } var PH = 1, IH = 2, LH = 3, RH = 4; function S9e(n) { var e = lT(n), t = sT(n); return !(n.lineDash || !(+e ^ +t) || e && typeof n.fill != "string" || t && typeof n.stroke != "string" || n.strokePercent < 1 || n.strokeOpacity < 1 || n.fillOpacity < 1) } function _a(n, e) { e.batchFill && n.fill(), e.batchStroke && n.stroke(), e.batchFill = "", e.batchStroke = "" } function k_(n, e) { return e && n.__hoverStyle || n.style } function pre(n, e) { ah(n, e, { inHover: !1, viewWidth: 0, viewHeight: 0 }, !0) } function ah(n, e, t, r) { var i = e.transform; if (!e.shouldBePainted(t.viewWidth, t.viewHeight, !1, !1)) { e.__dirty &= ~Ba, e.__isRendered = !1; return } var a = e.__clipPaths, o = t.prevElClipPaths, s = !1, l = !1; if ((!o || p9e(a, o)) && (o && o.length && (_a(n, t), n.restore(), l = s = !0, t.prevElClipPaths = null, t.allClipped = !1, t.prevEl = null), a && a.length && (_a(n, t), n.save(), w9e(a, n, t), s = !0), t.prevElClipPaths = a), t.allClipped) { e.__isRendered = !1; return } e.beforeBrush && e.beforeBrush(), e.innerBeforeBrush(); var c = t.prevEl; c || (l = s = !0); var u = e instanceof Nt && e.autoBatch && S9e(e.style); s || x9e(i, c.transform) ? (_a(n, t), hre(n, e)) : u || _a(n, t); var d = k_(e, t.inHover); e instanceof Nt ? (t.lastDrawType !== PH && (l = !0, t.lastDrawType = PH), jH(n, e, c, l, t), (!u || !t.batchFill && !t.batchStroke) && n.beginPath(), v9e(n, e, d, u), u && (t.batchFill = d.fill || "", t.batchStroke = d.stroke || "")) : e instanceof g_ ? (t.lastDrawType !== LH && (l = !0, t.lastDrawType = LH), jH(n, e, c, l, t), _9e(n, e, d)) : e instanceof gi ? (t.lastDrawType !== IH && (l = !0, t.lastDrawType = IH), b9e(n, e, c, l, t), y9e(n, e, d)) : e.getTemporalDisplayables && (t.lastDrawType !== RH && (l = !0, t.lastDrawType = RH), T9e(n, e, t)), u && r && _a(n, t), e.innerAfterBrush(), e.afterBrush && e.afterBrush(), t.prevEl = e, e.__dirty = 0, e.__isRendered = !0 } function T9e(n, e, t) { var r = e.getDisplayables(), i = e.getTemporalDisplayables(); n.save(); var a = { prevElClipPaths: null, prevEl: null, allClipped: !1, viewWidth: t.viewWidth, viewHeight: t.viewHeight, inHover: t.inHover }, o, s; for (o = e.getCursor(), s = r.length; o < s; o++) { var l = r[o]; l.beforeBrush && l.beforeBrush(), l.innerBeforeBrush(), ah(n, l, a, o === s - 1), l.innerAfterBrush(), l.afterBrush && l.afterBrush(), a.prevEl = l } for (var c = 0, u = i.length; c < u; c++) { var l = i[c]; l.beforeBrush && l.beforeBrush(), l.innerBeforeBrush(), ah(n, l, a, c === u - 1), l.innerAfterBrush(), l.afterBrush && l.afterBrush(), a.prevEl = l } e.clearTemporalDisplayables(), e.notClear = !0, n.restore() } var ZM = new r9e, NH = new _b(100), BH = ["symbol", "symbolSize", "symbolKeepAspect", "color", "backgroundColor", "dashArrayX", "dashArrayY", "maxTileWidth", "maxTileHeight"]; function Ag(n, e) { if (n === "none") return null; var t = e.getDevicePixelRatio(), r = e.getZr(), i = r.painter.type === "svg"; n.dirty && ZM.delete(n); var a = ZM.get(n); if (a) return a; var o = rt(n, { symbol: "rect", symbolSize: 1, symbolKeepAspect: !0, color: "rgba(0, 0, 0, 0.2)", backgroundColor: null, dashArrayX: 5, dashArrayY: 5, rotation: 0, maxTileWidth: 512, maxTileHeight: 512 }); o.backgroundColor === "none" && (o.backgroundColor = null); var s = { repeat: "repeat" }; return l(s), s.rotation = o.rotation, s.scaleX = s.scaleY = i ? 1 : 1 / t, ZM.set(n, s), n.dirty = !1, s; function l(c) { for (var u = [t], d = !0, f = 0; f < BH.length; ++f) { var h = o[BH[f]]; if (h != null && !ke(h) && !Fe(h) && !nn(h) && typeof h != "boolean") { d = !1; break } u.push(h) } var p; if (d) { p = u.join(",") + (i ? "-svg" : ""); var m = NH.get(p); m && (i ? c.svgElement = m : c.image = m) } var g = gre(o.dashArrayX), y = k9e(o.dashArrayY), b = mre(o.symbol), w = C9e(g), v = vre(y), S = !i && kd.createCanvas(), x = i && { tag: "g", attrs: {}, key: "dcl", children: [] }, k = C(), A; S && (S.width = k.width * t, S.height = k.height * t, A = S.getContext("2d")), E(), d && NH.put(p, S || x), c.image = S, c.svgElement = x, c.svgWidth = k.width, c.svgHeight = k.height; function C() { for (var O = 1, j = 0, I = w.length; j < I; ++j)O = tV(O, w[j]); for (var L = 1, j = 0, I = b.length; j < I; ++j)L = tV(L, b[j].length); O *= L; var R = v * w.length * b.length; return { width: Math.max(1, Math.min(O, o.maxTileWidth)), height: Math.max(1, Math.min(R, o.maxTileHeight)) } } function E() { A && (A.clearRect(0, 0, S.width, S.height), o.backgroundColor && (A.fillStyle = o.backgroundColor, A.fillRect(0, 0, S.width, S.height))); for (var O = 0, j = 0; j < y.length; ++j)O += y[j]; if (O <= 0) return; for (var I = -v, L = 0, R = 0, D = 0; I < k.height;) { if (L % 2 === 0) { for (var P = R / 2 % b.length, B = 0, F = 0, K = 0; B < k.width * 2;) { for (var V = 0, j = 0; j < g[D].length; ++j)V += g[D][j]; if (V <= 0) break; if (F % 2 === 0) { var W = (1 - o.symbolSize) * .5, J = B + g[D][F] * W, ie = I + y[L] * W, le = g[D][F] * o.symbolSize, De = y[L] * o.symbolSize, ae = K / 2 % b[P].length; pe(J, ie, le, De, b[P][ae]) } B += g[D][F], ++K, ++F, F === g[D].length && (F = 0) } ++D, D === g.length && (D = 0) } I += y[L], ++R, ++L, L === y.length && (L = 0) } function pe(se, ge, _e, je, U) { var q = i ? 1 : t, ee = Tr(U, se * q, ge * q, _e * q, je * q, o.color, o.symbolKeepAspect); if (i) { var de = r.painter.renderOneToVNode(ee); de && x.children.push(de) } else pre(A, ee) } } } } function mre(n) { if (!n || n.length === 0) return [["rect"]]; if (Fe(n)) return [[n]]; for (var e = !0, t = 0; t < n.length; ++t)if (!Fe(n[t])) { e = !1; break } if (e) return mre([n]); for (var r = [], t = 0; t < n.length; ++t)Fe(n[t]) ? r.push([n[t]]) : r.push(n[t]); return r } function gre(n) { if (!n || n.length === 0) return [[0, 0]]; if (nn(n)) { var e = Math.ceil(n); return [[e, e]] } for (var t = !0, r = 0; r < n.length; ++r)if (!nn(n[r])) { t = !1; break } if (t) return gre([n]); for (var i = [], r = 0; r < n.length; ++r)if (nn(n[r])) { var e = Math.ceil(n[r]); i.push([e, e]) } else { var e = Ae(n[r], function (s) { return Math.ceil(s) }); e.length % 2 === 1 ? i.push(e.concat(e)) : i.push(e) } return i } function k9e(n) { if (!n || typeof n == "object" && n.length === 0) return [0, 0]; if (nn(n)) { var e = Math.ceil(n); return [e, e] } var t = Ae(n, function (r) { return Math.ceil(r) }); return n.length % 2 ? t.concat(t) : t } function C9e(n) { return Ae(n, function (e) { return vre(e) }) } function vre(n) { for (var e = 0, t = 0; t < n.length; ++t)e += n[t]; return n.length % 2 === 1 ? e * 2 : e } function A9e(n, e) { n.eachRawSeries(function (t) { if (!n.isSeriesFiltered(t)) { var r = t.getData(); r.hasItemVisual() && r.each(function (o) { var s = r.getItemVisual(o, "decal"); if (s) { var l = r.ensureUniqueItemVisual(o, "style"); l.decal = Ag(s, e) } }); var i = r.getVisual("decal"); if (i) { var a = r.getVisual("style"); a.decal = Ag(i, e) } } }) } var E9e = new Go; const is = E9e; var yre = {}; function M9e(n, e) { yre[n] = e } function O9e(n) { return yre[n] } var D9e = 1, j9e = 800, P9e = 900, I9e = 1e3, L9e = 2e3, R9e = 5e3, _re = 1e3, N9e = 1100, f3 = 2e3, bre = 3e3, B9e = 4e3, yC = 4500, $9e = 4600, F9e = 5e3, z9e = 6e3, wre = 7e3, V9e = { PROCESSOR: { FILTER: I9e, SERIES_FILTER: j9e, STATISTIC: R9e }, VISUAL: { LAYOUT: _re, PROGRESSIVE_LAYOUT: N9e, GLOBAL: f3, CHART: bre, POST_CHART_LAYOUT: $9e, COMPONENT: B9e, BRUSH: F9e, CHART_ITEM: yC, ARIA: z9e, DECAL: wre } }, bi = "__flagInMainProcess", ha = "__pendingUpdate", XM = "__needsUpdateStatus", $H = /^[a-zA-Z0-9_]+$/, JM = "__connectUpdateStatus", FH = 0, H9e = 1, U9e = 2; function xre(n) { return function () { for (var e = [], t = 0; t < arguments.length; t++)e[t] = arguments[t]; if (this.isDisposed()) { this.id; return } return Tre(this, n, e) } } function Sre(n) { return function () { for (var e = [], t = 0; t < arguments.length; t++)e[t] = arguments[t]; return Tre(this, n, e) } } function Tre(n, e, t) { return t[0] = t[0] && t[0].toLowerCase(), Go.prototype[e].apply(n, t) } var kre = function (n) { te(e, n); function e() { return n !== null && n.apply(this, arguments) || this } return e }(Go), Cre = kre.prototype; Cre.on = Sre("on"); Cre.off = Sre("off"); var Xp, QM, qw, lu, eO, tO, nO, Xv, Jv, zH, VH, rO, HH, Yw, UH, Are, lo, GH, Ere = function (n) { te(e, n); function e(t, r, i) { var a = n.call(this, new ZHe) || this; a._chartsViews = [], a._chartsMap = {}, a._componentsViews = [], a._componentsMap = {}, a._pendingActions = [], i = i || {}, Fe(r) && (r = Mre[r]), a._dom = t; var o = "canvas", s = "auto", l = !1; i.ssr && SFe(function (f) { var h = pt(f), p = h.dataIndex; if (p != null) { var m = Ze(); return m.set("series_index", h.seriesIndex), m.set("data_index", p), h.ssrType && m.set("ssr_type", h.ssrType), m } }); var c = a._zr = X6(t, { renderer: i.renderer || o, devicePixelRatio: i.devicePixelRatio, width: i.width, height: i.height, ssr: i.ssr, useDirtyRect: yt(i.useDirtyRect, l), useCoarsePointer: yt(i.useCoarsePointer, s), pointerSize: i.pointerSize }); a._ssr = i.ssr, a._throttledZrFlush = c3(He(c.flush, c), 17), r = lt(r), r && Ine(r, !0), a._theme = r, a._locale = nVe(i.locale || sne), a._coordSysMgr = new Cb; var u = a._api = UH(a); function d(f, h) { return f.__prio - h.__prio } return Yx(uT, d), Yx(pI, d), a._scheduler = new lre(a, u, pI, uT), a._messageCenter = new kre, a._initEvents(), a.resize = He(a.resize, a), c.animation.on("frame", a._onframe, a), zH(c, a), VH(c, a), V2(a), a } return e.prototype._onframe = function () { if (!this._disposed) { GH(this); var t = this._scheduler; if (this[ha]) { var r = this[ha].silent; this[bi] = !0; try { Xp(this), lu.update.call(this, null, this[ha].updateParams) } catch (l) { throw this[bi] = !1, this[ha] = null, l } this._zr.flush(), this[bi] = !1, this[ha] = null, Xv.call(this, r), Jv.call(this, r) } else if (t.unfinished) { var i = D9e, a = this._model, o = this._api; t.unfinished = !1; do { var s = +new Date; t.performSeriesTasks(a), t.performDataProcessorTasks(a), tO(this, a), t.performVisualTasks(a), Yw(this, this._model, o, "remain", {}), i -= +new Date - s } while (i > 0 && t.unfinished); t.unfinished || this._zr.flush() } } }, e.prototype.getDom = function () { return this._dom }, e.prototype.getId = function () { return this.id }, e.prototype.getZr = function () { return this._zr }, e.prototype.isSSR = function () { return this._ssr }, e.prototype.setOption = function (t, r, i) { if (!this[bi]) { if (this._disposed) { this.id; return } var a, o, s; if (ot(r) && (i = r.lazyUpdate, a = r.silent, o = r.replaceMerge, s = r.transition, r = r.notMerge), this[bi] = !0, !this._model || r) { var l = new IVe(this._api), c = this._theme, u = this._model = new Dne; u.scheduler = this._scheduler, u.ssr = this._ssr, u.init(null, null, null, c, this._locale, l) } this._model.setOption(t, { replaceMerge: o }, mI); var d = { seriesTransition: s, optionChanged: !0 }; if (i) this[ha] = { silent: a, updateParams: d }, this[bi] = !1, this.getZr().wakeUp(); else { try { Xp(this), lu.update.call(this, null, d) } catch (f) { throw this[ha] = null, this[bi] = !1, f } this._ssr || this._zr.flush(), this[ha] = null, this[bi] = !1, Xv.call(this, a), Jv.call(this, a) } } }, e.prototype.setTheme = function () { }, e.prototype.getModel = function () { return this._model }, e.prototype.getOption = function () { return this._model && this._model.getOption() }, e.prototype.getWidth = function () { return this._zr.getWidth() }, e.prototype.getHeight = function () { return this._zr.getHeight() }, e.prototype.getDevicePixelRatio = function () { return this._zr.painter.dpr || en.hasGlobalWindow && window.devicePixelRatio || 1 }, e.prototype.getRenderedCanvas = function (t) { return this.renderToCanvas(t) }, e.prototype.renderToCanvas = function (t) { t = t || {}; var r = this._zr.painter; return r.getRenderedCanvas({ backgroundColor: t.backgroundColor || this._model.get("backgroundColor"), pixelRatio: t.pixelRatio || this.getDevicePixelRatio() }) }, e.prototype.renderToSVGString = function (t) { t = t || {}; var r = this._zr.painter; return r.renderToString({ useViewBox: t.useViewBox }) }, e.prototype.getSvgDataURL = function () { if (en.svgSupported) { var t = this._zr, r = t.storage.getDisplayList(); return $(r, function (i) { i.stopAnimation(null, !0) }), t.painter.toDataURL() } }, e.prototype.getDataURL = function (t) { if (this._disposed) { this.id; return } t = t || {}; var r = t.excludeComponents, i = this._model, a = [], o = this; $(r, function (l) { i.eachComponent({ mainType: l }, function (c) { var u = o._componentsMap[c.__viewId]; u.group.ignore || (a.push(u), u.group.ignore = !0) }) }); var s = this._zr.painter.getType() === "svg" ? this.getSvgDataURL() : this.renderToCanvas(t).toDataURL("image/" + (t && t.type || "png")); return $(a, function (l) { l.group.ignore = !1 }), s }, e.prototype.getConnectedDataURL = function (t) { if (this._disposed) { this.id; return } var r = t.type === "svg", i = this.group, a = Math.min, o = Math.max, s = 1 / 0; if (WH[i]) { var l = s, c = s, u = -s, d = -s, f = [], h = t && t.pixelRatio || this.getDevicePixelRatio(); $(b0, function (w, v) { if (w.group === i) { var S = r ? w.getZr().painter.getSvgDom().innerHTML : w.renderToCanvas(lt(t)), x = w.getDom().getBoundingClientRect(); l = a(x.left, l), c = a(x.top, c), u = o(x.right, u), d = o(x.bottom, d), f.push({ dom: S, left: x.left, top: x.top }) } }), l *= h, c *= h, u *= h, d *= h; var p = u - l, m = d - c, g = kd.createCanvas(), y = X6(g, { renderer: r ? "svg" : "canvas" }); if (y.resize({ width: p, height: m }), r) { var b = ""; return $(f, function (w) { var v = w.left - l, S = w.top - c; b += '<g transform="translate(' + v + "," + S + ')">' + w.dom + "</g>" }), y.painter.getSvgRoot().innerHTML = b, t.connectedBackgroundColor && y.painter.setBackgroundColor(t.connectedBackgroundColor), y.refreshImmediately(), y.painter.toDataURL() } else return t.connectedBackgroundColor && y.add(new Yt({ shape: { x: 0, y: 0, width: p, height: m }, style: { fill: t.connectedBackgroundColor } })), $(f, function (w) { var v = new gi({ style: { x: w.left * h - l, y: w.top * h - c, image: w.dom } }); y.add(v) }), y.refreshImmediately(), g.toDataURL("image/" + (t && t.type || "png")) } else return this.getDataURL(t) }, e.prototype.convertToPixel = function (t, r) { return eO(this, "convertToPixel", t, r) }, e.prototype.convertFromPixel = function (t, r) { return eO(this, "convertFromPixel", t, r) }, e.prototype.containPixel = function (t, r) { if (this._disposed) { this.id; return } var i = this._model, a, o = h0(i, t); return $(o, function (s, l) { l.indexOf("Models") >= 0 && $(s, function (c) { var u = c.coordinateSystem; if (u && u.containPoint) a = a || !!u.containPoint(r); else if (l === "seriesModels") { var d = this._chartsMap[c.__viewId]; d && d.containPoint && (a = a || d.containPoint(r, c)) } }, this) }, this), !!a }, e.prototype.getVisual = function (t, r) { var i = this._model, a = h0(i, t, { defaultMainType: "series" }), o = a.seriesModel, s = o.getData(), l = a.hasOwnProperty("dataIndexInside") ? a.dataIndexInside : a.hasOwnProperty("dataIndex") ? s.indexOfRawIndex(a.dataIndex) : null; return l != null ? u3(s, l, r) : Ab(s, r) }, e.prototype.getViewOfComponentModel = function (t) { return this._componentsMap[t.__viewId] }, e.prototype.getViewOfSeriesModel = function (t) { return this._chartsMap[t.__viewId] }, e.prototype._initEvents = function () { var t = this; $(G9e, function (r) { var i = function (a) { var o = t.getModel(), s = a.target, l, c = r === "globalout"; if (c ? l = {} : s && rh(s, function (p) { var m = pt(p); if (m && m.dataIndex != null) { var g = m.dataModel || o.getSeriesByIndex(m.seriesIndex); return l = g && g.getDataParams(m.dataIndex, m.dataType, s) || {}, !0 } else if (m.eventData) return l = be({}, m.eventData), !0 }, !0), l) { var u = l.componentType, d = l.componentIndex; (u === "markLine" || u === "markPoint" || u === "markArea") && (u = "series", d = l.seriesIndex); var f = u && d != null && o.getComponent(u, d), h = f && t[f.mainType === "series" ? "_chartsMap" : "_componentsMap"][f.__viewId]; l.event = a, l.type = r, t._$eventProcessor.eventInfo = { targetEl: s, packedEvent: l, model: f, view: h }, t.trigger(r, l) } }; i.zrEventfulCallAtLast = !0, t._zr.on(r, i, t) }), $(_0, function (r, i) { t._messageCenter.on(i, function (a) { this.trigger(i, a) }, t) }), $(["selectchanged"], function (r) { t._messageCenter.on(r, function (i) { this.trigger(r, i) }, t) }), QHe(this._messageCenter, this, this._api) }, e.prototype.isDisposed = function () { return this._disposed }, e.prototype.clear = function () { if (this._disposed) { this.id; return } this.setOption({ series: [] }, !0) }, e.prototype.dispose = function () { if (this._disposed) { this.id; return } this._disposed = !0; var t = this.getDom(); t && ote(this.getDom(), p3, ""); var r = this, i = r._api, a = r._model; $(r._componentsViews, function (o) { o.dispose(a, i) }), $(r._chartsViews, function (o) { o.dispose(a, i) }), r._zr.dispose(), r._dom = r._model = r._chartsMap = r._componentsMap = r._chartsViews = r._componentsViews = r._scheduler = r._api = r._zr = r._throttledZrFlush = r._theme = r._coordSysMgr = r._messageCenter = null, delete b0[r.id] }, e.prototype.resize = function (t) { if (!this[bi]) { if (this._disposed) { this.id; return } this._zr.resize(t); var r = this._model; if (this._loadingFX && this._loadingFX.resize(), !!r) { var i = r.resetOption("media"), a = t && t.silent; this[ha] && (a == null && (a = this[ha].silent), i = !0, this[ha] = null), this[bi] = !0; try { i && Xp(this), lu.update.call(this, { type: "resize", animation: be({ duration: 0 }, t && t.animation) }) } catch (o) { throw this[bi] = !1, o } this[bi] = !1, Xv.call(this, a), Jv.call(this, a) } } }, e.prototype.showLoading = function (t, r) { if (this._disposed) { this.id; return } if (ot(t) && (r = t, t = ""), t = t || "default", this.hideLoading(), !!gI[t]) { var i = gI[t](this._api, r), a = this._zr; this._loadingFX = i, a.add(i) } }, e.prototype.hideLoading = function () { if (this._disposed) { this.id; return } this._loadingFX && this._zr.remove(this._loadingFX), this._loadingFX = null }, e.prototype.makeActionFromEvent = function (t) { var r = be({}, t); return r.type = _0[t.type], r }, e.prototype.dispatchAction = function (t, r) { if (this._disposed) { this.id; return } if (ot(r) || (r = { silent: !!r }), !!cT[t.type] && this._model) { if (this[bi]) { this._pendingActions.push(t); return } var i = r.silent; nO.call(this, t, i); var a = r.flush; a ? this._zr.flush() : a !== !1 && en.browser.weChat && this._throttledZrFlush(), Xv.call(this, i), Jv.call(this, i) } }, e.prototype.updateLabelLayout = function () { is.trigger("series:layoutlabels", this._model, this._api, { updatedSeries: [] }) }, e.prototype.appendData = function (t) { if (this._disposed) { this.id; return } var r = t.seriesIndex, i = this.getModel(), a = i.getSeriesByIndex(r); a.appendData(t), this._scheduler.unfinished = !0, this.getZr().wakeUp() }, e.internalField = function () { Xp = function (d) { var f = d._scheduler; f.restorePipelines(d._model), f.prepareStageTasks(), QM(d, !0), QM(d, !1), f.plan() }, QM = function (d, f) { for (var h = d._model, p = d._scheduler, m = f ? d._componentsViews : d._chartsViews, g = f ? d._componentsMap : d._chartsMap, y = d._zr, b = d._api, w = 0; w < m.length; w++)m[w].__alive = !1; f ? h.eachComponent(function (x, k) { x !== "series" && v(k) }) : h.eachSeries(v); function v(x) { var k = x.__requireNewView; x.__requireNewView = !1; var A = "_ec_" + x.id + "_" + x.type, C = !k && g[A]; if (!C) { var E = sl(x.type), O = f ? nr.getClass(E.main, E.sub) : Nn.getClass(E.sub); C = new O, C.init(h, b), g[A] = C, m.push(C), y.add(C.group) } x.__viewId = C.__id = A, C.__alive = !0, C.__model = x, C.group.__ecComponentInfo = { mainType: x.mainType, index: x.componentIndex }, !f && p.prepareView(C, x, h, b) } for (var w = 0; w < m.length;) { var S = m[w]; S.__alive ? w++ : (!f && S.renderTask.dispose(), y.remove(S.group), S.dispose(h, b), m.splice(w, 1), g[S.__id] === S && delete g[S.__id], S.__id = S.group.__ecComponentInfo = null) } }, qw = function (d, f, h, p, m) { var g = d._model; if (g.setUpdatePayload(h), !p) { $([].concat(d._componentsViews).concat(d._chartsViews), S); return } var y = {}; y[p + "Id"] = h[p + "Id"], y[p + "Index"] = h[p + "Index"], y[p + "Name"] = h[p + "Name"]; var b = { mainType: p, query: y }; m && (b.subType = m); var w = h.excludeSeriesId, v; w != null && (v = Ze(), $(Cn(w), function (x) { var k = Er(x, null); k != null && v.set(k, !0) })), g && g.eachComponent(b, function (x) { var k = v && v.get(x.id) != null; if (!k) if (AV(h)) if (x instanceof Yn) h.type === Sh && !h.notBlur && !x.get(["emphasis", "disabled"]) && qze(x, h, d._api); else { var A = FN(x.mainType, x.componentIndex, h.name, d._api), C = A.focusSelf, E = A.dispatchers; h.type === Sh && C && !h.notBlur && ZP(x.mainType, x.componentIndex, d._api), E && $(E, function (O) { h.type === Sh ? Pc(O) : Ic(O) }) } else JP(h) && x instanceof Yn && (Xze(x, h, d._api), kV(x), lo(d)) }, d), g && g.eachComponent(b, function (x) { var k = v && v.get(x.id) != null; k || S(d[p === "series" ? "_chartsMap" : "_componentsMap"][x.__viewId]) }, d); function S(x) { x && x.__alive && x[f] && x[f](x.__model, g, d._api, h) } }, lu = { prepareAndUpdate: function (d) { Xp(this), lu.update.call(this, d, { optionChanged: d.newOption != null }) }, update: function (d, f) { var h = this._model, p = this._api, m = this._zr, g = this._coordSysMgr, y = this._scheduler; if (h) { h.setUpdatePayload(d), y.restoreData(h, d), y.performSeriesTasks(h), g.create(h, p), y.performDataProcessorTasks(h, d), tO(this, h), g.update(h, p), t(h), y.performVisualTasks(h, d), rO(this, h, p, d, f); var b = h.get("backgroundColor") || "transparent", w = h.get("darkMode"); m.setBackgroundColor(b), w != null && w !== "auto" && m.setDarkMode(w), is.trigger("afterupdate", h, p) } }, updateTransform: function (d) { var f = this, h = this._model, p = this._api; if (h) { h.setUpdatePayload(d); var m = []; h.eachComponent(function (y, b) { if (y !== "series") { var w = f.getViewOfComponentModel(b); if (w && w.__alive) if (w.updateTransform) { var v = w.updateTransform(b, h, p, d); v && v.update && m.push(w) } else m.push(w) } }); var g = Ze(); h.eachSeries(function (y) { var b = f._chartsMap[y.__viewId]; if (b.updateTransform) { var w = b.updateTransform(y, h, p, d); w && w.update && g.set(y.uid, 1) } else g.set(y.uid, 1) }), t(h), this._scheduler.performVisualTasks(h, d, { setDirty: !0, dirtyMap: g }), Yw(this, h, p, d, {}, g), is.trigger("afterupdate", h, p) } }, updateView: function (d) { var f = this._model; f && (f.setUpdatePayload(d), Nn.markUpdateMethod(d, "updateView"), t(f), this._scheduler.performVisualTasks(f, d, { setDirty: !0 }), rO(this, f, this._api, d, {}), is.trigger("afterupdate", f, this._api)) }, updateVisual: function (d) { var f = this, h = this._model; h && (h.setUpdatePayload(d), h.eachSeries(function (p) { p.getData().clearAllVisual() }), Nn.markUpdateMethod(d, "updateVisual"), t(h), this._scheduler.performVisualTasks(h, d, { visualType: "visual", setDirty: !0 }), h.eachComponent(function (p, m) { if (p !== "series") { var g = f.getViewOfComponentModel(m); g && g.__alive && g.updateVisual(m, h, f._api, d) } }), h.eachSeries(function (p) { var m = f._chartsMap[p.__viewId]; m.updateVisual(p, h, f._api, d) }), is.trigger("afterupdate", h, this._api)) }, updateLayout: function (d) { lu.update.call(this, d) } }, eO = function (d, f, h, p) { if (d._disposed) { d.id; return } for (var m = d._model, g = d._coordSysMgr.getCoordinateSystems(), y, b = h0(m, h), w = 0; w < g.length; w++) { var v = g[w]; if (v[f] && (y = v[f](m, b, p)) != null) return y } }, tO = function (d, f) { var h = d._chartsMap, p = d._scheduler; f.eachSeries(function (m) { p.updateStreamModes(m, h[m.__viewId]) }) }, nO = function (d, f) { var h = this, p = this.getModel(), m = d.type, g = d.escapeConnect, y = cT[m], b = y.actionInfo, w = (b.update || "update").split(":"), v = w.pop(), S = w[0] != null && sl(w[0]); this[bi] = !0; var x = [d], k = !1; d.batch && (k = !0, x = Ae(d.batch, function (L) { return L = rt(be({}, L), d), L.batch = null, L })); var A = [], C, E = JP(d), O = AV(d); if (O && Dte(this._api), $(x, function (L) { if (C = y.action(L, h._model, h._api), C = C || be({}, L), C.type = b.event || C.type, A.push(C), O) { var R = jN(d), D = R.queryOptionMap, P = R.mainTypeSpecified, B = P ? D.keys()[0] : "series"; qw(h, v, L, B), lo(h) } else E ? (qw(h, v, L, "series"), lo(h)) : S && qw(h, v, L, S.main, S.sub) }), v !== "none" && !O && !E && !S) try { this[ha] ? (Xp(this), lu.update.call(this, d), this[ha] = null) : lu[v].call(this, d) } catch (L) { throw this[bi] = !1, L } if (k ? C = { type: b.event || m, escapeConnect: g, batch: A } : C = A[0], this[bi] = !1, !f) { var j = this._messageCenter; if (j.trigger(C.type, C), E) { var I = { type: "selectchanged", escapeConnect: g, selected: Jze(p), isFromClick: d.isFromClick || !1, fromAction: d.type, fromActionPayload: d }; j.trigger(I.type, I) } } }, Xv = function (d) { for (var f = this._pendingActions; f.length;) { var h = f.shift(); nO.call(this, h, d) } }, Jv = function (d) { !d && this.trigger("updated") }, zH = function (d, f) { d.on("rendered", function (h) { f.trigger("rendered", h), d.animation.isFinished() && !f[ha] && !f._scheduler.unfinished && !f._pendingActions.length && f.trigger("finished") }) }, VH = function (d, f) { d.on("mouseover", function (h) { var p = h.target, m = rh(p, y_); m && (Yze(m, h, f._api), lo(f)) }).on("mouseout", function (h) { var p = h.target, m = rh(p, y_); m && (Zze(m, h, f._api), lo(f)) }).on("click", function (h) { var p = h.target, m = rh(p, function (b) { return pt(b).dataIndex != null }, !0); if (m) { var g = m.selected ? "unselect" : "select", y = pt(m); f._api.dispatchAction({ type: g, dataType: y.dataType, dataIndexInside: y.dataIndex, seriesIndex: y.seriesIndex, isFromClick: !0 }) } }) }; function t(d) { d.clearColorPalette(), d.eachSeries(function (f) { f.clearColorPalette() }) } function r(d) { var f = [], h = [], p = !1; if (d.eachComponent(function (b, w) { var v = w.get("zlevel") || 0, S = w.get("z") || 0, x = w.getZLevelKey(); p = p || !!x, (b === "series" ? h : f).push({ zlevel: v, z: S, idx: w.componentIndex, type: b, key: x }) }), p) { var m = f.concat(h), g, y; Yx(m, function (b, w) { return b.zlevel === w.zlevel ? b.z - w.z : b.zlevel - w.zlevel }), $(m, function (b) { var w = d.getComponent(b.type, b.idx), v = b.zlevel, S = b.key; g != null && (v = Math.max(g, v)), S ? (v === g && S !== y && v++, y = S) : y && (v === g && v++, y = ""), g = v, w.setZLevel(v) }) } } rO = function (d, f, h, p, m) { r(f), HH(d, f, h, p, m), $(d._chartsViews, function (g) { g.__alive = !1 }), Yw(d, f, h, p, m), $(d._chartsViews, function (g) { g.__alive || g.remove(f, h) }) }, HH = function (d, f, h, p, m, g) { $(g || d._componentsViews, function (y) { var b = y.__model; c(b, y), y.render(b, f, h, p), s(b, y), u(b, y) }) }, Yw = function (d, f, h, p, m, g) { var y = d._scheduler; m = be(m || {}, { updatedSeries: f.getSeries() }), is.trigger("series:beforeupdate", f, h, m); var b = !1; f.eachSeries(function (w) { var v = d._chartsMap[w.__viewId]; v.__alive = !0; var S = v.renderTask; y.updatePayload(S, p), c(w, v), g && g.get(w.uid) && S.dirty(), S.perform(y.getPerformArgs(S)) && (b = !0), v.group.silent = !!w.get("silent"), o(w, v), kV(w) }), y.unfinished = b || y.unfinished, is.trigger("series:layoutlabels", f, h, m), is.trigger("series:transition", f, h, m), f.eachSeries(function (w) { var v = d._chartsMap[w.__viewId]; s(w, v), u(w, v) }), a(d, f), is.trigger("series:afterupdate", f, h, m) }, lo = function (d) { d[XM] = !0, d.getZr().wakeUp() }, GH = function (d) { d[XM] && (d.getZr().storage.traverse(function (f) { qm(f) || i(f) }), d[XM] = !1) }; function i(d) { for (var f = [], h = d.currentStates, p = 0; p < h.length; p++) { var m = h[p]; m === "emphasis" || m === "blur" || m === "select" || f.push(m) } d.selected && d.states.select && f.push("select"), d.hoverState === tC && d.states.emphasis ? f.push("emphasis") : d.hoverState === xb && d.states.blur && f.push("blur"), d.useStates(f) } function a(d, f) { var h = d._zr, p = h.storage, m = 0; p.traverse(function (g) { g.isGroup || m++ }), m > f.get("hoverLayerThreshold") && !en.node && !en.worker && f.eachSeries(function (g) { if (!g.preventUsingHoverLayer) { var y = d._chartsMap[g.__viewId]; y.__alive && y.eachRendered(function (b) { b.states.emphasis && (b.states.emphasis.hoverLayer = !0) }) } }) } function o(d, f) { var h = d.get("blendMode") || null; f.eachRendered(function (p) { p.isGroup || (p.style.blend = h) }) } function s(d, f) { if (!d.preventAutoZ) { var h = d.get("z") || 0, p = d.get("zlevel") || 0; f.eachRendered(function (m) { return l(m, h, p, -1 / 0), !0 }) } } function l(d, f, h, p) { var m = d.getTextContent(), g = d.getTextGuideLine(), y = d.isGroup; if (y) for (var b = d.childrenRef(), w = 0; w < b.length; w++)p = Math.max(l(b[w], f, h, p), p); else d.z = f, d.zlevel = h, p = Math.max(d.z2, p); if (m && (m.z = f, m.zlevel = h, isFinite(p) && (m.z2 = p + 2)), g) { var v = d.textGuideLineConfig; g.z = f, g.zlevel = h, isFinite(p) && (g.z2 = p + (v && v.showAbove ? 1 : -1)) } return p } function c(d, f) { f.eachRendered(function (h) { if (!qm(h)) { var p = h.getTextContent(), m = h.getTextGuideLine(); h.stateTransition && (h.stateTransition = null), p && p.stateTransition && (p.stateTransition = null), m && m.stateTransition && (m.stateTransition = null), h.hasState() ? (h.prevStates = h.currentStates, h.clearStates()) : h.prevStates && (h.prevStates = null) } }) } function u(d, f) { var h = d.getModel("stateAnimation"), p = d.isAnimationEnabled(), m = h.get("duration"), g = m > 0 ? { duration: m, delay: h.get("delay"), easing: h.get("easing") } : null; f.eachRendered(function (y) { if (y.states && y.states.emphasis) { if (qm(y)) return; if (y instanceof Nt && r6e(y), y.__dirty) { var b = y.prevStates; b && y.useStates(b) } if (p) { y.stateTransition = g; var w = y.getTextContent(), v = y.getTextGuideLine(); w && (w.stateTransition = g), v && (v.stateTransition = g) } y.__dirty && i(y) } }) } UH = function (d) { return new (function (f) { te(h, f); function h() { return f !== null && f.apply(this, arguments) || this } return h.prototype.getCoordinateSystems = function () { return d._coordSysMgr.getCoordinateSystems() }, h.prototype.getComponentByElement = function (p) { for (; p;) { var m = p.__ecComponentInfo; if (m != null) return d._model.getComponent(m.mainType, m.index); p = p.parent } }, h.prototype.enterEmphasis = function (p, m) { Pc(p, m), lo(d) }, h.prototype.leaveEmphasis = function (p, m) { Ic(p, m), lo(d) }, h.prototype.enterBlur = function (p) { Ate(p), lo(d) }, h.prototype.leaveBlur = function (p) { $N(p), lo(d) }, h.prototype.enterSelect = function (p) { Ete(p), lo(d) }, h.prototype.leaveSelect = function (p) { Mte(p), lo(d) }, h.prototype.getModel = function () { return d.getModel() }, h.prototype.getViewOfComponentModel = function (p) { return d.getViewOfComponentModel(p) }, h.prototype.getViewOfSeriesModel = function (p) { return d.getViewOfSeriesModel(p) }, h }(jne))(d) }, Are = function (d) { function f(h, p) { for (var m = 0; m < h.length; m++) { var g = h[m]; g[JM] = p } } $(_0, function (h, p) { d._messageCenter.on(p, function (m) { if (WH[d.group] && d[JM] !== FH) { if (m && m.escapeConnect) return; var g = d.makeActionFromEvent(m), y = []; $(b0, function (b) { b !== d && b.group === d.group && y.push(b) }), f(y, FH), $(y, function (b) { b[JM] !== H9e && b.dispatchAction(g) }), f(y, U9e) } }) }) } }(), e }(Go), h3 = Ere.prototype; h3.on = xre("on"); h3.off = xre("off"); h3.one = function (n, e, t) { var r = this; function i() { for (var a = [], o = 0; o < arguments.length; o++)a[o] = arguments[o]; e && e.apply && e.apply(this, a), r.off(n, i) } this.on.call(this, n, i, t) }; var G9e = ["click", "dblclick", "mouseover", "mouseout", "mousemove", "mousedown", "mouseup", "globalout", "contextmenu"]; var cT = {}, _0 = {}, pI = [], mI = [], uT = [], Mre = {}, gI = {}, b0 = {}, WH = {}, W9e = +new Date - 0, p3 = "_echarts_instance_"; function aft(n, e, t) { var r = !(t && t.ssr); if (r) { var i = K9e(n); if (i) return i } var a = new Ere(n, e, t); return a.id = "ec_" + W9e++, b0[a.id] = a, r && ote(n, p3, a.id), Are(a), is.trigger("afterinit", a), a } function K9e(n) { return b0[HFe(n, p3)] } function Ore(n, e) { Mre[n] = e } function Dre(n) { Et(mI, n) < 0 && mI.push(n) } function jre(n, e) { g3(pI, n, e, L9e) } function q9e(n) { m3("afterinit", n) } function Y9e(n) { m3("afterupdate", n) } function m3(n, e) { is.on(n, e) } function Ll(n, e, t) { tt(e) && (t = e, e = ""); var r = ot(n) ? n.type : [n, n = { event: e }][0]; n.event = (n.event || r).toLowerCase(), e = n.event, !_0[e] && (na($H.test(r) && $H.test(e)), cT[r] || (cT[r] = { action: t, actionInfo: n }), _0[e] = r) } function Z9e(n, e) { Cb.register(n, e) } function X9e(n, e) { g3(uT, n, e, _re, "layout") } function lp(n, e) { g3(uT, n, e, bre, "visual") } var KH = []; function g3(n, e, t, r, i) { if ((tt(e) || ot(e)) && (t = e, e = r), !(Et(KH, t) >= 0)) { KH.push(t); var a = lre.wrapStageHandler(t, i); a.__prio = e, a.__raw = t, n.push(a) } } function Pre(n, e) { gI[n] = e } function J9e(n, e, t) { var r = O9e("registerMap"); r && r(n, e, t) } var Q9e = lHe; lp(f3, IHe); lp(yC, LHe); lp(yC, RHe); lp(f3, XHe); lp(yC, JHe); lp(wre, A9e); Dre(Ine); jre(P9e, VVe); Pre("default", NHe); Ll({ type: Sh, event: Sh, update: Sh }, gr); Ll({ type: tS, event: tS, update: tS }, gr); Ll({ type: p0, event: p0, update: p0 }, gr); Ll({ type: nS, event: nS, update: nS }, gr); Ll({ type: m0, event: m0, update: m0 }, gr); Ore("light", qHe); Ore("dark", YHe); var qH = [], e7e = { registerPreprocessor: Dre, registerProcessor: jre, registerPostInit: q9e, registerPostUpdate: Y9e, registerUpdateLifecycle: m3, registerAction: Ll, registerCoordinateSystem: Z9e, registerLayout: X9e, registerVisual: lp, registerTransform: Q9e, registerLoading: Pre, registerMap: J9e, registerImpl: M9e, PRIORITY: V9e, ComponentModel: Jt, ComponentView: nr, SeriesModel: Yn, ChartView: Nn, registerComponentModel: function (n) { Jt.registerClass(n) }, registerComponentView: function (n) { nr.registerClass(n) }, registerSeriesModel: function (n) { Yn.registerClass(n) }, registerChartView: function (n) { Nn.registerClass(n) }, registerSubTypeDefaulter: function (n, e) { Jt.registerSubTypeDefaulter(n, e) }, registerPainter: function (n, e) { wFe(n, e) } }; function It(n) { if (ke(n)) { $(n, function (e) { It(e) }); return } Et(qH, n) >= 0 || (qH.push(n), tt(n) && (n = { install: n }), n.install(e7e)) } function Qv(n) { return n == null ? 0 : n.length || 1 } function YH(n) { return n } var t7e = function () { function n(e, t, r, i, a, o) { this._old = e, this._new = t, this._oldKeyGetter = r || YH, this._newKeyGetter = i || YH, this.context = a, this._diffModeMultiple = o === "multiple" } return n.prototype.add = function (e) { return this._add = e, this }, n.prototype.update = function (e) { return this._update = e, this }, n.prototype.updateManyToOne = function (e) { return this._updateManyToOne = e, this }, n.prototype.updateOneToMany = function (e) { return this._updateOneToMany = e, this }, n.prototype.updateManyToMany = function (e) { return this._updateManyToMany = e, this }, n.prototype.remove = function (e) { return this._remove = e, this }, n.prototype.execute = function () { this[this._diffModeMultiple ? "_executeMultiple" : "_executeOneToOne"]() }, n.prototype._executeOneToOne = function () { var e = this._old, t = this._new, r = {}, i = new Array(e.length), a = new Array(t.length); this._initIndexMap(e, null, i, "_oldKeyGetter"), this._initIndexMap(t, r, a, "_newKeyGetter"); for (var o = 0; o < e.length; o++) { var s = i[o], l = r[s], c = Qv(l); if (c > 1) { var u = l.shift(); l.length === 1 && (r[s] = l[0]), this._update && this._update(u, o) } else c === 1 ? (r[s] = null, this._update && this._update(l, o)) : this._remove && this._remove(o) } this._performRestAdd(a, r) }, n.prototype._executeMultiple = function () { var e = this._old, t = this._new, r = {}, i = {}, a = [], o = []; this._initIndexMap(e, r, a, "_oldKeyGetter"), this._initIndexMap(t, i, o, "_newKeyGetter"); for (var s = 0; s < a.length; s++) { var l = a[s], c = r[l], u = i[l], d = Qv(c), f = Qv(u); if (d > 1 && f === 1) this._updateManyToOne && this._updateManyToOne(u, c), i[l] = null; else if (d === 1 && f > 1) this._updateOneToMany && this._updateOneToMany(u, c), i[l] = null; else if (d === 1 && f === 1) this._update && this._update(u, c), i[l] = null; else if (d > 1 && f > 1) this._updateManyToMany && this._updateManyToMany(u, c), i[l] = null; else if (d > 1) for (var h = 0; h < d; h++)this._remove && this._remove(c[h]); else this._remove && this._remove(c) } this._performRestAdd(o, i) }, n.prototype._performRestAdd = function (e, t) { for (var r = 0; r < e.length; r++) { var i = e[r], a = t[i], o = Qv(a); if (o > 1) for (var s = 0; s < o; s++)this._add && this._add(a[s]); else o === 1 && this._add && this._add(a); t[i] = null } }, n.prototype._initIndexMap = function (e, t, r, i) { for (var a = this._diffModeMultiple, o = 0; o < e.length; o++) { var s = "_ec_" + this[i](e[o], o); if (a || (r[o] = s), !!t) { var l = t[s], c = Qv(l); c === 0 ? (t[s] = o, a && r.push(s)) : c === 1 ? t[s] = [l, o] : l.push(o) } } }, n }(); const Lc = t7e; var n7e = function () { function n(e, t) { this._encode = e, this._schema = t } return n.prototype.get = function () { return { fullDimensions: this._getFullDimensionNames(), encode: this._encode } }, n.prototype._getFullDimensionNames = function () { return this._cachedDimNames || (this._cachedDimNames = this._schema ? this._schema.makeOutputDimensionNames() : []), this._cachedDimNames }, n }(); function r7e(n, e) { var t = {}, r = t.encode = {}, i = Ze(), a = [], o = [], s = {}; $(n.dimensions, function (f) { var h = n.getDimensionInfo(f), p = h.coordDim; if (p) { var m = h.coordDimIndex; iO(r, p)[m] = f, h.isExtraCoord || (i.set(p, 1), i7e(h.type) && (a[0] = f), iO(s, p)[m] = n.getDimensionIndex(h.name)), h.defaultTooltip && o.push(f) } Sne.each(function (g, y) { var b = iO(r, y), w = h.otherDims[y]; w != null && w !== !1 && (b[w] = h.name) }) }); var l = [], c = {}; i.each(function (f, h) { var p = r[h]; c[h] = p[0], l = l.concat(p) }), t.dataDimsOnCoord = l, t.dataDimIndicesOnCoord = Ae(l, function (f) { return n.getDimensionInfo(f).storeDimIndex }), t.encodeFirstDimNotExtra = c; var u = r.label; u && u.length && (a = u.slice()); var d = r.tooltip; return d && d.length ? o = d.slice() : o.length || (o = a.slice()), r.defaultedLabel = a, r.defaultedTooltip = o, t.userOutput = new n7e(s, e), t } function iO(n, e) { return n.hasOwnProperty(e) || (n[e] = []), n[e] } function dT(n) { return n === "category" ? "ordinal" : n === "time" ? "time" : "float" } function i7e(n) { return !(n === "ordinal" || n === "time") } var a7e = function () { function n(e) { this.otherDims = {}, e != null && be(this, e) } return n }(); const sS = a7e; var o7e = Kt(), s7e = { float: "f", int: "i", ordinal: "o", number: "n", time: "t" }, Ire = function () { function n(e) { this.dimensions = e.dimensions, this._dimOmitted = e.dimensionOmitted, this.source = e.source, this._fullDimCount = e.fullDimensionCount, this._updateDimOmitted(e.dimensionOmitted) } return n.prototype.isDimensionOmitted = function () { return this._dimOmitted }, n.prototype._updateDimOmitted = function (e) { this._dimOmitted = e, e && (this._dimNameMap || (this._dimNameMap = Nre(this.source))) }, n.prototype.getSourceDimensionIndex = function (e) { return yt(this._dimNameMap.get(e), -1) }, n.prototype.getSourceDimension = function (e) { var t = this.source.dimensionsDefine; if (t) return t[e] }, n.prototype.makeStoreSchema = function () { for (var e = this._fullDimCount, t = Rne(this.source), r = !Bre(e), i = "", a = [], o = 0, s = 0; o < e; o++) { var l = void 0, c = void 0, u = void 0, d = this.dimensions[s]; if (d && d.storeDimIndex === o) l = t ? d.name : null, c = d.type, u = d.ordinalMeta, s++; else { var f = this.getSourceDimension(o); f && (l = t ? f.name : null, c = f.type) } a.push({ property: l, type: c, ordinalMeta: u }), t && l != null && (!d || !d.isCalculationCoord) && (i += r ? l.replace(/\`/g, "`1").replace(/\$/g, "`2") : l), i += "$", i += s7e[c] || "f", u && (i += u.uid), i += "$" } var h = this.source, p = [h.seriesLayoutBy, h.startIndex, i].join("$$"); return { dimensions: a, hash: p } }, n.prototype.makeOutputDimensionNames = function () { for (var e = [], t = 0, r = 0; t < this._fullDimCount; t++) { var i = void 0, a = this.dimensions[r]; if (a && a.storeDimIndex === t) a.isCalculationCoord || (i = a.name), r++; else { var o = this.getSourceDimension(t); o && (i = o.name) } e.push(i) } return e }, n.prototype.appendCalculationDimension = function (e) { this.dimensions.push(e), e.isCalculationCoord = !0, this._fullDimCount++, this._updateDimOmitted(!0) }, n }(); function Lre(n) { return n instanceof Ire } function Rre(n) { for (var e = Ze(), t = 0; t < (n || []).length; t++) { var r = n[t], i = ot(r) ? r.name : r; i != null && e.get(i) == null && e.set(i, t) } return e } function Nre(n) { var e = o7e(n); return e.dimNameMap || (e.dimNameMap = Rre(n.dimensionsDefine)) } function Bre(n) { return n > 30 } var ey = ot, cu = Ae, l7e = typeof Int32Array > "u" ? Array : Int32Array, c7e = "e\0\0", ZH = -1, u7e = ["hasItemOption", "_nameList", "_idList", "_invertedIndicesMap", "_dimSummary", "userOutput", "_rawData", "_dimValueGetter", "_nameDimIdx", "_idDimIdx", "_nameRepeatCount"], d7e = ["_approximateExtent"], XH, Zw, ty, ny, aO, ry, oO, f7e = function () { function n(e, t) { this.type = "list", this._dimOmitted = !1, this._nameList = [], this._idList = [], this._visual = {}, this._layout = {}, this._itemVisuals = [], this._itemLayouts = [], this._graphicEls = [], this._approximateExtent = {}, this._calculationInfo = {}, this.hasItemOption = !1, this.TRANSFERABLE_METHODS = ["cloneShallow", "downSample", "minmaxDownSample", "lttbDownSample", "map"], this.CHANGABLE_METHODS = ["filterSelf", "selectRange"], this.DOWNSAMPLE_METHODS = ["downSample", "minmaxDownSample", "lttbDownSample"]; var r, i = !1; Lre(e) ? (r = e.dimensions, this._dimOmitted = e.isDimensionOmitted(), this._schema = e) : (i = !0, r = e), r = r || ["x", "y"]; for (var a = {}, o = [], s = {}, l = !1, c = {}, u = 0; u < r.length; u++) { var d = r[u], f = Fe(d) ? new sS({ name: d }) : d instanceof sS ? d : new sS(d), h = f.name; f.type = f.type || "float", f.coordDim || (f.coordDim = h, f.coordDimIndex = 0); var p = f.otherDims = f.otherDims || {}; o.push(h), a[h] = f, c[h] != null && (l = !0), f.createInvertedIndices && (s[h] = []), p.itemName === 0 && (this._nameDimIdx = u), p.itemId === 0 && (this._idDimIdx = u), i && (f.storeDimIndex = u) } if (this.dimensions = o, this._dimInfos = a, this._initGetDimensionInfo(l), this.hostModel = t, this._invertedIndicesMap = s, this._dimOmitted) { var m = this._dimIdxToName = Ze(); $(o, function (g) { m.set(a[g].storeDimIndex, g) }) } } return n.prototype.getDimension = function (e) { var t = this._recognizeDimIndex(e); if (t == null) return e; if (t = e, !this._dimOmitted) return this.dimensions[t]; var r = this._dimIdxToName.get(t); if (r != null) return r; var i = this._schema.getSourceDimension(t); if (i) return i.name }, n.prototype.getDimensionIndex = function (e) { var t = this._recognizeDimIndex(e); if (t != null) return t; if (e == null) return -1; var r = this._getDimInfo(e); return r ? r.storeDimIndex : this._dimOmitted ? this._schema.getSourceDimensionIndex(e) : -1 }, n.prototype._recognizeDimIndex = function (e) { if (nn(e) || e != null && !isNaN(e) && !this._getDimInfo(e) && (!this._dimOmitted || this._schema.getSourceDimensionIndex(e) < 0)) return +e }, n.prototype._getStoreDimIndex = function (e) { var t = this.getDimensionIndex(e); return t }, n.prototype.getDimensionInfo = function (e) { return this._getDimInfo(this.getDimension(e)) }, n.prototype._initGetDimensionInfo = function (e) { var t = this._dimInfos; this._getDimInfo = e ? function (r) { return t.hasOwnProperty(r) ? t[r] : void 0 } : function (r) { return t[r] } }, n.prototype.getDimensionsOnCoord = function () { return this._dimSummary.dataDimsOnCoord.slice() }, n.prototype.mapDimension = function (e, t) { var r = this._dimSummary; if (t == null) return r.encodeFirstDimNotExtra[e]; var i = r.encode[e]; return i ? i[t] : null }, n.prototype.mapDimensionsAll = function (e) { var t = this._dimSummary, r = t.encode[e]; return (r || []).slice() }, n.prototype.getStore = function () { return this._store }, n.prototype.initData = function (e, t, r) { var i = this, a; if (e instanceof sI && (a = e), !a) { var o = this.dimensions, s = r3(e) || Ii(e) ? new Nne(e, o.length) : e; a = new sI; var l = cu(o, function (c) { return { type: i._dimInfos[c].type, property: c } }); a.initData(s, l, r) } this._store = a, this._nameList = (t || []).slice(), this._idList = [], this._nameRepeatCount = {}, this._doInit(0, a.count()), this._dimSummary = r7e(this, this._schema), this.userOutput = this._dimSummary.userOutput }, n.prototype.appendData = function (e) { var t = this._store.appendData(e); this._doInit(t[0], t[1]) }, n.prototype.appendValues = function (e, t) { var r = this._store.appendValues(e, t && t.length), i = r.start, a = r.end, o = this._shouldMakeIdFromName(); if (this._updateOrdinalMeta(), t) for (var s = i; s < a; s++) { var l = s - i; this._nameList[s] = t[l], o && oO(this, s) } }, n.prototype._updateOrdinalMeta = function () { for (var e = this._store, t = this.dimensions, r = 0; r < t.length; r++) { var i = this._dimInfos[t[r]]; i.ordinalMeta && e.collectOrdinalMeta(i.storeDimIndex, i.ordinalMeta) } }, n.prototype._shouldMakeIdFromName = function () { var e = this._store.getProvider(); return this._idDimIdx == null && e.getSource().sourceFormat !== sd && !e.fillStorage }, n.prototype._doInit = function (e, t) { if (!(e >= t)) { var r = this._store, i = r.getProvider(); this._updateOrdinalMeta(); var a = this._nameList, o = this._idList, s = i.getSource().sourceFormat, l = s === Wo; if (l && !i.pure) for (var c = [], u = e; u < t; u++) { var d = i.getItem(u, c); if (!this.hasItemOption && OFe(d) && (this.hasItemOption = !0), d) { var f = d.name; a[u] == null && f != null && (a[u] = Er(f, null)); var h = d.id; o[u] == null && h != null && (o[u] = Er(h, null)) } } if (this._shouldMakeIdFromName()) for (var u = e; u < t; u++)oO(this, u); XH(this) } }, n.prototype.getApproximateExtent = function (e) { return this._approximateExtent[e] || this._store.getDataExtent(this._getStoreDimIndex(e)) }, n.prototype.setApproximateExtent = function (e, t) { t = this.getDimension(t), this._approximateExtent[t] = e.slice() }, n.prototype.getCalculationInfo = function (e) { return this._calculationInfo[e] }, n.prototype.setCalculationInfo = function (e, t) { ey(e) ? be(this._calculationInfo, e) : this._calculationInfo[e] = t }, n.prototype.getName = function (e) { var t = this.getRawIndex(e), r = this._nameList[t]; return r == null && this._nameDimIdx != null && (r = ty(this, this._nameDimIdx, t)), r == null && (r = ""), r }, n.prototype._getCategory = function (e, t) { var r = this._store.get(e, t), i = this._store.getOrdinalMeta(e); return i ? i.categories[r] : r }, n.prototype.getId = function (e) { return Zw(this, this.getRawIndex(e)) }, n.prototype.count = function () { return this._store.count() }, n.prototype.get = function (e, t) { var r = this._store, i = this._dimInfos[e]; if (i) return r.get(i.storeDimIndex, t) }, n.prototype.getByRawIndex = function (e, t) { var r = this._store, i = this._dimInfos[e]; if (i) return r.getByRawIndex(i.storeDimIndex, t) }, n.prototype.getIndices = function () { return this._store.getIndices() }, n.prototype.getDataExtent = function (e) { return this._store.getDataExtent(this._getStoreDimIndex(e)) }, n.prototype.getSum = function (e) { return this._store.getSum(this._getStoreDimIndex(e)) }, n.prototype.getMedian = function (e) { return this._store.getMedian(this._getStoreDimIndex(e)) }, n.prototype.getValues = function (e, t) { var r = this, i = this._store; return ke(e) ? i.getValues(cu(e, function (a) { return r._getStoreDimIndex(a) }), t) : i.getValues(e) }, n.prototype.hasValue = function (e) { for (var t = this._dimSummary.dataDimIndicesOnCoord, r = 0, i = t.length; r < i; r++)if (isNaN(this._store.get(t[r], e))) return !1; return !0 }, n.prototype.indexOfName = function (e) { for (var t = 0, r = this._store.count(); t < r; t++)if (this.getName(t) === e) return t; return -1 }, n.prototype.getRawIndex = function (e) { return this._store.getRawIndex(e) }, n.prototype.indexOfRawIndex = function (e) { return this._store.indexOfRawIndex(e) }, n.prototype.rawIndexOf = function (e, t) { var r = e && this._invertedIndicesMap[e], i = r && r[t]; return i == null || isNaN(i) ? ZH : i }, n.prototype.indicesOfNearest = function (e, t, r) { return this._store.indicesOfNearest(this._getStoreDimIndex(e), t, r) }, n.prototype.each = function (e, t, r) { tt(e) && (r = t, t = e, e = []); var i = r || this, a = cu(ny(e), this._getStoreDimIndex, this); this._store.each(a, i ? He(t, i) : t) }, n.prototype.filterSelf = function (e, t, r) { tt(e) && (r = t, t = e, e = []); var i = r || this, a = cu(ny(e), this._getStoreDimIndex, this); return this._store = this._store.filter(a, i ? He(t, i) : t), this }, n.prototype.selectRange = function (e) { var t = this, r = {}, i = Bt(e); return $(i, function (a) { var o = t._getStoreDimIndex(a); r[o] = e[a] }), this._store = this._store.selectRange(r), this }, n.prototype.mapArray = function (e, t, r) { tt(e) && (r = t, t = e, e = []), r = r || this; var i = []; return this.each(e, function () { i.push(t && t.apply(this, arguments)) }, r), i }, n.prototype.map = function (e, t, r, i) { var a = r || i || this, o = cu(ny(e), this._getStoreDimIndex, this), s = ry(this); return s._store = this._store.map(o, a ? He(t, a) : t), s }, n.prototype.modify = function (e, t, r, i) { var a = r || i || this, o = cu(ny(e), this._getStoreDimIndex, this); this._store.modify(o, a ? He(t, a) : t) }, n.prototype.downSample = function (e, t, r, i) { var a = ry(this); return a._store = this._store.downSample(this._getStoreDimIndex(e), t, r, i), a }, n.prototype.minmaxDownSample = function (e, t) { var r = ry(this); return r._store = this._store.minmaxDownSample(this._getStoreDimIndex(e), t), r }, n.prototype.lttbDownSample = function (e, t) { var r = ry(this); return r._store = this._store.lttbDownSample(this._getStoreDimIndex(e), t), r }, n.prototype.getRawDataItem = function (e) { return this._store.getRawDataItem(e) }, n.prototype.getItemModel = function (e) { var t = this.hostModel, r = this.getRawDataItem(e); return new Rn(r, t, t && t.ecModel) }, n.prototype.diff = function (e) { var t = this; return new Lc(e ? e.getStore().getIndices() : [], this.getStore().getIndices(), function (r) { return Zw(e, r) }, function (r) { return Zw(t, r) }) }, n.prototype.getVisual = function (e) { var t = this._visual; return t && t[e] }, n.prototype.setVisual = function (e, t) { this._visual = this._visual || {}, ey(e) ? be(this._visual, e) : this._visual[e] = t }, n.prototype.getItemVisual = function (e, t) { var r = this._itemVisuals[e], i = r && r[t]; return i ?? this.getVisual(t) }, n.prototype.hasItemVisual = function () { return this._itemVisuals.length > 0 }, n.prototype.ensureUniqueItemVisual = function (e, t) { var r = this._itemVisuals, i = r[e]; i || (i = r[e] = {}); var a = i[t]; return a == null && (a = this.getVisual(t), ke(a) ? a = a.slice() : ey(a) && (a = be({}, a)), i[t] = a), a }, n.prototype.setItemVisual = function (e, t, r) { var i = this._itemVisuals[e] || {}; this._itemVisuals[e] = i, ey(t) ? be(i, t) : i[t] = r }, n.prototype.clearAllVisual = function () { this._visual = {}, this._itemVisuals = [] }, n.prototype.setLayout = function (e, t) { ey(e) ? be(this._layout, e) : this._layout[e] = t }, n.prototype.getLayout = function (e) { return this._layout[e] }, n.prototype.getItemLayout = function (e) { return this._itemLayouts[e] }, n.prototype.setItemLayout = function (e, t, r) { this._itemLayouts[e] = r ? be(this._itemLayouts[e] || {}, t) : t }, n.prototype.clearItemLayouts = function () { this._itemLayouts.length = 0 }, n.prototype.setItemGraphicEl = function (e, t) { var r = this.hostModel && this.hostModel.seriesIndex; qP(r, this.dataType, e, t), this._graphicEls[e] = t }, n.prototype.getItemGraphicEl = function (e) { return this._graphicEls[e] }, n.prototype.eachItemGraphicEl = function (e, t) { $(this._graphicEls, function (r, i) { r && e && e.call(t, r, i) }) }, n.prototype.cloneShallow = function (e) { return e || (e = new n(this._schema ? this._schema : cu(this.dimensions, this._getDimInfo, this), this.hostModel)), aO(e, this), e._store = this._store, e }, n.prototype.wrapMethod = function (e, t) { var r = this[e]; tt(r) && (this.__wrappedMethods = this.__wrappedMethods || [], this.__wrappedMethods.push(e), this[e] = function () { var i = r.apply(this, arguments); return t.apply(this, [i].concat(wN(arguments))) }) }, n.internalField = function () { XH = function (e) { var t = e._invertedIndicesMap; $(t, function (r, i) { var a = e._dimInfos[i], o = a.ordinalMeta, s = e._store; if (o) { r = t[i] = new l7e(o.categories.length); for (var l = 0; l < r.length; l++)r[l] = ZH; for (var l = 0; l < s.count(); l++)r[s.get(a.storeDimIndex, l)] = l } }) }, ty = function (e, t, r) { return Er(e._getCategory(t, r), null) }, Zw = function (e, t) { var r = e._idList[t]; return r == null && e._idDimIdx != null && (r = ty(e, e._idDimIdx, t)), r == null && (r = c7e + t), r }, ny = function (e) { return ke(e) || (e = e != null ? [e] : []), e }, ry = function (e) { var t = new n(e._schema ? e._schema : cu(e.dimensions, e._getDimInfo, e), e.hostModel); return aO(t, e), t }, aO = function (e, t) { $(u7e.concat(t.__wrappedMethods || []), function (r) { t.hasOwnProperty(r) && (e[r] = t[r]) }), e.__wrappedMethods = t.__wrappedMethods, $(d7e, function (r) { e[r] = lt(t[r]) }), e._calculationInfo = be({}, t._calculationInfo) }, oO = function (e, t) { var r = e._nameList, i = e._idList, a = e._nameDimIdx, o = e._idDimIdx, s = r[t], l = i[t]; if (s == null && a != null && (r[t] = s = ty(e, a, t)), l == null && o != null && (i[t] = l = ty(e, o, t)), l == null && s != null) { var c = e._nameRepeatCount, u = c[s] = (c[s] || 0) + 1; l = s, u > 1 && (l += "__ec__" + u), i[t] = l } } }(), n }(); const Ji = f7e; function Eb(n, e) { r3(n) || (n = i3(n)), e = e || {}; var t = e.coordDimensions || [], r = e.dimensionsDefine || n.dimensionsDefine || [], i = Ze(), a = [], o = p7e(n, t, r, e.dimensionsCount), s = e.canOmitUnusedDimensions && Bre(o), l = r === n.dimensionsDefine, c = l ? Nre(n) : Rre(r), u = e.encodeDefine; !u && e.encodeDefaulter && (u = e.encodeDefaulter(n, o)); for (var d = Ze(u), f = new Gne(o), h = 0; h < f.length; h++)f[h] = -1; function p(C) { var E = f[C]; if (E < 0) { var O = r[C], j = ot(O) ? O : { name: O }, I = new sS, L = j.name; L != null && c.get(L) != null && (I.name = I.displayName = L), j.type != null && (I.type = j.type), j.displayName != null && (I.displayName = j.displayName); var R = a.length; return f[C] = R, I.storeDimIndex = C, a.push(I), I } return a[E] } if (!s) for (var h = 0; h < o; h++)p(h); d.each(function (C, E) { var O = Cn(C).slice(); if (O.length === 1 && !Fe(O[0]) && O[0] < 0) { d.set(E, !1); return } var j = d.set(E, []); $(O, function (I, L) { var R = Fe(I) ? c.get(I) : I; R != null && R < o && (j[L] = R, g(p(R), E, L)) }) }); var m = 0; $(t, function (C) { var E, O, j, I; if (Fe(C)) E = C, I = {}; else { I = C, E = I.name; var L = I.ordinalMeta; I.ordinalMeta = null, I = be({}, I), I.ordinalMeta = L, O = I.dimsDef, j = I.otherDims, I.name = I.coordDim = I.coordDimIndex = I.dimsDef = I.otherDims = null } var R = d.get(E); if (R !== !1) { if (R = Cn(R), !R.length) for (var D = 0; D < (O && O.length || 1); D++) { for (; m < o && p(m).coordDim != null;)m++; m < o && R.push(m++) } $(R, function (P, B) { var F = p(P); if (l && I.type != null && (F.type = I.type), g(rt(F, I), E, B), F.name == null && O) { var K = O[B]; !ot(K) && (K = { name: K }), F.name = F.displayName = K.name, F.defaultTooltip = K.defaultTooltip } j && rt(F.otherDims, j) }) } }); function g(C, E, O) { Sne.get(E) != null ? C.otherDims[E] = O : (C.coordDim = E, C.coordDimIndex = O, i.set(E, !0)) } var y = e.generateCoord, b = e.generateCoordCount, w = b != null; b = y ? b || 1 : 0; var v = y || "value"; function S(C) { C.name == null && (C.name = C.coordDim) } if (s) $(a, function (C) { S(C) }), a.sort(function (C, E) { return C.storeDimIndex - E.storeDimIndex }); else for (var x = 0; x < o; x++) { var k = p(x), A = k.coordDim; A == null && (k.coordDim = m7e(v, i, w), k.coordDimIndex = 0, (!y || b <= 0) && (k.isExtraCoord = !0), b--), S(k), k.type == null && (Ane(n, x) === oi.Must || k.isExtraCoord && (k.otherDims.itemName != null || k.otherDims.seriesName != null)) && (k.type = "ordinal") } return h7e(a), new Ire({ source: n, dimensions: a, fullDimensionCount: o, dimensionOmitted: s }) } function h7e(n) { for (var e = Ze(), t = 0; t < n.length; t++) { var r = n[t], i = r.name, a = e.get(i) || 0; a > 0 && (r.name = i + (a - 1)), a++, e.set(i, a) } } function p7e(n, e, t, r) { var i = Math.max(n.dimensionsDetectedCount || 1, e.length, t.length, r || 0); return $(e, function (a) { var o; ot(a) && (o = a.dimsDef) && (i = Math.max(i, o.length)) }), i } function m7e(n, e, t) { if (t || e.hasKey(n)) { for (var r = 0; e.hasKey(n + r);)r++; n += r } return e.set(n, !0), n } var g7e = function () { function n(e) { this.coordSysDims = [], this.axisMap = Ze(), this.categoryAxisMap = Ze(), this.coordSysName = e } return n }(); function v7e(n) { var e = n.get("coordinateSystem"), t = new g7e(e), r = y7e[e]; if (r) return r(n, t, t.axisMap, t.categoryAxisMap), t } var y7e = { cartesian2d: function (n, e, t, r) { var i = n.getReferringComponents("xAxis", xr).models[0], a = n.getReferringComponents("yAxis", xr).models[0]; e.coordSysDims = ["x", "y"], t.set("x", i), t.set("y", a), Jp(i) && (r.set("x", i), e.firstCategoryDimIndex = 0), Jp(a) && (r.set("y", a), e.firstCategoryDimIndex == null && (e.firstCategoryDimIndex = 1)) }, singleAxis: function (n, e, t, r) { var i = n.getReferringComponents("singleAxis", xr).models[0]; e.coordSysDims = ["single"], t.set("single", i), Jp(i) && (r.set("single", i), e.firstCategoryDimIndex = 0) }, polar: function (n, e, t, r) { var i = n.getReferringComponents("polar", xr).models[0], a = i.findAxisModel("radiusAxis"), o = i.findAxisModel("angleAxis"); e.coordSysDims = ["radius", "angle"], t.set("radius", a), t.set("angle", o), Jp(a) && (r.set("radius", a), e.firstCategoryDimIndex = 0), Jp(o) && (r.set("angle", o), e.firstCategoryDimIndex == null && (e.firstCategoryDimIndex = 1)) }, geo: function (n, e, t, r) { e.coordSysDims = ["lng", "lat"] }, parallel: function (n, e, t, r) { var i = n.ecModel, a = i.getComponent("parallel", n.get("parallelIndex")), o = e.coordSysDims = a.dimensions.slice(); $(a.parallelAxisIndex, function (s, l) { var c = i.getComponent("parallelAxis", s), u = o[l]; t.set(u, c), Jp(c) && (r.set(u, c), e.firstCategoryDimIndex == null && (e.firstCategoryDimIndex = l)) }) } }; function Jp(n) { return n.get("type") === "category" } function _7e(n, e, t) { t = t || {}; var r = t.byIndex, i = t.stackedCoordDimension, a, o, s; b7e(e) ? a = e : (o = e.schema, a = o.dimensions, s = e.store); var l = !!(n && n.get("stack")), c, u, d, f; if ($(a, function (b, w) { Fe(b) && (a[w] = b = { name: b }), l && !b.isExtraCoord && (!r && !c && b.ordinalMeta && (c = b), !u && b.type !== "ordinal" && b.type !== "time" && (!i || i === b.coordDim) && (u = b)) }), u && !r && !c && (r = !0), u) { d = "__\0ecstackresult_" + n.id, f = "__\0ecstackedover_" + n.id, c && (c.createInvertedIndices = !0); var h = u.coordDim, p = u.type, m = 0; $(a, function (b) { b.coordDim === h && m++ }); var g = { name: d, coordDim: h, coordDimIndex: m, type: p, isExtraCoord: !0, isCalculationCoord: !0, storeDimIndex: a.length }, y = { name: f, coordDim: f, coordDimIndex: m + 1, type: p, isExtraCoord: !0, isCalculationCoord: !0, storeDimIndex: a.length + 1 }; o ? (s && (g.storeDimIndex = s.ensureCalculationDimension(f, p), y.storeDimIndex = s.ensureCalculationDimension(d, p)), o.appendCalculationDimension(g), o.appendCalculationDimension(y)) : (a.push(g), a.push(y)) } return { stackedDimension: u && u.name, stackedByDimension: c && c.name, isStackedByIndex: r, stackedOverDimension: f, stackResultDimension: d } } function b7e(n) { return !Lre(n.schema) } function Md(n, e) { return !!e && e === n.getCalculationInfo("stackedDimension") } function $re(n, e) { return Md(n, e) ? n.getCalculationInfo("stackResultDimension") : e } function w7e(n, e) { var t = n.get("coordinateSystem"), r = Cb.get(t), i; return e && e.coordSysDims && (i = Ae(e.coordSysDims, function (a) { var o = { name: a }, s = e.axisMap.get(a); if (s) { var l = s.get("type"); o.type = dT(l) } return o })), i || (i = r && (r.getDimensionsInfo ? r.getDimensionsInfo() : r.dimensions.slice()) || ["x", "y"]), i } function x7e(n, e, t) { var r, i; return t && $(n, function (a, o) { var s = a.coordDim, l = t.categoryAxisMap.get(s); l && (r == null && (r = o), a.ordinalMeta = l.getOrdinalMeta(), e && (a.createInvertedIndices = !0)), a.otherDims.itemName != null && (i = !0) }), !i && r != null && (n[r].otherDims.itemName = 0), r } function Hc(n, e, t) { t = t || {}; var r = e.getSourceManager(), i, a = !1; n ? (a = !0, i = i3(n)) : (i = r.getSource(), a = i.sourceFormat === Wo); var o = v7e(e), s = w7e(e, o), l = t.useEncodeDefaulter, c = tt(l) ? l : l ? wt(Cne, s, e) : null, u = { coordDimensions: s, generateCoord: t.generateCoord, encodeDefine: e.getEncode(), encodeDefaulter: c, canOmitUnusedDimensions: !a }, d = Eb(i, u), f = x7e(d.dimensions, t.createInvertedIndices, o), h = a ? null : r.getSharedDataStore(d), p = _7e(e, { schema: d, store: h }), m = new Ji(d, e); m.setCalculationInfo(p); var g = f != null && S7e(i) ? function (y, b, w, v) { return v === f ? w : this.defaultDimValueGetter(y, b, w, v) } : null; return m.hasItemOption = !1, m.initData(a ? i : h, null, g), m } function S7e(n) { if (n.sourceFormat === Wo) { var e = T7e(n.data || []); return !ke(Yg(e)) } } function T7e(n) { for (var e = 0; e < n.length && n[e] == null;)e++; return n[e] } var Fre = function () { function n(e) { this._setting = e || {}, this._extent = [1 / 0, -1 / 0] } return n.prototype.getSetting = function (e) { return this._setting[e] }, n.prototype.unionExtent = function (e) { var t = this._extent; e[0] < t[0] && (t[0] = e[0]), e[1] > t[1] && (t[1] = e[1]) }, n.prototype.unionExtentFromData = function (e, t) { this.unionExtent(e.getApproximateExtent(t)) }, n.prototype.getExtent = function () { return this._extent.slice() }, n.prototype.setExtent = function (e, t) { var r = this._extent; isNaN(e) || (r[0] = e), isNaN(t) || (r[1] = t) }, n.prototype.isInExtentRange = function (e) { return this._extent[0] <= e && this._extent[1] >= e }, n.prototype.isBlank = function () { return this._isBlank }, n.prototype.setBlank = function (e) { this._isBlank = e }, n }(); Xk(Fre); const Uc = Fre; var k7e = 0, C7e = function () { function n(e) { this.categories = e.categories || [], this._needCollect = e.needCollect, this._deduplication = e.deduplication, this.uid = ++k7e } return n.createByAxisModel = function (e) { var t = e.option, r = t.data, i = r && Ae(r, A7e); return new n({ categories: i, needCollect: !i, deduplication: t.dedplication !== !1 }) }, n.prototype.getOrdinal = function (e) { return this._getOrCreateMap().get(e) }, n.prototype.parseAndCollect = function (e) { var t, r = this._needCollect; if (!Fe(e) && !r) return e; if (r && !this._deduplication) return t = this.categories.length, this.categories[t] = e, t; var i = this._getOrCreateMap(); return t = i.get(e), t == null && (r ? (t = this.categories.length, this.categories[t] = e, i.set(e, t)) : t = NaN), t }, n.prototype._getOrCreateMap = function () { return this._map || (this._map = Ze(this.categories)) }, n }(); function A7e(n) { return ot(n) && n.value != null ? n.value : n + "" } const vI = C7e; function yI(n) { return n.type === "interval" || n.type === "log" } function E7e(n, e, t, r) { var i = {}, a = n[1] - n[0], o = i.interval = Jee(a / e, !0); t != null && o < t && (o = i.interval = t), r != null && o > r && (o = i.interval = r); var s = i.intervalPrecision = zre(o), l = i.niceTickExtent = [lr(Math.ceil(n[0] / o) * o, s), lr(Math.floor(n[1] / o) * o, s)]; return M7e(l, n), i } function sO(n) { var e = Math.pow(10, ON(n)), t = n / e; return t ? t === 2 ? t = 3 : t === 3 ? t = 5 : t *= 2 : t = 1, lr(t * e) } function zre(n) { return ol(n) + 2 } function JH(n, e, t) { n[e] = Math.max(Math.min(n[e], t[1]), t[0]) } function M7e(n, e) { !isFinite(n[0]) && (n[0] = e[0]), !isFinite(n[1]) && (n[1] = e[1]), JH(n, 0, e), JH(n, 1, e), n[0] > n[1] && (n[0] = n[1]) } function _C(n, e) { return n >= e[0] && n <= e[1] } function bC(n, e) { return e[1] === e[0] ? .5 : (n - e[0]) / (e[1] - e[0]) } function wC(n, e) { return n * (e[1] - e[0]) + e[0] } var Vre = function (n) { te(e, n); function e(t) { var r = n.call(this, t) || this; r.type = "ordinal"; var i = r.getSetting("ordinalMeta"); return i || (i = new vI({})), ke(i) && (i = new vI({ categories: Ae(i, function (a) { return ot(a) ? a.value : a }) })), r._ordinalMeta = i, r._extent = r.getSetting("extent") || [0, i.categories.length - 1], r } return e.prototype.parse = function (t) { return t == null ? NaN : Fe(t) ? this._ordinalMeta.getOrdinal(t) : Math.round(t) }, e.prototype.contain = function (t) { return t = this.parse(t), _C(t, this._extent) && this._ordinalMeta.categories[t] != null }, e.prototype.normalize = function (t) { return t = this._getTickNumber(this.parse(t)), bC(t, this._extent) }, e.prototype.scale = function (t) { return t = Math.round(wC(t, this._extent)), this.getRawOrdinalNumber(t) }, e.prototype.getTicks = function () { for (var t = [], r = this._extent, i = r[0]; i <= r[1];)t.push({ value: i }), i++; return t }, e.prototype.getMinorTicks = function (t) { }, e.prototype.setSortInfo = function (t) { if (t == null) { this._ordinalNumbersByTick = this._ticksByOrdinalNumber = null; return } for (var r = t.ordinalNumbers, i = this._ordinalNumbersByTick = [], a = this._ticksByOrdinalNumber = [], o = 0, s = this._ordinalMeta.categories.length, l = Math.min(s, r.length); o < l; ++o) { var c = r[o]; i[o] = c, a[c] = o } for (var u = 0; o < s; ++o) { for (; a[u] != null;)u++; i.push(u), a[u] = o } }, e.prototype._getTickNumber = function (t) { var r = this._ticksByOrdinalNumber; return r && t >= 0 && t < r.length ? r[t] : t }, e.prototype.getRawOrdinalNumber = function (t) { var r = this._ordinalNumbersByTick; return r && t >= 0 && t < r.length ? r[t] : t }, e.prototype.getLabel = function (t) { if (!this.isBlank()) { var r = this.getRawOrdinalNumber(t.value), i = this._ordinalMeta.categories[r]; return i == null ? "" : i + "" } }, e.prototype.count = function () { return this._extent[1] - this._extent[0] + 1 }, e.prototype.unionExtentFromData = function (t, r) { this.unionExtent(t.getApproximateExtent(r)) }, e.prototype.isInExtentRange = function (t) { return t = this._getTickNumber(t), this._extent[0] <= t && this._extent[1] >= t }, e.prototype.getOrdinalMeta = function () { return this._ordinalMeta }, e.prototype.calcNiceTicks = function () { }, e.prototype.calcNiceExtent = function () { }, e.type = "ordinal", e }(Uc); Uc.registerClass(Vre); const v3 = Vre; var Ef = lr, Hre = function (n) { te(e, n); function e() { var t = n !== null && n.apply(this, arguments) || this; return t.type = "interval", t._interval = 0, t._intervalPrecision = 2, t } return e.prototype.parse = function (t) { return t }, e.prototype.contain = function (t) { return _C(t, this._extent) }, e.prototype.normalize = function (t) { return bC(t, this._extent) }, e.prototype.scale = function (t) { return wC(t, this._extent) }, e.prototype.setExtent = function (t, r) { var i = this._extent; isNaN(t) || (i[0] = parseFloat(t)), isNaN(r) || (i[1] = parseFloat(r)) }, e.prototype.unionExtent = function (t) { var r = this._extent; t[0] < r[0] && (r[0] = t[0]), t[1] > r[1] && (r[1] = t[1]), this.setExtent(r[0], r[1]) }, e.prototype.getInterval = function () { return this._interval }, e.prototype.setInterval = function (t) { this._interval = t, this._niceExtent = this._extent.slice(), this._intervalPrecision = zre(t) }, e.prototype.getTicks = function (t) { var r = this._interval, i = this._extent, a = this._niceExtent, o = this._intervalPrecision, s = []; if (!r) return s; var l = 1e4; i[0] < a[0] && (t ? s.push({ value: Ef(a[0] - r, o) }) : s.push({ value: i[0] })); for (var c = a[0]; c <= a[1] && (s.push({ value: c }), c = Ef(c + r, o), c !== s[s.length - 1].value);)if (s.length > l) return []; var u = s.length ? s[s.length - 1].value : a[1]; return i[1] > u && (t ? s.push({ value: Ef(u + r, o) }) : s.push({ value: i[1] })), s }, e.prototype.getMinorTicks = function (t) { for (var r = this.getTicks(!0), i = [], a = this.getExtent(), o = 1; o < r.length; o++) { for (var s = r[o], l = r[o - 1], c = 0, u = [], d = s.value - l.value, f = d / t; c < t - 1;) { var h = Ef(l.value + (c + 1) * f); h > a[0] && h < a[1] && u.push(h), c++ } i.push(u) } return i }, e.prototype.getLabel = function (t, r) { if (t == null) return ""; var i = r && r.precision; i == null ? i = ol(t.value) || 0 : i === "auto" && (i = this._intervalPrecision); var a = Ef(t.value, i, !0); return vne(a) }, e.prototype.calcNiceTicks = function (t, r, i) { t = t || 5; var a = this._extent, o = a[1] - a[0]; if (isFinite(o)) { o < 0 && (o = -o, a.reverse()); var s = E7e(a, t, r, i); this._intervalPrecision = s.intervalPrecision, this._interval = s.interval, this._niceExtent = s.niceTickExtent } }, e.prototype.calcNiceExtent = function (t) { var r = this._extent; if (r[0] === r[1]) if (r[0] !== 0) { var i = Math.abs(r[0]); t.fixMax || (r[1] += i / 2), r[0] -= i / 2 } else r[1] = 1; var a = r[1] - r[0]; isFinite(a) || (r[0] = 0, r[1] = 1), this.calcNiceTicks(t.splitNumber, t.minInterval, t.maxInterval); var o = this._interval; t.fixMin || (r[0] = Ef(Math.floor(r[0] / o) * o)), t.fixMax || (r[1] = Ef(Math.ceil(r[1] / o) * o)) }, e.prototype.setNiceExtent = function (t, r) { this._niceExtent = [t, r] }, e.type = "interval", e }(Uc); Uc.registerClass(Hre); const Od = Hre; var Ure = typeof Float32Array < "u", O7e = Ure ? Float32Array : Array; function ll(n) { return ke(n) ? Ure ? new Float32Array(n) : n : new O7e(n) } var _I = "__ec_stack_"; function y3(n) { return n.get("stack") || _I + n.seriesIndex } function _3(n) { return n.dim + n.index } function D7e(n) { var e = [], t = n.axis, r = "axis0"; if (t.type === "category") { for (var i = t.getBandWidth(), a = 0; a < n.count; a++)e.push(rt({ bandWidth: i, axisKey: r, stackId: _I + a }, n)); for (var o = Kre(e), s = [], a = 0; a < n.count; a++) { var l = o[r][_I + a]; l.offsetCenter = l.offset + l.width / 2, s.push(l) } return s } } function Gre(n, e) { var t = []; return e.eachSeriesByType(n, function (r) { Zre(r) && t.push(r) }), t } function j7e(n) { var e = {}; $(n, function (l) { var c = l.coordinateSystem, u = c.getBaseAxis(); if (!(u.type !== "time" && u.type !== "value")) for (var d = l.getData(), f = u.dim + "_" + u.index, h = d.getDimensionIndex(d.mapDimension(u.dim)), p = d.getStore(), m = 0, g = p.count(); m < g; ++m) { var y = p.get(h, m); e[f] ? e[f].push(y) : e[f] = [y] } }); var t = {}; for (var r in e) if (e.hasOwnProperty(r)) { var i = e[r]; if (i) { i.sort(function (l, c) { return l - c }); for (var a = null, o = 1; o < i.length; ++o) { var s = i[o] - i[o - 1]; s > 0 && (a = a === null ? s : Math.min(a, s)) } t[r] = a } } return t } function Wre(n) { var e = j7e(n), t = []; return $(n, function (r) { var i = r.coordinateSystem, a = i.getBaseAxis(), o = a.getExtent(), s; if (a.type === "category") s = a.getBandWidth(); else if (a.type === "value" || a.type === "time") { var l = a.dim + "_" + a.index, c = e[l], u = Math.abs(o[1] - o[0]), d = a.scale.getExtent(), f = Math.abs(d[1] - d[0]); s = c ? u / f * c : u } else { var h = r.getData(); s = Math.abs(o[1] - o[0]) / h.count() } var p = Ne(r.get("barWidth"), s), m = Ne(r.get("barMaxWidth"), s), g = Ne(r.get("barMinWidth") || (Xre(r) ? .5 : 1), s), y = r.get("barGap"), b = r.get("barCategoryGap"); t.push({ bandWidth: s, barWidth: p, barMaxWidth: m, barMinWidth: g, barGap: y, barCategoryGap: b, axisKey: _3(a), stackId: y3(r) }) }), Kre(t) } function Kre(n) { var e = {}; $(n, function (r, i) { var a = r.axisKey, o = r.bandWidth, s = e[a] || { bandWidth: o, remainedWidth: o, autoWidthCount: 0, categoryGap: null, gap: "20%", stacks: {} }, l = s.stacks; e[a] = s; var c = r.stackId; l[c] || s.autoWidthCount++, l[c] = l[c] || { width: 0, maxWidth: 0 }; var u = r.barWidth; u && !l[c].width && (l[c].width = u, u = Math.min(s.remainedWidth, u), s.remainedWidth -= u); var d = r.barMaxWidth; d && (l[c].maxWidth = d); var f = r.barMinWidth; f && (l[c].minWidth = f); var h = r.barGap; h != null && (s.gap = h); var p = r.barCategoryGap; p != null && (s.categoryGap = p) }); var t = {}; return $(e, function (r, i) { t[i] = {}; var a = r.stacks, o = r.bandWidth, s = r.categoryGap; if (s == null) { var l = Bt(a).length; s = Math.max(35 - l * 4, 15) + "%" } var c = Ne(s, o), u = Ne(r.gap, 1), d = r.remainedWidth, f = r.autoWidthCount, h = (d - c) / (f + (f - 1) * u); h = Math.max(h, 0), $(a, function (y) { var b = y.maxWidth, w = y.minWidth; if (y.width) { var v = y.width; b && (v = Math.min(v, b)), w && (v = Math.max(v, w)), y.width = v, d -= v + u * v, f-- } else { var v = h; b && b < v && (v = Math.min(b, d)), w && w > v && (v = w), v !== h && (y.width = v, d -= v + u * v, f--) } }), h = (d - c) / (f + (f - 1) * u), h = Math.max(h, 0); var p = 0, m; $(a, function (y, b) { y.width || (y.width = h), m = y, p += y.width * (1 + u) }), m && (p -= m.width * u); var g = -p / 2; $(a, function (y, b) { t[i][b] = t[i][b] || { bandWidth: o, offset: g, width: y.width }, g += y.width * (1 + u) }) }), t } function P7e(n, e, t) { if (n && e) { var r = n[_3(e)]; return r != null && t != null ? r[y3(t)] : r } } function qre(n, e) { var t = Gre(n, e), r = Wre(t); $(t, function (i) { var a = i.getData(), o = i.coordinateSystem, s = o.getBaseAxis(), l = y3(i), c = r[_3(s)][l], u = c.offset, d = c.width; a.setLayout({ bandWidth: c.bandWidth, offset: u, size: d }) }) } function Yre(n) { return { seriesType: n, plan: iv(), reset: function (e) { if (Zre(e)) { var t = e.getData(), r = e.coordinateSystem, i = r.getBaseAxis(), a = r.getOtherAxis(i), o = t.getDimensionIndex(t.mapDimension(a.dim)), s = t.getDimensionIndex(t.mapDimension(i.dim)), l = e.get("showBackground", !0), c = t.mapDimension(a.dim), u = t.getCalculationInfo("stackResultDimension"), d = Md(t, c) && !!t.getCalculationInfo("stackedOnSeries"), f = a.isHorizontal(), h = I7e(i, a), p = Xre(e), m = e.get("barMinHeight") || 0, g = u && t.getDimensionIndex(u), y = t.getLayout("size"), b = t.getLayout("offset"); return { progress: function (w, v) { for (var S = w.count, x = p && ll(S * 3), k = p && l && ll(S * 3), A = p && ll(S), C = r.master.getRect(), E = f ? C.width : C.height, O, j = v.getStore(), I = 0; (O = w.next()) != null;) { var L = j.get(d ? g : o, O), R = j.get(s, O), D = h, P = void 0; d && (P = +L - j.get(o, O)); var B = void 0, F = void 0, K = void 0, V = void 0; if (f) { var W = r.dataToPoint([L, R]); if (d) { var J = r.dataToPoint([P, R]); D = J[0] } B = D, F = W[1] + b, K = W[0] - D, V = y, Math.abs(K) < m && (K = (K < 0 ? -1 : 1) * m) } else { var W = r.dataToPoint([R, L]); if (d) { var J = r.dataToPoint([R, P]); D = J[1] } B = W[0] + b, F = D, K = y, V = W[1] - D, Math.abs(V) < m && (V = (V <= 0 ? -1 : 1) * m) } p ? (x[I] = B, x[I + 1] = F, x[I + 2] = f ? K : V, k && (k[I] = f ? C.x : B, k[I + 1] = f ? F : C.y, k[I + 2] = E), A[O] = O) : v.setItemLayout(O, { x: B, y: F, width: K, height: V }), I += 3 } p && v.setLayout({ largePoints: x, largeDataIndices: A, largeBackgroundPoints: k, valueAxisHorizontal: f }) } } } } } } function Zre(n) { return n.coordinateSystem && n.coordinateSystem.type === "cartesian2d" } function Xre(n) { return n.pipelineContext && n.pipelineContext.large } function I7e(n, e) { var t = e.model.get("startValue"); return t || (t = 0), e.toGlobalCoord(e.dataToCoord(e.type === "log" ? t > 0 ? t : 1 : t)) } var L7e = function (n, e, t, r) { for (; t < r;) { var i = t + r >>> 1; n[i][1] < e ? t = i + 1 : r = i } return t }, Jre = function (n) { te(e, n); function e(t) { var r = n.call(this, t) || this; return r.type = "time", r } return e.prototype.getLabel = function (t) { var r = this.getSetting("useUTC"); return lC(t.value, VV[aVe(Zm(this._minLevelUnit))] || VV.second, r, this.getSetting("locale")) }, e.prototype.getFormattedLabel = function (t, r, i) { var a = this.getSetting("useUTC"), o = this.getSetting("locale"); return oVe(t, r, i, o, a) }, e.prototype.getTicks = function () { var t = this._interval, r = this._extent, i = []; if (!t) return i; i.push({ value: r[0], level: 0 }); var a = this.getSetting("useUTC"), o = V7e(this._minLevelUnit, this._approxInterval, a, r); return i = i.concat(o), i.push({ value: r[1], level: 0 }), i }, e.prototype.calcNiceExtent = function (t) { var r = this._extent; if (r[0] === r[1] && (r[0] -= Ao, r[1] += Ao), r[1] === -1 / 0 && r[0] === 1 / 0) { var i = new Date; r[1] = +new Date(i.getFullYear(), i.getMonth(), i.getDate()), r[0] = r[1] - Ao } this.calcNiceTicks(t.splitNumber, t.minInterval, t.maxInterval) }, e.prototype.calcNiceTicks = function (t, r, i) { t = t || 10; var a = this._extent, o = a[1] - a[0]; this._approxInterval = o / t, r != null && this._approxInterval < r && (this._approxInterval = r), i != null && this._approxInterval > i && (this._approxInterval = i); var s = Xw.length, l = Math.min(L7e(Xw, this._approxInterval, 0, s), s - 1); this._interval = Xw[l][1], this._minLevelUnit = Xw[Math.max(l - 1, 0)][0] }, e.prototype.parse = function (t) { return nn(t) ? t : +kl(t) }, e.prototype.contain = function (t) { return _C(this.parse(t), this._extent) }, e.prototype.normalize = function (t) { return bC(this.parse(t), this._extent) }, e.prototype.scale = function (t) { return wC(t, this._extent) }, e.type = "time", e }(Od), Xw = [["second", ZN], ["minute", XN], ["hour", v0], ["quarter-day", v0 * 6], ["half-day", v0 * 12], ["day", Ao * 1.2], ["half-week", Ao * 3.5], ["week", Ao * 7], ["month", Ao * 31], ["quarter", Ao * 95], ["half-year", zV / 2], ["year", zV]]; function R7e(n, e, t, r) { var i = kl(e), a = kl(t), o = function (p) { return HV(i, p, r) === HV(a, p, r) }, s = function () { return o("year") }, l = function () { return s() && o("month") }, c = function () { return l() && o("day") }, u = function () { return c() && o("hour") }, d = function () { return u() && o("minute") }, f = function () { return d() && o("second") }, h = function () { return f() && o("millisecond") }; switch (n) { case "year": return s(); case "month": return l(); case "day": return c(); case "hour": return u(); case "minute": return d(); case "second": return f(); case "millisecond": return h() } } function N7e(n, e) { return n /= Ao, n > 16 ? 16 : n > 7.5 ? 7 : n > 3.5 ? 4 : n > 1.5 ? 2 : 1 } function B7e(n) { var e = 30 * Ao; return n /= e, n > 6 ? 6 : n > 3 ? 3 : n > 2 ? 2 : 1 } function $7e(n) { return n /= v0, n > 12 ? 12 : n > 6 ? 6 : n > 3.5 ? 4 : n > 2 ? 2 : 1 } function QH(n, e) { return n /= e ? XN : ZN, n > 30 ? 30 : n > 20 ? 20 : n > 15 ? 15 : n > 10 ? 10 : n > 5 ? 5 : n > 2 ? 2 : 1 } function F7e(n) { return Jee(n, !0) } function z7e(n, e, t) { var r = new Date(n); switch (Zm(e)) { case "year": case "month": r[dne(t)](0); case "day": r[fne(t)](1); case "hour": r[hne(t)](0); case "minute": r[pne(t)](0); case "second": r[mne(t)](0), r[gne(t)](0) }return r.getTime() } function V7e(n, e, t, r) { var i = 1e4, a = cne, o = 0; function s(E, O, j, I, L, R, D) { for (var P = new Date(O), B = O, F = P[I](); B < j && B <= r[1];)D.push({ value: B }), F += E, P[L](F), B = P.getTime(); D.push({ value: B, notAdd: !0 }) } function l(E, O, j) { var I = [], L = !O.length; if (!R7e(Zm(E), r[0], r[1], t)) { L && (O = [{ value: z7e(new Date(r[0]), E, t) }, { value: r[1] }]); for (var R = 0; R < O.length - 1; R++) { var D = O[R].value, P = O[R + 1].value; if (D !== P) { var B = void 0, F = void 0, K = void 0, V = !1; switch (E) { case "year": B = Math.max(1, Math.round(e / Ao / 365)), F = JN(t), K = sVe(t); break; case "half-year": case "quarter": case "month": B = B7e(e), F = Xm(t), K = dne(t); break; case "week": case "half-week": case "day": B = N7e(e), F = cC(t), K = fne(t), V = !0; break; case "half-day": case "quarter-day": case "hour": B = $7e(e), F = b_(t), K = hne(t); break; case "minute": B = QH(e, !0), F = uC(t), K = pne(t); break; case "second": B = QH(e, !1), F = dC(t), K = mne(t); break; case "millisecond": B = F7e(e), F = fC(t), K = gne(t); break }s(B, D, P, F, K, V, I), E === "year" && j.length > 1 && R === 0 && j.unshift({ value: j[0].value - B }) } } for (var R = 0; R < I.length; R++)j.push(I[R]); return I } } for (var c = [], u = [], d = 0, f = 0, h = 0; h < a.length && o++ < i; ++h) { var p = Zm(a[h]); if (iVe(a[h])) { l(a[h], c[c.length - 1] || [], u); var m = a[h + 1] ? Zm(a[h + 1]) : null; if (p !== m) { if (u.length) { f = d, u.sort(function (E, O) { return E.value - O.value }); for (var g = [], y = 0; y < u.length; ++y) { var b = u[y].value; (y === 0 || u[y - 1].value !== b) && (g.push(u[y]), b >= r[0] && b <= r[1] && d++) } var w = (r[1] - r[0]) / e; if (d > w * 1.5 && f > w / 1.5 || (c.push(g), d > w || n === a[h])) break } u = [] } } } for (var v = pn(Ae(c, function (E) { return pn(E, function (O) { return O.value >= r[0] && O.value <= r[1] && !O.notAdd }) }), function (E) { return E.length > 0 }), S = [], x = v.length - 1, h = 0; h < v.length; ++h)for (var k = v[h], A = 0; A < k.length; ++A)S.push({ value: k[A].value, level: x - h }); S.sort(function (E, O) { return E.value - O.value }); for (var C = [], h = 0; h < S.length; ++h)(h === 0 || S[h].value !== S[h - 1].value) && C.push(S[h]); return C } Uc.registerClass(Jre); const Qre = Jre; var e9 = Uc.prototype, w0 = Od.prototype, H7e = lr, U7e = Math.floor, G7e = Math.ceil, Jw = Math.pow, Qo = Math.log, b3 = function (n) { te(e, n); function e() { var t = n !== null && n.apply(this, arguments) || this; return t.type = "log", t.base = 10, t._originalScale = new Od, t._interval = 0, t } return e.prototype.getTicks = function (t) { var r = this._originalScale, i = this._extent, a = r.getExtent(), o = w0.getTicks.call(this, t); return Ae(o, function (s) { var l = s.value, c = lr(Jw(this.base, l)); return c = l === i[0] && this._fixMin ? Qw(c, a[0]) : c, c = l === i[1] && this._fixMax ? Qw(c, a[1]) : c, { value: c } }, this) }, e.prototype.setExtent = function (t, r) { var i = Qo(this.base); t = Qo(Math.max(0, t)) / i, r = Qo(Math.max(0, r)) / i, w0.setExtent.call(this, t, r) }, e.prototype.getExtent = function () { var t = this.base, r = e9.getExtent.call(this); r[0] = Jw(t, r[0]), r[1] = Jw(t, r[1]); var i = this._originalScale, a = i.getExtent(); return this._fixMin && (r[0] = Qw(r[0], a[0])), this._fixMax && (r[1] = Qw(r[1], a[1])), r }, e.prototype.unionExtent = function (t) { this._originalScale.unionExtent(t); var r = this.base; t[0] = Qo(t[0]) / Qo(r), t[1] = Qo(t[1]) / Qo(r), e9.unionExtent.call(this, t) }, e.prototype.unionExtentFromData = function (t, r) { this.unionExtent(t.getApproximateExtent(r)) }, e.prototype.calcNiceTicks = function (t) { t = t || 10; var r = this._extent, i = r[1] - r[0]; if (!(i === 1 / 0 || i <= 0)) { var a = MFe(i), o = t / i * a; for (o <= .5 && (a *= 10); !isNaN(a) && Math.abs(a) < 1 && Math.abs(a) > 0;)a *= 10; var s = [lr(G7e(r[0] / a) * a), lr(U7e(r[1] / a) * a)]; this._interval = a, this._niceExtent = s } }, e.prototype.calcNiceExtent = function (t) { w0.calcNiceExtent.call(this, t), this._fixMin = t.fixMin, this._fixMax = t.fixMax }, e.prototype.parse = function (t) { return t }, e.prototype.contain = function (t) { return t = Qo(t) / Qo(this.base), _C(t, this._extent) }, e.prototype.normalize = function (t) { return t = Qo(t) / Qo(this.base), bC(t, this._extent) }, e.prototype.scale = function (t) { return t = wC(t, this._extent), Jw(this.base, t) }, e.type = "log", e }(Uc), eie = b3.prototype; eie.getMinorTicks = w0.getMinorTicks; eie.getLabel = w0.getLabel; function Qw(n, e) { return H7e(n, ol(e)) } Uc.registerClass(b3); const W7e = b3; var K7e = function () { function n(e, t, r) { this._prepareParams(e, t, r) } return n.prototype._prepareParams = function (e, t, r) { r[1] < r[0] && (r = [NaN, NaN]), this._dataMin = r[0], this._dataMax = r[1]; var i = this._isOrdinal = e.type === "ordinal"; this._needCrossZero = e.type === "interval" && t.getNeedCrossZero && t.getNeedCrossZero(); var a = t.get("min", !0); a == null && (a = t.get("startValue", !0)); var o = this._modelMinRaw = a; tt(o) ? this._modelMinNum = ex(e, o({ min: r[0], max: r[1] })) : o !== "dataMin" && (this._modelMinNum = ex(e, o)); var s = this._modelMaxRaw = t.get("max", !0); if (tt(s) ? this._modelMaxNum = ex(e, s({ min: r[0], max: r[1] })) : s !== "dataMax" && (this._modelMaxNum = ex(e, s)), i) this._axisDataLen = t.getCategories().length; else { var l = t.get("boundaryGap"), c = ke(l) ? l : [l || 0, l || 0]; typeof c[0] == "boolean" || typeof c[1] == "boolean" ? this._boundaryGapInner = [0, 0] : this._boundaryGapInner = [Es(c[0], 1), Es(c[1], 1)] } }, n.prototype.calculate = function () { var e = this._isOrdinal, t = this._dataMin, r = this._dataMax, i = this._axisDataLen, a = this._boundaryGapInner, o = e ? null : r - t || Math.abs(t), s = this._modelMinRaw === "dataMin" ? t : this._modelMinNum, l = this._modelMaxRaw === "dataMax" ? r : this._modelMaxNum, c = s != null, u = l != null; s == null && (s = e ? i ? 0 : NaN : t - a[0] * o), l == null && (l = e ? i ? i - 1 : NaN : r + a[1] * o), (s == null || !isFinite(s)) && (s = NaN), (l == null || !isFinite(l)) && (l = NaN); var d = c_(s) || c_(l) || e && !i; this._needCrossZero && (s > 0 && l > 0 && !c && (s = 0), s < 0 && l < 0 && !u && (l = 0)); var f = this._determinedMin, h = this._determinedMax; return f != null && (s = f, c = !0), h != null && (l = h, u = !0), { min: s, max: l, minFixed: c, maxFixed: u, isBlank: d } }, n.prototype.modifyDataMinMax = function (e, t) { this[Y7e[e]] = t }, n.prototype.setDeterminedMinMax = function (e, t) { var r = q7e[e]; this[r] = t }, n.prototype.freeze = function () { this.frozen = !0 }, n }(), q7e = { min: "_determinedMin", max: "_determinedMax" }, Y7e = { min: "_dataMin", max: "_dataMax" }; function tie(n, e, t) { var r = n.rawExtentInfo; return r || (r = new K7e(n, e, t), n.rawExtentInfo = r, r) } function ex(n, e) { return e == null ? null : c_(e) ? NaN : n.parse(e) } function nie(n, e) { var t = n.type, r = tie(n, e, n.getExtent()).calculate(); n.setBlank(r.isBlank); var i = r.min, a = r.max, o = e.ecModel; if (o && t === "time") { var s = Gre("bar", o), l = !1; if ($(s, function (d) { l = l || d.getBaseAxis() === e.axis }), l) { var c = Wre(s), u = Z7e(i, a, e, c); i = u.min, a = u.max } } return { extent: [i, a], fixMin: r.minFixed, fixMax: r.maxFixed } } function Z7e(n, e, t, r) { var i = t.axis.getExtent(), a = Math.abs(i[1] - i[0]), o = P7e(r, t.axis); if (o === void 0) return { min: n, max: e }; var s = 1 / 0; $(o, function (h) { s = Math.min(h.offset, s) }); var l = -1 / 0; $(o, function (h) { l = Math.max(h.offset + h.width, l) }), s = Math.abs(s), l = Math.abs(l); var c = s + l, u = e - n, d = 1 - (s + l) / a, f = u / d - u; return e += f * (l / c), n -= f * (s / c), { min: n, max: e } } function Eg(n, e) { var t = e, r = nie(n, t), i = r.extent, a = t.get("splitNumber"); n instanceof W7e && (n.base = t.get("logBase")); var o = n.type, s = t.get("interval"), l = o === "interval" || o === "time"; n.setExtent(i[0], i[1]), n.calcNiceExtent({ splitNumber: a, fixMin: r.fixMin, fixMax: r.fixMax, minInterval: l ? t.get("minInterval") : null, maxInterval: l ? t.get("maxInterval") : null }), s != null && n.setInterval && n.setInterval(s) } function xC(n, e) { if (e = e || n.get("type"), e) switch (e) { case "category": return new v3({ ordinalMeta: n.getOrdinalMeta ? n.getOrdinalMeta() : n.getCategories(), extent: [1 / 0, -1 / 0] }); case "time": return new Qre({ locale: n.ecModel.getLocaleModel(), useUTC: n.ecModel.get("useUTC") }); default: return new (Uc.getClass(e) || Od) } } function X7e(n) { var e = n.scale.getExtent(), t = e[0], r = e[1]; return !(t > 0 && r > 0 || t < 0 && r < 0) } function sv(n) { var e = n.getLabelModel().get("formatter"), t = n.type === "category" ? n.scale.getExtent()[0] : null; return n.scale.type === "time" ? function (r) { return function (i, a) { return n.scale.getFormattedLabel(i, a, r) } }(e) : Fe(e) ? function (r) { return function (i) { var a = n.scale.getLabel(i), o = r.replace("{value}", a ?? ""); return o } }(e) : tt(e) ? function (r) { return function (i, a) { return t != null && (a = i.value - t), r(w3(n, i), a, i.level != null ? { level: i.level } : null) } }(e) : function (r) { return n.scale.getLabel(r) } } function w3(n, e) { return n.type === "category" ? n.scale.getLabel(e) : e.value } function J7e(n) { var e = n.model, t = n.scale; if (!(!e.get(["axisLabel", "show"]) || t.isBlank())) { var r, i, a = t.getExtent(); t instanceof v3 ? i = t.count() : (r = t.getTicks(), i = r.length); var o = n.getLabelModel(), s = sv(n), l, c = 1; i > 40 && (c = Math.ceil(i / 40)); for (var u = 0; u < i; u += c) { var d = r ? r[u] : { value: a[0] + u }, f = s(d, u), h = o.getTextRect(f), p = Q7e(h, o.get("rotate") || 0); l ? l.union(p) : l = p } return l } } function Q7e(n, e) { var t = e * Math.PI / 180, r = n.width, i = n.height, a = r * Math.abs(Math.cos(t)) + Math.abs(i * Math.sin(t)), o = r * Math.abs(Math.sin(t)) + Math.abs(i * Math.cos(t)), s = new kt(n.x, n.y, a, o); return s } function x3(n) { var e = n.get("interval"); return e ?? "auto" } function rie(n) { return n.type === "category" && x3(n.getLabelModel()) === 0 } function fT(n, e) { var t = {}; return $(n.mapDimensionsAll(e), function (r) { t[$re(n, r)] = !0 }), Bt(t) } function eUe(n, e, t) { e && $(fT(e, t), function (r) { var i = e.getApproximateExtent(r); i[0] < n[0] && (n[0] = i[0]), i[1] > n[1] && (n[1] = i[1]) }) } var Mb = function () { function n() { } return n.prototype.getNeedCrossZero = function () { var e = this.option; return !e.scale }, n.prototype.getCoordSysModel = function () { }, n }(), tUe = 1e-8; function t9(n, e) { return Math.abs(n - e) < tUe } function Vf(n, e, t) { var r = 0, i = n[0]; if (!i) return !1; for (var a = 1; a < n.length; a++) { var o = n[a]; r += ac(i[0], i[1], o[0], o[1], e, t), i = o } var s = n[0]; return (!t9(i[0], s[0]) || !t9(i[1], s[1])) && (r += ac(i[0], i[1], s[0], s[1], e, t)), r !== 0 } var nUe = []; function lO(n, e) { for (var t = 0; t < n.length; t++)fi(n[t], n[t], e) } function n9(n, e, t, r) { for (var i = 0; i < n.length; i++) { var a = n[i]; r && (a = r.project(a)), a && isFinite(a[0]) && isFinite(a[1]) && (Uu(e, e, a), Gu(t, t, a)) } } function rUe(n) { for (var e = 0, t = 0, r = 0, i = n.length, a = n[i - 1][0], o = n[i - 1][1], s = 0; s < i; s++) { var l = n[s][0], c = n[s][1], u = a * c - l * o; e += u, t += (a + l) * u, r += (o + c) * u, a = l, o = c } return e ? [t / e / 3, r / e / 3, e] : [n[0][0] || 0, n[0][1] || 0] } var iie = function () { function n(e) { this.name = e } return n.prototype.setCenter = function (e) { this._center = e }, n.prototype.getCenter = function () { var e = this._center; return e || (e = this._center = this.calcCenter()), e }, n }(), r9 = function () { function n(e, t) { this.type = "polygon", this.exterior = e, this.interiors = t } return n }(), i9 = function () { function n(e) { this.type = "linestring", this.points = e } return n }(), aie = function (n) { te(e, n); function e(t, r, i) { var a = n.call(this, t) || this; return a.type = "geoJSON", a.geometries = r, a._center = i && [i[0], i[1]], a } return e.prototype.calcCenter = function () { for (var t = this.geometries, r, i = 0, a = 0; a < t.length; a++) { var o = t[a], s = o.exterior, l = s && s.length; l > i && (r = o, i = l) } if (r) return rUe(r.exterior); var c = this.getBoundingRect(); return [c.x + c.width / 2, c.y + c.height / 2] }, e.prototype.getBoundingRect = function (t) { var r = this._rect; if (r && !t) return r; var i = [1 / 0, 1 / 0], a = [-1 / 0, -1 / 0], o = this.geometries; return $(o, function (s) { s.type === "polygon" ? n9(s.exterior, i, a, t) : $(s.points, function (l) { n9(l, i, a, t) }) }), isFinite(i[0]) && isFinite(i[1]) && isFinite(a[0]) && isFinite(a[1]) || (i[0] = i[1] = a[0] = a[1] = 0), r = new kt(i[0], i[1], a[0] - i[0], a[1] - i[1]), t || (this._rect = r), r }, e.prototype.contain = function (t) { var r = this.getBoundingRect(), i = this.geometries; if (!r.contain(t[0], t[1])) return !1; e: for (var a = 0, o = i.length; a < o; a++) { var s = i[a]; if (s.type === "polygon") { var l = s.exterior, c = s.interiors; if (Vf(l, t[0], t[1])) { for (var u = 0; u < (c ? c.length : 0); u++)if (Vf(c[u], t[0], t[1])) continue e; return !0 } } } return !1 }, e.prototype.transformTo = function (t, r, i, a) { var o = this.getBoundingRect(), s = o.width / o.height; i ? a || (a = i / s) : i = s * a; for (var l = new kt(t, r, i, a), c = o.calculateTransform(l), u = this.geometries, d = 0; d < u.length; d++) { var f = u[d]; f.type === "polygon" ? (lO(f.exterior, c), $(f.interiors, function (h) { lO(h, c) })) : $(f.points, function (h) { lO(h, c) }) } o = this._rect, o.copy(l), this._center = [o.x + o.width / 2, o.y + o.height / 2] }, e.prototype.cloneShallow = function (t) { t == null && (t = this.name); var r = new e(t, this.geometries, this._center); return r._rect = this._rect, r.transformTo = null, r }, e }(iie), iUe = function (n) { te(e, n); function e(t, r) { var i = n.call(this, t) || this; return i.type = "geoSVG", i._elOnlyForCalculate = r, i } return e.prototype.calcCenter = function () { for (var t = this._elOnlyForCalculate, r = t.getBoundingRect(), i = [r.x + r.width / 2, r.y + r.height / 2], a = qk(nUe), o = t; o && !o.isGeoSVGGraphicRoot;)bc(a, o.getLocalTransform(), a), o = o.parent; return qg(a, a), fi(i, i, a), i }, e }(iie); function aUe(n) { if (!n.UTF8Encoding) return n; var e = n, t = e.UTF8Scale; t == null && (t = 1024); var r = e.features; return $(r, function (i) { var a = i.geometry, o = a.encodeOffsets, s = a.coordinates; if (o) switch (a.type) { case "LineString": a.coordinates = oie(s, o, t); break; case "Polygon": cO(s, o, t); break; case "MultiLineString": cO(s, o, t); break; case "MultiPolygon": $(s, function (l, c) { return cO(l, o[c], t) }) } }), e.UTF8Encoding = !1, e } function cO(n, e, t) { for (var r = 0; r < n.length; r++)n[r] = oie(n[r], e[r], t) } function oie(n, e, t) { for (var r = [], i = e[0], a = e[1], o = 0; o < n.length; o += 2) { var s = n.charCodeAt(o) - 64, l = n.charCodeAt(o + 1) - 64; s = s >> 1 ^ -(s & 1), l = l >> 1 ^ -(l & 1), s += i, l += a, i = s, a = l, r.push([s / t, l / t]) } return r } function oUe(n, e) { return n = aUe(n), Ae(pn(n.features, function (t) { return t.geometry && t.properties && t.geometry.coordinates.length > 0 }), function (t) { var r = t.properties, i = t.geometry, a = []; switch (i.type) { case "Polygon": var o = i.coordinates; a.push(new r9(o[0], o.slice(1))); break; case "MultiPolygon": $(i.coordinates, function (l) { l[0] && a.push(new r9(l[0], l.slice(1))) }); break; case "LineString": a.push(new i9([i.coordinates])); break; case "MultiLineString": a.push(new i9(i.coordinates)) }var s = new aie(r[e || "name"], a, r.cp); return s.properties = r, s }) } var C_ = Kt(); function sie(n, e) { var t = Ae(e, function (r) { return n.scale.parse(r) }); return n.type === "time" && t.length > 0 && (t.sort(), t.unshift(t[0]), t.push(t[t.length - 1])), t } function sUe(n) { var e = n.getLabelModel().get("customValues"); if (e) { var t = sv(n), r = n.scale.getExtent(), i = sie(n, e), a = pn(i, function (o) { return o >= r[0] && o <= r[1] }); return { labels: Ae(a, function (o) { var s = { value: o }; return { formattedLabel: t(s), rawLabel: n.scale.getLabel(s), tickValue: o } }) } } return n.type === "category" ? cUe(n) : dUe(n) } function lUe(n, e) { var t = n.getTickModel().get("customValues"); if (t) { var r = n.scale.getExtent(), i = sie(n, t); return { ticks: pn(i, function (a) { return a >= r[0] && a <= r[1] }) } } return n.type === "category" ? uUe(n, e) : { ticks: Ae(n.scale.getTicks(), function (a) { return a.value }) } } function cUe(n) { var e = n.getLabelModel(), t = lie(n, e); return !e.get("show") || n.scale.isBlank() ? { labels: [], labelCategoryInterval: t.labelCategoryInterval } : t } function lie(n, e) { var t = cie(n, "labels"), r = x3(e), i = uie(t, r); if (i) return i; var a, o; return tt(r) ? a = hie(n, r) : (o = r === "auto" ? fUe(n) : r, a = fie(n, o)), die(t, r, { labels: a, labelCategoryInterval: o }) } function uUe(n, e) { var t = cie(n, "ticks"), r = x3(e), i = uie(t, r); if (i) return i; var a, o; if ((!e.get("show") || n.scale.isBlank()) && (a = []), tt(r)) a = hie(n, r, !0); else if (r === "auto") { var s = lie(n, n.getLabelModel()); o = s.labelCategoryInterval, a = Ae(s.labels, function (l) { return l.tickValue }) } else o = r, a = fie(n, o, !0); return die(t, r, { ticks: a, tickCategoryInterval: o }) } function dUe(n) { var e = n.scale.getTicks(), t = sv(n); return { labels: Ae(e, function (r, i) { return { level: r.level, formattedLabel: t(r, i), rawLabel: n.scale.getLabel(r), tickValue: r.value } }) } } function cie(n, e) { return C_(n)[e] || (C_(n)[e] = []) } function uie(n, e) { for (var t = 0; t < n.length; t++)if (n[t].key === e) return n[t].value } function die(n, e, t) { return n.push({ key: e, value: t }), t } function fUe(n) { var e = C_(n).autoInterval; return e ?? (C_(n).autoInterval = n.calculateCategoryInterval()) } function hUe(n) { var e = pUe(n), t = sv(n), r = (e.axisRotate - e.labelRotate) / 180 * Math.PI, i = n.scale, a = i.getExtent(), o = i.count(); if (a[1] - a[0] < 1) return 0; var s = 1; o > 40 && (s = Math.max(1, Math.floor(o / 40))); for (var l = a[0], c = n.dataToCoord(l + 1) - n.dataToCoord(l), u = Math.abs(c * Math.cos(r)), d = Math.abs(c * Math.sin(r)), f = 0, h = 0; l <= a[1]; l += s) { var p = 0, m = 0, g = bb(t({ value: l }), e.font, "center", "top"); p = g.width * 1.3, m = g.height * 1.3, f = Math.max(f, p, 7), h = Math.max(h, m, 7) } var y = f / u, b = h / d; isNaN(y) && (y = 1 / 0), isNaN(b) && (b = 1 / 0); var w = Math.max(0, Math.floor(Math.min(y, b))), v = C_(n.model), S = n.getExtent(), x = v.lastAutoInterval, k = v.lastTickCount; return x != null && k != null && Math.abs(x - w) <= 1 && Math.abs(k - o) <= 1 && x > w && v.axisExtent0 === S[0] && v.axisExtent1 === S[1] ? w = x : (v.lastTickCount = o, v.lastAutoInterval = w, v.axisExtent0 = S[0], v.axisExtent1 = S[1]), w } function pUe(n) { var e = n.getLabelModel(); return { axisRotate: n.getRotate ? n.getRotate() : n.isHorizontal && !n.isHorizontal() ? 90 : 0, labelRotate: e.get("rotate") || 0, font: e.getFont() } } function fie(n, e, t) { var r = sv(n), i = n.scale, a = i.getExtent(), o = n.getLabelModel(), s = [], l = Math.max((e || 0) + 1, 1), c = a[0], u = i.count(); c !== 0 && l > 1 && u / l > 2 && (c = Math.round(Math.ceil(c / l) * l)); var d = rie(n), f = o.get("showMinLabel") || d, h = o.get("showMaxLabel") || d; f && c !== a[0] && m(a[0]); for (var p = c; p <= a[1]; p += l)m(p); h && p - l !== a[1] && m(a[1]); function m(g) { var y = { value: g }; s.push(t ? g : { formattedLabel: r(y), rawLabel: i.getLabel(y), tickValue: g }) } return s } function hie(n, e, t) { var r = n.scale, i = sv(n), a = []; return $(r.getTicks(), function (o) { var s = r.getLabel(o), l = o.value; e(o.value, s) && a.push(t ? l : { formattedLabel: i(o), rawLabel: s, tickValue: l }) }), a } var a9 = [0, 1], mUe = function () { function n(e, t, r) { this.onBand = !1, this.inverse = !1, this.dim = e, this.scale = t, this._extent = r || [0, 0] } return n.prototype.contain = function (e) { var t = this._extent, r = Math.min(t[0], t[1]), i = Math.max(t[0], t[1]); return e >= r && e <= i }, n.prototype.containData = function (e) { return this.scale.contain(e) }, n.prototype.getExtent = function () { return this._extent.slice() }, n.prototype.getPixelPrecision = function (e) { return Zee(e || this.scale.getExtent(), this._extent) }, n.prototype.setExtent = function (e, t) { var r = this._extent; r[0] = e, r[1] = t }, n.prototype.dataToCoord = function (e, t) { var r = this._extent, i = this.scale; return e = i.normalize(e), this.onBand && i.type === "ordinal" && (r = r.slice(), o9(r, i.count())), vn(e, a9, r, t) }, n.prototype.coordToData = function (e, t) { var r = this._extent, i = this.scale; this.onBand && i.type === "ordinal" && (r = r.slice(), o9(r, i.count())); var a = vn(e, r, a9, t); return this.scale.scale(a) }, n.prototype.pointToData = function (e, t) { }, n.prototype.getTicksCoords = function (e) { e = e || {}; var t = e.tickModel || this.getTickModel(), r = lUe(this, t), i = r.ticks, a = Ae(i, function (s) { return { coord: this.dataToCoord(this.scale.type === "ordinal" ? this.scale.getRawOrdinalNumber(s) : s), tickValue: s } }, this), o = t.get("alignWithLabel"); return gUe(this, a, o, e.clamp), a }, n.prototype.getMinorTicksCoords = function () { if (this.scale.type === "ordinal") return []; var e = this.model.getModel("minorTick"), t = e.get("splitNumber"); t > 0 && t < 100 || (t = 5); var r = this.scale.getMinorTicks(t), i = Ae(r, function (a) { return Ae(a, function (o) { return { coord: this.dataToCoord(o), tickValue: o } }, this) }, this); return i }, n.prototype.getViewLabels = function () { return sUe(this).labels }, n.prototype.getLabelModel = function () { return this.model.getModel("axisLabel") }, n.prototype.getTickModel = function () { return this.model.getModel("axisTick") }, n.prototype.getBandWidth = function () { var e = this._extent, t = this.scale.getExtent(), r = t[1] - t[0] + (this.onBand ? 1 : 0); r === 0 && (r = 1); var i = Math.abs(e[1] - e[0]); return Math.abs(i) / r }, n.prototype.calculateCategoryInterval = function () { return hUe(this) }, n }(); function o9(n, e) { var t = n[1] - n[0], r = e, i = t / r / 2; n[0] += i, n[1] -= i } function gUe(n, e, t, r) { var i = e.length; if (!n.onBand || t || !i) return; var a = n.getExtent(), o, s; if (i === 1) e[0].coord = a[0], o = e[1] = { coord: a[1], tickValue: e[0].tickValue }; else { var l = e[i - 1].tickValue - e[0].tickValue, c = (e[i - 1].coord - e[0].coord) / l; $(e, function (h) { h.coord -= c / 2 }); var u = n.scale.getExtent(); s = 1 + u[1] - e[i - 1].tickValue, o = { coord: e[i - 1].coord + c * s, tickValue: u[1] + 1 }, e.push(o) } var d = a[0] > a[1]; f(e[0].coord, a[0]) && (r ? e[0].coord = a[0] : e.shift()), r && f(a[0], e[0].coord) && e.unshift({ coord: a[0] }), f(a[1], o.coord) && (r ? o.coord = a[1] : e.pop()), r && f(o.coord, a[1]) && e.push({ coord: a[1] }); function f(h, p) { return h = lr(h), p = lr(p), d ? h > p : h < p } } const Ps = mUe; var iy = Math.PI * 2, Mf = Cl.CMD, vUe = ["top", "right", "bottom", "left"]; function yUe(n, e, t, r, i) { var a = t.width, o = t.height; switch (n) { case "top": r.set(t.x + a / 2, t.y - e), i.set(0, -1); break; case "bottom": r.set(t.x + a / 2, t.y + o + e), i.set(0, 1); break; case "left": r.set(t.x - e, t.y + o / 2), i.set(-1, 0); break; case "right": r.set(t.x + a + e, t.y + o / 2), i.set(1, 0); break } } function _Ue(n, e, t, r, i, a, o, s, l) { o -= n, s -= e; var c = Math.sqrt(o * o + s * s); o /= c, s /= c; var u = o * t + n, d = s * t + e; if (Math.abs(r - i) % iy < 1e-4) return l[0] = u, l[1] = d, c - t; if (a) { var f = r; r = $a(i), i = $a(f) } else r = $a(r), i = $a(i); r > i && (i += iy); var h = Math.atan2(s, o); if (h < 0 && (h += iy), h >= r && h <= i || h + iy >= r && h + iy <= i) return l[0] = u, l[1] = d, c - t; var p = t * Math.cos(r) + n, m = t * Math.sin(r) + e, g = t * Math.cos(i) + n, y = t * Math.sin(i) + e, b = (p - o) * (p - o) + (m - s) * (m - s), w = (g - o) * (g - o) + (y - s) * (y - s); return b < w ? (l[0] = p, l[1] = m, Math.sqrt(b)) : (l[0] = g, l[1] = y, Math.sqrt(w)) } function hT(n, e, t, r, i, a, o, s) { var l = i - n, c = a - e, u = t - n, d = r - e, f = Math.sqrt(u * u + d * d); u /= f, d /= f; var h = l * u + c * d, p = h / f; s && (p = Math.min(Math.max(p, 0), 1)), p *= f; var m = o[0] = n + p * u, g = o[1] = e + p * d; return Math.sqrt((m - i) * (m - i) + (g - a) * (g - a)) } function pie(n, e, t, r, i, a, o) { t < 0 && (n = n + t, t = -t), r < 0 && (e = e + r, r = -r); var s = n + t, l = e + r, c = o[0] = Math.min(Math.max(i, n), s), u = o[1] = Math.min(Math.max(a, e), l); return Math.sqrt((c - i) * (c - i) + (u - a) * (u - a)) } var ss = []; function bUe(n, e, t) { var r = pie(e.x, e.y, e.width, e.height, n.x, n.y, ss); return t.set(ss[0], ss[1]), r } function wUe(n, e, t) { for (var r = 0, i = 0, a = 0, o = 0, s, l, c = 1 / 0, u = e.data, d = n.x, f = n.y, h = 0; h < u.length;) { var p = u[h++]; h === 1 && (r = u[h], i = u[h + 1], a = r, o = i); var m = c; switch (p) { case Mf.M: a = u[h++], o = u[h++], r = a, i = o; break; case Mf.L: m = hT(r, i, u[h], u[h + 1], d, f, ss, !0), r = u[h++], i = u[h++]; break; case Mf.C: m = Oee(r, i, u[h++], u[h++], u[h++], u[h++], u[h], u[h + 1], d, f, ss), r = u[h++], i = u[h++]; break; case Mf.Q: m = jee(r, i, u[h++], u[h++], u[h], u[h + 1], d, f, ss), r = u[h++], i = u[h++]; break; case Mf.A: var g = u[h++], y = u[h++], b = u[h++], w = u[h++], v = u[h++], S = u[h++]; h += 1; var x = !!(1 - u[h++]); s = Math.cos(v) * b + g, l = Math.sin(v) * w + y, h <= 1 && (a = s, o = l); var k = (d - g) * w / b + g; m = _Ue(g, y, w, v, v + S, x, k, f, ss), r = Math.cos(v + S) * b + g, i = Math.sin(v + S) * w + y; break; case Mf.R: a = r = u[h++], o = i = u[h++]; var A = u[h++], C = u[h++]; m = pie(a, o, A, C, d, f, ss); break; case Mf.Z: m = hT(r, i, a, o, d, f, ss, !0), r = a, i = o; break }m < c && (c = m, t.set(ss[0], ss[1])) } return c } var ms = new St, In = new St, fr = new St, cl = new St, nl = new St; function s9(n, e) { if (n) { var t = n.getTextGuideLine(), r = n.getTextContent(); if (r && t) { var i = n.textGuideLineConfig || {}, a = [[0, 0], [0, 0], [0, 0]], o = i.candidates || vUe, s = r.getBoundingRect().clone(); s.applyTransform(r.getComputedTransform()); var l = 1 / 0, c = i.anchor, u = n.getComputedTransform(), d = u && qg([], u), f = e.get("length2") || 0; c && fr.copy(c); for (var h = 0; h < o.length; h++) { var p = o[h]; yUe(p, 0, s, ms, cl), St.scaleAndAdd(In, ms, cl, f), In.transform(d); var m = n.getBoundingRect(), g = c ? c.distance(In) : n instanceof Nt ? wUe(In, n.path, fr) : bUe(In, m, fr); g < l && (l = g, In.transform(u), fr.transform(u), fr.toArray(a[0]), In.toArray(a[1]), ms.toArray(a[2])) } mie(a, e.get("minTurnAngle")), t.setShape({ points: a }) } } } var pT = [], qi = new St; function mie(n, e) { if (e <= 180 && e > 0) { e = e / 180 * Math.PI, ms.fromArray(n[0]), In.fromArray(n[1]), fr.fromArray(n[2]), St.sub(cl, ms, In), St.sub(nl, fr, In); var t = cl.len(), r = nl.len(); if (!(t < .001 || r < .001)) { cl.scale(1 / t), nl.scale(1 / r); var i = cl.dot(nl), a = Math.cos(e); if (a < i) { var o = hT(In.x, In.y, fr.x, fr.y, ms.x, ms.y, pT, !1); qi.fromArray(pT), qi.scaleAndAdd(nl, o / Math.tan(Math.PI - e)); var s = fr.x !== In.x ? (qi.x - In.x) / (fr.x - In.x) : (qi.y - In.y) / (fr.y - In.y); if (isNaN(s)) return; s < 0 ? St.copy(qi, In) : s > 1 && St.copy(qi, fr), qi.toArray(n[1]) } } } } function xUe(n, e, t) { if (t <= 180 && t > 0) { t = t / 180 * Math.PI, ms.fromArray(n[0]), In.fromArray(n[1]), fr.fromArray(n[2]), St.sub(cl, In, ms), St.sub(nl, fr, In); var r = cl.len(), i = nl.len(); if (!(r < .001 || i < .001)) { cl.scale(1 / r), nl.scale(1 / i); var a = cl.dot(e), o = Math.cos(t); if (a < o) { var s = hT(In.x, In.y, fr.x, fr.y, ms.x, ms.y, pT, !1); qi.fromArray(pT); var l = Math.PI / 2, c = Math.acos(nl.dot(e)), u = l + c - t; if (u >= l) St.copy(qi, fr); else { qi.scaleAndAdd(nl, s / Math.tan(Math.PI / 2 - u)); var d = fr.x !== In.x ? (qi.x - In.x) / (fr.x - In.x) : (qi.y - In.y) / (fr.y - In.y); if (isNaN(d)) return; d < 0 ? St.copy(qi, In) : d > 1 && St.copy(qi, fr) } qi.toArray(n[1]) } } } } function uO(n, e, t, r) { var i = t === "normal", a = i ? n : n.ensureState(t); a.ignore = e; var o = r.get("smooth"); o && o === !0 && (o = .3), a.shape = a.shape || {}, o > 0 && (a.shape.smooth = o); var s = r.getModel("lineStyle").getLineStyle(); i ? n.useStyle(s) : a.style = s } function SUe(n, e) { var t = e.smooth, r = e.points; if (r) if (n.moveTo(r[0][0], r[0][1]), t > 0 && r.length >= 3) { var i = Hu(r[0], r[1]), a = Hu(r[1], r[2]); if (!i || !a) { n.lineTo(r[1][0], r[1][1]), n.lineTo(r[2][0], r[2][1]); return } var o = Math.min(i, a) * t, s = qx([], r[1], r[0], o / i), l = qx([], r[1], r[2], o / a), c = qx([], s, l, .5); n.bezierCurveTo(s[0], s[1], s[0], s[1], c[0], c[1]), n.bezierCurveTo(l[0], l[1], l[0], l[1], r[2][0], r[2][1]) } else for (var u = 1; u < r.length; u++)n.lineTo(r[u][0], r[u][1]) } function S3(n, e, t) { var r = n.getTextGuideLine(), i = n.getTextContent(); if (!i) { r && n.removeTextGuideLine(); return } for (var a = e.normal, o = a.get("show"), s = i.ignore, l = 0; l < v_.length; l++) { var c = v_[l], u = e[c], d = c === "normal"; if (u) { var f = u.get("show"), h = d ? s : yt(i.states[c] && i.states[c].ignore, s); if (h || !yt(f, o)) { var p = d ? r : r && r.states[c]; p && (p.ignore = !0), r && uO(r, !0, c, u); continue } r || (r = new Ea, n.setTextGuideLine(r), !d && (s || !o) && uO(r, !0, "normal", e.normal), n.stateProxy && (r.stateProxy = n.stateProxy)), uO(r, !1, c, u) } } if (r) { rt(r.style, t), r.style.fill = null; var m = a.get("showAbove"), g = n.textGuideLineConfig = n.textGuideLineConfig || {}; g.showAbove = m || !1, r.buildPath = SUe } } function T3(n, e) { e = e || "labelLine"; for (var t = { normal: n.getModel(e) }, r = 0; r < ra.length; r++) { var i = ra[r]; t[i] = n.getModel([i, e]) } return t } function gie(n) { for (var e = [], t = 0; t < n.length; t++) { var r = n[t]; if (!r.defaultAttr.ignore) { var i = r.label, a = i.getComputedTransform(), o = i.getBoundingRect(), s = !a || a[1] < 1e-5 && a[2] < 1e-5, l = i.style.margin || 0, c = o.clone(); c.applyTransform(a), c.x -= l / 2, c.y -= l / 2, c.width += l, c.height += l; var u = s ? new J2(o, a) : null; e.push({ label: i, labelLine: r.labelLine, rect: c, localRect: o, obb: u, priority: r.priority, defaultAttr: r.defaultAttr, layoutOption: r.computedLayoutOption, axisAligned: s, transform: a }) } } return e } function vie(n, e, t, r, i, a) { var o = n.length; if (o < 2) return; n.sort(function (A, C) { return A.rect[e] - C.rect[e] }); for (var s = 0, l, c = !1, u = 0, d = 0; d < o; d++) { var f = n[d], h = f.rect; l = h[e] - s, l < 0 && (h[e] -= l, f.label[e] -= l, c = !0); var p = Math.max(-l, 0); u += p, s = h[e] + h[t] } u > 0 && a && S(-u / o, 0, o); var m = n[0], g = n[o - 1], y, b; w(), y < 0 && x(-y, .8), b < 0 && x(b, .8), w(), v(y, b, 1), v(b, y, -1), w(), y < 0 && k(-y), b < 0 && k(b); function w() { y = m.rect[e] - r, b = i - g.rect[e] - g.rect[t] } function v(A, C, E) { if (A < 0) { var O = Math.min(C, -A); if (O > 0) { S(O * E, 0, o); var j = O + A; j < 0 && x(-j * E, 1) } else x(-A * E, 1) } } function S(A, C, E) { A !== 0 && (c = !0); for (var O = C; O < E; O++) { var j = n[O], I = j.rect; I[e] += A, j.label[e] += A } } function x(A, C) { for (var E = [], O = 0, j = 1; j < o; j++) { var I = n[j - 1].rect, L = Math.max(n[j].rect[e] - I[e] - I[t], 0); E.push(L), O += L } if (O) { var R = Math.min(Math.abs(A) / O, C); if (A > 0) for (var j = 0; j < o - 1; j++) { var D = E[j] * R; S(D, 0, j + 1) } else for (var j = o - 1; j > 0; j--) { var D = E[j - 1] * R; S(-D, j, o) } } } function k(A) { var C = A < 0 ? -1 : 1; A = Math.abs(A); for (var E = Math.ceil(A / (o - 1)), O = 0; O < o - 1; O++)if (C > 0 ? S(E, 0, O + 1) : S(-E, o - O - 1, o), A -= E, A <= 0) return } return c } function TUe(n, e, t, r) { return vie(n, "x", "width", e, t, r) } function yie(n, e, t, r) { return vie(n, "y", "height", e, t, r) } function _ie(n) { var e = []; n.sort(function (m, g) { return g.priority - m.priority }); var t = new kt(0, 0, 0, 0); function r(m) { if (!m.ignore) { var g = m.ensureState("emphasis"); g.ignore == null && (g.ignore = !1) } m.ignore = !0 } for (var i = 0; i < n.length; i++) { var a = n[i], o = a.axisAligned, s = a.localRect, l = a.transform, c = a.label, u = a.labelLine; t.copy(a.rect), t.width -= .1, t.height -= .1, t.x += .05, t.y += .05; for (var d = a.obb, f = !1, h = 0; h < e.length; h++) { var p = e[h]; if (t.intersect(p.rect)) { if (o && p.axisAligned) { f = !0; break } if (p.obb || (p.obb = new J2(p.localRect, p.transform)), d || (d = new J2(s, l)), d.intersect(p.obb)) { f = !0; break } } } f ? (r(c), u && r(u)) : (c.attr("ignore", a.defaultAttr.ignore), u && u.attr("ignore", a.defaultAttr.labelGuideIgnore), e.push(a)) } } function kUe(n) { if (n) { for (var e = [], t = 0; t < n.length; t++)e.push(n[t].slice()); return e } } function CUe(n, e) { var t = n.label, r = e && e.getTextGuideLine(); return { dataIndex: n.dataIndex, dataType: n.dataType, seriesIndex: n.seriesModel.seriesIndex, text: n.label.style.text, rect: n.hostRect, labelRect: n.rect, align: t.style.align, verticalAlign: t.style.verticalAlign, labelLinePoints: kUe(r && r.shape.points) } } var l9 = ["align", "verticalAlign", "width", "height", "fontSize"], Vi = new mc, dO = Kt(), AUe = Kt(); function tx(n, e, t) { for (var r = 0; r < t.length; r++) { var i = t[r]; e[i] != null && (n[i] = e[i]) } } var nx = ["x", "y", "rotation"], EUe = function () { function n() { this._labelList = [], this._chartViewList = [] } return n.prototype.clearLabels = function () { this._labelList = [], this._chartViewList = [] }, n.prototype._addLabel = function (e, t, r, i, a) { var o = i.style, s = i.__hostTarget, l = s.textConfig || {}, c = i.getComputedTransform(), u = i.getBoundingRect().plain(); kt.applyTransform(u, u, c), c ? Vi.setLocalTransform(c) : (Vi.x = Vi.y = Vi.rotation = Vi.originX = Vi.originY = 0, Vi.scaleX = Vi.scaleY = 1), Vi.rotation = $a(Vi.rotation); var d = i.__hostTarget, f; if (d) { f = d.getBoundingRect().plain(); var h = d.getComputedTransform(); kt.applyTransform(f, f, h) } var p = f && d.getTextGuideLine(); this._labelList.push({ label: i, labelLine: p, seriesModel: r, dataIndex: e, dataType: t, layoutOption: a, computedLayoutOption: null, rect: u, hostRect: f, priority: f ? f.width * f.height : 0, defaultAttr: { ignore: i.ignore, labelGuideIgnore: p && p.ignore, x: Vi.x, y: Vi.y, scaleX: Vi.scaleX, scaleY: Vi.scaleY, rotation: Vi.rotation, style: { x: o.x, y: o.y, align: o.align, verticalAlign: o.verticalAlign, width: o.width, height: o.height, fontSize: o.fontSize }, cursor: i.cursor, attachedPos: l.position, attachedRot: l.rotation } }) }, n.prototype.addLabelsOfSeries = function (e) { var t = this; this._chartViewList.push(e); var r = e.__model, i = r.get("labelLayout"); (tt(i) || Bt(i).length) && e.group.traverse(function (a) { if (a.ignore) return !0; var o = a.getTextContent(), s = pt(a); o && !o.disableLabelLayout && t._addLabel(s.dataIndex, s.dataType, r, o, i) }) }, n.prototype.updateLayoutConfig = function (e) { var t = e.getWidth(), r = e.getHeight(); function i(w, v) { return function () { s9(w, v) } } for (var a = 0; a < this._labelList.length; a++) { var o = this._labelList[a], s = o.label, l = s.__hostTarget, c = o.defaultAttr, u = void 0; tt(o.layoutOption) ? u = o.layoutOption(CUe(o, l)) : u = o.layoutOption, u = u || {}, o.computedLayoutOption = u; var d = Math.PI / 180; l && l.setTextConfig({ local: !1, position: u.x != null || u.y != null ? null : c.attachedPos, rotation: u.rotate != null ? u.rotate * d : c.attachedRot, offset: [u.dx || 0, u.dy || 0] }); var f = !1; if (u.x != null ? (s.x = Ne(u.x, t), s.setStyle("x", 0), f = !0) : (s.x = c.x, s.setStyle("x", c.style.x)), u.y != null ? (s.y = Ne(u.y, r), s.setStyle("y", 0), f = !0) : (s.y = c.y, s.setStyle("y", c.style.y)), u.labelLinePoints) { var h = l.getTextGuideLine(); h && (h.setShape({ points: u.labelLinePoints }), f = !1) } var p = dO(s); p.needsUpdateLabelLine = f, s.rotation = u.rotate != null ? u.rotate * d : c.rotation, s.scaleX = c.scaleX, s.scaleY = c.scaleY; for (var m = 0; m < l9.length; m++) { var g = l9[m]; s.setStyle(g, u[g] != null ? u[g] : c.style[g]) } if (u.draggable) { if (s.draggable = !0, s.cursor = "move", l) { var y = o.seriesModel; if (o.dataIndex != null) { var b = o.seriesModel.getData(o.dataType); y = b.getItemModel(o.dataIndex) } s.on("drag", i(l, y.getModel("labelLine"))) } } else s.off("drag"), s.cursor = c.cursor } }, n.prototype.layout = function (e) { var t = e.getWidth(), r = e.getHeight(), i = gie(this._labelList), a = pn(i, function (l) { return l.layoutOption.moveOverlap === "shiftX" }), o = pn(i, function (l) { return l.layoutOption.moveOverlap === "shiftY" }); TUe(a, 0, t), yie(o, 0, r); var s = pn(i, function (l) { return l.layoutOption.hideOverlap }); _ie(s) }, n.prototype.processLabelsOverall = function () { var e = this; $(this._chartViewList, function (t) { var r = t.__model, i = t.ignoreLabelLineUpdate, a = r.isAnimationEnabled(); t.group.traverse(function (o) { if (o.ignore && !o.forceLabelAnimation) return !0; var s = !i, l = o.getTextContent(); !s && l && (s = dO(l).needsUpdateLabelLine), s && e._updateLabelLine(o, r), a && e._animateLabels(o, r) }) }) }, n.prototype._updateLabelLine = function (e, t) { var r = e.getTextContent(), i = pt(e), a = i.dataIndex; if (r && a != null) { var o = t.getData(i.dataType), s = o.getItemModel(a), l = {}, c = o.getItemVisual(a, "style"); if (c) { var u = o.getVisual("drawType"); l.stroke = c[u] } var d = s.getModel("labelLine"); S3(e, T3(s), l), s9(e, d) } }, n.prototype._animateLabels = function (e, t) { var r = e.getTextContent(), i = e.getTextGuideLine(); if (r && (e.forceLabelAnimation || !r.ignore && !r.invisible && !e.disableLabelAnimation && !qm(e))) { var a = dO(r), o = a.oldLayout, s = pt(e), l = s.dataIndex, c = { x: r.x, y: r.y, rotation: r.rotation }, u = t.getData(s.dataType); if (o) { r.attr(o); var f = e.prevStates; f && (Et(f, "select") >= 0 && r.attr(a.oldLayoutSelect), Et(f, "emphasis") >= 0 && r.attr(a.oldLayoutEmphasis)), on(r, c, t, l) } else if (r.attr(c), !Jg(r).valueAnimation) { var d = yt(r.style.opacity, 1); r.style.opacity = 0, Un(r, { style: { opacity: d } }, t, l) } if (a.oldLayout = c, r.states.select) { var h = a.oldLayoutSelect = {}; tx(h, c, nx), tx(h, r.states.select, nx) } if (r.states.emphasis) { var p = a.oldLayoutEmphasis = {}; tx(p, c, nx), tx(p, r.states.emphasis, nx) } ine(r, l, u, t, t) } if (i && !i.ignore && !i.invisible) { var a = AUe(i), o = a.oldLayout, m = { points: i.shape.points }; o ? (i.attr({ shape: o }), on(i, { shape: m }, t)) : (i.setShape(m), i.style.strokePercent = 0, Un(i, { style: { strokePercent: 1 } }, t)), a.oldLayout = m } }, n }(); const MUe = EUe; var fO = Kt(); function OUe(n) { n.registerUpdateLifecycle("series:beforeupdate", function (e, t, r) { var i = fO(t).labelManager; i || (i = fO(t).labelManager = new MUe), i.clearLabels() }), n.registerUpdateLifecycle("series:layoutlabels", function (e, t, r) { var i = fO(t).labelManager; r.updatedSeries.forEach(function (a) { i.addLabelsOfSeries(t.getViewOfSeriesModel(a)) }), i.updateLayoutConfig(t), i.layout(t), i.processLabelsOverall() }) } var hO = Math.sin, pO = Math.cos, bie = Math.PI, Of = Math.PI * 2, DUe = 180 / bie, jUe = function () { function n() { } return n.prototype.reset = function (e) { this._start = !0, this._d = [], this._str = "", this._p = Math.pow(10, e || 4) }, n.prototype.moveTo = function (e, t) { this._add("M", e, t) }, n.prototype.lineTo = function (e, t) { this._add("L", e, t) }, n.prototype.bezierCurveTo = function (e, t, r, i, a, o) { this._add("C", e, t, r, i, a, o) }, n.prototype.quadraticCurveTo = function (e, t, r, i) { this._add("Q", e, t, r, i) }, n.prototype.arc = function (e, t, r, i, a, o) { this.ellipse(e, t, r, r, 0, i, a, o) }, n.prototype.ellipse = function (e, t, r, i, a, o, s, l) { var c = s - o, u = !l, d = Math.abs(c), f = qu(d - Of) || (u ? c >= Of : -c >= Of), h = c > 0 ? c % Of : c % Of + Of, p = !1; f ? p = !0 : qu(d) ? p = !1 : p = h >= bie == !!u; var m = e + r * pO(o), g = t + i * hO(o); this._start && this._add("M", m, g); var y = Math.round(a * DUe); if (f) { var b = 1 / this._p, w = (u ? 1 : -1) * (Of - b); this._add("A", r, i, y, 1, +u, e + r * pO(o + w), t + i * hO(o + w)), b > .01 && this._add("A", r, i, y, 0, +u, m, g) } else { var v = e + r * pO(s), S = t + i * hO(s); this._add("A", r, i, y, +p, +u, v, S) } }, n.prototype.rect = function (e, t, r, i) { this._add("M", e, t), this._add("l", r, 0), this._add("l", 0, i), this._add("l", -r, 0), this._add("Z") }, n.prototype.closePath = function () { this._d.length > 0 && this._add("Z") }, n.prototype._add = function (e, t, r, i, a, o, s, l, c) { for (var u = [], d = this._p, f = 1; f < arguments.length; f++) { var h = arguments[f]; if (isNaN(h)) { this._invalid = !0; return } u.push(Math.round(h * d) / d) } this._d.push(e + u.join(" ")), this._start = e === "Z" }, n.prototype.generateStr = function () { this._str = this._invalid ? "" : this._d.join(""), this._d = [] }, n.prototype.getStr = function () { return this._str }, n }(); const wie = jUe; var x0 = "none", PUe = Math.round; function IUe(n) { var e = n.fill; return e != null && e !== x0 } function LUe(n) { var e = n.stroke; return e != null && e !== x0 } var bI = ["lineCap", "miterLimit", "lineJoin"], RUe = Ae(bI, function (n) { return "stroke-" + n.toLowerCase() }); function NUe(n, e, t, r) { var i = e.opacity == null ? 1 : e.opacity; if (t instanceof gi) { n("opacity", i); return } if (IUe(e)) { var a = h_(e.fill); n("fill", a.color); var o = e.fillOpacity != null ? e.fillOpacity * a.opacity * i : a.opacity * i; (r || o < 1) && n("fill-opacity", o) } else n("fill", x0); if (LUe(e)) { var s = h_(e.stroke); n("stroke", s.color); var l = e.strokeNoScale ? t.getLineScale() : 1, c = l ? (e.lineWidth || 0) / l : 0, u = e.strokeOpacity != null ? e.strokeOpacity * s.opacity * i : s.opacity * i, d = e.strokeFirst; if ((r || c !== 1) && n("stroke-width", c), (r || d) && n("paint-order", d ? "stroke" : "fill"), (r || u < 1) && n("stroke-opacity", u), e.lineDash) { var f = d3(t), h = f[0], p = f[1]; h && (p = PUe(p || 0), n("stroke-dasharray", h.join(",")), (p || r) && n("stroke-dashoffset", p)) } else r && n("stroke-dasharray", x0); for (var m = 0; m < bI.length; m++) { var g = bI[m]; if (r || e[g] !== Z2[g]) { var y = e[g] || Z2[g]; y && n(RUe[m], y) } } } else r && n("stroke", x0) } var xie = "http://www.w3.org/2000/svg", Sie = "http://www.w3.org/1999/xlink", BUe = "http://www.w3.org/2000/xmlns/", $Ue = "http://www.w3.org/XML/1998/namespace", c9 = "ecmeta_"; function Tie(n) { return document.createElementNS(xie, n) } function Vr(n, e, t, r, i) { return { tag: n, attrs: t || {}, children: r, text: i, key: e } } function FUe(n, e) { var t = []; if (e) for (var r in e) { var i = e[r], a = r; i !== !1 && (i !== !0 && i != null && (a += '="' + i + '"'), t.push(a)) } return "<" + n + " " + t.join(" ") + ">" } function zUe(n) { return "</" + n + ">" } function k3(n, e) {
  e = e || {}; var t = e.newline ? `
`: ""; function r(i) { var a = i.children, o = i.tag, s = i.attrs, l = i.text; return FUe(o, s) + (o !== "style" ? Ai(l) : l || "") + (a ? "" + t + Ae(a, function (c) { return r(c) }).join(t) + t : "") + zUe(o) } return r(n)
} function VUe(n, e, t) {
  t = t || {}; var r = t.newline ? `
`: "", i = " {" + r, a = r + "}", o = Ae(Bt(n), function (l) { return l + i + Ae(Bt(n[l]), function (c) { return c + ":" + n[l][c] + ";" }).join(r) + a }).join(r), s = Ae(Bt(e), function (l) { return "@keyframes " + l + i + Ae(Bt(e[l]), function (c) { return c + i + Ae(Bt(e[l][c]), function (u) { var d = e[l][c][u]; return u === "d" && (d = 'path("' + d + '")'), u + ":" + d + ";" }).join(r) + a }).join(r) + a }).join(r); return !o && !s ? "" : ["<![CDATA[", o, s, "]]>"].join(r)
} function wI(n) { return { zrId: n, shadowCache: {}, patternCache: {}, gradientCache: {}, clipPathCache: {}, defs: {}, cssNodes: {}, cssAnims: {}, cssStyleCache: {}, cssAnimIdx: 0, shadowIdx: 0, gradientIdx: 0, patternIdx: 0, clipPathIdx: 0 } } function u9(n, e, t, r) { return Vr("svg", "root", { width: n, height: e, xmlns: xie, "xmlns:xlink": Sie, version: "1.1", baseProfile: "full", viewBox: r ? "0 0 " + n + " " + e : !1 }, t) } var HUe = 0; function kie() { return HUe++ } var d9 = { cubicIn: "0.32,0,0.67,0", cubicOut: "0.33,1,0.68,1", cubicInOut: "0.65,0,0.35,1", quadraticIn: "0.11,0,0.5,0", quadraticOut: "0.5,1,0.89,1", quadraticInOut: "0.45,0,0.55,1", quarticIn: "0.5,0,0.75,0", quarticOut: "0.25,1,0.5,1", quarticInOut: "0.76,0,0.24,1", quinticIn: "0.64,0,0.78,0", quinticOut: "0.22,1,0.36,1", quinticInOut: "0.83,0,0.17,1", sinusoidalIn: "0.12,0,0.39,0", sinusoidalOut: "0.61,1,0.88,1", sinusoidalInOut: "0.37,0,0.63,1", exponentialIn: "0.7,0,0.84,0", exponentialOut: "0.16,1,0.3,1", exponentialInOut: "0.87,0,0.13,1", circularIn: "0.55,0,1,0.45", circularOut: "0,0.55,0.45,1", circularInOut: "0.85,0,0.15,1" }, If = "transform-origin"; function UUe(n, e, t) { var r = be({}, n.shape); be(r, e), n.buildPath(t, r); var i = new wie; return i.reset($ee(n)), t.rebuildPath(i, 1), i.generateStr(), i.getStr() } function GUe(n, e) { var t = e.originX, r = e.originY; (t || r) && (n[If] = t + "px " + r + "px") } var WUe = { fill: "fill", opacity: "opacity", lineWidth: "stroke-width", lineDashOffset: "stroke-dashoffset" }; function Cie(n, e) { var t = e.zrId + "-ani-" + e.cssAnimIdx++; return e.cssAnims[t] = n, t } function KUe(n, e, t) { var r = n.shape.paths, i = {}, a, o; if ($(r, function (l) { var c = wI(t.zrId); c.animation = !0, SC(l, {}, c, !0); var u = c.cssAnims, d = c.cssNodes, f = Bt(u), h = f.length; if (h) { o = f[h - 1]; var p = u[o]; for (var m in p) { var g = p[m]; i[m] = i[m] || { d: "" }, i[m].d += g.d || "" } for (var y in d) { var b = d[y].animation; b.indexOf(o) >= 0 && (a = b) } } }), !!a) { e.d = !1; var s = Cie(i, t); return a.replace(o, s) } } function f9(n) { return Fe(n) ? d9[n] ? "cubic-bezier(" + d9[n] + ")" : CN(n) ? n : "" : "" } function SC(n, e, t, r) { var i = n.animators, a = i.length, o = []; if (n instanceof UN) { var s = KUe(n, e, t); if (s) o.push(s); else if (!a) return } else if (!a) return; for (var l = {}, c = 0; c < a; c++) { var u = i[c], d = [u.getMaxTime() / 1e3 + "s"], f = f9(u.getClip().easing), h = u.getDelay(); f ? d.push(f) : d.push("linear"), h && d.push(h / 1e3 + "s"), u.getLoop() && d.push("infinite"); var p = d.join(" "); l[p] = l[p] || [p, []], l[p][1].push(u) } function m(b) { var w = b[1], v = w.length, S = {}, x = {}, k = {}, A = "animation-timing-function"; function C(pe, se, ge) { for (var _e = pe.getTracks(), je = pe.getMaxTime(), U = 0; U < _e.length; U++) { var q = _e[U]; if (q.needsAnimate()) { var ee = q.keyframes, de = q.propName; if (ge && (de = ge(de)), de) for (var me = 0; me < ee.length; me++) { var fe = ee[me], we = Math.round(fe.time / je * 100) + "%", Oe = f9(fe.easing), ve = fe.rawValue; (Fe(ve) || nn(ve)) && (se[we] = se[we] || {}, se[we][de] = fe.rawValue, Oe && (se[we][A] = Oe)) } } } } for (var E = 0; E < v; E++) { var O = w[E], j = O.targetName; j ? j === "shape" && C(O, x) : !r && C(O, S) } for (var I in S) { var L = {}; Uee(L, n), be(L, S[I]); var R = Fee(L), D = S[I][A]; k[I] = R ? { transform: R } : {}, GUe(k[I], L), D && (k[I][A] = D) } var P, B = !0; for (var I in x) { k[I] = k[I] || {}; var F = !P, D = x[I][A]; F && (P = new Cl); var K = P.len(); P.reset(), k[I].d = UUe(n, x[I], P); var V = P.len(); if (!F && K !== V) { B = !1; break } D && (k[I][A] = D) } if (!B) for (var I in k) delete k[I].d; if (!r) for (var E = 0; E < v; E++) { var O = w[E], j = O.targetName; j === "style" && C(O, k, function (_e) { return WUe[_e] }) } for (var W = Bt(k), J = !0, ie, E = 1; E < W.length; E++) { var le = W[E - 1], De = W[E]; if (k[le][If] !== k[De][If]) { J = !1; break } ie = k[le][If] } if (J && ie) { for (var I in k) k[I][If] && delete k[I][If]; e[If] = ie } if (pn(W, function (pe) { return Bt(k[pe]).length > 0 }).length) { var ae = Cie(k, t); return ae + " " + b[0] + " both" } } for (var g in l) { var s = m(l[g]); s && o.push(s) } if (o.length) { var y = t.zrId + "-cls-" + kie(); t.cssNodes["." + y] = { animation: o.join(",") }, e.class = y } } function qUe(n, e, t) { if (!n.ignore) if (n.isSilent()) { var r = { "pointer-events": "none" }; h9(r, e, t, !0) } else { var i = n.states.emphasis && n.states.emphasis.style ? n.states.emphasis.style : {}, a = i.fill; if (!a) { var o = n.style && n.style.fill, s = n.states.select && n.states.select.style && n.states.select.style.fill, l = n.currentStates.indexOf("select") >= 0 && s || o; l && (a = PP(l)) } var c = i.lineWidth; if (c) { var u = !i.strokeNoScale && n.transform ? n.transform[0] : 1; c = c / u } var r = { cursor: "pointer" }; a && (r.fill = a), i.stroke && (r.stroke = i.stroke), c && (r["stroke-width"] = c), h9(r, e, t, !0) } } function h9(n, e, t, r) { var i = JSON.stringify(n), a = t.cssStyleCache[i]; a || (a = t.zrId + "-cls-" + kie(), t.cssStyleCache[i] = a, t.cssNodes["." + a + (r ? ":hover" : "")] = n), e.class = e.class ? e.class + " " + a : a } var A_ = Math.round; function Aie(n) { return n && Fe(n.src) } function Eie(n) { return n && tt(n.toDataURL) } function C3(n, e, t, r) { NUe(function (i, a) { var o = i === "fill" || i === "stroke"; o && Bee(a) ? Oie(e, n, i, r) : o && AN(a) ? Die(t, n, i, r) : n[i] = a, o && r.ssr && a === "none" && (n["pointer-events"] = "visible") }, e, t, !1), tGe(t, n, r) } function A3(n, e) { var t = xFe(e); t && (t.each(function (r, i) { r != null && (n[(c9 + i).toLowerCase()] = r + "") }), e.isSilent() && (n[c9 + "silent"] = "true")) } function p9(n) { return qu(n[0] - 1) && qu(n[1]) && qu(n[2]) && qu(n[3] - 1) } function YUe(n) { return qu(n[4]) && qu(n[5]) } function E3(n, e, t) { if (e && !(YUe(e) && p9(e))) { var r = t ? 10 : 1e4; n.transform = p9(e) ? "translate(" + A_(e[4] * r) / r + " " + A_(e[5] * r) / r + ")" : V$e(e) } } function m9(n, e, t) { for (var r = n.points, i = [], a = 0; a < r.length; a++)i.push(A_(r[a][0] * t) / t), i.push(A_(r[a][1] * t) / t); e.points = i.join(" ") } function g9(n) { return !n.smooth } function ZUe(n) { var e = Ae(n, function (t) { return typeof t == "string" ? [t, t] : t }); return function (t, r, i) { for (var a = 0; a < e.length; a++) { var o = e[a], s = t[o[0]]; s != null && (r[o[1]] = A_(s * i) / i) } } } var XUe = { circle: [ZUe(["cx", "cy", "r"])], polyline: [m9, g9], polygon: [m9, g9] }; function JUe(n) { for (var e = n.animators, t = 0; t < e.length; t++)if (e[t].targetName === "shape") return !0; return !1 } function Mie(n, e) { var t = n.style, r = n.shape, i = XUe[n.type], a = {}, o = e.animation, s = "path", l = n.style.strokePercent, c = e.compress && $ee(n) || 4; if (i && !e.willUpdate && !(i[1] && !i[1](r)) && !(o && JUe(n)) && !(l < 1)) { s = n.type; var u = Math.pow(10, c); i[0](r, a, u) } else { var d = !n.path || n.shapeChanged(); n.path || n.createPathProxy(); var f = n.path; d && (f.beginPath(), n.buildPath(f, n.shape), n.pathUpdated()); var h = f.getVersion(), p = n, m = p.__svgPathBuilder; (p.__svgPathVersion !== h || !m || l !== p.__svgPathStrokePercent) && (m || (m = p.__svgPathBuilder = new wie), m.reset(c), f.rebuildPath(m, l), m.generateStr(), p.__svgPathVersion = h, p.__svgPathStrokePercent = l), a.d = m.getStr() } return E3(a, n.transform), C3(a, t, n, e), A3(a, n), e.animation && SC(n, a, e), e.emphasis && qUe(n, a, e), Vr(s, n.id + "", a) } function QUe(n, e) { var t = n.style, r = t.image; if (r && !Fe(r) && (Aie(r) ? r = r.src : Eie(r) && (r = r.toDataURL())), !!r) { var i = t.x || 0, a = t.y || 0, o = t.width, s = t.height, l = { href: r, width: o, height: s }; return i && (l.x = i), a && (l.y = a), E3(l, n.transform), C3(l, t, n, e), A3(l, n), e.animation && SC(n, l, e), Vr("image", n.id + "", l) } } function eGe(n, e) { var t = n.style, r = t.text; if (r != null && (r += ""), !(!r || isNaN(t.x) || isNaN(t.y))) { var i = t.font || Td, a = t.x || 0, o = U$e(t.y || 0, Zk(i), t.textBaseline), s = H$e[t.textAlign] || t.textAlign, l = { "dominant-baseline": "central", "text-anchor": s }; if (xte(t)) { var c = "", u = t.fontStyle, d = wte(t.fontSize); if (!parseFloat(d)) return; var f = t.fontFamily || hee, h = t.fontWeight; c += "font-size:" + d + ";font-family:" + f + ";", u && u !== "normal" && (c += "font-style:" + u + ";"), h && h !== "normal" && (c += "font-weight:" + h + ";"), l.style = c } else l.style = "font: " + i; return r.match(/\s/) && (l["xml:space"] = "preserve"), a && (l.x = a), o && (l.y = o), E3(l, n.transform), C3(l, t, n, e), A3(l, n), e.animation && SC(n, l, e), Vr("text", n.id + "", l, void 0, r) } } function v9(n, e) { if (n instanceof Nt) return Mie(n, e); if (n instanceof gi) return QUe(n, e); if (n instanceof g_) return eGe(n, e) } function tGe(n, e, t) { var r = n.style; if (G$e(r)) { var i = W$e(n), a = t.shadowCache, o = a[i]; if (!o) { var s = n.getGlobalScale(), l = s[0], c = s[1]; if (!l || !c) return; var u = r.shadowOffsetX || 0, d = r.shadowOffsetY || 0, f = r.shadowBlur, h = h_(r.shadowColor), p = h.opacity, m = h.color, g = f / 2 / l, y = f / 2 / c, b = g + " " + y; o = t.zrId + "-s" + t.shadowIdx++, t.defs[o] = Vr("filter", o, { id: o, x: "-100%", y: "-100%", width: "300%", height: "300%" }, [Vr("feDropShadow", "", { dx: u / l, dy: d / c, stdDeviation: b, "flood-color": m, "flood-opacity": p })]), a[i] = o } e.filter = Yk(o) } } function Oie(n, e, t, r) { var i = n[t], a, o = { gradientUnits: i.global ? "userSpaceOnUse" : "objectBoundingBox" }; if (Ree(i)) a = "linearGradient", o.x1 = i.x, o.y1 = i.y, o.x2 = i.x2, o.y2 = i.y2; else if (Nee(i)) a = "radialGradient", o.cx = yt(i.x, .5), o.cy = yt(i.y, .5), o.r = yt(i.r, .5); else return; for (var s = i.colorStops, l = [], c = 0, u = s.length; c < u; ++c) { var d = IP(s[c].offset) * 100 + "%", f = s[c].color, h = h_(f), p = h.color, m = h.opacity, g = { offset: d }; g["stop-color"] = p, m < 1 && (g["stop-opacity"] = m), l.push(Vr("stop", c + "", g)) } var y = Vr(a, "", o, l), b = k3(y), w = r.gradientCache, v = w[b]; v || (v = r.zrId + "-g" + r.gradientIdx++, w[b] = v, o.id = v, r.defs[v] = Vr(a, v, o, l)), e[t] = Yk(v) } function Die(n, e, t, r) { var i = n.style[t], a = n.getBoundingRect(), o = {}, s = i.repeat, l = s === "no-repeat", c = s === "repeat-x", u = s === "repeat-y", d; if (Lee(i)) { var f = i.imageWidth, h = i.imageHeight, p = void 0, m = i.image; if (Fe(m) ? p = m : Aie(m) ? p = m.src : Eie(m) && (p = m.toDataURL()), typeof Image > "u") { var g = "Image width/height must been given explictly in svg-ssr renderer."; na(f, g), na(h, g) } else if (f == null || h == null) { var y = function (E, O) { if (E) { var j = E.elm, I = f || O.width, L = h || O.height; E.tag === "pattern" && (c ? (L = 1, I /= a.width) : u && (I = 1, L /= a.height)), E.attrs.width = I, E.attrs.height = L, j && (j.setAttribute("width", I), j.setAttribute("height", L)) } }, b = IN(p, null, n, function (E) { l || y(x, E), y(d, E) }); b && b.width && b.height && (f = f || b.width, h = h || b.height) } d = Vr("image", "img", { href: p, width: f, height: h }), o.width = f, o.height = h } else i.svgElement && (d = lt(i.svgElement), o.width = i.svgWidth, o.height = i.svgHeight); if (d) { var w, v; l ? w = v = 1 : c ? (v = 1, w = o.width / a.width) : u ? (w = 1, v = o.height / a.height) : o.patternUnits = "userSpaceOnUse", w != null && !isNaN(w) && (o.width = w), v != null && !isNaN(v) && (o.height = v); var S = Fee(i); S && (o.patternTransform = S); var x = Vr("pattern", "", o, [d]), k = k3(x), A = r.patternCache, C = A[k]; C || (C = r.zrId + "-p" + r.patternIdx++, A[k] = C, o.id = C, x = r.defs[C] = Vr("pattern", C, o, [d])), e[t] = Yk(C) } } function nGe(n, e, t) { var r = t.clipPathCache, i = t.defs, a = r[n.id]; if (!a) { a = t.zrId + "-c" + t.clipPathIdx++; var o = { id: a }; r[n.id] = a, i[a] = Vr("clipPath", a, o, [Mie(n, t)]) } e["clip-path"] = Yk(a) } function y9(n) { return document.createTextNode(n) } function Hf(n, e, t) { n.insertBefore(e, t) } function _9(n, e) { n.removeChild(e) } function b9(n, e) { n.appendChild(e) } function jie(n) { return n.parentNode } function Pie(n) { return n.nextSibling } function mO(n, e) { n.textContent = e } var w9 = 58, rGe = 120, iGe = Vr("", ""); function xI(n) { return n === void 0 } function Qs(n) { return n !== void 0 } function aGe(n, e, t) { for (var r = {}, i = e; i <= t; ++i) { var a = n[i].key; a !== void 0 && (r[a] = i) } return r } function Oy(n, e) { var t = n.key === e.key, r = n.tag === e.tag; return r && t } function E_(n) { var e, t = n.children, r = n.tag; if (Qs(r)) { var i = n.elm = Tie(r); if (M3(iGe, n), ke(t)) for (e = 0; e < t.length; ++e) { var a = t[e]; a != null && b9(i, E_(a)) } else Qs(n.text) && !ot(n.text) && b9(i, y9(n.text)) } else n.elm = y9(n.text); return n.elm } function Iie(n, e, t, r, i) { for (; r <= i; ++r) { var a = t[r]; a != null && Hf(n, E_(a), e) } } function mT(n, e, t, r) { for (; t <= r; ++t) { var i = e[t]; if (i != null) if (Qs(i.tag)) { var a = jie(i.elm); _9(a, i.elm) } else _9(n, i.elm) } } function M3(n, e) { var t, r = e.elm, i = n && n.attrs || {}, a = e.attrs || {}; if (i !== a) { for (t in a) { var o = a[t], s = i[t]; s !== o && (o === !0 ? r.setAttribute(t, "") : o === !1 ? r.removeAttribute(t) : t === "style" ? r.style.cssText = o : t.charCodeAt(0) !== rGe ? r.setAttribute(t, o) : t === "xmlns:xlink" || t === "xmlns" ? r.setAttributeNS(BUe, t, o) : t.charCodeAt(3) === w9 ? r.setAttributeNS($Ue, t, o) : t.charCodeAt(5) === w9 ? r.setAttributeNS(Sie, t, o) : r.setAttribute(t, o)) } for (t in i) t in a || r.removeAttribute(t) } } function oGe(n, e, t) { for (var r = 0, i = 0, a = e.length - 1, o = e[0], s = e[a], l = t.length - 1, c = t[0], u = t[l], d, f, h, p; r <= a && i <= l;)o == null ? o = e[++r] : s == null ? s = e[--a] : c == null ? c = t[++i] : u == null ? u = t[--l] : Oy(o, c) ? (Sm(o, c), o = e[++r], c = t[++i]) : Oy(s, u) ? (Sm(s, u), s = e[--a], u = t[--l]) : Oy(o, u) ? (Sm(o, u), Hf(n, o.elm, Pie(s.elm)), o = e[++r], u = t[--l]) : Oy(s, c) ? (Sm(s, c), Hf(n, s.elm, o.elm), s = e[--a], c = t[++i]) : (xI(d) && (d = aGe(e, r, a)), f = d[c.key], xI(f) ? Hf(n, E_(c), o.elm) : (h = e[f], h.tag !== c.tag ? Hf(n, E_(c), o.elm) : (Sm(h, c), e[f] = void 0, Hf(n, h.elm, o.elm))), c = t[++i]); (r <= a || i <= l) && (r > a ? (p = t[l + 1] == null ? null : t[l + 1].elm, Iie(n, p, t, i, l)) : mT(n, e, r, a)) } function Sm(n, e) { var t = e.elm = n.elm, r = n.children, i = e.children; n !== e && (M3(n, e), xI(e.text) ? Qs(r) && Qs(i) ? r !== i && oGe(t, r, i) : Qs(i) ? (Qs(n.text) && mO(t, ""), Iie(t, null, i, 0, i.length - 1)) : Qs(r) ? mT(t, r, 0, r.length - 1) : Qs(n.text) && mO(t, "") : n.text !== e.text && (Qs(r) && mT(t, r, 0, r.length - 1), mO(t, e.text))) } function sGe(n, e) { if (Oy(n, e)) Sm(n, e); else { var t = n.elm, r = jie(t); E_(e), r !== null && (Hf(r, e.elm, Pie(t)), mT(r, [n], 0, 0)) } return e } var lGe = 0, cGe = function () { function n(e, t, r) { if (this.type = "svg", this.refreshHover = x9(), this.configLayer = x9(), this.storage = t, this._opts = r = be({}, r), this.root = e, this._id = "zr" + lGe++, this._oldVNode = u9(r.width, r.height), e && !r.ssr) { var i = this._viewport = document.createElement("div"); i.style.cssText = "position:relative;overflow:hidden"; var a = this._svgDom = this._oldVNode.elm = Tie("svg"); M3(null, this._oldVNode), i.appendChild(a), e.appendChild(i) } this.resize(r.width, r.height) } return n.prototype.getType = function () { return this.type }, n.prototype.getViewportRoot = function () { return this._viewport }, n.prototype.getViewportRootOffset = function () { var e = this.getViewportRoot(); if (e) return { offsetLeft: e.offsetLeft || 0, offsetTop: e.offsetTop || 0 } }, n.prototype.getSvgDom = function () { return this._svgDom }, n.prototype.refresh = function () { if (this.root) { var e = this.renderToVNode({ willUpdate: !0 }); e.attrs.style = "position:absolute;left:0;top:0;user-select:none", sGe(this._oldVNode, e), this._oldVNode = e } }, n.prototype.renderOneToVNode = function (e) { return v9(e, wI(this._id)) }, n.prototype.renderToVNode = function (e) { e = e || {}; var t = this.storage.getDisplayList(!0), r = this._width, i = this._height, a = wI(this._id); a.animation = e.animation, a.willUpdate = e.willUpdate, a.compress = e.compress, a.emphasis = e.emphasis, a.ssr = this._opts.ssr; var o = [], s = this._bgVNode = uGe(r, i, this._backgroundColor, a); s && o.push(s); var l = e.compress ? null : this._mainVNode = Vr("g", "main", {}, []); this._paintList(t, a, l ? l.children : o), l && o.push(l); var c = Ae(Bt(a.defs), function (f) { return a.defs[f] }); if (c.length && o.push(Vr("defs", "defs", {}, c)), e.animation) { var u = VUe(a.cssNodes, a.cssAnims, { newline: !0 }); if (u) { var d = Vr("style", "stl", {}, [], u); o.push(d) } } return u9(r, i, o, e.useViewBox) }, n.prototype.renderToString = function (e) { return e = e || {}, k3(this.renderToVNode({ animation: yt(e.cssAnimation, !0), emphasis: yt(e.cssEmphasis, !0), willUpdate: !1, compress: !0, useViewBox: yt(e.useViewBox, !0) }), { newline: !0 }) }, n.prototype.setBackgroundColor = function (e) { this._backgroundColor = e }, n.prototype.getSvgRoot = function () { return this._mainVNode && this._mainVNode.elm }, n.prototype._paintList = function (e, t, r) { for (var i = e.length, a = [], o = 0, s, l, c = 0, u = 0; u < i; u++) { var d = e[u]; if (!d.invisible) { var f = d.__clipPaths, h = f && f.length || 0, p = l && l.length || 0, m = void 0; for (m = Math.max(h - 1, p - 1); m >= 0 && !(f && l && f[m] === l[m]); m--); for (var g = p - 1; g > m; g--)o--, s = a[o - 1]; for (var y = m + 1; y < h; y++) { var b = {}; nGe(f[y], b, t); var w = Vr("g", "clip-g-" + c++, b, []); (s ? s.children : r).push(w), a[o++] = w, s = w } l = f; var v = v9(d, t); v && (s ? s.children : r).push(v) } } }, n.prototype.resize = function (e, t) { var r = this._opts, i = this.root, a = this._viewport; if (e != null && (r.width = e), t != null && (r.height = t), i && a && (a.style.display = "none", e = Im(i, 0, r), t = Im(i, 1, r), a.style.display = ""), this._width !== e || this._height !== t) { if (this._width = e, this._height = t, a) { var o = a.style; o.width = e + "px", o.height = t + "px" } if (AN(this._backgroundColor)) this.refresh(); else { var s = this._svgDom; s && (s.setAttribute("width", e), s.setAttribute("height", t)); var l = this._bgVNode && this._bgVNode.elm; l && (l.setAttribute("width", e), l.setAttribute("height", t)) } } }, n.prototype.getWidth = function () { return this._width }, n.prototype.getHeight = function () { return this._height }, n.prototype.dispose = function () { this.root && (this.root.innerHTML = ""), this._svgDom = this._viewport = this.storage = this._oldVNode = this._bgVNode = this._mainVNode = null }, n.prototype.clear = function () { this._svgDom && (this._svgDom.innerHTML = null), this._oldVNode = null }, n.prototype.toDataURL = function (e) { var t = this.renderToString(), r = "data:image/svg+xml;"; return e ? (t = q$e(t), t && r + "base64," + t) : r + "charset=UTF-8," + encodeURIComponent(t) }, n }(); function x9(n) { return function () { } } function uGe(n, e, t, r) { var i; if (t && t !== "none") if (i = Vr("rect", "bg", { width: n, height: e, x: "0", y: "0" }), Bee(t)) Oie({ fill: t }, i.attrs, "fill", r); else if (AN(t)) Die({ style: { fill: t }, dirty: gr, getBoundingRect: function () { return { width: n, height: e } } }, i.attrs, "fill", r); else { var a = h_(t), o = a.color, s = a.opacity; i.attrs.fill = o, s < 1 && (i.attrs["fill-opacity"] = s) } return i } const dGe = cGe; function fGe(n) { n.registerPainter("svg", dGe) } function S9(n, e, t) { var r = kd.createCanvas(), i = e.getWidth(), a = e.getHeight(), o = r.style; return o && (o.position = "absolute", o.left = "0", o.top = "0", o.width = i + "px", o.height = a + "px", r.setAttribute("data-zr-dom-id", n)), r.width = i * t, r.height = a * t, r } var hGe = function (n) { te(e, n); function e(t, r, i) { var a = n.call(this) || this; a.motionBlur = !1, a.lastFrameAlpha = .7, a.dpr = 1, a.virtual = !1, a.config = {}, a.incremental = !1, a.zlevel = 0, a.maxRepaintRectCount = 5, a.__dirty = !0, a.__firstTimePaint = !0, a.__used = !1, a.__drawIndex = 0, a.__startIndex = 0, a.__endIndex = 0, a.__prevStartIndex = null, a.__prevEndIndex = null; var o; i = i || q2, typeof t == "string" ? o = S9(t, r, i) : ot(t) && (o = t, t = o.id), a.id = t, a.dom = o; var s = o.style; return s && (_ee(o), o.onselectstart = function () { return !1 }, s.padding = "0", s.margin = "0", s.borderWidth = "0"), a.painter = r, a.dpr = i, a } return e.prototype.getElementCount = function () { return this.__endIndex - this.__startIndex }, e.prototype.afterBrush = function () { this.__prevStartIndex = this.__startIndex, this.__prevEndIndex = this.__endIndex }, e.prototype.initContext = function () { this.ctx = this.dom.getContext("2d"), this.ctx.dpr = this.dpr }, e.prototype.setUnpainted = function () { this.__firstTimePaint = !0 }, e.prototype.createBackBuffer = function () { var t = this.dpr; this.domBack = S9("back-" + this.id, this.painter, t), this.ctxBack = this.domBack.getContext("2d"), t !== 1 && this.ctxBack.scale(t, t) }, e.prototype.createRepaintRects = function (t, r, i, a) { if (this.__firstTimePaint) return this.__firstTimePaint = !1, null; var o = [], s = this.maxRepaintRectCount, l = !1, c = new kt(0, 0, 0, 0); function u(b) { if (!(!b.isFinite() || b.isZero())) if (o.length === 0) { var w = new kt(0, 0, 0, 0); w.copy(b), o.push(w) } else { for (var v = !1, S = 1 / 0, x = 0, k = 0; k < o.length; ++k) { var A = o[k]; if (A.intersect(b)) { var C = new kt(0, 0, 0, 0); C.copy(A), C.union(b), o[k] = C, v = !0; break } else if (l) { c.copy(b), c.union(A); var E = b.width * b.height, O = A.width * A.height, j = c.width * c.height, I = j - E - O; I < S && (S = I, x = k) } } if (l && (o[x].union(b), v = !0), !v) { var w = new kt(0, 0, 0, 0); w.copy(b), o.push(w) } l || (l = o.length >= s) } } for (var d = this.__startIndex; d < this.__endIndex; ++d) { var f = t[d]; if (f) { var h = f.shouldBePainted(i, a, !0, !0), p = f.__isRendered && (f.__dirty & Ba || !h) ? f.getPrevPaintRect() : null; p && u(p); var m = h && (f.__dirty & Ba || !f.__isRendered) ? f.getPaintRect() : null; m && u(m) } } for (var d = this.__prevStartIndex; d < this.__prevEndIndex; ++d) { var f = r[d], h = f && f.shouldBePainted(i, a, !0, !0); if (f && (!h || !f.__zr) && f.__isRendered) { var p = f.getPrevPaintRect(); p && u(p) } } var g; do { g = !1; for (var d = 0; d < o.length;) { if (o[d].isZero()) { o.splice(d, 1); continue } for (var y = d + 1; y < o.length;)o[d].intersect(o[y]) ? (g = !0, o[d].union(o[y]), o.splice(y, 1)) : y++; d++ } } while (g); return this._paintRects = o, o }, e.prototype.debugGetPaintRects = function () { return (this._paintRects || []).slice() }, e.prototype.resize = function (t, r) { var i = this.dpr, a = this.dom, o = a.style, s = this.domBack; o && (o.width = t + "px", o.height = r + "px"), a.width = t * i, a.height = r * i, s && (s.width = t * i, s.height = r * i, i !== 1 && this.ctxBack.scale(i, i)) }, e.prototype.clear = function (t, r, i) { var a = this.dom, o = this.ctx, s = a.width, l = a.height; r = r || this.clearColor; var c = this.motionBlur && !t, u = this.lastFrameAlpha, d = this.dpr, f = this; c && (this.domBack || this.createBackBuffer(), this.ctxBack.globalCompositeOperation = "copy", this.ctxBack.drawImage(a, 0, 0, s / d, l / d)); var h = this.domBack; function p(m, g, y, b) { if (o.clearRect(m, g, y, b), r && r !== "transparent") { var w = void 0; if (Wk(r)) { var v = r.global || r.__width === y && r.__height === b; w = v && r.__canvasGradient || fI(o, r, { x: 0, y: 0, width: y, height: b }), r.__canvasGradient = w, r.__width = y, r.__height = b } else q4e(r) && (r.scaleX = r.scaleX || d, r.scaleY = r.scaleY || d, w = hI(o, r, { dirty: function () { f.setUnpainted(), f.painter.refresh() } })); o.save(), o.fillStyle = w || r, o.fillRect(m, g, y, b), o.restore() } c && (o.save(), o.globalAlpha = u, o.drawImage(h, m, g, y, b), o.restore()) } !i || c ? p(0, 0, s, l) : i.length && $(i, function (m) { p(m.x * d, m.y * d, m.width * d, m.height * d) }) }, e }(Go); const gO = hGe; var T9 = 1e5, Df = 314159, rx = .01, pGe = .001; function mGe(n) { return n ? n.__builtin__ ? !0 : !(typeof n.resize != "function" || typeof n.refresh != "function") : !1 } function gGe(n, e) { var t = document.createElement("div"); return t.style.cssText = ["position:relative", "width:" + n + "px", "height:" + e + "px", "padding:0", "margin:0", "border-width:0"].join(";") + ";", t } var vGe = function () { function n(e, t, r, i) { this.type = "canvas", this._zlevelList = [], this._prevDisplayList = [], this._layers = {}, this._layerConfig = {}, this._needsManuallyCompositing = !1, this.type = "canvas"; var a = !e.nodeName || e.nodeName.toUpperCase() === "CANVAS"; this._opts = r = be({}, r || {}), this.dpr = r.devicePixelRatio || q2, this._singleCanvas = a, this.root = e; var o = e.style; o && (_ee(e), e.innerHTML = ""), this.storage = t; var s = this._zlevelList; this._prevDisplayList = []; var l = this._layers; if (a) { var u = e, d = u.width, f = u.height; r.width != null && (d = r.width), r.height != null && (f = r.height), this.dpr = r.devicePixelRatio || 1, u.width = d * this.dpr, u.height = f * this.dpr, this._width = d, this._height = f; var h = new gO(u, this, this.dpr); h.__builtin__ = !0, h.initContext(), l[Df] = h, h.zlevel = Df, s.push(Df), this._domRoot = e } else { this._width = Im(e, 0, r), this._height = Im(e, 1, r); var c = this._domRoot = gGe(this._width, this._height); e.appendChild(c) } } return n.prototype.getType = function () { return "canvas" }, n.prototype.isSingleCanvas = function () { return this._singleCanvas }, n.prototype.getViewportRoot = function () { return this._domRoot }, n.prototype.getViewportRootOffset = function () { var e = this.getViewportRoot(); if (e) return { offsetLeft: e.offsetLeft || 0, offsetTop: e.offsetTop || 0 } }, n.prototype.refresh = function (e) { var t = this.storage.getDisplayList(!0), r = this._prevDisplayList, i = this._zlevelList; this._redrawId = Math.random(), this._paintList(t, r, e, this._redrawId); for (var a = 0; a < i.length; a++) { var o = i[a], s = this._layers[o]; if (!s.__builtin__ && s.refresh) { var l = a === 0 ? this._backgroundColor : null; s.refresh(l) } } return this._opts.useDirtyRect && (this._prevDisplayList = t.slice()), this }, n.prototype.refreshHover = function () { this._paintHoverList(this.storage.getDisplayList(!1)) }, n.prototype._paintHoverList = function (e) { var t = e.length, r = this._hoverlayer; if (r && r.clear(), !!t) { for (var i = { inHover: !0, viewWidth: this._width, viewHeight: this._height }, a, o = 0; o < t; o++) { var s = e[o]; s.__inHover && (r || (r = this._hoverlayer = this.getLayer(T9)), a || (a = r.ctx, a.save()), ah(a, s, i, o === t - 1)) } a && a.restore() } }, n.prototype.getHoverLayer = function () { return this.getLayer(T9) }, n.prototype.paintOne = function (e, t) { pre(e, t) }, n.prototype._paintList = function (e, t, r, i) { if (this._redrawId === i) { r = r || !1, this._updateLayerStatus(e); var a = this._doPaintList(e, t, r), o = a.finished, s = a.needsRefreshHover; if (this._needsManuallyCompositing && this._compositeManually(), s && this._paintHoverList(e), o) this.eachLayer(function (c) { c.afterBrush && c.afterBrush() }); else { var l = this; EP(function () { l._paintList(e, t, r, i) }) } } }, n.prototype._compositeManually = function () { var e = this.getLayer(Df).ctx, t = this._domRoot.width, r = this._domRoot.height; e.clearRect(0, 0, t, r), this.eachBuiltinLayer(function (i) { i.virtual && e.drawImage(i.dom, 0, 0, t, r) }) }, n.prototype._doPaintList = function (e, t, r) { for (var i = this, a = [], o = this._opts.useDirtyRect, s = 0; s < this._zlevelList.length; s++) { var l = this._zlevelList[s], c = this._layers[l]; c.__builtin__ && c !== this._hoverlayer && (c.__dirty || r) && a.push(c) } for (var u = !0, d = !1, f = function (m) { var g = a[m], y = g.ctx, b = o && g.createRepaintRects(e, t, h._width, h._height), w = r ? g.__startIndex : g.__drawIndex, v = !r && g.incremental && Date.now, S = v && Date.now(), x = g.zlevel === h._zlevelList[0] ? h._backgroundColor : null; if (g.__startIndex === g.__endIndex) g.clear(!1, x, b); else if (w === g.__startIndex) { var k = e[w]; (!k.incremental || !k.notClear || r) && g.clear(!1, x, b) } w === -1 && (console.error("For some unknown reason. drawIndex is -1"), w = g.__startIndex); var A, C = function (I) { var L = { inHover: !1, allClipped: !1, prevEl: null, viewWidth: i._width, viewHeight: i._height }; for (A = w; A < g.__endIndex; A++) { var R = e[A]; if (R.__inHover && (d = !0), i._doPaintEl(R, g, o, I, L, A === g.__endIndex - 1), v) { var D = Date.now() - S; if (D > 15) break } } L.prevElClipPaths && y.restore() }; if (b) if (b.length === 0) A = g.__endIndex; else for (var E = h.dpr, O = 0; O < b.length; ++O) { var j = b[O]; y.save(), y.beginPath(), y.rect(j.x * E, j.y * E, j.width * E, j.height * E), y.clip(), C(j), y.restore() } else y.save(), C(), y.restore(); g.__drawIndex = A, g.__drawIndex < g.__endIndex && (u = !1) }, h = this, p = 0; p < a.length; p++)f(p); return en.wxa && $(this._layers, function (m) { m && m.ctx && m.ctx.draw && m.ctx.draw() }), { finished: u, needsRefreshHover: d } }, n.prototype._doPaintEl = function (e, t, r, i, a, o) { var s = t.ctx; if (r) { var l = e.getPaintRect(); (!i || l && l.intersect(i)) && (ah(s, e, a, o), e.setPrevPaintRect(l)) } else ah(s, e, a, o) }, n.prototype.getLayer = function (e, t) { this._singleCanvas && !this._needsManuallyCompositing && (e = Df); var r = this._layers[e]; return r || (r = new gO("zr_" + e, this, this.dpr), r.zlevel = e, r.__builtin__ = !0, this._layerConfig[e] ? xt(r, this._layerConfig[e], !0) : this._layerConfig[e - rx] && xt(r, this._layerConfig[e - rx], !0), t && (r.virtual = t), this.insertLayer(e, r), r.initContext()), r }, n.prototype.insertLayer = function (e, t) { var r = this._layers, i = this._zlevelList, a = i.length, o = this._domRoot, s = null, l = -1; if (!r[e] && mGe(t)) { if (a > 0 && e > i[0]) { for (l = 0; l < a - 1 && !(i[l] < e && i[l + 1] > e); l++); s = r[i[l]] } if (i.splice(l + 1, 0, e), r[e] = t, !t.virtual) if (s) { var c = s.dom; c.nextSibling ? o.insertBefore(t.dom, c.nextSibling) : o.appendChild(t.dom) } else o.firstChild ? o.insertBefore(t.dom, o.firstChild) : o.appendChild(t.dom); t.painter || (t.painter = this) } }, n.prototype.eachLayer = function (e, t) { for (var r = this._zlevelList, i = 0; i < r.length; i++) { var a = r[i]; e.call(t, this._layers[a], a) } }, n.prototype.eachBuiltinLayer = function (e, t) { for (var r = this._zlevelList, i = 0; i < r.length; i++) { var a = r[i], o = this._layers[a]; o.__builtin__ && e.call(t, o, a) } }, n.prototype.eachOtherLayer = function (e, t) { for (var r = this._zlevelList, i = 0; i < r.length; i++) { var a = r[i], o = this._layers[a]; o.__builtin__ || e.call(t, o, a) } }, n.prototype.getLayers = function () { return this._layers }, n.prototype._updateLayerStatus = function (e) { this.eachBuiltinLayer(function (d, f) { d.__dirty = d.__used = !1 }); function t(d) { a && (a.__endIndex !== d && (a.__dirty = !0), a.__endIndex = d) } if (this._singleCanvas) for (var r = 1; r < e.length; r++) { var i = e[r]; if (i.zlevel !== e[r - 1].zlevel || i.incremental) { this._needsManuallyCompositing = !0; break } } var a = null, o = 0, s, l; for (l = 0; l < e.length; l++) { var i = e[l], c = i.zlevel, u = void 0; s !== c && (s = c, o = 0), i.incremental ? (u = this.getLayer(c + pGe, this._needsManuallyCompositing), u.incremental = !0, o = 1) : u = this.getLayer(c + (o > 0 ? rx : 0), this._needsManuallyCompositing), u.__builtin__ || _N("ZLevel " + c + " has been used by unkown layer " + u.id), u !== a && (u.__used = !0, u.__startIndex !== l && (u.__dirty = !0), u.__startIndex = l, u.incremental ? u.__drawIndex = -1 : u.__drawIndex = l, t(l), a = u), i.__dirty & Ba && !i.__inHover && (u.__dirty = !0, u.incremental && u.__drawIndex < 0 && (u.__drawIndex = l)) } t(l), this.eachBuiltinLayer(function (d, f) { !d.__used && d.getElementCount() > 0 && (d.__dirty = !0, d.__startIndex = d.__endIndex = d.__drawIndex = 0), d.__dirty && d.__drawIndex < 0 && (d.__drawIndex = d.__startIndex) }) }, n.prototype.clear = function () { return this.eachBuiltinLayer(this._clearLayer), this }, n.prototype._clearLayer = function (e) { e.clear() }, n.prototype.setBackgroundColor = function (e) { this._backgroundColor = e, $(this._layers, function (t) { t.setUnpainted() }) }, n.prototype.configLayer = function (e, t) { if (t) { var r = this._layerConfig; r[e] ? xt(r[e], t, !0) : r[e] = t; for (var i = 0; i < this._zlevelList.length; i++) { var a = this._zlevelList[i]; if (a === e || a === e + rx) { var o = this._layers[a]; xt(o, r[e], !0) } } } }, n.prototype.delLayer = function (e) { var t = this._layers, r = this._zlevelList, i = t[e]; i && (i.dom.parentNode.removeChild(i.dom), delete t[e], r.splice(Et(r, e), 1)) }, n.prototype.resize = function (e, t) { if (this._domRoot.style) { var r = this._domRoot; r.style.display = "none"; var i = this._opts, a = this.root; if (e != null && (i.width = e), t != null && (i.height = t), e = Im(a, 0, i), t = Im(a, 1, i), r.style.display = "", this._width !== e || t !== this._height) { r.style.width = e + "px", r.style.height = t + "px"; for (var o in this._layers) this._layers.hasOwnProperty(o) && this._layers[o].resize(e, t); this.refresh(!0) } this._width = e, this._height = t } else { if (e == null || t == null) return; this._width = e, this._height = t, this.getLayer(Df).resize(e, t) } return this }, n.prototype.clearLayer = function (e) { var t = this._layers[e]; t && t.clear() }, n.prototype.dispose = function () { this.root.innerHTML = "", this.root = this.storage = this._domRoot = this._layers = null }, n.prototype.getRenderedCanvas = function (e) { if (e = e || {}, this._singleCanvas && !this._compositeManually) return this._layers[Df].dom; var t = new gO("image", this, e.pixelRatio || this.dpr); t.initContext(), t.clear(!1, e.backgroundColor || this._backgroundColor); var r = t.ctx; if (e.pixelRatio <= this.dpr) { this.refresh(); var i = t.dom.width, a = t.dom.height; this.eachLayer(function (d) { d.__builtin__ ? r.drawImage(d.dom, 0, 0, i, a) : d.renderToCanvas && (r.save(), d.renderToCanvas(r), r.restore()) }) } else for (var o = { inHover: !1, viewWidth: this._width, viewHeight: this._height }, s = this.storage.getDisplayList(!0), l = 0, c = s.length; l < c; l++) { var u = s[l]; ah(r, u, o, l === c - 1) } return t.dom }, n.prototype.getWidth = function () { return this._width }, n.prototype.getHeight = function () { return this._height }, n }(); const yGe = vGe; function _Ge(n) { n.registerPainter("canvas", yGe) } var bGe = function (n) { te(e, n); function e() { var t = n !== null && n.apply(this, arguments) || this; return t.type = e.type, t.hasSymbolVisual = !0, t } return e.prototype.getInitialData = function (t) { return Hc(null, this, { useEncodeDefaulter: !0 }) }, e.prototype.getLegendIcon = function (t) { var r = new ft, i = Tr("line", 0, t.itemHeight / 2, t.itemWidth, 0, t.lineStyle.stroke, !1); r.add(i), i.setStyle(t.lineStyle); var a = this.getData().getVisual("symbol"), o = this.getData().getVisual("symbolRotate"), s = a === "none" ? "circle" : a, l = t.itemHeight * .8, c = Tr(s, (t.itemWidth - l) / 2, (t.itemHeight - l) / 2, l, l, t.itemStyle.fill); r.add(c), c.setStyle(t.itemStyle); var u = t.iconRotate === "inherit" ? o : t.iconRotate || 0; return c.rotation = u * Math.PI / 180, c.setOrigin([t.itemWidth / 2, t.itemHeight / 2]), s.indexOf("empty") > -1 && (c.style.stroke = c.style.fill, c.style.fill = "#fff", c.style.lineWidth = 2), r }, e.type = "series.line", e.dependencies = ["grid", "polar"], e.defaultOption = { z: 3, coordinateSystem: "cartesian2d", legendHoverLink: !0, clip: !0, label: { position: "top" }, endLabel: { show: !1, valueAnimation: !0, distance: 8 }, lineStyle: { width: 2, type: "solid" }, emphasis: { scale: !0 }, step: !1, smooth: !1, smoothMonotone: null, symbol: "emptyCircle", symbolSize: 4, symbolRotate: null, showSymbol: !0, showAllSymbol: "auto", connectNulls: !1, sampling: "none", animationEasing: "linear", progressive: 0, hoverLayerThreshold: 1 / 0, universalTransition: { divideShape: "clone" }, triggerLineEvent: !1 }, e }(Yn); const wGe = bGe; function Mg(n, e) { var t = n.mapDimensionsAll("defaultedLabel"), r = t.length; if (r === 1) { var i = Cg(n, e, t[0]); return i != null ? i + "" : null } else if (r) { for (var a = [], o = 0; o < t.length; o++)a.push(Cg(n, e, t[o])); return a.join(" ") } } function Lie(n, e) { var t = n.mapDimensionsAll("defaultedLabel"); if (!ke(e)) return e + ""; for (var r = [], i = 0; i < t.length; i++) { var a = n.getDimensionIndex(t[i]); a >= 0 && r.push(e[a]) } return r.join(" ") } var xGe = function (n) { te(e, n); function e(t, r, i, a) { var o = n.call(this) || this; return o.updateData(t, r, i, a), o } return e.prototype._createSymbol = function (t, r, i, a, o) { this.removeAll(); var s = Tr(t, -1, -1, 2, 2, null, o); s.attr({ z2: 100, culling: !0, scaleX: a[0] / 2, scaleY: a[1] / 2 }), s.drift = SGe, this._symbolType = t, this.add(s) }, e.prototype.stopSymbolAnimation = function (t) { this.childAt(0).stopAnimation(null, t) }, e.prototype.getSymbolType = function () { return this._symbolType }, e.prototype.getSymbolPath = function () { return this.childAt(0) }, e.prototype.highlight = function () { Pc(this.childAt(0)) }, e.prototype.downplay = function () { Ic(this.childAt(0)) }, e.prototype.setZ = function (t, r) { var i = this.childAt(0); i.zlevel = t, i.z = r }, e.prototype.setDraggable = function (t, r) { var i = this.childAt(0); i.draggable = t, i.cursor = !r && t ? "move" : i.cursor }, e.prototype.updateData = function (t, r, i, a) { this.silent = !1; var o = t.getItemVisual(r, "symbol") || "circle", s = t.hostModel, l = e.getSymbolSize(t, r), c = o !== this._symbolType, u = a && a.disableAnimation; if (c) { var d = t.getItemVisual(r, "symbolKeepAspect"); this._createSymbol(o, t, r, l, d) } else { var f = this.childAt(0); f.silent = !1; var h = { scaleX: l[0] / 2, scaleY: l[1] / 2 }; u ? f.attr(h) : on(f, h, s, r), Ms(f) } if (this._updateCommon(t, r, l, i, a), c) { var f = this.childAt(0); if (!u) { var h = { scaleX: this._sizeX, scaleY: this._sizeY, style: { opacity: f.style.opacity } }; f.scaleX = f.scaleY = 0, f.style.opacity = 0, Un(f, h, s, r) } } u && this.childAt(0).stopAnimation("leave") }, e.prototype._updateCommon = function (t, r, i, a, o) { var s = this.childAt(0), l = t.hostModel, c, u, d, f, h, p, m, g, y; if (a && (c = a.emphasisItemStyle, u = a.blurItemStyle, d = a.selectItemStyle, f = a.focus, h = a.blurScope, m = a.labelStatesModels, g = a.hoverScale, y = a.cursorStyle, p = a.emphasisDisabled), !a || t.hasItemOption) { var b = a && a.itemModel ? a.itemModel : t.getItemModel(r), w = b.getModel("emphasis"); c = w.getModel("itemStyle").getItemStyle(), d = b.getModel(["select", "itemStyle"]).getItemStyle(), u = b.getModel(["blur", "itemStyle"]).getItemStyle(), f = w.get("focus"), h = w.get("blurScope"), p = w.get("disabled"), m = Ur(b), g = w.getShallow("scale"), y = b.getShallow("cursor") } var v = t.getItemVisual(r, "symbolRotate"); s.attr("rotation", (v || 0) * Math.PI / 180 || 0); var S = sp(t.getItemVisual(r, "symbolOffset"), i); S && (s.x = S[0], s.y = S[1]), y && s.attr("cursor", y); var x = t.getItemVisual(r, "style"), k = x.fill; if (s instanceof gi) { var A = s.style; s.useStyle(be({ image: A.image, x: A.x, y: A.y, width: A.width, height: A.height }, x)) } else s.__isEmptyBrush ? s.useStyle(be({}, x)) : s.useStyle(x), s.style.decal = null, s.setColor(k, o && o.symbolInnerColor), s.style.strokeNoScale = !0; var C = t.getItemVisual(r, "liftZ"), E = this._z2; C != null ? E == null && (this._z2 = s.z2, s.z2 += C) : E != null && (s.z2 = E, this._z2 = null); var O = o && o.useNameLabel; mi(s, m, { labelFetcher: l, labelDataIndex: r, defaultText: j, inheritColor: k, defaultOpacity: x.opacity }); function j(R) { return O ? t.getName(R) : Mg(t, R) } this._sizeX = i[0] / 2, this._sizeY = i[1] / 2; var I = s.ensureState("emphasis"); I.style = c, s.ensureState("select").style = d, s.ensureState("blur").style = u; var L = g == null || g === !0 ? Math.max(1.1, 3 / this._sizeY) : isFinite(g) && g > 0 ? +g : 1; I.scaleX = this._sizeX * L, I.scaleY = this._sizeY * L, this.setSymbolScale(1), Qn(this, f, h, p) }, e.prototype.setSymbolScale = function (t) { this.scaleX = this.scaleY = t }, e.prototype.fadeOut = function (t, r, i) { var a = this.childAt(0), o = pt(this).dataIndex, s = i && i.animation; if (this.silent = a.silent = !0, i && i.fadeLabel) { var l = a.getTextContent(); l && Ad(l, { style: { opacity: 0 } }, r, { dataIndex: o, removeOpt: s, cb: function () { a.removeTextContent() } }) } else a.removeTextContent(); Ad(a, { style: { opacity: 0 }, scaleX: 0, scaleY: 0 }, r, { dataIndex: o, cb: t, removeOpt: s }) }, e.getSymbolSize = function (t, r) { return ov(t.getItemVisual(r, "symbolSize")) }, e }(ft); function SGe(n, e) { this.parent.drift(n, e) } const Ob = xGe; function vO(n, e, t, r) { return e && !isNaN(e[0]) && !isNaN(e[1]) && !(r.isIgnore && r.isIgnore(t)) && !(r.clipShape && !r.clipShape.contain(e[0], e[1])) && n.getItemVisual(t, "symbol") !== "none" } function k9(n) { return n != null && !ot(n) && (n = { isIgnore: n }), n || {} } function C9(n) { var e = n.hostModel, t = e.getModel("emphasis"); return { emphasisItemStyle: t.getModel("itemStyle").getItemStyle(), blurItemStyle: e.getModel(["blur", "itemStyle"]).getItemStyle(), selectItemStyle: e.getModel(["select", "itemStyle"]).getItemStyle(), focus: t.get("focus"), blurScope: t.get("blurScope"), emphasisDisabled: t.get("disabled"), hoverScale: t.get("scale"), labelStatesModels: Ur(e), cursorStyle: e.get("cursor") } } var TGe = function () { function n(e) { this.group = new ft, this._SymbolCtor = e || Ob } return n.prototype.updateData = function (e, t) { this._progressiveEls = null, t = k9(t); var r = this.group, i = e.hostModel, a = this._data, o = this._SymbolCtor, s = t.disableAnimation, l = C9(e), c = { disableAnimation: s }, u = t.getSymbolPoint || function (d) { return e.getItemLayout(d) }; a || r.removeAll(), e.diff(a).add(function (d) { var f = u(d); if (vO(e, f, d, t)) { var h = new o(e, d, l, c); h.setPosition(f), e.setItemGraphicEl(d, h), r.add(h) } }).update(function (d, f) { var h = a.getItemGraphicEl(f), p = u(d); if (!vO(e, p, d, t)) { r.remove(h); return } var m = e.getItemVisual(d, "symbol") || "circle", g = h && h.getSymbolType && h.getSymbolType(); if (!h || g && g !== m) r.remove(h), h = new o(e, d, l, c), h.setPosition(p); else { h.updateData(e, d, l, c); var y = { x: p[0], y: p[1] }; s ? h.attr(y) : on(h, y, i) } r.add(h), e.setItemGraphicEl(d, h) }).remove(function (d) { var f = a.getItemGraphicEl(d); f && f.fadeOut(function () { r.remove(f) }, i) }).execute(), this._getSymbolPoint = u, this._data = e }, n.prototype.updateLayout = function () { var e = this, t = this._data; t && t.eachItemGraphicEl(function (r, i) { var a = e._getSymbolPoint(i); r.setPosition(a), r.markRedraw() }) }, n.prototype.incrementalPrepareUpdate = function (e) { this._seriesScope = C9(e), this._data = null, this.group.removeAll() }, n.prototype.incrementalUpdate = function (e, t, r) { this._progressiveEls = [], r = k9(r); function i(l) { l.isGroup || (l.incremental = !0, l.ensureState("emphasis").hoverLayer = !0) } for (var a = e.start; a < e.end; a++) { var o = t.getItemLayout(a); if (vO(t, o, a, r)) { var s = new this._SymbolCtor(t, a, this._seriesScope); s.traverse(i), s.setPosition(o), this.group.add(s), t.setItemGraphicEl(a, s), this._progressiveEls.push(s) } } }, n.prototype.eachRendered = function (e) { Gd(this._progressiveEls || this.group, e) }, n.prototype.remove = function (e) { var t = this.group, r = this._data; r && e ? r.eachItemGraphicEl(function (i) { i.fadeOut(function () { t.remove(i) }, r.hostModel) }) : t.removeAll() }, n }(); const Db = TGe; function Rie(n, e, t) { var r = n.getBaseAxis(), i = n.getOtherAxis(r), a = kGe(i, t), o = r.dim, s = i.dim, l = e.mapDimension(s), c = e.mapDimension(o), u = s === "x" || s === "radius" ? 1 : 0, d = Ae(n.dimensions, function (p) { return e.mapDimension(p) }), f = !1, h = e.getCalculationInfo("stackResultDimension"); return Md(e, d[0]) && (f = !0, d[0] = h), Md(e, d[1]) && (f = !0, d[1] = h), { dataDimsForPoint: d, valueStart: a, valueAxisDim: s, baseAxisDim: o, stacked: !!f, valueDim: l, baseDim: c, baseDataOffset: u, stackedOverDimension: e.getCalculationInfo("stackedOverDimension") } } function kGe(n, e) { var t = 0, r = n.scale.getExtent(); return e === "start" ? t = r[0] : e === "end" ? t = r[1] : nn(e) && !isNaN(e) ? t = e : r[0] > 0 ? t = r[0] : r[1] < 0 && (t = r[1]), t } function Nie(n, e, t, r) { var i = NaN; n.stacked && (i = t.get(t.getCalculationInfo("stackedOverDimension"), r)), isNaN(i) && (i = n.valueStart); var a = n.baseDataOffset, o = []; return o[a] = t.get(n.baseDim, r), o[1 - a] = i, e.dataToPoint(o) } function CGe(n, e) { var t = []; return e.diff(n).add(function (r) { t.push({ cmd: "+", idx: r }) }).update(function (r, i) { t.push({ cmd: "=", idx: i, idx1: r }) }).remove(function (r) { t.push({ cmd: "-", idx: r }) }).execute(), t } function AGe(n, e, t, r, i, a, o, s) { for (var l = CGe(n, e), c = [], u = [], d = [], f = [], h = [], p = [], m = [], g = Rie(i, e, o), y = n.getLayout("points") || [], b = e.getLayout("points") || [], w = 0; w < l.length; w++) { var v = l[w], S = !0, x = void 0, k = void 0; switch (v.cmd) { case "=": x = v.idx * 2, k = v.idx1 * 2; var A = y[x], C = y[x + 1], E = b[k], O = b[k + 1]; (isNaN(A) || isNaN(C)) && (A = E, C = O), c.push(A, C), u.push(E, O), d.push(t[x], t[x + 1]), f.push(r[k], r[k + 1]), m.push(e.getRawIndex(v.idx1)); break; case "+": var j = v.idx, I = g.dataDimsForPoint, L = i.dataToPoint([e.get(I[0], j), e.get(I[1], j)]); k = j * 2, c.push(L[0], L[1]), u.push(b[k], b[k + 1]); var R = Nie(g, i, e, j); d.push(R[0], R[1]), f.push(r[k], r[k + 1]), m.push(e.getRawIndex(j)); break; case "-": S = !1 }S && (h.push(v), p.push(p.length)) } p.sort(function (le, De) { return m[le] - m[De] }); for (var D = c.length, P = ll(D), B = ll(D), F = ll(D), K = ll(D), V = [], w = 0; w < p.length; w++) { var W = p[w], J = w * 2, ie = W * 2; P[J] = c[ie], P[J + 1] = c[ie + 1], B[J] = u[ie], B[J + 1] = u[ie + 1], F[J] = d[ie], F[J + 1] = d[ie + 1], K[J] = f[ie], K[J + 1] = f[ie + 1], V[w] = h[W] } return { current: P, next: B, stackedOnCurrent: F, stackedOnNext: K, status: V } } var uu = Math.min, du = Math.max; function Ah(n, e) { return isNaN(n) || isNaN(e) } function SI(n, e, t, r, i, a, o, s, l) { for (var c, u, d, f, h, p, m = t, g = 0; g < r; g++) { var y = e[m * 2], b = e[m * 2 + 1]; if (m >= i || m < 0) break; if (Ah(y, b)) { if (l) { m += a; continue } break } if (m === t) n[a > 0 ? "moveTo" : "lineTo"](y, b), d = y, f = b; else { var w = y - c, v = b - u; if (w * w + v * v < .5) { m += a; continue } if (o > 0) { for (var S = m + a, x = e[S * 2], k = e[S * 2 + 1]; x === y && k === b && g < r;)g++, S += a, m += a, x = e[S * 2], k = e[S * 2 + 1], y = e[m * 2], b = e[m * 2 + 1], w = y - c, v = b - u; var A = g + 1; if (l) for (; Ah(x, k) && A < r;)A++, S += a, x = e[S * 2], k = e[S * 2 + 1]; var C = .5, E = 0, O = 0, j = void 0, I = void 0; if (A >= r || Ah(x, k)) h = y, p = b; else { E = x - c, O = k - u; var L = y - c, R = x - y, D = b - u, P = k - b, B = void 0, F = void 0; if (s === "x") { B = Math.abs(L), F = Math.abs(R); var K = E > 0 ? 1 : -1; h = y - K * B * o, p = b, j = y + K * F * o, I = b } else if (s === "y") { B = Math.abs(D), F = Math.abs(P); var V = O > 0 ? 1 : -1; h = y, p = b - V * B * o, j = y, I = b + V * F * o } else B = Math.sqrt(L * L + D * D), F = Math.sqrt(R * R + P * P), C = F / (F + B), h = y - E * o * (1 - C), p = b - O * o * (1 - C), j = y + E * o * C, I = b + O * o * C, j = uu(j, du(x, y)), I = uu(I, du(k, b)), j = du(j, uu(x, y)), I = du(I, uu(k, b)), E = j - y, O = I - b, h = y - E * B / F, p = b - O * B / F, h = uu(h, du(c, y)), p = uu(p, du(u, b)), h = du(h, uu(c, y)), p = du(p, uu(u, b)), E = y - h, O = b - p, j = y + E * F / B, I = b + O * F / B } n.bezierCurveTo(d, f, h, p, y, b), d = j, f = I } else n.lineTo(y, b) } c = y, u = b, m += a } return g } var Bie = function () { function n() { this.smooth = 0, this.smoothConstraint = !0 } return n }(), EGe = function (n) { te(e, n); function e(t) { var r = n.call(this, t) || this; return r.type = "ec-polyline", r } return e.prototype.getDefaultStyle = function () { return { stroke: "#000", fill: null } }, e.prototype.getDefaultShape = function () { return new Bie }, e.prototype.buildPath = function (t, r) { var i = r.points, a = 0, o = i.length / 2; if (r.connectNulls) { for (; o > 0 && Ah(i[o * 2 - 2], i[o * 2 - 1]); o--); for (; a < o && Ah(i[a * 2], i[a * 2 + 1]); a++); } for (; a < o;)a += SI(t, i, a, o, o, 1, r.smooth, r.smoothMonotone, r.connectNulls) + 1 }, e.prototype.getPointOn = function (t, r) { this.path || (this.createPathProxy(), this.buildPath(this.path, this.shape)); for (var i = this.path, a = i.data, o = Cl.CMD, s, l, c = r === "x", u = [], d = 0; d < a.length;) { var f = a[d++], h = void 0, p = void 0, m = void 0, g = void 0, y = void 0, b = void 0, w = void 0; switch (f) { case o.M: s = a[d++], l = a[d++]; break; case o.L: if (h = a[d++], p = a[d++], w = c ? (t - s) / (h - s) : (t - l) / (p - l), w <= 1 && w >= 0) { var v = c ? (p - l) * w + l : (h - s) * w + s; return c ? [t, v] : [v, t] } s = h, l = p; break; case o.C: h = a[d++], p = a[d++], m = a[d++], g = a[d++], y = a[d++], b = a[d++]; var S = c ? U2(s, h, m, y, t, u) : U2(l, p, g, b, t, u); if (S > 0) for (var x = 0; x < S; x++) { var k = u[x]; if (k <= 1 && k >= 0) { var v = c ? Nr(l, p, g, b, k) : Nr(s, h, m, y, k); return c ? [t, v] : [v, t] } } s = y, l = b; break } } }, e }(Nt), MGe = function (n) { te(e, n); function e() { return n !== null && n.apply(this, arguments) || this } return e }(Bie), $ie = function (n) { te(e, n); function e(t) { var r = n.call(this, t) || this; return r.type = "ec-polygon", r } return e.prototype.getDefaultShape = function () { return new MGe }, e.prototype.buildPath = function (t, r) { var i = r.points, a = r.stackedOnPoints, o = 0, s = i.length / 2, l = r.smoothMonotone; if (r.connectNulls) { for (; s > 0 && Ah(i[s * 2 - 2], i[s * 2 - 1]); s--); for (; o < s && Ah(i[o * 2], i[o * 2 + 1]); o++); } for (; o < s;) { var c = SI(t, i, o, s, s, 1, r.smooth, l, r.connectNulls); SI(t, a, o + c - 1, c, s, -1, r.stackedOnSmooth, l, r.connectNulls), o += c + 1, t.closePath() } }, e }(Nt); function Fie(n, e, t, r, i) { var a = n.getArea(), o = a.x, s = a.y, l = a.width, c = a.height, u = t.get(["lineStyle", "width"]) || 0; o -= u / 2, s -= u / 2, l += u, c += u, l = Math.ceil(l), o !== Math.floor(o) && (o = Math.floor(o), l++); var d = new Yt({ shape: { x: o, y: s, width: l, height: c } }); if (e) { var f = n.getBaseAxis(), h = f.isHorizontal(), p = f.inverse; h ? (p && (d.shape.x += l), d.shape.width = 0) : (p || (d.shape.y += c), d.shape.height = 0); var m = tt(i) ? function (g) { i(g, d) } : null; Un(d, { shape: { width: l, height: c, x: o, y: s } }, t, null, r, m) } return d } function zie(n, e, t) { var r = n.getArea(), i = lr(r.r0, 1), a = lr(r.r, 1), o = new Ca({ shape: { cx: lr(n.cx, 1), cy: lr(n.cy, 1), r0: i, r: a, startAngle: r.startAngle, endAngle: r.endAngle, clockwise: r.clockwise } }); if (e) { var s = n.getBaseAxis().dim === "angle"; s ? o.shape.endAngle = r.startAngle : o.shape.r = i, Un(o, { shape: { endAngle: r.endAngle, r: a } }, t) } return o } function jb(n, e, t, r, i) { if (n) { if (n.type === "polar") return zie(n, e, t); if (n.type === "cartesian2d") return Fie(n, e, t, r, i) } else return null; return null } function cp(n, e) { return n.type === e } function A9(n, e) { if (n.length === e.length) { for (var t = 0; t < n.length; t++)if (n[t] !== e[t]) return; return !0 } } function E9(n) { for (var e = 1 / 0, t = 1 / 0, r = -1 / 0, i = -1 / 0, a = 0; a < n.length;) { var o = n[a++], s = n[a++]; isNaN(o) || (e = Math.min(o, e), r = Math.max(o, r)), isNaN(s) || (t = Math.min(s, t), i = Math.max(s, i)) } return [[e, t], [r, i]] } function M9(n, e) { var t = E9(n), r = t[0], i = t[1], a = E9(e), o = a[0], s = a[1]; return Math.max(Math.abs(r[0] - o[0]), Math.abs(r[1] - o[1]), Math.abs(i[0] - s[0]), Math.abs(i[1] - s[1])) } function O9(n) { return nn(n) ? n : n ? .5 : 0 } function OGe(n, e, t) { if (!t.valueDim) return []; for (var r = e.count(), i = ll(r * 2), a = 0; a < r; a++) { var o = Nie(t, n, e, a); i[a * 2] = o[0], i[a * 2 + 1] = o[1] } return i } function fu(n, e, t, r, i) { var a = t.getBaseAxis(), o = a.dim === "x" || a.dim === "radius" ? 0 : 1, s = [], l = 0, c = [], u = [], d = [], f = []; if (i) { for (l = 0; l < n.length; l += 2) { var h = e || n; !isNaN(h[l]) && !isNaN(h[l + 1]) && f.push(n[l], n[l + 1]) } n = f } for (l = 0; l < n.length - 2; l += 2)switch (d[0] = n[l + 2], d[1] = n[l + 3], u[0] = n[l], u[1] = n[l + 1], s.push(u[0], u[1]), r) { case "end": c[o] = d[o], c[1 - o] = u[1 - o], s.push(c[0], c[1]); break; case "middle": var p = (u[o] + d[o]) / 2, m = []; c[o] = m[o] = p, c[1 - o] = u[1 - o], m[1 - o] = d[1 - o], s.push(c[0], c[1]), s.push(m[0], m[1]); break; default: c[o] = u[o], c[1 - o] = d[1 - o], s.push(c[0], c[1]) }return s.push(n[l++], n[l++]), s } function DGe(n, e) { var t = [], r = n.length, i, a; function o(u, d, f) { var h = u.coord, p = (f - h) / (d.coord - h), m = z$e(p, [u.color, d.color]); return { coord: f, color: m } } for (var s = 0; s < r; s++) { var l = n[s], c = l.coord; if (c < 0) i = l; else if (c > e) { a ? t.push(o(a, l, e)) : i && t.push(o(i, l, 0), o(i, l, e)); break } else i && (t.push(o(i, l, 0)), i = null), t.push(l), a = l } return t } function jGe(n, e, t) { var r = n.getVisual("visualMeta"); if (!(!r || !r.length || !n.count()) && e.type === "cartesian2d") { for (var i, a, o = r.length - 1; o >= 0; o--) { var s = n.getDimensionInfo(r[o].dimension); if (i = s && s.coordDim, i === "x" || i === "y") { a = r[o]; break } } if (a) { var l = e.getAxis(i), c = Ae(a.stops, function (w) { return { coord: l.toGlobalCoord(l.dataToCoord(w.value)), color: w.color } }), u = c.length, d = a.outerColors.slice(); u && c[0].coord > c[u - 1].coord && (c.reverse(), d.reverse()); var f = DGe(c, i === "x" ? t.getWidth() : t.getHeight()), h = f.length; if (!h && u) return c[0].coord < 0 ? d[1] ? d[1] : c[u - 1].color : d[0] ? d[0] : c[0].color; var p = 10, m = f[0].coord - p, g = f[h - 1].coord + p, y = g - m; if (y < .001) return "transparent"; $(f, function (w) { w.offset = (w.coord - m) / y }), f.push({ offset: h ? f[h - 1].offset : .5, color: d[1] || "transparent" }), f.unshift({ offset: h ? f[0].offset : .5, color: d[0] || "transparent" }); var b = new Sb(0, 0, 0, 0, f, !0); return b[i] = m, b[i + "2"] = g, b } } } function PGe(n, e, t) { var r = n.get("showAllSymbol"), i = r === "auto"; if (!(r && !i)) { var a = t.getAxesByScale("ordinal")[0]; if (a && !(i && IGe(a, e))) { var o = e.mapDimension(a.dim), s = {}; return $(a.getViewLabels(), function (l) { var c = a.scale.getRawOrdinalNumber(l.tickValue); s[c] = 1 }), function (l) { return !s.hasOwnProperty(e.get(o, l)) } } } } function IGe(n, e) { var t = n.getExtent(), r = Math.abs(t[1] - t[0]) / n.scale.count(); isNaN(r) && (r = 0); for (var i = e.count(), a = Math.max(1, Math.round(i / 5)), o = 0; o < i; o += a)if (Ob.getSymbolSize(e, o)[n.isHorizontal() ? 1 : 0] * 1.5 > r) return !1; return !0 } function LGe(n, e) { return isNaN(n) || isNaN(e) } function RGe(n) { for (var e = n.length / 2; e > 0 && LGe(n[e * 2 - 2], n[e * 2 - 1]); e--); return e - 1 } function D9(n, e) { return [n[e * 2], n[e * 2 + 1]] } function NGe(n, e, t) { for (var r = n.length / 2, i = t === "x" ? 0 : 1, a, o, s = 0, l = -1, c = 0; c < r; c++)if (o = n[c * 2 + i], !(isNaN(o) || isNaN(n[c * 2 + 1 - i]))) { if (c === 0) { a = o; continue } if (a <= e && o >= e || a >= e && o <= e) { l = c; break } s = c, a = o } return { range: [s, l], t: (e - a) / (o - a) } } function Vie(n) { if (n.get(["endLabel", "show"])) return !0; for (var e = 0; e < ra.length; e++)if (n.get([ra[e], "endLabel", "show"])) return !0; return !1 } function yO(n, e, t, r) { if (cp(e, "cartesian2d")) { var i = r.getModel("endLabel"), a = i.get("valueAnimation"), o = r.getData(), s = { lastFrameIndex: 0 }, l = Vie(r) ? function (h, p) { n._endLabelOnDuring(h, p, o, s, a, i, e) } : null, c = e.getBaseAxis().isHorizontal(), u = Fie(e, t, r, function () { var h = n._endLabel; h && t && s.originalX != null && h.attr({ x: s.originalX, y: s.originalY }) }, l); if (!r.get("clip", !0)) { var d = u.shape, f = Math.max(d.width, d.height); c ? (d.y -= f, d.height += f * 2) : (d.x -= f, d.width += f * 2) } return l && l(1, u), u } else return zie(e, t, r) } function BGe(n, e) { var t = e.getBaseAxis(), r = t.isHorizontal(), i = t.inverse, a = r ? i ? "right" : "left" : "center", o = r ? "middle" : i ? "top" : "bottom"; return { normal: { align: n.get("align") || a, verticalAlign: n.get("verticalAlign") || o } } } var $Ge = function (n) { te(e, n); function e() { return n !== null && n.apply(this, arguments) || this } return e.prototype.init = function () { var t = new ft, r = new Db; this.group.add(r.group), this._symbolDraw = r, this._lineGroup = t, this._changePolyState = He(this._changePolyState, this) }, e.prototype.render = function (t, r, i) { var a = t.coordinateSystem, o = this.group, s = t.getData(), l = t.getModel("lineStyle"), c = t.getModel("areaStyle"), u = s.getLayout("points") || [], d = a.type === "polar", f = this._coordSys, h = this._symbolDraw, p = this._polyline, m = this._polygon, g = this._lineGroup, y = !r.ssr && t.get("animation"), b = !c.isEmpty(), w = c.get("origin"), v = Rie(a, s, w), S = b && OGe(a, s, v), x = t.get("showSymbol"), k = t.get("connectNulls"), A = x && !d && PGe(t, s, a), C = this._data; C && C.eachItemGraphicEl(function (le, De) { le.__temp && (o.remove(le), C.setItemGraphicEl(De, null)) }), x || h.remove(), o.add(g); var E = d ? !1 : t.get("step"), O; a && a.getArea && t.get("clip", !0) && (O = a.getArea(), O.width != null ? (O.x -= .1, O.y -= .1, O.width += .2, O.height += .2) : O.r0 && (O.r0 -= .5, O.r += .5)), this._clipShapeForSymbol = O; var j = jGe(s, a, i) || s.getVisual("style")[s.getVisual("drawType")]; if (!(p && f.type === a.type && E === this._step)) x && h.updateData(s, { isIgnore: A, clipShape: O, disableAnimation: !0, getSymbolPoint: function (le) { return [u[le * 2], u[le * 2 + 1]] } }), y && this._initSymbolLabelAnimation(s, a, O), E && (S && (S = fu(S, u, a, E, k)), u = fu(u, null, a, E, k)), p = this._newPolyline(u), b ? m = this._newPolygon(u, S) : m && (g.remove(m), m = this._polygon = null), d || this._initOrUpdateEndLabel(t, a, Wh(j)), g.setClipPath(yO(this, a, !0, t)); else { b && !m ? m = this._newPolygon(u, S) : m && !b && (g.remove(m), m = this._polygon = null), d || this._initOrUpdateEndLabel(t, a, Wh(j)); var I = g.getClipPath(); if (I) { var L = yO(this, a, !1, t); Un(I, { shape: L.shape }, t) } else g.setClipPath(yO(this, a, !0, t)); x && h.updateData(s, { isIgnore: A, clipShape: O, disableAnimation: !0, getSymbolPoint: function (le) { return [u[le * 2], u[le * 2 + 1]] } }), (!A9(this._stackedOnPoints, S) || !A9(this._points, u)) && (y ? this._doUpdateAnimation(s, S, a, i, E, w, k) : (E && (S && (S = fu(S, u, a, E, k)), u = fu(u, null, a, E, k)), p.setShape({ points: u }), m && m.setShape({ points: u, stackedOnPoints: S }))) } var R = t.getModel("emphasis"), D = R.get("focus"), P = R.get("blurScope"), B = R.get("disabled"); if (p.useStyle(rt(l.getLineStyle(), { fill: "none", stroke: j, lineJoin: "bevel" })), pi(p, t, "lineStyle"), p.style.lineWidth > 0 && t.get(["emphasis", "lineStyle", "width"]) === "bolder") { var F = p.getState("emphasis").style; F.lineWidth = +p.style.lineWidth + 1 } pt(p).seriesIndex = t.seriesIndex, Qn(p, D, P, B); var K = O9(t.get("smooth")), V = t.get("smoothMonotone"); if (p.setShape({ smooth: K, smoothMonotone: V, connectNulls: k }), m) { var W = s.getCalculationInfo("stackedOnSeries"), J = 0; m.useStyle(rt(c.getAreaStyle(), { fill: j, opacity: .7, lineJoin: "bevel", decal: s.getVisual("style").decal })), W && (J = O9(W.get("smooth"))), m.setShape({ smooth: K, stackedOnSmooth: J, smoothMonotone: V, connectNulls: k }), pi(m, t, "areaStyle"), pt(m).seriesIndex = t.seriesIndex, Qn(m, D, P, B) } var ie = this._changePolyState; s.eachItemGraphicEl(function (le) { le && (le.onHoverStateChange = ie) }), this._polyline.onHoverStateChange = ie, this._data = s, this._coordSys = a, this._stackedOnPoints = S, this._points = u, this._step = E, this._valueOrigin = w, t.get("triggerLineEvent") && (this.packEventData(t, p), m && this.packEventData(t, m)) }, e.prototype.packEventData = function (t, r) { pt(r).eventData = { componentType: "series", componentSubType: "line", componentIndex: t.componentIndex, seriesIndex: t.seriesIndex, seriesName: t.name, seriesType: "line" } }, e.prototype.highlight = function (t, r, i, a) { var o = t.getData(), s = Hh(o, a); if (this._changePolyState("emphasis"), !(s instanceof Array) && s != null && s >= 0) { var l = o.getLayout("points"), c = o.getItemGraphicEl(s); if (!c) { var u = l[s * 2], d = l[s * 2 + 1]; if (isNaN(u) || isNaN(d) || this._clipShapeForSymbol && !this._clipShapeForSymbol.contain(u, d)) return; var f = t.get("zlevel") || 0, h = t.get("z") || 0; c = new Ob(o, s), c.x = u, c.y = d, c.setZ(f, h); var p = c.getSymbolPath().getTextContent(); p && (p.zlevel = f, p.z = h, p.z2 = this._polyline.z2 + 1), c.__temp = !0, o.setItemGraphicEl(s, c), c.stopSymbolAnimation(!0), this.group.add(c) } c.highlight() } else Nn.prototype.highlight.call(this, t, r, i, a) }, e.prototype.downplay = function (t, r, i, a) { var o = t.getData(), s = Hh(o, a); if (this._changePolyState("normal"), s != null && s >= 0) { var l = o.getItemGraphicEl(s); l && (l.__temp ? (o.setItemGraphicEl(s, null), this.group.remove(l)) : l.downplay()) } else Nn.prototype.downplay.call(this, t, r, i, a) }, e.prototype._changePolyState = function (t) { var r = this._polygon; X2(this._polyline, t), r && X2(r, t) }, e.prototype._newPolyline = function (t) { var r = this._polyline; return r && this._lineGroup.remove(r), r = new EGe({ shape: { points: t }, segmentIgnoreThreshold: 2, z2: 10 }), this._lineGroup.add(r), this._polyline = r, r }, e.prototype._newPolygon = function (t, r) { var i = this._polygon; return i && this._lineGroup.remove(i), i = new $ie({ shape: { points: t, stackedOnPoints: r }, segmentIgnoreThreshold: 2 }), this._lineGroup.add(i), this._polygon = i, i }, e.prototype._initSymbolLabelAnimation = function (t, r, i) { var a, o, s = r.getBaseAxis(), l = s.inverse; r.type === "cartesian2d" ? (a = s.isHorizontal(), o = !1) : r.type === "polar" && (a = s.dim === "angle", o = !0); var c = t.hostModel, u = c.get("animationDuration"); tt(u) && (u = u(null)); var d = c.get("animationDelay") || 0, f = tt(d) ? d(null) : d; t.eachItemGraphicEl(function (h, p) { var m = h; if (m) { var g = [h.x, h.y], y = void 0, b = void 0, w = void 0; if (i) if (o) { var v = i, S = r.pointToCoord(g); a ? (y = v.startAngle, b = v.endAngle, w = -S[1] / 180 * Math.PI) : (y = v.r0, b = v.r, w = S[0]) } else { var x = i; a ? (y = x.x, b = x.x + x.width, w = h.x) : (y = x.y + x.height, b = x.y, w = h.y) } var k = b === y ? 0 : (w - y) / (b - y); l && (k = 1 - k); var A = tt(d) ? d(p) : u * k + f, C = m.getSymbolPath(), E = C.getTextContent(); m.attr({ scaleX: 0, scaleY: 0 }), m.animateTo({ scaleX: 1, scaleY: 1 }, { duration: 200, setToFinal: !0, delay: A }), E && E.animateFrom({ style: { opacity: 0 } }, { duration: 300, delay: A }), C.disableLabelAnimation = !0 } }) }, e.prototype._initOrUpdateEndLabel = function (t, r, i) { var a = t.getModel("endLabel"); if (Vie(t)) { var o = t.getData(), s = this._polyline, l = o.getLayout("points"); if (!l) { s.removeTextContent(), this._endLabel = null; return } var c = this._endLabel; c || (c = this._endLabel = new tn({ z2: 200 }), c.ignoreClip = !0, s.setTextContent(this._endLabel), s.disableLabelAnimation = !0); var u = RGe(l); u >= 0 && (mi(s, Ur(t, "endLabel"), { inheritColor: i, labelFetcher: t, labelDataIndex: u, defaultText: function (d, f, h) { return h != null ? Lie(o, h) : Mg(o, d) }, enableTextSetter: !0 }, BGe(a, r)), s.textConfig.position = null) } else this._endLabel && (this._polyline.removeTextContent(), this._endLabel = null) }, e.prototype._endLabelOnDuring = function (t, r, i, a, o, s, l) { var c = this._endLabel, u = this._polyline; if (c) { t < 1 && a.originalX == null && (a.originalX = c.x, a.originalY = c.y); var d = i.getLayout("points"), f = i.hostModel, h = f.get("connectNulls"), p = s.get("precision"), m = s.get("distance") || 0, g = l.getBaseAxis(), y = g.isHorizontal(), b = g.inverse, w = r.shape, v = b ? y ? w.x : w.y + w.height : y ? w.x + w.width : w.y, S = (y ? m : 0) * (b ? -1 : 1), x = (y ? 0 : -m) * (b ? -1 : 1), k = y ? "x" : "y", A = NGe(d, v, k), C = A.range, E = C[1] - C[0], O = void 0; if (E >= 1) { if (E > 1 && !h) { var j = D9(d, C[0]); c.attr({ x: j[0] + S, y: j[1] + x }), o && (O = f.getRawValue(C[0])) } else { var j = u.getPointOn(v, k); j && c.attr({ x: j[0] + S, y: j[1] + x }); var I = f.getRawValue(C[0]), L = f.getRawValue(C[1]); o && (O = ste(i, p, I, L, A.t)) } a.lastFrameIndex = C[0] } else { var R = t === 1 || a.lastFrameIndex > 0 ? C[0] : 0, j = D9(d, R); o && (O = f.getRawValue(R)), c.attr({ x: j[0] + S, y: j[1] + x }) } if (o) { var D = Jg(c); typeof D.setLabelText == "function" && D.setLabelText(O) } } }, e.prototype._doUpdateAnimation = function (t, r, i, a, o, s, l) { var c = this._polyline, u = this._polygon, d = t.hostModel, f = AGe(this._data, t, this._stackedOnPoints, r, this._coordSys, i, this._valueOrigin), h = f.current, p = f.stackedOnCurrent, m = f.next, g = f.stackedOnNext; if (o && (p = fu(f.stackedOnCurrent, f.current, i, o, l), h = fu(f.current, null, i, o, l), g = fu(f.stackedOnNext, f.next, i, o, l), m = fu(f.next, null, i, o, l)), M9(h, m) > 3e3 || u && M9(p, g) > 3e3) { c.stopAnimation(), c.setShape({ points: m }), u && (u.stopAnimation(), u.setShape({ points: m, stackedOnPoints: g })); return } c.shape.__points = f.current, c.shape.points = h; var y = { shape: { points: m } }; f.current !== h && (y.shape.__points = f.next), c.stopAnimation(), on(c, y, d), u && (u.setShape({ points: h, stackedOnPoints: p }), u.stopAnimation(), on(u, { shape: { stackedOnPoints: g } }, d), c.shape.points !== u.shape.points && (u.shape.points = c.shape.points)); for (var b = [], w = f.status, v = 0; v < w.length; v++) { var S = w[v].cmd; if (S === "=") { var x = t.getItemGraphicEl(w[v].idx1); x && b.push({ el: x, ptIdx: v }) } } c.animators && c.animators.length && c.animators[0].during(function () { u && u.dirtyShape(); for (var k = c.shape.__points, A = 0; A < b.length; A++) { var C = b[A].el, E = b[A].ptIdx * 2; C.x = k[E], C.y = k[E + 1], C.markRedraw() } }) }, e.prototype.remove = function (t) { var r = this.group, i = this._data; this._lineGroup.removeAll(), this._symbolDraw.remove(!0), i && i.eachItemGraphicEl(function (a, o) { a.__temp && (r.remove(a), i.setItemGraphicEl(o, null)) }), this._polyline = this._polygon = this._coordSys = this._points = this._stackedOnPoints = this._endLabel = this._data = null }, e.type = "line", e }(Nn); const FGe = $Ge; function Pb(n, e) { return { seriesType: n, plan: iv(), reset: function (t) { var r = t.getData(), i = t.coordinateSystem, a = t.pipelineContext, o = e || a.large; if (i) { var s = Ae(i.dimensions, function (h) { return r.mapDimension(h) }).slice(0, 2), l = s.length, c = r.getCalculationInfo("stackResultDimension"); Md(r, s[0]) && (s[0] = c), Md(r, s[1]) && (s[1] = c); var u = r.getStore(), d = r.getDimensionIndex(s[0]), f = r.getDimensionIndex(s[1]); return l && { progress: function (h, p) { for (var m = h.end - h.start, g = o && ll(m * l), y = [], b = [], w = h.start, v = 0; w < h.end; w++) { var S = void 0; if (l === 1) { var x = u.get(d, w); S = i.dataToPoint(x, null, b) } else y[0] = u.get(d, w), y[1] = u.get(f, w), S = i.dataToPoint(y, null, b); o ? (g[v++] = S[0], g[v++] = S[1]) : p.setItemLayout(w, S.slice()) } o && p.setLayout("points", g) } } } } } } var zGe = { average: function (n) { for (var e = 0, t = 0, r = 0; r < n.length; r++)isNaN(n[r]) || (e += n[r], t++); return t === 0 ? NaN : e / t }, sum: function (n) { for (var e = 0, t = 0; t < n.length; t++)e += n[t] || 0; return e }, max: function (n) { for (var e = -1 / 0, t = 0; t < n.length; t++)n[t] > e && (e = n[t]); return isFinite(e) ? e : NaN }, min: function (n) { for (var e = 1 / 0, t = 0; t < n.length; t++)n[t] < e && (e = n[t]); return isFinite(e) ? e : NaN }, nearest: function (n) { return n[0] } }, VGe = function (n) { return Math.round(n.length / 2) }; function Hie(n) { return { seriesType: n, reset: function (e, t, r) { var i = e.getData(), a = e.get("sampling"), o = e.coordinateSystem, s = i.count(); if (s > 10 && o.type === "cartesian2d" && a) { var l = o.getBaseAxis(), c = o.getOtherAxis(l), u = l.getExtent(), d = r.getDevicePixelRatio(), f = Math.abs(u[1] - u[0]) * (d || 1), h = Math.round(s / f); if (isFinite(h) && h > 1) { a === "lttb" ? e.setData(i.lttbDownSample(i.mapDimension(c.dim), 1 / h)) : a === "minmax" && e.setData(i.minmaxDownSample(i.mapDimension(c.dim), 1 / h)); var p = void 0; Fe(a) ? p = zGe[a] : tt(a) && (p = a), p && e.setData(i.downSample(i.mapDimension(c.dim), 1 / h, p, VGe)) } } } } } function HGe(n) { n.registerChartView(FGe), n.registerSeriesModel(wGe), n.registerLayout(Pb("line", !0)), n.registerVisual({ seriesType: "line", reset: function (e) { var t = e.getData(), r = e.getModel("lineStyle").getLineStyle(); r && !r.stroke && (r.stroke = t.getVisual("style").fill), t.setVisual("legendLineStyle", r) } }), n.registerProcessor(n.PRIORITY.PROCESSOR.STATISTIC, Hie("line")) } var Uie = function (n) { te(e, n); function e() { var t = n !== null && n.apply(this, arguments) || this; return t.type = e.type, t } return e.prototype.getInitialData = function (t, r) { return Hc(null, this, { useEncodeDefaulter: !0 }) }, e.prototype.getMarkerPosition = function (t, r, i) { var a = this.coordinateSystem; if (a && a.clampData) { var o = a.clampData(t), s = a.dataToPoint(o); if (i) $(a.getAxes(), function (f, h) { if (f.type === "category" && r != null) { var p = f.getTicksCoords(), m = f.getTickModel().get("alignWithLabel"), g = o[h], y = r[h] === "x1" || r[h] === "y1"; if (y && !m && (g += 1), p.length < 2) return; if (p.length === 2) { s[h] = f.toGlobalCoord(f.getExtent()[y ? 1 : 0]); return } for (var b = void 0, w = void 0, v = 1, S = 0; S < p.length; S++) { var x = p[S].coord, k = S === p.length - 1 ? p[S - 1].tickValue + v : p[S].tickValue; if (k === g) { w = x; break } else if (k < g) b = x; else if (b != null && k > g) { w = (x + b) / 2; break } S === 1 && (v = k - p[0].tickValue) } w == null && (b ? b && (w = p[p.length - 1].coord) : w = p[0].coord), s[h] = f.toGlobalCoord(w) } }); else { var l = this.getData(), c = l.getLayout("offset"), u = l.getLayout("size"), d = a.getBaseAxis().isHorizontal() ? 0 : 1; s[d] += c + u / 2 } return s } return [NaN, NaN] }, e.type = "series.__base_bar__", e.defaultOption = { z: 2, coordinateSystem: "cartesian2d", legendHoverLink: !0, barMinHeight: 0, barMinAngle: 0, large: !1, largeThreshold: 400, progressive: 3e3, progressiveChunkMode: "mod" }, e }(Yn); Yn.registerClass(Uie); const gT = Uie; var UGe = function (n) { te(e, n); function e() { var t = n !== null && n.apply(this, arguments) || this; return t.type = e.type, t } return e.prototype.getInitialData = function () { return Hc(null, this, { useEncodeDefaulter: !0, createInvertedIndices: !!this.get("realtimeSort", !0) || null }) }, e.prototype.getProgressive = function () { return this.get("large") ? this.get("progressive") : !1 }, e.prototype.getProgressiveThreshold = function () { var t = this.get("progressiveThreshold"), r = this.get("largeThreshold"); return r > t && (t = r), t }, e.prototype.brushSelector = function (t, r, i) { return i.rect(r.getItemLayout(t)) }, e.type = "series.bar", e.dependencies = ["grid", "polar"], e.defaultOption = Wd(gT.defaultOption, { clip: !0, roundCap: !1, showBackground: !1, backgroundStyle: { color: "rgba(180, 180, 180, 0.2)", borderColor: null, borderWidth: 0, borderType: "solid", borderRadius: 0, shadowBlur: 0, shadowColor: null, shadowOffsetX: 0, shadowOffsetY: 0, opacity: 1 }, select: { itemStyle: { borderColor: "#212121" } }, realtimeSort: !1 }), e }(gT); const GGe = UGe; var WGe = function () { function n() { this.cx = 0, this.cy = 0, this.r0 = 0, this.r = 0, this.startAngle = 0, this.endAngle = Math.PI * 2, this.clockwise = !0 } return n }(), KGe = function (n) { te(e, n); function e(t) { var r = n.call(this, t) || this; return r.type = "sausage", r } return e.prototype.getDefaultShape = function () { return new WGe }, e.prototype.buildPath = function (t, r) { var i = r.cx, a = r.cy, o = Math.max(r.r0 || 0, 0), s = Math.max(r.r, 0), l = (s - o) * .5, c = o + l, u = r.startAngle, d = r.endAngle, f = r.clockwise, h = Math.PI * 2, p = f ? d - u < h : u - d < h; p || (u = d - (f ? h : -h)); var m = Math.cos(u), g = Math.sin(u), y = Math.cos(d), b = Math.sin(d); p ? (t.moveTo(m * o + i, g * o + a), t.arc(m * c + i, g * c + a, l, -Math.PI + u, u, !f)) : t.moveTo(m * s + i, g * s + a), t.arc(i, a, s, u, d, !f), t.arc(y * c + i, b * c + a, l, d - Math.PI * 2, d - Math.PI, !f), o !== 0 && t.arc(i, a, o, d, u, f) }, e }(Nt); const vT = KGe; function qGe(n, e) { e = e || {}; var t = e.isRoundCap; return function (r, i, a) { var o = i.position; if (!o || o instanceof Array) return Y2(r, i, a); var s = n(o), l = i.distance != null ? i.distance : 5, c = this.shape, u = c.cx, d = c.cy, f = c.r, h = c.r0, p = (f + h) / 2, m = c.startAngle, g = c.endAngle, y = (m + g) / 2, b = t ? Math.abs(f - h) / 2 : 0, w = Math.cos, v = Math.sin, S = u + f * w(m), x = d + f * v(m), k = "left", A = "top"; switch (s) { case "startArc": S = u + (h - l) * w(y), x = d + (h - l) * v(y), k = "center", A = "top"; break; case "insideStartArc": S = u + (h + l) * w(y), x = d + (h + l) * v(y), k = "center", A = "bottom"; break; case "startAngle": S = u + p * w(m) + ix(m, l + b, !1), x = d + p * v(m) + ax(m, l + b, !1), k = "right", A = "middle"; break; case "insideStartAngle": S = u + p * w(m) + ix(m, -l + b, !1), x = d + p * v(m) + ax(m, -l + b, !1), k = "left", A = "middle"; break; case "middle": S = u + p * w(y), x = d + p * v(y), k = "center", A = "middle"; break; case "endArc": S = u + (f + l) * w(y), x = d + (f + l) * v(y), k = "center", A = "bottom"; break; case "insideEndArc": S = u + (f - l) * w(y), x = d + (f - l) * v(y), k = "center", A = "top"; break; case "endAngle": S = u + p * w(g) + ix(g, l + b, !0), x = d + p * v(g) + ax(g, l + b, !0), k = "left", A = "middle"; break; case "insideEndAngle": S = u + p * w(g) + ix(g, -l + b, !0), x = d + p * v(g) + ax(g, -l + b, !0), k = "right", A = "middle"; break; default: return Y2(r, i, a) }return r = r || {}, r.x = S, r.y = x, r.align = k, r.verticalAlign = A, r } } function YGe(n, e, t, r) { if (nn(r)) { n.setTextConfig({ rotation: r }); return } else if (ke(e)) { n.setTextConfig({ rotation: 0 }); return } var i = n.shape, a = i.clockwise ? i.startAngle : i.endAngle, o = i.clockwise ? i.endAngle : i.startAngle, s = (a + o) / 2, l, c = t(e); switch (c) { case "startArc": case "insideStartArc": case "middle": case "insideEndArc": case "endArc": l = s; break; case "startAngle": case "insideStartAngle": l = a; break; case "endAngle": case "insideEndAngle": l = o; break; default: n.setTextConfig({ rotation: 0 }); return }var u = Math.PI * 1.5 - l; c === "middle" && u > Math.PI / 2 && u < Math.PI * 1.5 && (u -= Math.PI), n.setTextConfig({ rotation: u }) } function ix(n, e, t) { return e * Math.sin(n) * (t ? -1 : 1) } function ax(n, e, t) { return e * Math.cos(n) * (t ? 1 : -1) } function oh(n, e, t) { var r = n.get("borderRadius"); if (r == null) return t ? { cornerRadius: 0 } : null; ke(r) || (r = [r, r, r, r]); var i = Math.abs(e.r || 0 - e.r0 || 0); return { cornerRadius: Ae(r, function (a) { return Es(a, i) }) } } var _O = Math.max, bO = Math.min; function ZGe(n, e) { var t = n.getArea && n.getArea(); if (cp(n, "cartesian2d")) { var r = n.getBaseAxis(); if (r.type !== "category" || !r.onBand) { var i = e.getLayout("bandWidth"); r.isHorizontal() ? (t.x -= i, t.width += i * 2) : (t.y -= i, t.height += i * 2) } } return t } var XGe = function (n) { te(e, n); function e() { var t = n.call(this) || this; return t.type = e.type, t._isFirstFrame = !0, t } return e.prototype.render = function (t, r, i, a) { this._model = t, this._removeOnRenderedListener(i), this._updateDrawMode(t); var o = t.get("coordinateSystem"); (o === "cartesian2d" || o === "polar") && (this._progressiveEls = null, this._isLargeDraw ? this._renderLarge(t, r, i) : this._renderNormal(t, r, i, a)) }, e.prototype.incrementalPrepareRender = function (t) { this._clear(), this._updateDrawMode(t), this._updateLargeClip(t) }, e.prototype.incrementalRender = function (t, r) { this._progressiveEls = [], this._incrementalRenderLarge(t, r) }, e.prototype.eachRendered = function (t) { Gd(this._progressiveEls || this.group, t) }, e.prototype._updateDrawMode = function (t) { var r = t.pipelineContext.large; (this._isLargeDraw == null || r !== this._isLargeDraw) && (this._isLargeDraw = r, this._clear()) }, e.prototype._renderNormal = function (t, r, i, a) { var o = this.group, s = t.getData(), l = this._data, c = t.coordinateSystem, u = c.getBaseAxis(), d; c.type === "cartesian2d" ? d = u.isHorizontal() : c.type === "polar" && (d = u.dim === "angle"); var f = t.isAnimationEnabled() ? t : null, h = JGe(t, c); h && this._enableRealtimeSort(h, s, i); var p = t.get("clip", !0) || h, m = ZGe(c, s); o.removeClipPath(); var g = t.get("roundCap", !0), y = t.get("showBackground", !0), b = t.getModel("backgroundStyle"), w = b.get("borderRadius") || 0, v = [], S = this._backgroundEls, x = a && a.isInitSort, k = a && a.type === "changeAxisOrder"; function A(O) { var j = ox[c.type](s, O), I = aWe(c, d, j); return I.useStyle(b.getItemStyle()), c.type === "cartesian2d" ? I.setShape("r", w) : I.setShape("cornerRadius", w), v[O] = I, I } s.diff(l).add(function (O) { var j = s.getItemModel(O), I = ox[c.type](s, O, j); if (y && A(O), !(!s.hasValue(O) || !R9[c.type](I))) { var L = !1; p && (L = j9[c.type](m, I)); var R = P9[c.type](t, s, O, I, d, f, u.model, !1, g); h && (R.forceLabelAnimation = !0), N9(R, s, O, j, I, t, d, c.type === "polar"), x ? R.attr({ shape: I }) : h ? I9(h, f, R, I, O, d, !1, !1) : Un(R, { shape: I }, t, O), s.setItemGraphicEl(O, R), o.add(R), R.ignore = L } }).update(function (O, j) { var I = s.getItemModel(O), L = ox[c.type](s, O, I); if (y) { var R = void 0; S.length === 0 ? R = A(j) : (R = S[j], R.useStyle(b.getItemStyle()), c.type === "cartesian2d" ? R.setShape("r", w) : R.setShape("cornerRadius", w), v[O] = R); var D = ox[c.type](s, O), P = Wie(d, D, c); on(R, { shape: P }, f, O) } var B = l.getItemGraphicEl(j); if (!s.hasValue(O) || !R9[c.type](L)) { o.remove(B); return } var F = !1; if (p && (F = j9[c.type](m, L), F && o.remove(B)), B ? Ms(B) : B = P9[c.type](t, s, O, L, d, f, u.model, !!B, g), h && (B.forceLabelAnimation = !0), k) { var K = B.getTextContent(); if (K) { var V = Jg(K); V.prevValue != null && (V.prevValue = V.value) } } else N9(B, s, O, I, L, t, d, c.type === "polar"); x ? B.attr({ shape: L }) : h ? I9(h, f, B, L, O, d, !0, k) : on(B, { shape: L }, t, O, null), s.setItemGraphicEl(O, B), B.ignore = F, o.add(B) }).remove(function (O) { var j = l.getItemGraphicEl(O); j && __(j, t, O) }).execute(); var C = this._backgroundGroup || (this._backgroundGroup = new ft); C.removeAll(); for (var E = 0; E < v.length; ++E)C.add(v[E]); o.add(C), this._backgroundEls = v, this._data = s }, e.prototype._renderLarge = function (t, r, i) { this._clear(), $9(t, this.group), this._updateLargeClip(t) }, e.prototype._incrementalRenderLarge = function (t, r) { this._removeBackground(), $9(r, this.group, this._progressiveEls, !0) }, e.prototype._updateLargeClip = function (t) { var r = t.get("clip", !0) && jb(t.coordinateSystem, !1, t), i = this.group; r ? i.setClipPath(r) : i.removeClipPath() }, e.prototype._enableRealtimeSort = function (t, r, i) { var a = this; if (r.count()) { var o = t.baseAxis; if (this._isFirstFrame) this._dispatchInitSort(r, t, i), this._isFirstFrame = !1; else { var s = function (l) { var c = r.getItemGraphicEl(l), u = c && c.shape; return u && Math.abs(o.isHorizontal() ? u.height : u.width) || 0 }; this._onRendered = function () { a._updateSortWithinSameData(r, s, o, i) }, i.getZr().on("rendered", this._onRendered) } } }, e.prototype._dataSort = function (t, r, i) { var a = []; return t.each(t.mapDimension(r.dim), function (o, s) { var l = i(s); l = l ?? NaN, a.push({ dataIndex: s, mappedValue: l, ordinalNumber: o }) }), a.sort(function (o, s) { return s.mappedValue - o.mappedValue }), { ordinalNumbers: Ae(a, function (o) { return o.ordinalNumber }) } }, e.prototype._isOrderChangedWithinSameData = function (t, r, i) { for (var a = i.scale, o = t.mapDimension(i.dim), s = Number.MAX_VALUE, l = 0, c = a.getOrdinalMeta().categories.length; l < c; ++l) { var u = t.rawIndexOf(o, a.getRawOrdinalNumber(l)), d = u < 0 ? Number.MIN_VALUE : r(t.indexOfRawIndex(u)); if (d > s) return !0; s = d } return !1 }, e.prototype._isOrderDifferentInView = function (t, r) { for (var i = r.scale, a = i.getExtent(), o = Math.max(0, a[0]), s = Math.min(a[1], i.getOrdinalMeta().categories.length - 1); o <= s; ++o)if (t.ordinalNumbers[o] !== i.getRawOrdinalNumber(o)) return !0 }, e.prototype._updateSortWithinSameData = function (t, r, i, a) { if (this._isOrderChangedWithinSameData(t, r, i)) { var o = this._dataSort(t, i, r); this._isOrderDifferentInView(o, i) && (this._removeOnRenderedListener(a), a.dispatchAction({ type: "changeAxisOrder", componentType: i.dim + "Axis", axisId: i.index, sortInfo: o })) } }, e.prototype._dispatchInitSort = function (t, r, i) { var a = r.baseAxis, o = this._dataSort(t, a, function (s) { return t.get(t.mapDimension(r.otherAxis.dim), s) }); i.dispatchAction({ type: "changeAxisOrder", componentType: a.dim + "Axis", isInitSort: !0, axisId: a.index, sortInfo: o }) }, e.prototype.remove = function (t, r) { this._clear(this._model), this._removeOnRenderedListener(r) }, e.prototype.dispose = function (t, r) { this._removeOnRenderedListener(r) }, e.prototype._removeOnRenderedListener = function (t) { this._onRendered && (t.getZr().off("rendered", this._onRendered), this._onRendered = null) }, e.prototype._clear = function (t) { var r = this.group, i = this._data; t && t.isAnimationEnabled() && i && !this._isLargeDraw ? (this._removeBackground(), this._backgroundEls = [], i.eachItemGraphicEl(function (a) { __(a, t, pt(a).dataIndex) })) : r.removeAll(), this._data = null, this._isFirstFrame = !0 }, e.prototype._removeBackground = function () { this.group.remove(this._backgroundGroup), this._backgroundGroup = null }, e.type = "bar", e }(Nn), j9 = { cartesian2d: function (n, e) { var t = e.width < 0 ? -1 : 1, r = e.height < 0 ? -1 : 1; t < 0 && (e.x += e.width, e.width = -e.width), r < 0 && (e.y += e.height, e.height = -e.height); var i = n.x + n.width, a = n.y + n.height, o = _O(e.x, n.x), s = bO(e.x + e.width, i), l = _O(e.y, n.y), c = bO(e.y + e.height, a), u = s < o, d = c < l; return e.x = u && o > i ? s : o, e.y = d && l > a ? c : l, e.width = u ? 0 : s - o, e.height = d ? 0 : c - l, t < 0 && (e.x += e.width, e.width = -e.width), r < 0 && (e.y += e.height, e.height = -e.height), u || d }, polar: function (n, e) { var t = e.r0 <= e.r ? 1 : -1; if (t < 0) { var r = e.r; e.r = e.r0, e.r0 = r } var i = bO(e.r, n.r), a = _O(e.r0, n.r0); e.r = i, e.r0 = a; var o = i - a < 0; if (t < 0) { var r = e.r; e.r = e.r0, e.r0 = r } return o } }, P9 = { cartesian2d: function (n, e, t, r, i, a, o, s, l) { var c = new Yt({ shape: be({}, r), z2: 1 }); if (c.__dataIndex = t, c.name = "item", a) { var u = c.shape, d = i ? "height" : "width"; u[d] = 0 } return c }, polar: function (n, e, t, r, i, a, o, s, l) { var c = !i && l ? vT : Ca, u = new c({ shape: r, z2: 1 }); u.name = "item"; var d = Gie(i); if (u.calculateTextPosition = qGe(d, { isRoundCap: c === vT }), a) { var f = u.shape, h = i ? "r" : "endAngle", p = {}; f[h] = i ? r.r0 : r.startAngle, p[h] = r[h], (s ? on : Un)(u, { shape: p }, a) } return u } }; function JGe(n, e) { var t = n.get("realtimeSort", !0), r = e.getBaseAxis(); if (t && r.type === "category" && e.type === "cartesian2d") return { baseAxis: r, otherAxis: e.getOtherAxis(r) } } function I9(n, e, t, r, i, a, o, s) { var l, c; a ? (c = { x: r.x, width: r.width }, l = { y: r.y, height: r.height }) : (c = { y: r.y, height: r.height }, l = { x: r.x, width: r.width }), s || (o ? on : Un)(t, { shape: l }, e, i, null); var u = e ? n.baseAxis.model : null; (o ? on : Un)(t, { shape: c }, u, i) } function L9(n, e) { for (var t = 0; t < e.length; t++)if (!isFinite(n[e[t]])) return !0; return !1 } var QGe = ["x", "y", "width", "height"], eWe = ["cx", "cy", "r", "startAngle", "endAngle"], R9 = { cartesian2d: function (n) { return !L9(n, QGe) }, polar: function (n) { return !L9(n, eWe) } }, ox = { cartesian2d: function (n, e, t) { var r = n.getItemLayout(e), i = t ? nWe(t, r) : 0, a = r.width > 0 ? 1 : -1, o = r.height > 0 ? 1 : -1; return { x: r.x + a * i / 2, y: r.y + o * i / 2, width: r.width - a * i, height: r.height - o * i } }, polar: function (n, e, t) { var r = n.getItemLayout(e); return { cx: r.cx, cy: r.cy, r0: r.r0, r: r.r, startAngle: r.startAngle, endAngle: r.endAngle, clockwise: r.clockwise } } }; function tWe(n) { return n.startAngle != null && n.endAngle != null && n.startAngle === n.endAngle } function Gie(n) { return function (e) { var t = e ? "Arc" : "Angle"; return function (r) { switch (r) { case "start": case "insideStart": case "end": case "insideEnd": return r + t; default: return r } } }(n) } function N9(n, e, t, r, i, a, o, s) { var l = e.getItemVisual(t, "style"); if (s) { if (!a.get("roundCap")) { var u = n.shape, d = oh(r.getModel("itemStyle"), u, !0); be(u, d), n.setShape(u) } } else { var c = r.get(["itemStyle", "borderRadius"]) || 0; n.setShape("r", c) } n.useStyle(l); var f = r.getShallow("cursor"); f && n.attr("cursor", f); var h = s ? o ? i.r >= i.r0 ? "endArc" : "startArc" : i.endAngle >= i.startAngle ? "endAngle" : "startAngle" : o ? i.height >= 0 ? "bottom" : "top" : i.width >= 0 ? "right" : "left", p = Ur(r); mi(n, p, { labelFetcher: a, labelDataIndex: t, defaultText: Mg(a.getData(), t), inheritColor: l.fill, defaultOpacity: l.opacity, defaultOutsidePosition: h }); var m = n.getTextContent(); if (s && m) { var g = r.get(["label", "position"]); n.textConfig.inside = g === "middle" ? !0 : null, YGe(n, g === "outside" ? h : g, Gie(o), r.get(["label", "rotate"])) } rne(m, p, a.getRawValue(t), function (b) { return Lie(e, b) }); var y = r.getModel(["emphasis"]); Qn(n, y.get("focus"), y.get("blurScope"), y.get("disabled")), pi(n, r), tWe(i) && (n.style.fill = "none", n.style.stroke = "none", $(n.states, function (b) { b.style && (b.style.fill = b.style.stroke = "none") })) } function nWe(n, e) { var t = n.get(["itemStyle", "borderColor"]); if (!t || t === "none") return 0; var r = n.get(["itemStyle", "borderWidth"]) || 0, i = isNaN(e.width) ? Number.MAX_VALUE : Math.abs(e.width), a = isNaN(e.height) ? Number.MAX_VALUE : Math.abs(e.height); return Math.min(r, i, a) } var rWe = function () { function n() { } return n }(), B9 = function (n) { te(e, n); function e(t) { var r = n.call(this, t) || this; return r.type = "largeBar", r } return e.prototype.getDefaultShape = function () { return new rWe }, e.prototype.buildPath = function (t, r) { for (var i = r.points, a = this.baseDimIdx, o = 1 - this.baseDimIdx, s = [], l = [], c = this.barWidth, u = 0; u < i.length; u += 3)l[a] = c, l[o] = i[u + 2], s[a] = i[u + a], s[o] = i[u + o], t.rect(s[0], s[1], l[0], l[1]) }, e }(Nt); function $9(n, e, t, r) { var i = n.getData(), a = i.getLayout("valueAxisHorizontal") ? 1 : 0, o = i.getLayout("largeDataIndices"), s = i.getLayout("size"), l = n.getModel("backgroundStyle"), c = i.getLayout("largeBackgroundPoints"); if (c) { var u = new B9({ shape: { points: c }, incremental: !!r, silent: !0, z2: 0 }); u.baseDimIdx = a, u.largeDataIndices = o, u.barWidth = s, u.useStyle(l.getItemStyle()), e.add(u), t && t.push(u) } var d = new B9({ shape: { points: i.getLayout("largePoints") }, incremental: !!r, ignoreCoarsePointer: !0, z2: 1 }); d.baseDimIdx = a, d.largeDataIndices = o, d.barWidth = s, e.add(d), d.useStyle(i.getVisual("style")), d.style.stroke = null, pt(d).seriesIndex = n.seriesIndex, n.get("silent") || (d.on("mousedown", F9), d.on("mousemove", F9)), t && t.push(d) } var F9 = c3(function (n) { var e = this, t = iWe(e, n.offsetX, n.offsetY); pt(e).dataIndex = t >= 0 ? t : null }, 30, !1); function iWe(n, e, t) { for (var r = n.baseDimIdx, i = 1 - r, a = n.shape.points, o = n.largeDataIndices, s = [], l = [], c = n.barWidth, u = 0, d = a.length / 3; u < d; u++) { var f = u * 3; if (l[r] = c, l[i] = a[f + 2], s[r] = a[f + r], s[i] = a[f + i], l[i] < 0 && (s[i] += l[i], l[i] = -l[i]), e >= s[0] && e <= s[0] + l[0] && t >= s[1] && t <= s[1] + l[1]) return o[u] } return -1 } function Wie(n, e, t) { if (cp(t, "cartesian2d")) { var r = e, i = t.getArea(); return { x: n ? r.x : i.x, y: n ? i.y : r.y, width: n ? r.width : i.width, height: n ? i.height : r.height } } else { var i = t.getArea(), a = e; return { cx: i.cx, cy: i.cy, r0: n ? i.r0 : a.r0, r: n ? i.r : a.r, startAngle: n ? a.startAngle : 0, endAngle: n ? a.endAngle : Math.PI * 2 } } } function aWe(n, e, t) { var r = n.type === "polar" ? Ca : Yt; return new r({ shape: Wie(e, t, n), silent: !0, z2: 0 }) } const oWe = XGe; function sWe(n) { n.registerChartView(oWe), n.registerSeriesModel(GGe), n.registerLayout(n.PRIORITY.VISUAL.LAYOUT, wt(qre, "bar")), n.registerLayout(n.PRIORITY.VISUAL.PROGRESSIVE_LAYOUT, Yre("bar")), n.registerProcessor(n.PRIORITY.PROCESSOR.STATISTIC, Hie("bar")), n.registerAction({ type: "changeAxisOrder", event: "changeAxisOrder", update: "update" }, function (e, t) { var r = e.componentType || "series"; t.eachComponent({ mainType: r, query: e }, function (i) { e.sortInfo && i.axis.setCategorySortInfo(e.sortInfo) }) }) } var z9 = Math.PI * 2, sx = Math.PI / 180; function Kie(n, e) { return jr(n.getBoxLayoutParams(), { width: e.getWidth(), height: e.getHeight() }) } function qie(n, e) { var t = Kie(n, e), r = n.get("center"), i = n.get("radius"); ke(i) || (i = [0, i]); var a = Ne(t.width, e.getWidth()), o = Ne(t.height, e.getHeight()), s = Math.min(a, o), l = Ne(i[0], s / 2), c = Ne(i[1], s / 2), u, d, f = n.coordinateSystem; if (f) { var h = f.dataToPoint(r); u = h[0] || 0, d = h[1] || 0 } else ke(r) || (r = [r, r]), u = Ne(r[0], a) + t.x, d = Ne(r[1], o) + t.y; return { cx: u, cy: d, r0: l, r: c } } function lWe(n, e, t) { e.eachSeriesByType(n, function (r) { var i = r.getData(), a = i.mapDimension("value"), o = Kie(r, t), s = qie(r, t), l = s.cx, c = s.cy, u = s.r, d = s.r0, f = -r.get("startAngle") * sx, h = r.get("endAngle"), p = r.get("padAngle") * sx; h = h === "auto" ? f - z9 : -h * sx; var m = r.get("minAngle") * sx, g = m + p, y = 0; i.each(a, function (P) { !isNaN(P) && y++ }); var b = i.getSum(a), w = Math.PI / (b || y) * 2, v = r.get("clockwise"), S = r.get("roseType"), x = r.get("stillShowZeroSum"), k = i.getDataExtent(a); k[0] = 0; var A = v ? 1 : -1, C = [f, h], E = A * p / 2; LN(C, !v), f = C[0], h = C[1]; var O = Yie(r); O.startAngle = f, O.endAngle = h, O.clockwise = v; var j = Math.abs(h - f), I = j, L = 0, R = f; if (i.setLayout({ viewRect: o, r: u }), i.each(a, function (P, B) { var F; if (isNaN(P)) { i.setItemLayout(B, { angle: NaN, startAngle: NaN, endAngle: NaN, clockwise: v, cx: l, cy: c, r0: d, r: S ? NaN : u }); return } S !== "area" ? F = b === 0 && x ? w : P * w : F = j / y, F < g ? (F = g, I -= g) : L += P; var K = R + A * F, V = 0, W = 0; p > F ? (V = R + A * F / 2, W = V) : (V = R + E, W = K - E), i.setItemLayout(B, { angle: F, startAngle: V, endAngle: W, clockwise: v, cx: l, cy: c, r0: d, r: S ? vn(P, k, [d, u]) : u }), R = K }), I < z9 && y) if (I <= .001) { var D = j / y; i.each(a, function (P, B) { if (!isNaN(P)) { var F = i.getItemLayout(B); F.angle = D; var K = 0, V = 0; D < p ? (K = f + A * (B + 1 / 2) * D, V = K) : (K = f + A * B * D + E, V = f + A * (B + 1) * D - E), F.startAngle = K, F.endAngle = V } }) } else w = I / L, R = f, i.each(a, function (P, B) { if (!isNaN(P)) { var F = i.getItemLayout(B), K = F.angle === g ? g : P * w, V = 0, W = 0; K < p ? (V = R + A * K / 2, W = V) : (V = R + E, W = R + A * K - E), F.startAngle = V, F.endAngle = W, R += A * K } }) }) } var Yie = Kt(); function Ib(n) { return { seriesType: n, reset: function (e, t) { var r = t.findComponents({ mainType: "legend" }); if (!(!r || !r.length)) { var i = e.getData(); i.filterSelf(function (a) { for (var o = i.getName(a), s = 0; s < r.length; s++)if (!r[s].isSelected(o)) return !1; return !0 }) } } } } var cWe = Math.PI / 180; function V9(n, e, t, r, i, a, o, s, l, c) { if (n.length < 2) return; function u(m) { for (var g = m.rB, y = g * g, b = 0; b < m.list.length; b++) { var w = m.list[b], v = Math.abs(w.label.y - t), S = r + w.len, x = S * S, k = Math.sqrt(Math.abs((1 - v * v / y) * x)), A = e + (k + w.len2) * i, C = A - w.label.x, E = w.targetTextWidth - C * i; Zie(w, E, !0), w.label.x = A } } function d(m) { for (var g = { list: [], maxY: 0 }, y = { list: [], maxY: 0 }, b = 0; b < m.length; b++)if (m[b].labelAlignTo === "none") { var w = m[b], v = w.label.y > t ? y : g, S = Math.abs(w.label.y - t); if (S >= v.maxY) { var x = w.label.x - e - w.len2 * i, k = r + w.len, A = Math.abs(x) < k ? Math.sqrt(S * S / (1 - x * x / k / k)) : k; v.rB = A, v.maxY = S } v.list.push(w) } u(g), u(y) } for (var f = n.length, h = 0; h < f; h++)if (n[h].position === "outer" && n[h].labelAlignTo === "labelLine") { var p = n[h].label.x - c; n[h].linePoints[1][0] += p, n[h].label.x = c } yie(n, l, l + o) && d(n) } function uWe(n, e, t, r, i, a, o, s) { for (var l = [], c = [], u = Number.MAX_VALUE, d = -Number.MAX_VALUE, f = 0; f < n.length; f++) { var h = n[f].label; wO(n[f]) || (h.x < e ? (u = Math.min(u, h.x), l.push(n[f])) : (d = Math.max(d, h.x), c.push(n[f]))) } for (var f = 0; f < n.length; f++) { var p = n[f]; if (!wO(p) && p.linePoints) { if (p.labelStyleWidth != null) continue; var h = p.label, m = p.linePoints, g = void 0; p.labelAlignTo === "edge" ? h.x < e ? g = m[2][0] - p.labelDistance - o - p.edgeDistance : g = o + i - p.edgeDistance - m[2][0] - p.labelDistance : p.labelAlignTo === "labelLine" ? h.x < e ? g = u - o - p.bleedMargin : g = o + i - d - p.bleedMargin : h.x < e ? g = h.x - o - p.bleedMargin : g = o + i - h.x - p.bleedMargin, p.targetTextWidth = g, Zie(p, g) } } V9(c, e, t, r, 1, i, a, o, s, d), V9(l, e, t, r, -1, i, a, o, s, u); for (var f = 0; f < n.length; f++) { var p = n[f]; if (!wO(p) && p.linePoints) { var h = p.label, m = p.linePoints, y = p.labelAlignTo === "edge", b = h.style.padding, w = b ? b[1] + b[3] : 0, v = h.style.backgroundColor ? 0 : w, S = p.rect.width + v, x = m[1][0] - m[2][0]; y ? h.x < e ? m[2][0] = o + p.edgeDistance + S + p.labelDistance : m[2][0] = o + i - p.edgeDistance - S - p.labelDistance : (h.x < e ? m[2][0] = h.x + p.labelDistance : m[2][0] = h.x - p.labelDistance, m[1][0] = m[2][0] + x), m[1][1] = m[2][1] = h.y } } } function Zie(n, e, t) { if (t === void 0 && (t = !1), n.labelStyleWidth == null) { var r = n.label, i = r.style, a = n.rect, o = i.backgroundColor, s = i.padding, l = s ? s[1] + s[3] : 0, c = i.overflow, u = a.width + (o ? 0 : l); if (e < u || t) { var d = a.height; if (c && c.match("break")) { r.setStyle("backgroundColor", null), r.setStyle("width", e - l); var f = r.getBoundingRect(); r.setStyle("width", Math.ceil(f.width)), r.setStyle("backgroundColor", o) } else { var h = e - l, p = e < u ? h : t ? h > n.unconstrainedWidth ? null : h : null; r.setStyle("width", p) } var m = r.getBoundingRect(); a.width = m.width; var g = (r.style.margin || 0) + 2.1; a.height = m.height + g, a.y -= (a.height - d) / 2 } } } function wO(n) { return n.position === "center" } function dWe(n) { var e = n.getData(), t = [], r, i, a = !1, o = (n.get("minShowLabelAngle") || 0) * cWe, s = e.getLayout("viewRect"), l = e.getLayout("r"), c = s.width, u = s.x, d = s.y, f = s.height; function h(x) { x.ignore = !0 } function p(x) { if (!x.ignore) return !0; for (var k in x.states) if (x.states[k].ignore === !1) return !0; return !1 } e.each(function (x) { var k = e.getItemGraphicEl(x), A = k.shape, C = k.getTextContent(), E = k.getTextGuideLine(), O = e.getItemModel(x), j = O.getModel("label"), I = j.get("position") || O.get(["emphasis", "label", "position"]), L = j.get("distanceToLabelLine"), R = j.get("alignTo"), D = Ne(j.get("edgeDistance"), c), P = j.get("bleedMargin"), B = O.getModel("labelLine"), F = B.get("length"); F = Ne(F, c); var K = B.get("length2"); if (K = Ne(K, c), Math.abs(A.endAngle - A.startAngle) < o) { $(C.states, h), C.ignore = !0, E && ($(E.states, h), E.ignore = !0); return } if (p(C)) { var V = (A.startAngle + A.endAngle) / 2, W = Math.cos(V), J = Math.sin(V), ie, le, De, ae; r = A.cx, i = A.cy; var pe = I === "inside" || I === "inner"; if (I === "center") ie = A.cx, le = A.cy, ae = "center"; else { var se = (pe ? (A.r + A.r0) / 2 * W : A.r * W) + r, ge = (pe ? (A.r + A.r0) / 2 * J : A.r * J) + i; if (ie = se + W * 3, le = ge + J * 3, !pe) { var _e = se + W * (F + l - A.r), je = ge + J * (F + l - A.r), U = _e + (W < 0 ? -1 : 1) * K, q = je; R === "edge" ? ie = W < 0 ? u + D : u + c - D : ie = U + (W < 0 ? -L : L), le = q, De = [[se, ge], [_e, je], [U, q]] } ae = pe ? "center" : R === "edge" ? W > 0 ? "right" : "left" : W > 0 ? "left" : "right" } var ee = Math.PI, de = 0, me = j.get("rotate"); if (nn(me)) de = me * (ee / 180); else if (I === "center") de = 0; else if (me === "radial" || me === !0) { var fe = W < 0 ? -V + ee : -V; de = fe } else if (me === "tangential" && I !== "outside" && I !== "outer") { var we = Math.atan2(W, J); we < 0 && (we = ee * 2 + we); var Oe = J > 0; Oe && (we = ee + we), de = we - ee } if (a = !!de, C.x = ie, C.y = le, C.rotation = de, C.setStyle({ verticalAlign: "middle" }), pe) { C.setStyle({ align: ae }); var Ke = C.states.select; Ke && (Ke.x += C.x, Ke.y += C.y) } else { var ve = C.getBoundingRect().clone(); ve.applyTransform(C.getComputedTransform()); var Se = (C.style.margin || 0) + 2.1; ve.y -= Se / 2, ve.height += Se, t.push({ label: C, labelLine: E, position: I, len: F, len2: K, minTurnAngle: B.get("minTurnAngle"), maxSurfaceAngle: B.get("maxSurfaceAngle"), surfaceNormal: new St(W, J), linePoints: De, textAlign: ae, labelDistance: L, labelAlignTo: R, edgeDistance: D, bleedMargin: P, rect: ve, unconstrainedWidth: ve.width, labelStyleWidth: C.style.width }) } k.setTextConfig({ inside: pe }) } }), !a && n.get("avoidLabelOverlap") && uWe(t, r, i, l, c, f, u, d); for (var m = 0; m < t.length; m++) { var g = t[m], y = g.label, b = g.labelLine, w = isNaN(y.x) || isNaN(y.y); if (y) { y.setStyle({ align: g.textAlign }), w && ($(y.states, h), y.ignore = !0); var v = y.states.select; v && (v.x += y.x, v.y += y.y) } if (b) { var S = g.linePoints; w || !S ? ($(b.states, h), b.ignore = !0) : (mie(S, g.minTurnAngle), xUe(S, g.surfaceNormal, g.maxSurfaceAngle), b.setShape({ points: S }), y.__hostTarget.textGuideLineConfig = { anchor: new St(S[0][0], S[0][1]) }) } } } var fWe = function (n) { te(e, n); function e(t, r, i) { var a = n.call(this) || this; a.z2 = 2; var o = new tn; return a.setTextContent(o), a.updateData(t, r, i, !0), a } return e.prototype.updateData = function (t, r, i, a) { var o = this, s = t.hostModel, l = t.getItemModel(r), c = l.getModel("emphasis"), u = t.getItemLayout(r), d = be(oh(l.getModel("itemStyle"), u, !0), u); if (isNaN(d.startAngle)) { o.setShape(d); return } if (a) { o.setShape(d); var f = s.getShallow("animationType"); s.ecModel.ssr ? (Un(o, { scaleX: 0, scaleY: 0 }, s, { dataIndex: r, isFrom: !0 }), o.originX = d.cx, o.originY = d.cy) : f === "scale" ? (o.shape.r = u.r0, Un(o, { shape: { r: u.r } }, s, r)) : i != null ? (o.setShape({ startAngle: i, endAngle: i }), Un(o, { shape: { startAngle: u.startAngle, endAngle: u.endAngle } }, s, r)) : (o.shape.endAngle = u.startAngle, on(o, { shape: { endAngle: u.endAngle } }, s, r)) } else Ms(o), on(o, { shape: d }, s, r); o.useStyle(t.getItemVisual(r, "style")), pi(o, l); var h = (u.startAngle + u.endAngle) / 2, p = s.get("selectedOffset"), m = Math.cos(h) * p, g = Math.sin(h) * p, y = l.getShallow("cursor"); y && o.attr("cursor", y), this._updateLabel(s, t, r), o.ensureState("emphasis").shape = be({ r: u.r + (c.get("scale") && c.get("scaleSize") || 0) }, oh(c.getModel("itemStyle"), u)), be(o.ensureState("select"), { x: m, y: g, shape: oh(l.getModel(["select", "itemStyle"]), u) }), be(o.ensureState("blur"), { shape: oh(l.getModel(["blur", "itemStyle"]), u) }); var b = o.getTextGuideLine(), w = o.getTextContent(); b && be(b.ensureState("select"), { x: m, y: g }), be(w.ensureState("select"), { x: m, y: g }), Qn(this, c.get("focus"), c.get("blurScope"), c.get("disabled")) }, e.prototype._updateLabel = function (t, r, i) { var a = this, o = r.getItemModel(i), s = o.getModel("labelLine"), l = r.getItemVisual(i, "style"), c = l && l.fill, u = l && l.opacity; mi(a, Ur(o), { labelFetcher: r.hostModel, labelDataIndex: i, inheritColor: c, defaultOpacity: u, defaultText: t.getFormattedLabel(i, "normal") || r.getName(i) }); var d = a.getTextContent(); a.setTextConfig({ position: null, rotation: null }), d.attr({ z2: 10 }); var f = t.get(["label", "position"]); if (f !== "outside" && f !== "outer") a.removeTextGuideLine(); else { var h = this.getTextGuideLine(); h || (h = new Ea, this.setTextGuideLine(h)), S3(this, T3(o), { stroke: c, opacity: pl(s.get(["lineStyle", "opacity"]), u, 1) }) } }, e }(Ca), hWe = function (n) { te(e, n); function e() { var t = n !== null && n.apply(this, arguments) || this; return t.ignoreLabelLineUpdate = !0, t } return e.prototype.render = function (t, r, i, a) { var o = t.getData(), s = this._data, l = this.group, c; if (!s && o.count() > 0) { for (var u = o.getItemLayout(0), d = 1; isNaN(u && u.startAngle) && d < o.count(); ++d)u = o.getItemLayout(d); u && (c = u.startAngle) } if (this._emptyCircleSector && l.remove(this._emptyCircleSector), o.count() === 0 && t.get("showEmptyCircle")) { var f = Yie(t), h = new Ca({ shape: be(qie(t, i), f) }); h.useStyle(t.getModel("emptyCircleStyle").getItemStyle()), this._emptyCircleSector = h, l.add(h) } o.diff(s).add(function (p) { var m = new fWe(o, p, c); o.setItemGraphicEl(p, m), l.add(m) }).update(function (p, m) { var g = s.getItemGraphicEl(m); g.updateData(o, p, c), g.off("click"), l.add(g), o.setItemGraphicEl(p, g) }).remove(function (p) { var m = s.getItemGraphicEl(p); __(m, t, p) }).execute(), dWe(t), t.get("animationTypeUpdate") !== "expansion" && (this._data = o) }, e.prototype.dispose = function () { }, e.prototype.containPoint = function (t, r) { var i = r.getData(), a = i.getItemLayout(0); if (a) { var o = t[0] - a.cx, s = t[1] - a.cy, l = Math.sqrt(o * o + s * s); return l <= a.r && l >= a.r0 } }, e.type = "pie", e }(Nn); const pWe = hWe; function lv(n, e, t) { e = ke(e) && { coordDimensions: e } || be({ encodeDefine: n.getEncode() }, e); var r = n.getSource(), i = Eb(r, e).dimensions, a = new Ji(i, n); return a.initData(r, t), a } var mWe = function () { function n(e, t) { this._getDataWithEncodedVisual = e, this._getRawData = t } return n.prototype.getAllNames = function () { var e = this._getRawData(); return e.mapArray(e.getName) }, n.prototype.containName = function (e) { var t = this._getRawData(); return t.indexOfName(e) >= 0 }, n.prototype.indexOfName = function (e) { var t = this._getDataWithEncodedVisual(); return t.indexOfName(e) }, n.prototype.getItemVisual = function (e, t) { var r = this._getDataWithEncodedVisual(); return r.getItemVisual(e, t) }, n }(); const Lb = mWe; var gWe = Kt(), vWe = function (n) { te(e, n); function e() { return n !== null && n.apply(this, arguments) || this } return e.prototype.init = function (t) { n.prototype.init.apply(this, arguments), this.legendVisualProvider = new Lb(He(this.getData, this), He(this.getRawData, this)), this._defaultLabelLine(t) }, e.prototype.mergeOption = function () { n.prototype.mergeOption.apply(this, arguments) }, e.prototype.getInitialData = function () { return lv(this, { coordDimensions: ["value"], encodeDefaulter: wt(e3, this) }) }, e.prototype.getDataParams = function (t) { var r = this.getData(), i = gWe(r), a = i.seats; if (!a) { var o = []; r.each(r.mapDimension("value"), function (l) { o.push(l) }), a = i.seats = CFe(o, r.hostModel.get("percentPrecision")) } var s = n.prototype.getDataParams.call(this, t); return s.percent = a[t] || 0, s.$vars.push("percent"), s }, e.prototype._defaultLabelLine = function (t) { Vh(t, "labelLine", ["show"]); var r = t.labelLine, i = t.emphasis.labelLine; r.show = r.show && t.label.show, i.show = i.show && t.emphasis.label.show }, e.type = "series.pie", e.defaultOption = { z: 2, legendHoverLink: !0, colorBy: "data", center: ["50%", "50%"], radius: [0, "75%"], clockwise: !0, startAngle: 90, endAngle: "auto", padAngle: 0, minAngle: 0, minShowLabelAngle: 0, selectedOffset: 10, percentPrecision: 2, stillShowZeroSum: !0, left: 0, top: 0, right: 0, bottom: 0, width: null, height: null, label: { rotate: 0, show: !0, overflow: "truncate", position: "outer", alignTo: "none", edgeDistance: "25%", bleedMargin: 10, distanceToLabelLine: 5 }, labelLine: { show: !0, length: 15, length2: 15, smooth: !1, minTurnAngle: 90, maxSurfaceAngle: 90, lineStyle: { width: 1, type: "solid" } }, itemStyle: { borderWidth: 1, borderJoin: "round" }, showEmptyCircle: !0, emptyCircleStyle: { color: "lightgray", opacity: 1 }, labelLayout: { hideOverlap: !0 }, emphasis: { scale: !0, scaleSize: 5 }, avoidLabelOverlap: !0, animationType: "expansion", animationDuration: 1e3, animationTypeUpdate: "transition", animationEasingUpdate: "cubicInOut", animationDurationUpdate: 500, animationEasing: "cubicInOut" }, e }(Yn); const yWe = vWe; function _We(n) { return { seriesType: n, reset: function (e, t) { var r = e.getData(); r.filterSelf(function (i) { var a = r.mapDimension("value"), o = r.get(a, i); return !(nn(o) && !isNaN(o) && o < 0) }) } } } function bWe(n) { n.registerChartView(pWe), n.registerSeriesModel(yWe), dre("pie", n.registerAction), n.registerLayout(wt(lWe, "pie")), n.registerProcessor(Ib("pie")), n.registerProcessor(_We("pie")) } var wWe = function (n) { te(e, n); function e() { var t = n !== null && n.apply(this, arguments) || this; return t.type = e.type, t.hasSymbolVisual = !0, t } return e.prototype.getInitialData = function (t, r) { return Hc(null, this, { useEncodeDefaulter: !0 }) }, e.prototype.getProgressive = function () { var t = this.option.progressive; return t ?? (this.option.large ? 5e3 : this.get("progressive")) }, e.prototype.getProgressiveThreshold = function () { var t = this.option.progressiveThreshold; return t ?? (this.option.large ? 1e4 : this.get("progressiveThreshold")) }, e.prototype.brushSelector = function (t, r, i) { return i.point(r.getItemLayout(t)) }, e.prototype.getZLevelKey = function () { return this.getData().count() > this.getProgressiveThreshold() ? this.id : "" }, e.type = "series.scatter", e.dependencies = ["grid", "polar", "geo", "singleAxis", "calendar"], e.defaultOption = { coordinateSystem: "cartesian2d", z: 2, legendHoverLink: !0, symbolSize: 10, large: !1, largeThreshold: 2e3, itemStyle: { opacity: .8 }, emphasis: { scale: !0 }, clip: !0, select: { itemStyle: { borderColor: "#212121" } }, universalTransition: { divideShape: "clone" } }, e }(Yn); const xWe = wWe; var Xie = 4, SWe = function () { function n() { } return n }(), TWe = function (n) { te(e, n); function e(t) { var r = n.call(this, t) || this; return r._off = 0, r.hoverDataIdx = -1, r } return e.prototype.getDefaultShape = function () { return new SWe }, e.prototype.reset = function () { this.notClear = !1, this._off = 0 }, e.prototype.buildPath = function (t, r) { var i = r.points, a = r.size, o = this.symbolProxy, s = o.shape, l = t.getContext ? t.getContext() : t, c = l && a[0] < Xie, u = this.softClipShape, d; if (c) { this._ctx = l; return } for (this._ctx = null, d = this._off; d < i.length;) { var f = i[d++], h = i[d++]; isNaN(f) || isNaN(h) || u && !u.contain(f, h) || (s.x = f - a[0] / 2, s.y = h - a[1] / 2, s.width = a[0], s.height = a[1], o.buildPath(t, s, !0)) } this.incremental && (this._off = d, this.notClear = !0) }, e.prototype.afterBrush = function () { var t = this.shape, r = t.points, i = t.size, a = this._ctx, o = this.softClipShape, s; if (a) { for (s = this._off; s < r.length;) { var l = r[s++], c = r[s++]; isNaN(l) || isNaN(c) || o && !o.contain(l, c) || a.fillRect(l - i[0] / 2, c - i[1] / 2, i[0], i[1]) } this.incremental && (this._off = s, this.notClear = !0) } }, e.prototype.findDataIndex = function (t, r) { for (var i = this.shape, a = i.points, o = i.size, s = Math.max(o[0], 4), l = Math.max(o[1], 4), c = a.length / 2 - 1; c >= 0; c--) { var u = c * 2, d = a[u] - s / 2, f = a[u + 1] - l / 2; if (t >= d && r >= f && t <= d + s && r <= f + l) return c } return -1 }, e.prototype.contain = function (t, r) { var i = this.transformCoordToLocal(t, r), a = this.getBoundingRect(); if (t = i[0], r = i[1], a.contain(t, r)) { var o = this.hoverDataIdx = this.findDataIndex(t, r); return o >= 0 } return this.hoverDataIdx = -1, !1 }, e.prototype.getBoundingRect = function () { var t = this._rect; if (!t) { for (var r = this.shape, i = r.points, a = r.size, o = a[0], s = a[1], l = 1 / 0, c = 1 / 0, u = -1 / 0, d = -1 / 0, f = 0; f < i.length;) { var h = i[f++], p = i[f++]; l = Math.min(h, l), u = Math.max(h, u), c = Math.min(p, c), d = Math.max(p, d) } t = this._rect = new kt(l - o / 2, c - s / 2, u - l + o, d - c + s) } return t }, e }(Nt), kWe = function () { function n() { this.group = new ft } return n.prototype.updateData = function (e, t) { this._clear(); var r = this._create(); r.setShape({ points: e.getLayout("points") }), this._setCommon(r, e, t) }, n.prototype.updateLayout = function (e) { var t = e.getLayout("points"); this.group.eachChild(function (r) { if (r.startIndex != null) { var i = (r.endIndex - r.startIndex) * 2, a = r.startIndex * 4 * 2; t = new Float32Array(t.buffer, a, i) } r.setShape("points", t), r.reset() }) }, n.prototype.incrementalPrepareUpdate = function (e) { this._clear() }, n.prototype.incrementalUpdate = function (e, t, r) { var i = this._newAdded[0], a = t.getLayout("points"), o = i && i.shape.points; if (o && o.length < 2e4) { var s = o.length, l = new Float32Array(s + a.length); l.set(o), l.set(a, s), i.endIndex = e.end, i.setShape({ points: l }) } else { this._newAdded = []; var c = this._create(); c.startIndex = e.start, c.endIndex = e.end, c.incremental = !0, c.setShape({ points: a }), this._setCommon(c, t, r) } }, n.prototype.eachRendered = function (e) { this._newAdded[0] && e(this._newAdded[0]) }, n.prototype._create = function () { var e = new TWe({ cursor: "default" }); return e.ignoreCoarsePointer = !0, this.group.add(e), this._newAdded.push(e), e }, n.prototype._setCommon = function (e, t, r) { var i = t.hostModel; r = r || {}; var a = t.getVisual("symbolSize"); e.setShape("size", a instanceof Array ? a : [a, a]), e.softClipShape = r.clipShape || null, e.symbolProxy = Tr(t.getVisual("symbol"), 0, 0, 0, 0), e.setColor = e.symbolProxy.setColor; var o = e.shape.size[0] < Xie; e.useStyle(i.getModel("itemStyle").getItemStyle(o ? ["color", "shadowBlur", "shadowColor"] : ["color"])); var s = t.getVisual("style"), l = s && s.fill; l && e.setColor(l); var c = pt(e); c.seriesIndex = i.seriesIndex, e.on("mousemove", function (u) { c.dataIndex = null; var d = e.hoverDataIdx; d >= 0 && (c.dataIndex = d + (e.startIndex || 0)) }) }, n.prototype.remove = function () { this._clear() }, n.prototype._clear = function () { this._newAdded = [], this.group.removeAll() }, n }(); const CWe = kWe; var AWe = function (n) { te(e, n); function e() { var t = n !== null && n.apply(this, arguments) || this; return t.type = e.type, t } return e.prototype.render = function (t, r, i) { var a = t.getData(), o = this._updateSymbolDraw(a, t); o.updateData(a, { clipShape: this._getClipShape(t) }), this._finished = !0 }, e.prototype.incrementalPrepareRender = function (t, r, i) { var a = t.getData(), o = this._updateSymbolDraw(a, t); o.incrementalPrepareUpdate(a), this._finished = !1 }, e.prototype.incrementalRender = function (t, r, i) { this._symbolDraw.incrementalUpdate(t, r.getData(), { clipShape: this._getClipShape(r) }), this._finished = t.end === r.getData().count() }, e.prototype.updateTransform = function (t, r, i) { var a = t.getData(); if (this.group.dirty(), !this._finished || a.count() > 1e4) return { update: !0 }; var o = Pb("").reset(t, r, i); o.progress && o.progress({ start: 0, end: a.count(), count: a.count() }, a), this._symbolDraw.updateLayout(a) }, e.prototype.eachRendered = function (t) { this._symbolDraw && this._symbolDraw.eachRendered(t) }, e.prototype._getClipShape = function (t) { if (t.get("clip", !0)) { var r = t.coordinateSystem; return r && r.getArea && r.getArea(.1) } }, e.prototype._updateSymbolDraw = function (t, r) { var i = this._symbolDraw, a = r.pipelineContext, o = a.large; return (!i || o !== this._isLargeDraw) && (i && i.remove(), i = this._symbolDraw = o ? new CWe : new Db, this._isLargeDraw = o, this.group.removeAll()), this.group.add(i.group), i }, e.prototype.remove = function (t, r) { this._symbolDraw && this._symbolDraw.remove(!0), this._symbolDraw = null }, e.prototype.dispose = function () { }, e.type = "scatter", e }(Nn); const EWe = AWe; var MWe = function (n) { te(e, n); function e() { return n !== null && n.apply(this, arguments) || this } return e.type = "grid", e.dependencies = ["xAxis", "yAxis"], e.layoutMode = "box", e.defaultOption = { show: !1, z: 0, left: "10%", top: 60, right: "10%", bottom: 70, containLabel: !1, backgroundColor: "rgba(0,0,0,0)", borderWidth: 1, borderColor: "#ccc" }, e }(Jt); const OWe = MWe; var TI = function (n) { te(e, n); function e() { return n !== null && n.apply(this, arguments) || this } return e.prototype.getCoordSysModel = function () { return this.getReferringComponents("grid", xr).models[0] }, e.type = "cartesian2dAxis", e }(Jt); Cr(TI, Mb); var Jie = { show: !0, z: 0, inverse: !1, name: "", nameLocation: "end", nameRotate: null, nameTruncate: { maxWidth: null, ellipsis: "...", placeholder: "." }, nameTextStyle: {}, nameGap: 15, silent: !1, triggerEvent: !1, tooltip: { show: !1 }, axisPointer: {}, axisLine: { show: !0, onZero: !0, onZeroAxisIndex: null, lineStyle: { color: "#6E7079", width: 1, type: "solid" }, symbol: ["none", "none"], symbolSize: [10, 15] }, axisTick: { show: !0, inside: !1, length: 5, lineStyle: { width: 1 } }, axisLabel: { show: !0, inside: !1, rotate: 0, showMinLabel: null, showMaxLabel: null, margin: 8, fontSize: 12 }, splitLine: { show: !0, showMinLine: !0, showMaxLine: !0, lineStyle: { color: ["#E0E6F1"], width: 1, type: "solid" } }, splitArea: { show: !1, areaStyle: { color: ["rgba(250,250,250,0.2)", "rgba(210,219,238,0.2)"] } } }, DWe = xt({ boundaryGap: !0, deduplication: null, splitLine: { show: !1 }, axisTick: { alignWithLabel: !1, interval: "auto" }, axisLabel: { interval: "auto" } }, Jie), O3 = xt({ boundaryGap: [0, 0], axisLine: { show: "auto" }, axisTick: { show: "auto" }, splitNumber: 5, minorTick: { show: !1, splitNumber: 5, length: 3, lineStyle: {} }, minorSplitLine: { show: !1, lineStyle: { color: "#F4F7FD", width: 1 } } }, Jie), jWe = xt({ splitNumber: 6, axisLabel: { showMinLabel: !1, showMaxLabel: !1, rich: { primary: { fontWeight: "bold" } } }, splitLine: { show: !1 } }, O3), PWe = rt({ logBase: 10 }, O3); const Qie = { category: DWe, value: O3, time: jWe, log: PWe }; var IWe = { value: 1, category: 1, time: 1, log: 1 }; function Og(n, e, t, r) { $(IWe, function (i, a) { var o = xt(xt({}, Qie[a], !0), r, !0), s = function (l) { te(c, l); function c() { var u = l !== null && l.apply(this, arguments) || this; return u.type = e + "Axis." + a, u } return c.prototype.mergeDefaultAndTheme = function (u, d) { var f = w_(this), h = f ? tv(u) : {}, p = d.getTheme(); xt(u, p.get(a + "Axis")), xt(u, this.getDefaultOption()), u.type = H9(u), f && Ed(u, h, f) }, c.prototype.optionUpdated = function () { var u = this.option; u.type === "category" && (this.__ordinalMeta = vI.createByAxisModel(this)) }, c.prototype.getCategories = function (u) { var d = this.option; if (d.type === "category") return u ? d.data : this.__ordinalMeta.categories }, c.prototype.getOrdinalMeta = function () { return this.__ordinalMeta }, c.type = e + "Axis." + a, c.defaultOption = o, c }(t); n.registerComponentModel(s) }), n.registerSubTypeDefaulter(e + "Axis", H9) } function H9(n) { return n.type || (n.data ? "category" : "value") } var LWe = function () { function n(e) { this.type = "cartesian", this._dimList = [], this._axes = {}, this.name = e || "" } return n.prototype.getAxis = function (e) { return this._axes[e] }, n.prototype.getAxes = function () { return Ae(this._dimList, function (e) { return this._axes[e] }, this) }, n.prototype.getAxesByScale = function (e) { return e = e.toLowerCase(), pn(this.getAxes(), function (t) { return t.scale.type === e }) }, n.prototype.addAxis = function (e) { var t = e.dim; this._axes[t] = e, this._dimList.push(t) }, n }(); const RWe = LWe; var kI = ["x", "y"]; function U9(n) { return n.type === "interval" || n.type === "time" } var NWe = function (n) { te(e, n); function e() { var t = n !== null && n.apply(this, arguments) || this; return t.type = "cartesian2d", t.dimensions = kI, t } return e.prototype.calcAffineTransform = function () { this._transform = this._invTransform = null; var t = this.getAxis("x").scale, r = this.getAxis("y").scale; if (!(!U9(t) || !U9(r))) { var i = t.getExtent(), a = r.getExtent(), o = this.dataToPoint([i[0], a[0]]), s = this.dataToPoint([i[1], a[1]]), l = i[1] - i[0], c = a[1] - a[0]; if (!(!l || !c)) { var u = (s[0] - o[0]) / l, d = (s[1] - o[1]) / c, f = o[0] - i[0] * u, h = o[1] - a[0] * d, p = this._transform = [u, 0, 0, d, f, h]; this._invTransform = qg([], p) } } }, e.prototype.getBaseAxis = function () { return this.getAxesByScale("ordinal")[0] || this.getAxesByScale("time")[0] || this.getAxis("x") }, e.prototype.containPoint = function (t) { var r = this.getAxis("x"), i = this.getAxis("y"); return r.contain(r.toLocalCoord(t[0])) && i.contain(i.toLocalCoord(t[1])) }, e.prototype.containData = function (t) { return this.getAxis("x").containData(t[0]) && this.getAxis("y").containData(t[1]) }, e.prototype.containZone = function (t, r) { var i = this.dataToPoint(t), a = this.dataToPoint(r), o = this.getArea(), s = new kt(i[0], i[1], a[0] - i[0], a[1] - i[1]); return o.intersect(s) }, e.prototype.dataToPoint = function (t, r, i) { i = i || []; var a = t[0], o = t[1]; if (this._transform && a != null && isFinite(a) && o != null && isFinite(o)) return fi(i, t, this._transform); var s = this.getAxis("x"), l = this.getAxis("y"); return i[0] = s.toGlobalCoord(s.dataToCoord(a, r)), i[1] = l.toGlobalCoord(l.dataToCoord(o, r)), i }, e.prototype.clampData = function (t, r) { var i = this.getAxis("x").scale, a = this.getAxis("y").scale, o = i.getExtent(), s = a.getExtent(), l = i.parse(t[0]), c = a.parse(t[1]); return r = r || [], r[0] = Math.min(Math.max(Math.min(o[0], o[1]), l), Math.max(o[0], o[1])), r[1] = Math.min(Math.max(Math.min(s[0], s[1]), c), Math.max(s[0], s[1])), r }, e.prototype.pointToData = function (t, r) { var i = []; if (this._invTransform) return fi(i, t, this._invTransform); var a = this.getAxis("x"), o = this.getAxis("y"); return i[0] = a.coordToData(a.toLocalCoord(t[0]), r), i[1] = o.coordToData(o.toLocalCoord(t[1]), r), i }, e.prototype.getOtherAxis = function (t) { return this.getAxis(t.dim === "x" ? "y" : "x") }, e.prototype.getArea = function (t) { t = t || 0; var r = this.getAxis("x").getGlobalExtent(), i = this.getAxis("y").getGlobalExtent(), a = Math.min(r[0], r[1]) - t, o = Math.min(i[0], i[1]) - t, s = Math.max(r[0], r[1]) - a + t, l = Math.max(i[0], i[1]) - o + t; return new kt(a, o, s, l) }, e }(RWe), BWe = function (n) { te(e, n); function e(t, r, i, a, o) { var s = n.call(this, t, r, i) || this; return s.index = 0, s.type = a || "value", s.position = o || "bottom", s } return e.prototype.isHorizontal = function () { var t = this.position; return t === "top" || t === "bottom" }, e.prototype.getGlobalExtent = function (t) { var r = this.getExtent(); return r[0] = this.toGlobalCoord(r[0]), r[1] = this.toGlobalCoord(r[1]), t && r[0] > r[1] && r.reverse(), r }, e.prototype.pointToData = function (t, r) { return this.coordToData(this.toLocalCoord(t[this.dim === "x" ? 0 : 1]), r) }, e.prototype.setCategorySortInfo = function (t) { if (this.type !== "category") return !1; this.model.option.categorySortInfo = t, this.scale.setSortInfo(t) }, e }(Ps); const $We = BWe; function CI(n, e, t) { t = t || {}; var r = n.coordinateSystem, i = e.axis, a = {}, o = i.getAxesOnZeroOf()[0], s = i.position, l = o ? "onZero" : s, c = i.dim, u = r.getRect(), d = [u.x, u.x + u.width, u.y, u.y + u.height], f = { left: 0, right: 1, top: 0, bottom: 1, onZero: 2 }, h = e.get("offset") || 0, p = c === "x" ? [d[2] - h, d[3] + h] : [d[0] - h, d[1] + h]; if (o) { var m = o.toGlobalCoord(o.dataToCoord(0)); p[f.onZero] = Math.max(Math.min(m, p[1]), p[0]) } a.position = [c === "y" ? p[f[l]] : d[0], c === "x" ? p[f[l]] : d[3]], a.rotation = Math.PI / 2 * (c === "x" ? 0 : 1); var g = { top: -1, bottom: 1, left: -1, right: 1 }; a.labelDirection = a.tickDirection = a.nameDirection = g[s], a.labelOffset = o ? p[f[s]] - p[f.onZero] : 0, e.get(["axisTick", "inside"]) && (a.tickDirection = -a.tickDirection), Xr(t.labelInside, e.get(["axisLabel", "inside"])) && (a.labelDirection = -a.labelDirection); var y = e.get(["axisLabel", "rotate"]); return a.labelRotate = l === "top" ? -y : y, a.z2 = 1, a } function G9(n) { return n.get("coordinateSystem") === "cartesian2d" } function W9(n) { var e = { xAxisModel: null, yAxisModel: null }; return $(e, function (t, r) { var i = r.replace(/Model$/, ""), a = n.getReferringComponents(i, xr).models[0]; e[r] = a }), e } var xO = Math.log; function eae(n, e, t) { var r = Od.prototype, i = r.getTicks.call(t), a = r.getTicks.call(t, !0), o = i.length - 1, s = r.getInterval.call(t), l = nie(n, e), c = l.extent, u = l.fixMin, d = l.fixMax; if (n.type === "log") { var f = xO(n.base); c = [xO(c[0]) / f, xO(c[1]) / f] } n.setExtent(c[0], c[1]), n.calcNiceExtent({ splitNumber: o, fixMin: u, fixMax: d }); var h = r.getExtent.call(n); u && (c[0] = h[0]), d && (c[1] = h[1]); var p = r.getInterval.call(n), m = c[0], g = c[1]; if (u && d) p = (g - m) / o; else if (u) for (g = c[0] + p * o; g < c[1] && isFinite(g) && isFinite(c[1]);)p = sO(p), g = c[0] + p * o; else if (d) for (m = c[1] - p * o; m > c[0] && isFinite(m) && isFinite(c[0]);)p = sO(p), m = c[1] - p * o; else { var y = n.getTicks().length - 1; y > o && (p = sO(p)); var b = p * o; g = Math.ceil(c[1] / p) * p, m = lr(g - b), m < 0 && c[0] >= 0 ? (m = 0, g = lr(b)) : g > 0 && c[1] <= 0 && (g = 0, m = -lr(b)) } var w = (i[0].value - a[0].value) / s, v = (i[o].value - a[o].value) / s; r.setExtent.call(n, m + p * w, g + p * v), r.setInterval.call(n, p), (w || v) && r.setNiceExtent.call(n, m + p, g - p) } var FWe = function () { function n(e, t, r) { this.type = "grid", this._coordsMap = {}, this._coordsList = [], this._axesMap = {}, this._axesList = [], this.axisPointerEnabled = !0, this.dimensions = kI, this._initCartesian(e, t, r), this.model = e } return n.prototype.getRect = function () { return this._rect }, n.prototype.update = function (e, t) { var r = this._axesMap; this._updateScale(e, this.model); function i(o) { var s, l = Bt(o), c = l.length; if (c) { for (var u = [], d = c - 1; d >= 0; d--) { var f = +l[d], h = o[f], p = h.model, m = h.scale; yI(m) && p.get("alignTicks") && p.get("interval") == null ? u.push(h) : (Eg(m, p), yI(m) && (s = h)) } u.length && (s || (s = u.pop(), Eg(s.scale, s.model)), $(u, function (g) { eae(g.scale, g.model, s.scale) })) } } i(r.x), i(r.y); var a = {}; $(r.x, function (o) { K9(r, "y", o, a) }), $(r.y, function (o) { K9(r, "x", o, a) }), this.resize(this.model, t) }, n.prototype.resize = function (e, t, r) { var i = e.getBoxLayoutParams(), a = !r && e.get("containLabel"), o = jr(i, { width: t.getWidth(), height: t.getHeight() }); this._rect = o; var s = this._axesList; l(), a && ($(s, function (c) { if (!c.model.get(["axisLabel", "inside"])) { var u = J7e(c); if (u) { var d = c.isHorizontal() ? "height" : "width", f = c.model.get(["axisLabel", "margin"]); o[d] -= u[d] + f, c.position === "top" ? o.y += u.height + f : c.position === "left" && (o.x += u.width + f) } } }), l()), $(this._coordsList, function (c) { c.calcAffineTransform() }); function l() { $(s, function (c) { var u = c.isHorizontal(), d = u ? [0, o.width] : [0, o.height], f = c.inverse ? 1 : 0; c.setExtent(d[f], d[1 - f]), zWe(c, u ? o.x : o.y) }) } }, n.prototype.getAxis = function (e, t) { var r = this._axesMap[e]; if (r != null) return r[t || 0] }, n.prototype.getAxes = function () { return this._axesList.slice() }, n.prototype.getCartesian = function (e, t) { if (e != null && t != null) { var r = "x" + e + "y" + t; return this._coordsMap[r] } ot(e) && (t = e.yAxisIndex, e = e.xAxisIndex); for (var i = 0, a = this._coordsList; i < a.length; i++)if (a[i].getAxis("x").index === e || a[i].getAxis("y").index === t) return a[i] }, n.prototype.getCartesians = function () { return this._coordsList.slice() }, n.prototype.convertToPixel = function (e, t, r) { var i = this._findConvertTarget(t); return i.cartesian ? i.cartesian.dataToPoint(r) : i.axis ? i.axis.toGlobalCoord(i.axis.dataToCoord(r)) : null }, n.prototype.convertFromPixel = function (e, t, r) { var i = this._findConvertTarget(t); return i.cartesian ? i.cartesian.pointToData(r) : i.axis ? i.axis.coordToData(i.axis.toLocalCoord(r)) : null }, n.prototype._findConvertTarget = function (e) { var t = e.seriesModel, r = e.xAxisModel || t && t.getReferringComponents("xAxis", xr).models[0], i = e.yAxisModel || t && t.getReferringComponents("yAxis", xr).models[0], a = e.gridModel, o = this._coordsList, s, l; if (t) s = t.coordinateSystem, Et(o, s) < 0 && (s = null); else if (r && i) s = this.getCartesian(r.componentIndex, i.componentIndex); else if (r) l = this.getAxis("x", r.componentIndex); else if (i) l = this.getAxis("y", i.componentIndex); else if (a) { var c = a.coordinateSystem; c === this && (s = this._coordsList[0]) } return { cartesian: s, axis: l } }, n.prototype.containPoint = function (e) { var t = this._coordsList[0]; if (t) return t.containPoint(e) }, n.prototype._initCartesian = function (e, t, r) { var i = this, a = this, o = { left: !1, right: !1, top: !1, bottom: !1 }, s = { x: {}, y: {} }, l = { x: 0, y: 0 }; if (t.eachComponent("xAxis", c("x"), this), t.eachComponent("yAxis", c("y"), this), !l.x || !l.y) { this._axesMap = {}, this._axesList = []; return } this._axesMap = s, $(s.x, function (u, d) { $(s.y, function (f, h) { var p = "x" + d + "y" + h, m = new NWe(p); m.master = i, m.model = e, i._coordsMap[p] = m, i._coordsList.push(m), m.addAxis(u), m.addAxis(f) }) }); function c(u) { return function (d, f) { if (SO(d, e)) { var h = d.get("position"); u === "x" ? h !== "top" && h !== "bottom" && (h = o.bottom ? "top" : "bottom") : h !== "left" && h !== "right" && (h = o.left ? "right" : "left"), o[h] = !0; var p = new $We(u, xC(d), [0, 0], d.get("type"), h), m = p.type === "category"; p.onBand = m && d.get("boundaryGap"), p.inverse = d.get("inverse"), d.axis = p, p.model = d, p.grid = a, p.index = f, a._axesList.push(p), s[u][f] = p, l[u]++ } } } }, n.prototype._updateScale = function (e, t) { $(this._axesList, function (i) { if (i.scale.setExtent(1 / 0, -1 / 0), i.type === "category") { var a = i.model.get("categorySortInfo"); i.scale.setSortInfo(a) } }), e.eachSeries(function (i) { if (G9(i)) { var a = W9(i), o = a.xAxisModel, s = a.yAxisModel; if (!SO(o, t) || !SO(s, t)) return; var l = this.getCartesian(o.componentIndex, s.componentIndex), c = i.getData(), u = l.getAxis("x"), d = l.getAxis("y"); r(c, u), r(c, d) } }, this); function r(i, a) { $(fT(i, a.dim), function (o) { a.scale.unionExtentFromData(i, o) }) } }, n.prototype.getTooltipAxes = function (e) { var t = [], r = []; return $(this.getCartesians(), function (i) { var a = e != null && e !== "auto" ? i.getAxis(e) : i.getBaseAxis(), o = i.getOtherAxis(a); Et(t, a) < 0 && t.push(a), Et(r, o) < 0 && r.push(o) }), { baseAxes: t, otherAxes: r } }, n.create = function (e, t) { var r = []; return e.eachComponent("grid", function (i, a) { var o = new n(i, e, t); o.name = "grid_" + a, o.resize(i, t, !0), i.coordinateSystem = o, r.push(o) }), e.eachSeries(function (i) { if (G9(i)) { var a = W9(i), o = a.xAxisModel, s = a.yAxisModel, l = o.getCoordSysModel(), c = l.coordinateSystem; i.coordinateSystem = c.getCartesian(o.componentIndex, s.componentIndex) } }), r }, n.dimensions = kI, n }(); function SO(n, e) { return n.getCoordSysModel() === e } function K9(n, e, t, r) { t.getAxesOnZeroOf = function () { return a ? [a] : [] }; var i = n[e], a, o = t.model, s = o.get(["axisLine", "onZero"]), l = o.get(["axisLine", "onZeroAxisIndex"]); if (!s) return; if (l != null) q9(i[l]) && (a = i[l]); else for (var c in i) if (i.hasOwnProperty(c) && q9(i[c]) && !r[u(i[c])]) { a = i[c]; break } a && (r[u(a)] = !0); function u(d) { return d.dim + "_" + d.index } } function q9(n) { return n && n.type !== "category" && n.type !== "time" && X7e(n) } function zWe(n, e) { var t = n.getExtent(), r = t[0] + t[1]; n.toGlobalCoord = n.dim === "x" ? function (i) { return i + e } : function (i) { return r - i + e }, n.toLocalCoord = n.dim === "x" ? function (i) { return i - e } : function (i) { return r - i + e } } const VWe = FWe; var Yu = Math.PI, Eh = function () { function n(e, t) { this.group = new ft, this.opt = t, this.axisModel = e, rt(t, { labelOffset: 0, nameDirection: 1, tickDirection: 1, labelDirection: 1, silent: !0, handleAutoShown: function () { return !0 } }); var r = new ft({ x: t.position[0], y: t.position[1], rotation: t.rotation }); r.updateTransform(), this._transformGroup = r } return n.prototype.hasBuilder = function (e) { return !!Y9[e] }, n.prototype.add = function (e) { Y9[e](this.opt, this.axisModel, this.group, this._transformGroup) }, n.prototype.getGroup = function () { return this.group }, n.innerTextLayout = function (e, t, r) { var i = Xee(t - e), a, o; return p_(i) ? (o = r > 0 ? "top" : "bottom", a = "center") : p_(i - Yu) ? (o = r > 0 ? "bottom" : "top", a = "center") : (o = "middle", i > 0 && i < Yu ? a = r > 0 ? "right" : "left" : a = r > 0 ? "left" : "right"), { rotation: i, textAlign: a, textVerticalAlign: o } }, n.makeAxisEventDataBase = function (e) { var t = { componentType: e.mainType, componentIndex: e.componentIndex }; return t[e.mainType + "Index"] = e.componentIndex, t }, n.isLabelSilent = function (e) { var t = e.get("tooltip"); return e.get("silent") || !(e.get("triggerEvent") || t && t.show) }, n }(), Y9 = { axisLine: function (n, e, t, r) { var i = e.get(["axisLine", "show"]); if (i === "auto" && n.handleAutoShown && (i = n.handleAutoShown("axisLine")), !!i) { var a = e.axis.getExtent(), o = r.transform, s = [a[0], 0], l = [a[1], 0], c = s[0] > l[0]; o && (fi(s, s, o), fi(l, l, o)); var u = be({ lineCap: "round" }, e.getModel(["axisLine", "lineStyle"]).getLineStyle()), d = new Jr({ shape: { x1: s[0], y1: s[1], x2: l[0], y2: l[1] }, style: u, strokeContainThreshold: n.strokeContainThreshold || 5, silent: !0, z2: 1 }); kg(d.shape, d.style.lineWidth), d.anid = "line", t.add(d); var f = e.get(["axisLine", "symbol"]); if (f != null) { var h = e.get(["axisLine", "symbolSize"]); Fe(f) && (f = [f, f]), (Fe(h) || nn(h)) && (h = [h, h]); var p = sp(e.get(["axisLine", "symbolOffset"]) || 0, h), m = h[0], g = h[1]; $([{ rotate: n.rotation + Math.PI / 2, offset: p[0], r: 0 }, { rotate: n.rotation - Math.PI / 2, offset: p[1], r: Math.sqrt((s[0] - l[0]) * (s[0] - l[0]) + (s[1] - l[1]) * (s[1] - l[1])) }], function (y, b) { if (f[b] !== "none" && f[b] != null) { var w = Tr(f[b], -m / 2, -g / 2, m, g, u.stroke, !0), v = y.r + y.offset, S = c ? l : s; w.attr({ rotation: y.rotate, x: S[0] + v * Math.cos(n.rotation), y: S[1] - v * Math.sin(n.rotation), silent: !0, z2: 11 }), t.add(w) } }) } } }, axisTickLabel: function (n, e, t, r) { var i = GWe(t, r, e, n), a = KWe(t, r, e, n); if (UWe(e, a, i), WWe(t, r, e, n.tickDirection), e.get(["axisLabel", "hideOverlap"])) { var o = gie(Ae(a, function (s) { return { label: s, priority: s.z2, defaultAttr: { ignore: s.ignore } } })); _ie(o) } }, axisName: function (n, e, t, r) { var i = Xr(n.axisName, e.get("name")); if (i) { var a = e.get("nameLocation"), o = n.nameDirection, s = e.getModel("nameTextStyle"), l = e.get("nameGap") || 0, c = e.axis.getExtent(), u = c[0] > c[1] ? -1 : 1, d = [a === "start" ? c[0] - u * l : a === "end" ? c[1] + u * l : (c[0] + c[1]) / 2, X9(a) ? n.labelOffset + o * l : 0], f, h = e.get("nameRotate"); h != null && (h = h * Yu / 180); var p; X9(a) ? f = Eh.innerTextLayout(n.rotation, h ?? n.rotation, o) : (f = HWe(n.rotation, a, h || 0, c), p = n.axisNameAvailableWidth, p != null && (p = Math.abs(p / Math.sin(f.rotation)), !isFinite(p) && (p = null))); var m = s.getFont(), g = e.get("nameTruncate", !0) || {}, y = g.ellipsis, b = Xr(n.nameTruncateMaxWidth, g.maxWidth, p), w = new tn({ x: d[0], y: d[1], rotation: f.rotation, silent: Eh.isLabelSilent(e), style: Ln(s, { text: i, font: m, overflow: "truncate", width: b, ellipsis: y, fill: s.getTextColor() || e.get(["axisLine", "lineStyle", "color"]), align: s.get("align") || f.textAlign, verticalAlign: s.get("verticalAlign") || f.textVerticalAlign }), z2: 1 }); if (ip({ el: w, componentModel: e, itemName: i }), w.__fullText = i, w.anid = "name", e.get("triggerEvent")) { var v = Eh.makeAxisEventDataBase(e); v.targetType = "axisName", v.name = i, pt(w).eventData = v } r.add(w), w.updateTransform(), t.add(w), w.decomposeTransform() } } }; function HWe(n, e, t, r) { var i = Xee(t - n), a, o, s = r[0] > r[1], l = e === "start" && !s || e !== "start" && s; return p_(i - Yu / 2) ? (o = l ? "bottom" : "top", a = "center") : p_(i - Yu * 1.5) ? (o = l ? "top" : "bottom", a = "center") : (o = "middle", i < Yu * 1.5 && i > Yu / 2 ? a = l ? "left" : "right" : a = l ? "right" : "left"), { rotation: i, textAlign: a, textVerticalAlign: o } } function UWe(n, e, t) { if (!rie(n.axis)) { var r = n.get(["axisLabel", "showMinLabel"]), i = n.get(["axisLabel", "showMaxLabel"]); e = e || [], t = t || []; var a = e[0], o = e[1], s = e[e.length - 1], l = e[e.length - 2], c = t[0], u = t[1], d = t[t.length - 1], f = t[t.length - 2]; r === !1 ? (co(a), co(c)) : Z9(a, o) && (r ? (co(o), co(u)) : (co(a), co(c))), i === !1 ? (co(s), co(d)) : Z9(l, s) && (i ? (co(l), co(f)) : (co(s), co(d))) } } function co(n) { n && (n.ignore = !0) } function Z9(n, e) { var t = n && n.getBoundingRect().clone(), r = e && e.getBoundingRect().clone(); if (!(!t || !r)) { var i = qk([]); return rp(i, i, -n.rotation), t.applyTransform(bc([], i, n.getLocalTransform())), r.applyTransform(bc([], i, e.getLocalTransform())), t.intersect(r) } } function X9(n) { return n === "middle" || n === "center" } function tae(n, e, t, r, i) { for (var a = [], o = [], s = [], l = 0; l < n.length; l++) { var c = n[l].coord; o[0] = c, o[1] = 0, s[0] = c, s[1] = t, e && (fi(o, o, e), fi(s, s, e)); var u = new Jr({ shape: { x1: o[0], y1: o[1], x2: s[0], y2: s[1] }, style: r, z2: 2, autoBatch: !0, silent: !0 }); kg(u.shape, u.style.lineWidth), u.anid = i + "_" + n[l].tickValue, a.push(u) } return a } function GWe(n, e, t, r) { var i = t.axis, a = t.getModel("axisTick"), o = a.get("show"); if (o === "auto" && r.handleAutoShown && (o = r.handleAutoShown("axisTick")), !(!o || i.scale.isBlank())) { for (var s = a.getModel("lineStyle"), l = r.tickDirection * a.get("length"), c = i.getTicksCoords(), u = tae(c, e.transform, l, rt(s.getLineStyle(), { stroke: t.get(["axisLine", "lineStyle", "color"]) }), "ticks"), d = 0; d < u.length; d++)n.add(u[d]); return u } } function WWe(n, e, t, r) { var i = t.axis, a = t.getModel("minorTick"); if (!(!a.get("show") || i.scale.isBlank())) { var o = i.getMinorTicksCoords(); if (o.length) for (var s = a.getModel("lineStyle"), l = r * a.get("length"), c = rt(s.getLineStyle(), rt(t.getModel("axisTick").getLineStyle(), { stroke: t.get(["axisLine", "lineStyle", "color"]) })), u = 0; u < o.length; u++)for (var d = tae(o[u], e.transform, l, c, "minorticks_" + u), f = 0; f < d.length; f++)n.add(d[f]) } } function KWe(n, e, t, r) { var i = t.axis, a = Xr(r.axisLabelShow, t.get(["axisLabel", "show"])); if (!(!a || i.scale.isBlank())) { var o = t.getModel("axisLabel"), s = o.get("margin"), l = i.getViewLabels(), c = (Xr(r.labelRotate, o.get("rotate")) || 0) * Yu / 180, u = Eh.innerTextLayout(r.rotation, c, r.labelDirection), d = t.getCategories && t.getCategories(!0), f = [], h = Eh.isLabelSilent(t), p = t.get("triggerEvent"); return $(l, function (m, g) { var y = i.scale.type === "ordinal" ? i.scale.getRawOrdinalNumber(m.tickValue) : m.tickValue, b = m.formattedLabel, w = m.rawLabel, v = o; if (d && d[y]) { var S = d[y]; ot(S) && S.textStyle && (v = new Rn(S.textStyle, o, t.ecModel)) } var x = v.getTextColor() || t.get(["axisLine", "lineStyle", "color"]), k = i.dataToCoord(y), A = v.getShallow("align", !0) || u.textAlign, C = yt(v.getShallow("alignMinLabel", !0), A), E = yt(v.getShallow("alignMaxLabel", !0), A), O = v.getShallow("verticalAlign", !0) || v.getShallow("baseline", !0) || u.textVerticalAlign, j = yt(v.getShallow("verticalAlignMinLabel", !0), O), I = yt(v.getShallow("verticalAlignMaxLabel", !0), O), L = new tn({ x: k, y: r.labelOffset + r.labelDirection * s, rotation: u.rotation, silent: h, z2: 10 + (m.level || 0), style: Ln(v, { text: b, align: g === 0 ? C : g === l.length - 1 ? E : A, verticalAlign: g === 0 ? j : g === l.length - 1 ? I : O, fill: tt(x) ? x(i.type === "category" ? w : i.type === "value" ? y + "" : y, g) : x }) }); if (L.anid = "label_" + y, ip({ el: L, componentModel: t, itemName: b, formatterParamsExtra: { isTruncated: function () { return L.isTruncated }, value: w, tickIndex: g } }), p) { var R = Eh.makeAxisEventDataBase(t); R.targetType = "axisLabel", R.value = w, R.tickIndex = g, i.type === "category" && (R.dataIndex = y), pt(L).eventData = R } e.add(L), L.updateTransform(), f.push(L), n.add(L), L.decomposeTransform() }), f } } const Rc = Eh; function qWe(n, e) { var t = { axesInfo: {}, seriesInvolved: !1, coordSysAxesInfo: {}, coordSysMap: {} }; return YWe(t, n, e), t.seriesInvolved && XWe(t, n), t } function YWe(n, e, t) { var r = e.getComponent("tooltip"), i = e.getComponent("axisPointer"), a = i.get("link", !0) || [], o = []; $(t.getCoordinateSystems(), function (s) { if (!s.axisPointerEnabled) return; var l = M_(s.model), c = n.coordSysAxesInfo[l] = {}; n.coordSysMap[l] = s; var u = s.model, d = u.getModel("tooltip", r); if ($(s.getAxes(), wt(m, !1, null)), s.getTooltipAxes && r && d.get("show")) { var f = d.get("trigger") === "axis", h = d.get(["axisPointer", "type"]) === "cross", p = s.getTooltipAxes(d.get(["axisPointer", "axis"])); (f || h) && $(p.baseAxes, wt(m, h ? "cross" : !0, f)), h && $(p.otherAxes, wt(m, "cross", !1)) } function m(g, y, b) { var w = b.model.getModel("axisPointer", i), v = w.get("show"); if (!(!v || v === "auto" && !g && !AI(w))) { y == null && (y = w.get("triggerTooltip")), w = g ? ZWe(b, d, i, e, g, y) : w; var S = w.get("snap"), x = w.get("triggerEmphasis"), k = M_(b.model), A = y || S || b.type === "category", C = n.axesInfo[k] = { key: k, axis: b, coordSys: s, axisPointerModel: w, triggerTooltip: y, triggerEmphasis: x, involveSeries: A, snap: S, useHandle: AI(w), seriesModels: [], linkGroup: null }; c[k] = C, n.seriesInvolved = n.seriesInvolved || A; var E = JWe(a, b); if (E != null) { var O = o[E] || (o[E] = { axesInfo: {} }); O.axesInfo[k] = C, O.mapper = a[E].mapper, C.linkGroup = O } } } }) } function ZWe(n, e, t, r, i, a) { var o = e.getModel("axisPointer"), s = ["type", "snap", "lineStyle", "shadowStyle", "label", "animation", "animationDurationUpdate", "animationEasingUpdate", "z"], l = {}; $(s, function (f) { l[f] = lt(o.get(f)) }), l.snap = n.type !== "category" && !!a, o.get("type") === "cross" && (l.type = "line"); var c = l.label || (l.label = {}); if (c.show == null && (c.show = !1), i === "cross") { var u = o.get(["label", "show"]); if (c.show = u ?? !0, !a) { var d = l.lineStyle = o.get("crossStyle"); d && rt(c, d.textStyle) } } return n.model.getModel("axisPointer", new Rn(l, t, r)) } function XWe(n, e) { e.eachSeries(function (t) { var r = t.coordinateSystem, i = t.get(["tooltip", "trigger"], !0), a = t.get(["tooltip", "show"], !0); !r || i === "none" || i === !1 || i === "item" || a === !1 || t.get(["axisPointer", "show"], !0) === !1 || $(n.coordSysAxesInfo[M_(r.model)], function (o) { var s = o.axis; r.getAxis(s.dim) === s && (o.seriesModels.push(t), o.seriesDataCount == null && (o.seriesDataCount = 0), o.seriesDataCount += t.getData().count()) }) }) } function JWe(n, e) { for (var t = e.model, r = e.dim, i = 0; i < n.length; i++) { var a = n[i] || {}; if (TO(a[r + "AxisId"], t.id) || TO(a[r + "AxisIndex"], t.componentIndex) || TO(a[r + "AxisName"], t.name)) return i } } function TO(n, e) { return n === "all" || ke(n) && Et(n, e) >= 0 || n === e } function QWe(n) { var e = D3(n); if (e) { var t = e.axisPointerModel, r = e.axis.scale, i = t.option, a = t.get("status"), o = t.get("value"); o != null && (o = r.parse(o)); var s = AI(t); a == null && (i.status = s ? "show" : "hide"); var l = r.getExtent().slice(); l[0] > l[1] && l.reverse(), (o == null || o > l[1]) && (o = l[1]), o < l[0] && (o = l[0]), i.value = o, s && (i.status = e.axis.scale.isBlank() ? "hide" : "show") } } function D3(n) { var e = (n.ecModel.getComponent("axisPointer") || {}).coordSysAxesInfo; return e && e.axesInfo[M_(n)] } function eKe(n) { var e = D3(n); return e && e.axisPointerModel } function AI(n) { return !!n.get(["handle", "show"]) } function M_(n) { return n.type + "||" + n.id } var J9 = {}, tKe = function (n) { te(e, n); function e() { var t = n !== null && n.apply(this, arguments) || this; return t.type = e.type, t } return e.prototype.render = function (t, r, i, a) { this.axisPointerClass && QWe(t), n.prototype.render.apply(this, arguments), this._doUpdateAxisPointerClass(t, i, !0) }, e.prototype.updateAxisPointer = function (t, r, i, a) { this._doUpdateAxisPointerClass(t, i, !1) }, e.prototype.remove = function (t, r) { var i = this._axisPointer; i && i.remove(r) }, e.prototype.dispose = function (t, r) { this._disposeAxisPointer(r), n.prototype.dispose.apply(this, arguments) }, e.prototype._doUpdateAxisPointerClass = function (t, r, i) { var a = e.getAxisPointerClass(this.axisPointerClass); if (a) { var o = eKe(t); o ? (this._axisPointer || (this._axisPointer = new a)).render(t, o, r, i) : this._disposeAxisPointer(r) } }, e.prototype._disposeAxisPointer = function (t) { this._axisPointer && this._axisPointer.dispose(t), this._axisPointer = null }, e.registerAxisPointerClass = function (t, r) { J9[t] = r }, e.getAxisPointerClass = function (t) { return t && J9[t] }, e.type = "axis", e }(nr); const up = tKe; var EI = Kt(); function nae(n, e, t, r) { var i = t.axis; if (!i.scale.isBlank()) { var a = t.getModel("splitArea"), o = a.getModel("areaStyle"), s = o.get("color"), l = r.coordinateSystem.getRect(), c = i.getTicksCoords({ tickModel: a, clamp: !0 }); if (c.length) { var u = s.length, d = EI(n).splitAreaColors, f = Ze(), h = 0; if (d) for (var p = 0; p < c.length; p++) { var m = d.get(c[p].tickValue); if (m != null) { h = (m + (u - 1) * p) % u; break } } var g = i.toGlobalCoord(c[0].coord), y = o.getAreaStyle(); s = ke(s) ? s : [s]; for (var p = 1; p < c.length; p++) { var b = i.toGlobalCoord(c[p].coord), w = void 0, v = void 0, S = void 0, x = void 0; i.isHorizontal() ? (w = g, v = l.y, S = b - w, x = l.height, g = w + S) : (w = l.x, v = g, S = l.width, x = b - v, g = v + x); var k = c[p - 1].tickValue; k != null && f.set(k, h), e.add(new Yt({ anid: k != null ? "area_" + k : null, shape: { x: w, y: v, width: S, height: x }, style: rt({ fill: s[h] }, y), autoBatch: !0, silent: !0 })), h = (h + 1) % u } EI(n).splitAreaColors = f } } } function rae(n) { EI(n).splitAreaColors = null } var nKe = ["axisLine", "axisTickLabel", "axisName"], rKe = ["splitArea", "splitLine", "minorSplitLine"], iae = function (n) { te(e, n); function e() { var t = n !== null && n.apply(this, arguments) || this; return t.type = e.type, t.axisPointerClass = "CartesianAxisPointer", t } return e.prototype.render = function (t, r, i, a) { this.group.removeAll(); var o = this._axisGroup; if (this._axisGroup = new ft, this.group.add(this._axisGroup), !!t.get("show")) { var s = t.getCoordSysModel(), l = CI(s, t), c = new Rc(t, be({ handleAutoShown: function (d) { for (var f = s.coordinateSystem.getCartesians(), h = 0; h < f.length; h++)if (yI(f[h].getOtherAxis(t.axis).scale)) return !0; return !1 } }, l)); $(nKe, c.add, c), this._axisGroup.add(c.getGroup()), $(rKe, function (d) { t.get([d, "show"]) && iKe[d](this, this._axisGroup, t, s) }, this); var u = a && a.type === "changeAxisOrder" && a.isInitSort; u || Tb(o, this._axisGroup, t), n.prototype.render.call(this, t, r, i, a) } }, e.prototype.remove = function () { rae(this) }, e.type = "cartesianAxis", e }(up), iKe = { splitLine: function (n, e, t, r) { var i = t.axis; if (!i.scale.isBlank()) { var a = t.getModel("splitLine"), o = a.getModel("lineStyle"), s = o.get("color"), l = a.get("showMinLine") !== !1, c = a.get("showMaxLine") !== !1; s = ke(s) ? s : [s]; for (var u = r.coordinateSystem.getRect(), d = i.isHorizontal(), f = 0, h = i.getTicksCoords({ tickModel: a }), p = [], m = [], g = o.getLineStyle(), y = 0; y < h.length; y++) { var b = i.toGlobalCoord(h[y].coord); if (!(y === 0 && !l || y === h.length - 1 && !c)) { var w = h[y].tickValue; d ? (p[0] = b, p[1] = u.y, m[0] = b, m[1] = u.y + u.height) : (p[0] = u.x, p[1] = b, m[0] = u.x + u.width, m[1] = b); var v = f++ % s.length, S = new Jr({ anid: w != null ? "line_" + w : null, autoBatch: !0, shape: { x1: p[0], y1: p[1], x2: m[0], y2: m[1] }, style: rt({ stroke: s[v] }, g), silent: !0 }); kg(S.shape, g.lineWidth), e.add(S) } } } }, minorSplitLine: function (n, e, t, r) { var i = t.axis, a = t.getModel("minorSplitLine"), o = a.getModel("lineStyle"), s = r.coordinateSystem.getRect(), l = i.isHorizontal(), c = i.getMinorTicksCoords(); if (c.length) for (var u = [], d = [], f = o.getLineStyle(), h = 0; h < c.length; h++)for (var p = 0; p < c[h].length; p++) { var m = i.toGlobalCoord(c[h][p].coord); l ? (u[0] = m, u[1] = s.y, d[0] = m, d[1] = s.y + s.height) : (u[0] = s.x, u[1] = m, d[0] = s.x + s.width, d[1] = m); var g = new Jr({ anid: "minor_line_" + c[h][p].tickValue, autoBatch: !0, shape: { x1: u[0], y1: u[1], x2: d[0], y2: d[1] }, style: f, silent: !0 }); kg(g.shape, f.lineWidth), e.add(g) } }, splitArea: function (n, e, t, r) { nae(n, e, t, r) } }, aae = function (n) { te(e, n); function e() { var t = n !== null && n.apply(this, arguments) || this; return t.type = e.type, t } return e.type = "xAxis", e }(iae), aKe = function (n) { te(e, n); function e() { var t = n !== null && n.apply(this, arguments) || this; return t.type = aae.type, t } return e.type = "yAxis", e }(iae), oKe = function (n) { te(e, n); function e() { var t = n !== null && n.apply(this, arguments) || this; return t.type = "grid", t } return e.prototype.render = function (t, r) { this.group.removeAll(), t.get("show") && this.group.add(new Yt({ shape: t.coordinateSystem.getRect(), style: rt({ fill: t.get("backgroundColor") }, t.getItemStyle()), silent: !0, z2: -1 })) }, e.type = "grid", e }(nr), Q9 = { offset: 0 }; function oae(n) { n.registerComponentView(oKe), n.registerComponentModel(OWe), n.registerCoordinateSystem("cartesian2d", VWe), Og(n, "x", TI, Q9), Og(n, "y", TI, Q9), n.registerComponentView(aae), n.registerComponentView(aKe), n.registerPreprocessor(function (e) { e.xAxis && e.yAxis && !e.grid && (e.grid = {}) }) } function sKe(n) { It(oae), n.registerSeriesModel(xWe), n.registerChartView(EWe), n.registerLayout(Pb("scatter")) } function lKe(n) { n.eachSeriesByType("radar", function (e) { var t = e.getData(), r = [], i = e.coordinateSystem; if (i) { var a = i.getIndicatorAxes(); $(a, function (o, s) { t.each(t.mapDimension(a[s].dim), function (l, c) { r[c] = r[c] || []; var u = i.dataToPoint(l, s); r[c][s] = e7(u) ? u : t7(i) }) }), t.each(function (o) { var s = W4e(r[o], function (l) { return e7(l) }) || t7(i); r[o].push(s.slice()), t.setItemLayout(o, r[o]) }) } }) } function e7(n) { return !isNaN(n[0]) && !isNaN(n[1]) } function t7(n) { return [n.cx, n.cy] } function cKe(n) { var e = n.polar; if (e) { ke(e) || (e = [e]); var t = []; $(e, function (r, i) { r.indicator ? (r.type && !r.shape && (r.shape = r.type), n.radar = n.radar || [], ke(n.radar) || (n.radar = [n.radar]), n.radar.push(r)) : t.push(r) }), n.polar = t } $(n.series, function (r) { r && r.type === "radar" && r.polarIndex && (r.radarIndex = r.polarIndex) }) } var uKe = function (n) { te(e, n); function e() { var t = n !== null && n.apply(this, arguments) || this; return t.type = e.type, t } return e.prototype.render = function (t, r, i) { var a = t.coordinateSystem, o = this.group, s = t.getData(), l = this._data; function c(f, h) { var p = f.getItemVisual(h, "symbol") || "circle"; if (p !== "none") { var m = ov(f.getItemVisual(h, "symbolSize")), g = Tr(p, -1, -1, 2, 2), y = f.getItemVisual(h, "symbolRotate") || 0; return g.attr({ style: { strokeNoScale: !0 }, z2: 100, scaleX: m[0] / 2, scaleY: m[1] / 2, rotation: y * Math.PI / 180 || 0 }), g } } function u(f, h, p, m, g, y) { p.removeAll(); for (var b = 0; b < h.length - 1; b++) { var w = c(m, g); w && (w.__dimIdx = b, f[b] ? (w.setPosition(f[b]), ap[y ? "initProps" : "updateProps"](w, { x: h[b][0], y: h[b][1] }, t, g)) : w.setPosition(h[b]), p.add(w)) } } function d(f) { return Ae(f, function (h) { return [a.cx, a.cy] }) } s.diff(l).add(function (f) { var h = s.getItemLayout(f); if (h) { var p = new Aa, m = new Ea, g = { shape: { points: h } }; p.shape.points = d(h), m.shape.points = d(h), Un(p, g, t, f), Un(m, g, t, f); var y = new ft, b = new ft; y.add(m), y.add(p), y.add(b), u(m.shape.points, h, b, s, f, !0), s.setItemGraphicEl(f, y) } }).update(function (f, h) { var p = l.getItemGraphicEl(h), m = p.childAt(0), g = p.childAt(1), y = p.childAt(2), b = { shape: { points: s.getItemLayout(f) } }; b.shape.points && (u(m.shape.points, b.shape.points, y, s, f, !1), Ms(g), Ms(m), on(m, b, t), on(g, b, t), s.setItemGraphicEl(f, p)) }).remove(function (f) { o.remove(l.getItemGraphicEl(f)) }).execute(), s.eachItemGraphicEl(function (f, h) { var p = s.getItemModel(h), m = f.childAt(0), g = f.childAt(1), y = f.childAt(2), b = s.getItemVisual(h, "style"), w = b.fill; o.add(f), m.useStyle(rt(p.getModel("lineStyle").getLineStyle(), { fill: "none", stroke: w })), pi(m, p, "lineStyle"), pi(g, p, "areaStyle"); var v = p.getModel("areaStyle"), S = v.isEmpty() && v.parentModel.isEmpty(); g.ignore = S, $(["emphasis", "select", "blur"], function (A) { var C = p.getModel([A, "areaStyle"]), E = C.isEmpty() && C.parentModel.isEmpty(); g.ensureState(A).ignore = E && S }), g.useStyle(rt(v.getAreaStyle(), { fill: w, opacity: .7, decal: b.decal })); var x = p.getModel("emphasis"), k = x.getModel("itemStyle").getItemStyle(); y.eachChild(function (A) { if (A instanceof gi) { var C = A.style; A.useStyle(be({ image: C.image, x: C.x, y: C.y, width: C.width, height: C.height }, b)) } else A.useStyle(b), A.setColor(w), A.style.strokeNoScale = !0; var E = A.ensureState("emphasis"); E.style = lt(k); var O = s.getStore().get(s.getDimensionIndex(A.__dimIdx), h); (O == null || isNaN(O)) && (O = ""), mi(A, Ur(p), { labelFetcher: s.hostModel, labelDataIndex: h, labelDimIndex: A.__dimIdx, defaultText: O, inheritColor: w, defaultOpacity: b.opacity }) }), Qn(f, x.get("focus"), x.get("blurScope"), x.get("disabled")) }), this._data = s }, e.prototype.remove = function () { this.group.removeAll(), this._data = null }, e.type = "radar", e }(Nn); const dKe = uKe; var fKe = function (n) { te(e, n); function e() { var t = n !== null && n.apply(this, arguments) || this; return t.type = e.type, t.hasSymbolVisual = !0, t } return e.prototype.init = function (t) { n.prototype.init.apply(this, arguments), this.legendVisualProvider = new Lb(He(this.getData, this), He(this.getRawData, this)) }, e.prototype.getInitialData = function (t, r) { return lv(this, { generateCoord: "indicator_", generateCoordCount: 1 / 0 }) }, e.prototype.formatTooltip = function (t, r, i) { var a = this.getData(), o = this.coordinateSystem, s = o.getIndicatorAxes(), l = this.getData().getName(t), c = l === "" ? this.name : l, u = Qne(this, t); return Gr("section", { header: c, sortBlocks: !0, blocks: Ae(s, function (d) { var f = a.get(a.mapDimension(d.dim), t); return Gr("nameValue", { markerType: "subItem", markerColor: u, name: d.name, value: f, sortParam: f }) }) }) }, e.prototype.getTooltipPosition = function (t) { if (t != null) { for (var r = this.getData(), i = this.coordinateSystem, a = r.getValues(Ae(i.dimensions, function (c) { return r.mapDimension(c) }), t), o = 0, s = a.length; o < s; o++)if (!isNaN(a[o])) { var l = i.getIndicatorAxes(); return i.coordToPoint(l[o].dataToCoord(a[o]), o) } } }, e.type = "series.radar", e.dependencies = ["radar"], e.defaultOption = { z: 2, colorBy: "data", coordinateSystem: "radar", legendHoverLink: !0, radarIndex: 0, lineStyle: { width: 2, type: "solid", join: "round" }, label: { position: "top" }, symbolSize: 8 }, e }(Yn); const hKe = fKe; var ay = Qie.value; function lx(n, e) { return rt({ show: e }, n) } var pKe = function (n) { te(e, n); function e() { var t = n !== null && n.apply(this, arguments) || this; return t.type = e.type, t } return e.prototype.optionUpdated = function () { var t = this.get("boundaryGap"), r = this.get("splitNumber"), i = this.get("scale"), a = this.get("axisLine"), o = this.get("axisTick"), s = this.get("axisLabel"), l = this.get("axisName"), c = this.get(["axisName", "show"]), u = this.get(["axisName", "formatter"]), d = this.get("axisNameGap"), f = this.get("triggerEvent"), h = Ae(this.get("indicator") || [], function (p) { p.max != null && p.max > 0 && !p.min ? p.min = 0 : p.min != null && p.min < 0 && !p.max && (p.max = 0); var m = l; p.color != null && (m = rt({ color: p.color }, l)); var g = xt(lt(p), { boundaryGap: t, splitNumber: r, scale: i, axisLine: a, axisTick: o, axisLabel: s, name: p.text, showName: c, nameLocation: "end", nameGap: d, nameTextStyle: m, triggerEvent: f }, !1); if (Fe(u)) { var y = g.name; g.name = u.replace("{value}", y ?? "") } else tt(u) && (g.name = u(g.name, g)); var b = new Rn(g, null, this.ecModel); return Cr(b, Mb.prototype), b.mainType = "radar", b.componentIndex = this.componentIndex, b }, this); this._indicatorModels = h }, e.prototype.getIndicatorModels = function () { return this._indicatorModels }, e.type = "radar", e.defaultOption = { z: 0, center: ["50%", "50%"], radius: "75%", startAngle: 90, axisName: { show: !0 }, boundaryGap: [0, 0], splitNumber: 5, axisNameGap: 15, scale: !1, shape: "polygon", axisLine: xt({ lineStyle: { color: "#bbb" } }, ay.axisLine), axisLabel: lx(ay.axisLabel, !1), axisTick: lx(ay.axisTick, !1), splitLine: lx(ay.splitLine, !0), splitArea: lx(ay.splitArea, !0), indicator: [] }, e }(Jt); const mKe = pKe; var gKe = ["axisLine", "axisTickLabel", "axisName"], vKe = function (n) { te(e, n); function e() { var t = n !== null && n.apply(this, arguments) || this; return t.type = e.type, t } return e.prototype.render = function (t, r, i) { var a = this.group; a.removeAll(), this._buildAxes(t), this._buildSplitLineAndArea(t) }, e.prototype._buildAxes = function (t) { var r = t.coordinateSystem, i = r.getIndicatorAxes(), a = Ae(i, function (o) { var s = o.model.get("showName") ? o.name : "", l = new Rc(o.model, { axisName: s, position: [r.cx, r.cy], rotation: o.angle, labelDirection: -1, tickDirection: -1, nameDirection: 1 }); return l }); $(a, function (o) { $(gKe, o.add, o), this.group.add(o.getGroup()) }, this) }, e.prototype._buildSplitLineAndArea = function (t) { var r = t.coordinateSystem, i = r.getIndicatorAxes(); if (!i.length) return; var a = t.get("shape"), o = t.getModel("splitLine"), s = t.getModel("splitArea"), l = o.getModel("lineStyle"), c = s.getModel("areaStyle"), u = o.get("show"), d = s.get("show"), f = l.get("color"), h = c.get("color"), p = ke(f) ? f : [f], m = ke(h) ? h : [h], g = [], y = []; function b(R, D, P) { var B = P % D.length; return R[B] = R[B] || [], B } if (a === "circle") for (var w = i[0].getTicksCoords(), v = r.cx, S = r.cy, x = 0; x < w.length; x++) { if (u) { var k = b(g, p, x); g[k].push(new Ud({ shape: { cx: v, cy: S, r: w[x].coord } })) } if (d && x < w.length - 1) { var k = b(y, m, x); y[k].push(new rC({ shape: { cx: v, cy: S, r0: w[x].coord, r: w[x + 1].coord } })) } } else for (var A, C = Ae(i, function (R, D) { var P = R.getTicksCoords(); return A = A == null ? P.length - 1 : Math.min(P.length - 1, A), Ae(P, function (B) { return r.coordToPoint(B.coord, D) }) }), E = [], x = 0; x <= A; x++) { for (var O = [], j = 0; j < i.length; j++)O.push(C[j][x]); if (O[0] && O.push(O[0].slice()), u) { var k = b(g, p, x); g[k].push(new Ea({ shape: { points: O } })) } if (d && E) { var k = b(y, m, x - 1); y[k].push(new Aa({ shape: { points: O.concat(E) } })) } E = O.slice().reverse() } var I = l.getLineStyle(), L = c.getAreaStyle(); $(y, function (R, D) { this.group.add(Co(R, { style: rt({ stroke: "none", fill: m[D % m.length] }, L), silent: !0 })) }, this), $(g, function (R, D) { this.group.add(Co(R, { style: rt({ fill: "none", stroke: p[D % p.length] }, I), silent: !0 })) }, this) }, e.type = "radar", e }(nr); const yKe = vKe; var _Ke = function (n) { te(e, n); function e(t, r, i) { var a = n.call(this, t, r, i) || this; return a.type = "value", a.angle = 0, a.name = "", a } return e }(Ps); const bKe = _Ke; var wKe = function () { function n(e, t, r) { this.dimensions = [], this._model = e, this._indicatorAxes = Ae(e.getIndicatorModels(), function (i, a) { var o = "indicator_" + a, s = new bKe(o, new Od); return s.name = i.get("name"), s.model = i, i.axis = s, this.dimensions.push(o), s }, this), this.resize(e, r) } return n.prototype.getIndicatorAxes = function () { return this._indicatorAxes }, n.prototype.dataToPoint = function (e, t) { var r = this._indicatorAxes[t]; return this.coordToPoint(r.dataToCoord(e), t) }, n.prototype.coordToPoint = function (e, t) { var r = this._indicatorAxes[t], i = r.angle, a = this.cx + e * Math.cos(i), o = this.cy - e * Math.sin(i); return [a, o] }, n.prototype.pointToData = function (e) { var t = e[0] - this.cx, r = e[1] - this.cy, i = Math.sqrt(t * t + r * r); t /= i, r /= i; for (var a = Math.atan2(-r, t), o = 1 / 0, s, l = -1, c = 0; c < this._indicatorAxes.length; c++) { var u = this._indicatorAxes[c], d = Math.abs(a - u.angle); d < o && (s = u, l = c, o = d) } return [l, +(s && s.coordToData(i))] }, n.prototype.resize = function (e, t) { var r = e.get("center"), i = t.getWidth(), a = t.getHeight(), o = Math.min(i, a) / 2; this.cx = Ne(r[0], i), this.cy = Ne(r[1], a), this.startAngle = e.get("startAngle") * Math.PI / 180; var s = e.get("radius"); (Fe(s) || nn(s)) && (s = [0, s]), this.r0 = Ne(s[0], o), this.r = Ne(s[1], o), $(this._indicatorAxes, function (l, c) { l.setExtent(this.r0, this.r); var u = this.startAngle + c * Math.PI * 2 / this._indicatorAxes.length; u = Math.atan2(Math.sin(u), Math.cos(u)), l.angle = u }, this) }, n.prototype.update = function (e, t) { var r = this._indicatorAxes, i = this._model; $(r, function (s) { s.scale.setExtent(1 / 0, -1 / 0) }), e.eachSeriesByType("radar", function (s, l) { if (!(s.get("coordinateSystem") !== "radar" || e.getComponent("radar", s.get("radarIndex")) !== i)) { var c = s.getData(); $(r, function (u) { u.scale.unionExtentFromData(c, c.mapDimension(u.dim)) }) } }, this); var a = i.get("splitNumber"), o = new Od; o.setExtent(0, a), o.setInterval(1), $(r, function (s, l) { eae(s.scale, s.model, o) }) }, n.prototype.convertToPixel = function (e, t, r) { return console.warn("Not implemented."), null }, n.prototype.convertFromPixel = function (e, t, r) { return console.warn("Not implemented."), null }, n.prototype.containPoint = function (e) { return console.warn("Not implemented."), !1 }, n.create = function (e, t) { var r = []; return e.eachComponent("radar", function (i) { var a = new n(i, e, t); r.push(a), i.coordinateSystem = a }), e.eachSeriesByType("radar", function (i) { i.get("coordinateSystem") === "radar" && (i.coordinateSystem = r[i.get("radarIndex") || 0]) }), r }, n.dimensions = [], n }(); const xKe = wKe; function SKe(n) { n.registerCoordinateSystem("radar", xKe), n.registerComponentModel(mKe), n.registerComponentView(yKe), n.registerVisual({ seriesType: "radar", reset: function (e) { var t = e.getData(); t.each(function (r) { t.setItemVisual(r, "legendIcon", "roundRect") }), t.setVisual("legendIcon", "roundRect") } }) } function TKe(n) { It(SKe), n.registerChartView(dKe), n.registerSeriesModel(hKe), n.registerLayout(lKe), n.registerProcessor(Ib("radar")), n.registerPreprocessor(cKe) } var n7 = "\0_ec_interaction_mutex"; function kKe(n, e, t) { var r = j3(n); r[e] = t } function CKe(n, e, t) { var r = j3(n), i = r[e]; i === t && (r[e] = null) } function r7(n, e) { return !!j3(n)[e] } function j3(n) { return n[n7] || (n[n7] = {}) } Ll({ type: "takeGlobalCursor", event: "globalCursorTaken", update: "update" }, gr); var AKe = function (n) { te(e, n); function e(t) { var r = n.call(this) || this; r._zr = t; var i = He(r._mousedownHandler, r), a = He(r._mousemoveHandler, r), o = He(r._mouseupHandler, r), s = He(r._mousewheelHandler, r), l = He(r._pinchHandler, r); return r.enable = function (c, u) { this.disable(), this._opt = rt(lt(u) || {}, { zoomOnMouseWheel: !0, moveOnMouseMove: !0, moveOnMouseWheel: !1, preventDefaultMouseMove: !0 }), c == null && (c = !0), (c === !0 || c === "move" || c === "pan") && (t.on("mousedown", i), t.on("mousemove", a), t.on("mouseup", o)), (c === !0 || c === "scale" || c === "zoom") && (t.on("mousewheel", s), t.on("pinch", l)) }, r.disable = function () { t.off("mousedown", i), t.off("mousemove", a), t.off("mouseup", o), t.off("mousewheel", s), t.off("pinch", l) }, r } return e.prototype.isDragging = function () { return this._dragging }, e.prototype.isPinching = function () { return this._pinching }, e.prototype.setPointerChecker = function (t) { this.pointerChecker = t }, e.prototype.dispose = function () { this.disable() }, e.prototype._mousedownHandler = function (t) { if (!M6(t)) { for (var r = t.target; r;) { if (r.draggable) return; r = r.__hostTarget || r.parent } var i = t.offsetX, a = t.offsetY; this.pointerChecker && this.pointerChecker(t, i, a) && (this._x = i, this._y = a, this._dragging = !0) } }, e.prototype._mousemoveHandler = function (t) { if (!(!this._dragging || !lS("moveOnMouseMove", t, this._opt) || t.gestureEvent === "pinch" || r7(this._zr, "globalPan"))) { var r = t.offsetX, i = t.offsetY, a = this._x, o = this._y, s = r - a, l = i - o; this._x = r, this._y = i, this._opt.preventDefaultMouseMove && Dc(t.event), sae(this, "pan", "moveOnMouseMove", t, { dx: s, dy: l, oldX: a, oldY: o, newX: r, newY: i, isAvailableBehavior: null }) } }, e.prototype._mouseupHandler = function (t) { M6(t) || (this._dragging = !1) }, e.prototype._mousewheelHandler = function (t) { var r = lS("zoomOnMouseWheel", t, this._opt), i = lS("moveOnMouseWheel", t, this._opt), a = t.wheelDelta, o = Math.abs(a), s = t.offsetX, l = t.offsetY; if (!(a === 0 || !r && !i)) { if (r) { var c = o > 3 ? 1.4 : o > 1 ? 1.2 : 1.1, u = a > 0 ? c : 1 / c; kO(this, "zoom", "zoomOnMouseWheel", t, { scale: u, originX: s, originY: l, isAvailableBehavior: null }) } if (i) { var d = Math.abs(a), f = (a > 0 ? 1 : -1) * (d > 3 ? .4 : d > 1 ? .15 : .05); kO(this, "scrollMove", "moveOnMouseWheel", t, { scrollDelta: f, originX: s, originY: l, isAvailableBehavior: null }) } } }, e.prototype._pinchHandler = function (t) { if (!r7(this._zr, "globalPan")) { var r = t.pinchScale > 1 ? 1.1 : 1 / 1.1; kO(this, "zoom", null, t, { scale: r, originX: t.pinchX, originY: t.pinchY, isAvailableBehavior: null }) } }, e }(Go); function kO(n, e, t, r, i) { n.pointerChecker && n.pointerChecker(r, i.originX, i.originY) && (Dc(r.event), sae(n, e, t, r, i)) } function sae(n, e, t, r, i) { i.isAvailableBehavior = He(lS, null, t, r), n.trigger(e, i) } function lS(n, e, t) { var r = t[n]; return !n || r && (!Fe(r) || e.event[r + "Key"]) } const Rb = AKe; function P3(n, e, t) { var r = n.target; r.x += e, r.y += t, r.dirty() } function I3(n, e, t, r) { var i = n.target, a = n.zoomLimit, o = n.zoom = n.zoom || 1; if (o *= e, a) { var s = a.min || 0, l = a.max || 1 / 0; o = Math.max(Math.min(l, o), s) } var c = o / n.zoom; n.zoom = o, i.x -= (t - i.x) * (c - 1), i.y -= (r - i.y) * (c - 1), i.scaleX *= c, i.scaleY *= c, i.dirty() } var EKe = { axisPointer: 1, tooltip: 1, brush: 1 }; function TC(n, e, t) { var r = e.getComponentByElement(n.topTarget), i = r && r.coordinateSystem; return r && r !== t && !EKe.hasOwnProperty(r.mainType) && i && i.model !== t } function lae(n) { if (Fe(n)) { var e = new DOMParser; n = e.parseFromString(n, "text/xml") } var t = n; for (t.nodeType === 9 && (t = t.firstChild); t.nodeName.toLowerCase() !== "svg" || t.nodeType !== 1;)t = t.nextSibling; return t } var CO, yT = { fill: "fill", stroke: "stroke", "stroke-width": "lineWidth", opacity: "opacity", "fill-opacity": "fillOpacity", "stroke-opacity": "strokeOpacity", "stroke-dasharray": "lineDash", "stroke-dashoffset": "lineDashOffset", "stroke-linecap": "lineCap", "stroke-linejoin": "lineJoin", "stroke-miterlimit": "miterLimit", "font-family": "fontFamily", "font-size": "fontSize", "font-style": "fontStyle", "font-weight": "fontWeight", "text-anchor": "textAlign", visibility: "visibility", display: "display" }, i7 = Bt(yT), _T = { "alignment-baseline": "textBaseline", "stop-color": "stopColor" }, a7 = Bt(_T), MKe = function () { function n() { this._defs = {}, this._root = null } return n.prototype.parse = function (e, t) { t = t || {}; var r = lae(e); this._defsUsePending = []; var i = new ft; this._root = i; var a = [], o = r.getAttribute("viewBox") || "", s = parseFloat(r.getAttribute("width") || t.width), l = parseFloat(r.getAttribute("height") || t.height); isNaN(s) && (s = null), isNaN(l) && (l = null), La(r, i, null, !0, !1); for (var c = r.firstChild; c;)this._parseNode(c, i, a, null, !1, !1), c = c.nextSibling; jKe(this._defs, this._defsUsePending), this._defsUsePending = []; var u, d; if (o) { var f = kC(o); f.length >= 4 && (u = { x: parseFloat(f[0] || 0), y: parseFloat(f[1] || 0), width: parseFloat(f[2]), height: parseFloat(f[3]) }) } if (u && s != null && l != null && (d = uae(u, { x: 0, y: 0, width: s, height: l }), !t.ignoreViewBox)) { var h = i; i = new ft, i.add(h), h.scaleX = h.scaleY = d.scale, h.x = d.x, h.y = d.y } return !t.ignoreRootClip && s != null && l != null && i.setClipPath(new Yt({ shape: { x: 0, y: 0, width: s, height: l } })), { root: i, width: s, height: l, viewBoxRect: u, viewBoxTransform: d, named: a } }, n.prototype._parseNode = function (e, t, r, i, a, o) { var s = e.nodeName.toLowerCase(), l, c = i; if (s === "defs" && (a = !0), s === "text" && (o = !0), s === "defs" || s === "switch") l = t; else { if (!a) { var u = CO[s]; if (u && Ge(CO, s)) { l = u.call(this, e, t); var d = e.getAttribute("name"); if (d) { var f = { name: d, namedFrom: null, svgNodeTagLower: s, el: l }; r.push(f), s === "g" && (c = f) } else i && r.push({ name: i.name, namedFrom: i, svgNodeTagLower: s, el: l }); t.add(l) } } var h = o7[s]; if (h && Ge(o7, s)) { var p = h.call(this, e), m = e.getAttribute("id"); m && (this._defs[m] = p) } } if (l && l.isGroup) for (var g = e.firstChild; g;)g.nodeType === 1 ? this._parseNode(g, l, r, c, a, o) : g.nodeType === 3 && o && this._parseText(g, l), g = g.nextSibling }, n.prototype._parseText = function (e, t) { var r = new g_({ style: { text: e.textContent }, silent: !0, x: this._textX || 0, y: this._textY || 0 }); uo(t, r), La(e, r, this._defsUsePending, !1, !1), OKe(r, t); var i = r.style, a = i.fontSize; a && a < 9 && (i.fontSize = 9, r.scaleX *= a / 9, r.scaleY *= a / 9); var o = (i.fontSize || i.fontFamily) && [i.fontStyle, i.fontWeight, (i.fontSize || 12) + "px", i.fontFamily || "sans-serif"].join(" "); i.font = o; var s = r.getBoundingRect(); return this._textX += s.width, t.add(r), r }, n.internalField = function () { CO = { g: function (e, t) { var r = new ft; return uo(t, r), La(e, r, this._defsUsePending, !1, !1), r }, rect: function (e, t) { var r = new Yt; return uo(t, r), La(e, r, this._defsUsePending, !1, !1), r.setShape({ x: parseFloat(e.getAttribute("x") || "0"), y: parseFloat(e.getAttribute("y") || "0"), width: parseFloat(e.getAttribute("width") || "0"), height: parseFloat(e.getAttribute("height") || "0") }), r.silent = !0, r }, circle: function (e, t) { var r = new Ud; return uo(t, r), La(e, r, this._defsUsePending, !1, !1), r.setShape({ cx: parseFloat(e.getAttribute("cx") || "0"), cy: parseFloat(e.getAttribute("cy") || "0"), r: parseFloat(e.getAttribute("r") || "0") }), r.silent = !0, r }, line: function (e, t) { var r = new Jr; return uo(t, r), La(e, r, this._defsUsePending, !1, !1), r.setShape({ x1: parseFloat(e.getAttribute("x1") || "0"), y1: parseFloat(e.getAttribute("y1") || "0"), x2: parseFloat(e.getAttribute("x2") || "0"), y2: parseFloat(e.getAttribute("y2") || "0") }), r.silent = !0, r }, ellipse: function (e, t) { var r = new VN; return uo(t, r), La(e, r, this._defsUsePending, !1, !1), r.setShape({ cx: parseFloat(e.getAttribute("cx") || "0"), cy: parseFloat(e.getAttribute("cy") || "0"), rx: parseFloat(e.getAttribute("rx") || "0"), ry: parseFloat(e.getAttribute("ry") || "0") }), r.silent = !0, r }, polygon: function (e, t) { var r = e.getAttribute("points"), i; r && (i = c7(r)); var a = new Aa({ shape: { points: i || [] }, silent: !0 }); return uo(t, a), La(e, a, this._defsUsePending, !1, !1), a }, polyline: function (e, t) { var r = e.getAttribute("points"), i; r && (i = c7(r)); var a = new Ea({ shape: { points: i || [] }, silent: !0 }); return uo(t, a), La(e, a, this._defsUsePending, !1, !1), a }, image: function (e, t) { var r = new gi; return uo(t, r), La(e, r, this._defsUsePending, !1, !1), r.setStyle({ image: e.getAttribute("xlink:href") || e.getAttribute("href"), x: +e.getAttribute("x"), y: +e.getAttribute("y"), width: +e.getAttribute("width"), height: +e.getAttribute("height") }), r.silent = !0, r }, text: function (e, t) { var r = e.getAttribute("x") || "0", i = e.getAttribute("y") || "0", a = e.getAttribute("dx") || "0", o = e.getAttribute("dy") || "0"; this._textX = parseFloat(r) + parseFloat(a), this._textY = parseFloat(i) + parseFloat(o); var s = new ft; return uo(t, s), La(e, s, this._defsUsePending, !1, !0), s }, tspan: function (e, t) { var r = e.getAttribute("x"), i = e.getAttribute("y"); r != null && (this._textX = parseFloat(r)), i != null && (this._textY = parseFloat(i)); var a = e.getAttribute("dx") || "0", o = e.getAttribute("dy") || "0", s = new ft; return uo(t, s), La(e, s, this._defsUsePending, !1, !0), this._textX += parseFloat(a), this._textY += parseFloat(o), s }, path: function (e, t) { var r = e.getAttribute("d") || "", i = Rte(r); return uo(t, i), La(e, i, this._defsUsePending, !1, !1), i.silent = !0, i } } }(), n }(), o7 = { lineargradient: function (n) { var e = parseInt(n.getAttribute("x1") || "0", 10), t = parseInt(n.getAttribute("y1") || "0", 10), r = parseInt(n.getAttribute("x2") || "10", 10), i = parseInt(n.getAttribute("y2") || "0", 10), a = new Sb(e, t, r, i); return s7(n, a), l7(n, a), a }, radialgradient: function (n) { var e = parseInt(n.getAttribute("cx") || "0", 10), t = parseInt(n.getAttribute("cy") || "0", 10), r = parseInt(n.getAttribute("r") || "0", 10), i = new Yte(e, t, r); return s7(n, i), l7(n, i), i } }; function s7(n, e) { var t = n.getAttribute("gradientUnits"); t === "userSpaceOnUse" && (e.global = !0) } function l7(n, e) { for (var t = n.firstChild; t;) { if (t.nodeType === 1 && t.nodeName.toLocaleLowerCase() === "stop") { var r = t.getAttribute("offset"), i = void 0; r && r.indexOf("%") > 0 ? i = parseInt(r, 10) / 100 : r ? i = parseFloat(r) : i = 0; var a = {}; cae(t, a, a); var o = a.stopColor || t.getAttribute("stop-color") || "#000000"; e.colorStops.push({ offset: i, color: o }) } t = t.nextSibling } } function uo(n, e) { n && n.__inheritedStyle && (e.__inheritedStyle || (e.__inheritedStyle = {}), rt(e.__inheritedStyle, n.__inheritedStyle)) } function c7(n) { for (var e = kC(n), t = [], r = 0; r < e.length; r += 2) { var i = parseFloat(e[r]), a = parseFloat(e[r + 1]); t.push([i, a]) } return t } function La(n, e, t, r, i) { var a = e, o = a.__inheritedStyle = a.__inheritedStyle || {}, s = {}; n.nodeType === 1 && (LKe(n, e), cae(n, o, s), r || RKe(n, o, s)), a.style = a.style || {}, o.fill != null && (a.style.fill = u7(a, "fill", o.fill, t)), o.stroke != null && (a.style.stroke = u7(a, "stroke", o.stroke, t)), $(["lineWidth", "opacity", "fillOpacity", "strokeOpacity", "miterLimit", "fontSize"], function (l) { o[l] != null && (a.style[l] = parseFloat(o[l])) }), $(["lineDashOffset", "lineCap", "lineJoin", "fontWeight", "fontFamily", "fontStyle", "textAlign"], function (l) { o[l] != null && (a.style[l] = o[l]) }), i && (a.__selfStyle = s), o.lineDash && (a.style.lineDash = Ae(kC(o.lineDash), function (l) { return parseFloat(l) })), (o.visibility === "hidden" || o.visibility === "collapse") && (a.invisible = !0), o.display === "none" && (a.ignore = !0) } function OKe(n, e) { var t = e.__selfStyle; if (t) { var r = t.textBaseline, i = r; !r || r === "auto" || r === "baseline" ? i = "alphabetic" : r === "before-edge" || r === "text-before-edge" ? i = "top" : r === "after-edge" || r === "text-after-edge" ? i = "bottom" : (r === "central" || r === "mathematical") && (i = "middle"), n.style.textBaseline = i } var a = e.__inheritedStyle; if (a) { var o = a.textAlign, s = o; o && (o === "middle" && (s = "center"), n.style.textAlign = s) } } var DKe = /^url\(\s*#(.*?)\)/; function u7(n, e, t, r) { var i = t && t.match(DKe); if (i) { var a = ps(i[1]); r.push([n, e, a]); return } return t === "none" && (t = null), t } function jKe(n, e) { for (var t = 0; t < e.length; t++) { var r = e[t]; r[0].style[r[1]] = n[r[2]] } } var PKe = /-?([0-9]*\.)?[0-9]+([eE]-?[0-9]+)?/g; function kC(n) { return n.match(PKe) || [] } var IKe = /(translate|scale|rotate|skewX|skewY|matrix)\(([\-\s0-9\.eE,]*)\)/g, AO = Math.PI / 180; function LKe(n, e) { var t = n.getAttribute("transform"); if (t) { t = t.replace(/,/g, " "); var r = [], i = null; t.replace(IKe, function (d, f, h) { return r.push(f, h), "" }); for (var a = r.length - 1; a > 0; a -= 2) { var o = r[a], s = r[a - 1], l = kC(o); switch (i = i || Va(), s) { case "translate": Sl(i, i, [parseFloat(l[0]), parseFloat(l[1] || "0")]); break; case "scale": kN(i, i, [parseFloat(l[0]), parseFloat(l[1] || l[0])]); break; case "rotate": rp(i, i, -parseFloat(l[0]) * AO, [parseFloat(l[1] || "0"), parseFloat(l[2] || "0")]); break; case "skewX": var c = Math.tan(parseFloat(l[0]) * AO); bc(i, [1, 0, c, 1, 0, 0], i); break; case "skewY": var u = Math.tan(parseFloat(l[0]) * AO); bc(i, [1, u, 0, 1, 0, 0], i); break; case "matrix": i[0] = parseFloat(l[0]), i[1] = parseFloat(l[1]), i[2] = parseFloat(l[2]), i[3] = parseFloat(l[3]), i[4] = parseFloat(l[4]), i[5] = parseFloat(l[5]); break } } e.setLocalTransform(i) } } var d7 = /([^\s:;]+)\s*:\s*([^:;]+)/g; function cae(n, e, t) { var r = n.getAttribute("style"); if (r) { d7.lastIndex = 0; for (var i; (i = d7.exec(r)) != null;) { var a = i[1], o = Ge(yT, a) ? yT[a] : null; o && (e[o] = i[2]); var s = Ge(_T, a) ? _T[a] : null; s && (t[s] = i[2]) } } } function RKe(n, e, t) { for (var r = 0; r < i7.length; r++) { var i = i7[r], a = n.getAttribute(i); a != null && (e[yT[i]] = a) } for (var r = 0; r < a7.length; r++) { var i = a7[r], a = n.getAttribute(i); a != null && (t[_T[i]] = a) } } function uae(n, e) { var t = e.width / n.width, r = e.height / n.height, i = Math.min(t, r); return { scale: i, x: -(n.x + n.width / 2) * i + (e.x + e.width / 2), y: -(n.y + n.height / 2) * i + (e.y + e.height / 2) } } function NKe(n, e) { var t = new MKe; return t.parse(n, e) } var BKe = Ze(["rect", "circle", "line", "ellipse", "polygon", "polyline", "path", "text", "tspan", "g"]), $Ke = function () {
  function n(e, t) { this.type = "geoSVG", this._usedGraphicMap = Ze(), this._freedGraphics = [], this._mapName = e, this._parsedXML = lae(t) } return n.prototype.load = function () { var e = this._firstGraphic; if (!e) { e = this._firstGraphic = this._buildGraphic(this._parsedXML), this._freedGraphics.push(e), this._boundingRect = this._firstGraphic.boundingRect.clone(); var t = zKe(e.named), r = t.regions, i = t.regionsMap; this._regions = r, this._regionsMap = i } return { boundingRect: this._boundingRect, regions: this._regions, regionsMap: this._regionsMap } }, n.prototype._buildGraphic = function (e) {
    var t, r; try { t = e && NKe(e, { ignoreViewBox: !0, ignoreRootClip: !0 }) || {}, r = t.root, na(r != null) } catch (g) {
      throw new Error(`Invalid svg format
`+ g.message)
    } var i = new ft; i.add(r), i.isGeoSVGGraphicRoot = !0; var a = t.width, o = t.height, s = t.viewBoxRect, l = this._boundingRect; if (!l) { var c = void 0, u = void 0, d = void 0, f = void 0; if (a != null ? (c = 0, d = a) : s && (c = s.x, d = s.width), o != null ? (u = 0, f = o) : s && (u = s.y, f = s.height), c == null || u == null) { var h = r.getBoundingRect(); c == null && (c = h.x, d = h.width), u == null && (u = h.y, f = h.height) } l = this._boundingRect = new kt(c, u, d, f) } if (s) { var p = uae(s, l); r.scaleX = r.scaleY = p.scale, r.x = p.x, r.y = p.y } i.setClipPath(new Yt({ shape: l.plain() })); var m = []; return $(t.named, function (g) { BKe.get(g.svgNodeTagLower) != null && (m.push(g), FKe(g.el)) }), { root: i, boundingRect: l, named: m }
  }, n.prototype.useGraphic = function (e) { var t = this._usedGraphicMap, r = t.get(e); return r || (r = this._freedGraphics.pop() || this._buildGraphic(this._parsedXML), t.set(e, r), r) }, n.prototype.freeGraphic = function (e) { var t = this._usedGraphicMap, r = t.get(e); r && (t.removeKey(e), this._freedGraphics.push(r)) }, n
}(); function FKe(n) { n.silent = !1, n.isGroup && n.traverse(function (e) { e.silent = !1 }) } function zKe(n) { var e = [], t = Ze(); return $(n, function (r) { if (r.namedFrom == null) { var i = new iUe(r.name, r.el); e.push(i), t.set(r.name, i) } }), { regions: e, regionsMap: t } } var MI = [126, 25], f7 = "", Lf = [[[0, 3.5], [7, 11.2], [15, 11.9], [30, 7], [42, .7], [52, .7], [56, 7.7], [59, .7], [64, .7], [64, 0], [5, 0], [0, 3.5]], [[13, 16.1], [19, 14.7], [16, 21.7], [11, 23.1], [13, 16.1]], [[12, 32.2], [14, 38.5], [15, 38.5], [13, 32.2], [12, 32.2]], [[16, 47.6], [12, 53.2], [13, 53.2], [18, 47.6], [16, 47.6]], [[6, 64.4], [8, 70], [9, 70], [8, 64.4], [6, 64.4]], [[23, 82.6], [29, 79.8], [30, 79.8], [25, 82.6], [23, 82.6]], [[37, 70.7], [43, 62.3], [44, 62.3], [39, 70.7], [37, 70.7]], [[48, 51.1], [51, 45.5], [53, 45.5], [50, 51.1], [48, 51.1]], [[51, 35], [51, 28.7], [53, 28.7], [53, 35], [51, 35]], [[52, 22.4], [55, 17.5], [56, 17.5], [53, 22.4], [52, 22.4]], [[58, 12.6], [62, 7], [63, 7], [60, 12.6], [58, 12.6]], [[0, 3.5], [0, 93.1], [64, 93.1], [64, 0], [63, 0], [63, 92.4], [1, 92.4], [1, 3.5], [0, 3.5]]]; for (var jf = 0; jf < Lf.length; jf++)for (var Qp = 0; Qp < Lf[jf].length; Qp++)Lf[jf][Qp][0] /= 10.5, Lf[jf][Qp][1] /= -10.5 / .75, Lf[jf][Qp][0] += MI[0], Lf[jf][Qp][1] += MI[1]; function VKe(n, e) { if (n === "china") { for (var t = 0; t < e.length; t++)if (e[t].name === f7) return; e.push(new aie(f7, Ae(Lf, function (r) { return { type: "polygon", exterior: r } }), MI)) } } var HKe = { : [32, 80], : [0, -10], : [10, 5], : [-10, 10], : [5, 5] }; function UKe(n, e) { if (n === "china") { var t = HKe[e.name]; if (t) { var r = e.getCenter(); r[0] += t[0] / 10.5, r[1] += -t[1] / (10.5 / .75), e.setCenter(r) } } } var GKe = [[[123.45165252685547, 25.73527164402261], [123.49731445312499, 25.73527164402261], [123.49731445312499, 25.750734064600884], [123.45165252685547, 25.750734064600884], [123.45165252685547, 25.73527164402261]]]; function WKe(n, e) { n === "china" && e.name === "" && e.geometries.push({ type: "polygon", exterior: GKe[0] }) } var KKe = "name", qKe = function () {
  function n(e, t, r) { this.type = "geoJSON", this._parsedMap = Ze(), this._mapName = e, this._specialAreas = r, this._geoJSON = ZKe(t) } return n.prototype.load = function (e, t) { t = t || KKe; var r = this._parsedMap.get(t); if (!r) { var i = this._parseToRegions(t); r = this._parsedMap.set(t, { regions: i, boundingRect: YKe(i) }) } var a = Ze(), o = []; return $(r.regions, function (s) { var l = s.name; e && Ge(e, l) && (s = s.cloneShallow(l = e[l])), o.push(s), a.set(l, s) }), { regions: o, boundingRect: r.boundingRect || new kt(0, 0, 0, 0), regionsMap: a } }, n.prototype._parseToRegions = function (e) {
    var t = this._mapName, r = this._geoJSON, i; try { i = r ? oUe(r, e) : [] } catch (a) {
      throw new Error(`Invalid geoJson format
`+ a.message)
    } return VKe(t, i), $(i, function (a) { var o = a.name; UKe(t, a), WKe(t, a); var s = this._specialAreas && this._specialAreas[o]; s && a.transformTo(s.left, s.top, s.width, s.height) }, this), i
  }, n.prototype.getMapForUser = function () { return { geoJson: this._geoJSON, geoJSON: this._geoJSON, specialAreas: this._specialAreas } }, n
}(); function YKe(n) { for (var e, t = 0; t < n.length; t++) { var r = n[t].getBoundingRect(); e = e || r.clone(), e.union(r) } return e } function ZKe(n) { return Fe(n) ? typeof JSON < "u" && JSON.parse ? JSON.parse(n) : new Function("return (" + n + ");")() : n } var oy = Ze(); const Nc = { registerMap: function (n, e, t) { if (e.svg) { var r = new $Ke(n, e.svg); oy.set(n, r) } else { var i = e.geoJson || e.geoJSON; i && !e.features ? t = e.specialAreas : i = e; var r = new qKe(n, i, t); oy.set(n, r) } }, getGeoResource: function (n) { return oy.get(n) }, getMapForUser: function (n) { var e = oy.get(n); return e && e.type === "geoJSON" && e.getMapForUser() }, load: function (n, e, t) { var r = oy.get(n); if (r) return r.load(e, t) } }; var L3 = ["rect", "circle", "line", "ellipse", "polygon", "polyline", "path"], XKe = Ze(L3), JKe = Ze(L3.concat(["g"])), QKe = Ze(L3.concat(["g"])), dae = Kt(); function cx(n) { var e = n.getItemStyle(), t = n.get("areaColor"); return t != null && (e.fill = t), e } function h7(n) { var e = n.style; e && (e.stroke = e.stroke || e.fill, e.fill = null) } var eqe = function () { function n(e) { var t = new ft; this.uid = Qg("ec_map_draw"), this._controller = new Rb(e.getZr()), this._controllerHost = { target: t }, this.group = t, t.add(this._regionsGroup = new ft), t.add(this._svgGroup = new ft) } return n.prototype.draw = function (e, t, r, i, a) { var o = e.mainType === "geo", s = e.getData && e.getData(); o && t.eachComponent({ mainType: "series", subType: "map" }, function (y) { !s && y.getHostGeoModel() === e && (s = y.getData()) }); var l = e.coordinateSystem, c = this._regionsGroup, u = this.group, d = l.getTransformInfo(), f = d.raw, h = d.roam, p = !c.childAt(0) || a; p ? (u.x = h.x, u.y = h.y, u.scaleX = h.scaleX, u.scaleY = h.scaleY, u.dirty()) : on(u, h, e); var m = s && s.getVisual("visualMeta") && s.getVisual("visualMeta").length > 0, g = { api: r, geo: l, mapOrGeoModel: e, data: s, isVisualEncodedByVisualMap: m, isGeo: o, transformInfoRaw: f }; l.resourceType === "geoJSON" ? this._buildGeoJSON(g) : l.resourceType === "geoSVG" && this._buildSVG(g), this._updateController(e, t, r), this._updateMapSelectHandler(e, c, r, i) }, n.prototype._buildGeoJSON = function (e) { var t = this._regionsGroupByName = Ze(), r = Ze(), i = this._regionsGroup, a = e.transformInfoRaw, o = e.mapOrGeoModel, s = e.data, l = e.geo.projection, c = l && l.stream; function u(h, p) { return p && (h = p(h)), h && [h[0] * a.scaleX + a.x, h[1] * a.scaleY + a.y] } function d(h) { for (var p = [], m = !c && l && l.project, g = 0; g < h.length; ++g) { var y = u(h[g], m); y && p.push(y) } return p } function f(h) { return { shape: { points: d(h) } } } i.removeAll(), $(e.geo.regions, function (h) { var p = h.name, m = t.get(p), g = r.get(p) || {}, y = g.dataIdx, b = g.regionModel; if (!m) { m = t.set(p, new ft), i.add(m), y = s ? s.indexOfName(p) : null, b = e.isGeo ? o.getRegionModel(p) : s ? s.getItemModel(y) : null; var w = b.get("silent", !0); w != null && (m.silent = w), r.set(p, { dataIdx: y, regionModel: b }) } var v = [], S = []; $(h.geometries, function (A) { if (A.type === "polygon") { var C = [A.exterior].concat(A.interiors || []); c && (C = _7(C, c)), $(C, function (O) { v.push(new Aa(f(O))) }) } else { var E = A.points; c && (E = _7(E, c, !0)), $(E, function (O) { S.push(new Ea(f(O))) }) } }); var x = u(h.getCenter(), l && l.project); function k(A, C) { if (A.length) { var E = new UN({ culling: !0, segmentIgnoreThreshold: 1, shape: { paths: A } }); m.add(E), p7(e, E, y, b), m7(e, E, p, b, o, y, x), C && (h7(E), $(E.states, h7)) } } k(v), k(S, !0) }), t.each(function (h, p) { var m = r.get(p), g = m.dataIdx, y = m.regionModel; g7(e, h, p, y, o, g), v7(e, h, p, y, o), y7(e, h, p, y, o) }, this) }, n.prototype._buildSVG = function (e) { var t = e.geo.map, r = e.transformInfoRaw; this._svgGroup.x = r.x, this._svgGroup.y = r.y, this._svgGroup.scaleX = r.scaleX, this._svgGroup.scaleY = r.scaleY, this._svgResourceChanged(t) && (this._freeSVG(), this._useSVG(t)); var i = this._svgDispatcherMap = Ze(), a = !1; $(this._svgGraphicRecord.named, function (o) { var s = o.name, l = e.mapOrGeoModel, c = e.data, u = o.svgNodeTagLower, d = o.el, f = c ? c.indexOfName(s) : null, h = l.getRegionModel(s); XKe.get(u) != null && d instanceof Ho && p7(e, d, f, h), d instanceof Ho && (d.culling = !0); var p = h.get("silent", !0); if (p != null && (d.silent = p), d.z2EmphasisLift = 0, !o.namedFrom && (QKe.get(u) != null && m7(e, d, s, h, l, f, null), g7(e, d, s, h, l, f), v7(e, d, s, h, l), JKe.get(u) != null)) { var m = y7(e, d, s, h, l); m === "self" && (a = !0); var g = i.get(s) || i.set(s, []); g.push(d) } }, this), this._enableBlurEntireSVG(a, e) }, n.prototype._enableBlurEntireSVG = function (e, t) { if (e && t.isGeo) { var r = t.mapOrGeoModel.getModel(["blur", "itemStyle"]).getItemStyle(), i = r.opacity; this._svgGraphicRecord.root.traverse(function (a) { if (!a.isGroup) { Gh(a); var o = a.ensureState("blur").style || {}; o.opacity == null && i != null && (o.opacity = i), a.ensureState("emphasis") } }) } }, n.prototype.remove = function () { this._regionsGroup.removeAll(), this._regionsGroupByName = null, this._svgGroup.removeAll(), this._freeSVG(), this._controller.dispose(), this._controllerHost = null }, n.prototype.findHighDownDispatchers = function (e, t) { if (e == null) return []; var r = t.coordinateSystem; if (r.resourceType === "geoJSON") { var i = this._regionsGroupByName; if (i) { var a = i.get(e); return a ? [a] : [] } } else if (r.resourceType === "geoSVG") return this._svgDispatcherMap && this._svgDispatcherMap.get(e) || [] }, n.prototype._svgResourceChanged = function (e) { return this._svgMapName !== e }, n.prototype._useSVG = function (e) { var t = Nc.getGeoResource(e); if (t && t.type === "geoSVG") { var r = t.useGraphic(this.uid); this._svgGroup.add(r.root), this._svgGraphicRecord = r, this._svgMapName = e } }, n.prototype._freeSVG = function () { var e = this._svgMapName; if (e != null) { var t = Nc.getGeoResource(e); t && t.type === "geoSVG" && t.freeGraphic(this.uid), this._svgGraphicRecord = null, this._svgDispatcherMap = null, this._svgGroup.removeAll(), this._svgMapName = null } }, n.prototype._updateController = function (e, t, r) { var i = e.coordinateSystem, a = this._controller, o = this._controllerHost; o.zoomLimit = e.get("scaleLimit"), o.zoom = i.getZoom(), a.enable(e.get("roam") || !1); var s = e.mainType; function l() { var c = { type: "geoRoam", componentType: s }; return c[s + "Id"] = e.id, c } a.off("pan").on("pan", function (c) { this._mouseDownFlag = !1, P3(o, c.dx, c.dy), r.dispatchAction(be(l(), { dx: c.dx, dy: c.dy, animation: { duration: 0 } })) }, this), a.off("zoom").on("zoom", function (c) { this._mouseDownFlag = !1, I3(o, c.scale, c.originX, c.originY), r.dispatchAction(be(l(), { totalZoom: o.zoom, zoom: c.scale, originX: c.originX, originY: c.originY, animation: { duration: 0 } })) }, this), a.setPointerChecker(function (c, u, d) { return i.containPoint([u, d]) && !TC(c, r, e) }) }, n.prototype.resetForLabelLayout = function () { this.group.traverse(function (e) { var t = e.getTextContent(); t && (t.ignore = dae(t).ignore) }) }, n.prototype._updateMapSelectHandler = function (e, t, r, i) { var a = this; t.off("mousedown"), t.off("click"), e.get("selectedMode") && (t.on("mousedown", function () { a._mouseDownFlag = !0 }), t.on("click", function (o) { a._mouseDownFlag && (a._mouseDownFlag = !1) })) }, n }(); function p7(n, e, t, r) { var i = r.getModel("itemStyle"), a = r.getModel(["emphasis", "itemStyle"]), o = r.getModel(["blur", "itemStyle"]), s = r.getModel(["select", "itemStyle"]), l = cx(i), c = cx(a), u = cx(s), d = cx(o), f = n.data; if (f) { var h = f.getItemVisual(t, "style"), p = f.getItemVisual(t, "decal"); n.isVisualEncodedByVisualMap && h.fill && (l.fill = h.fill), p && (l.decal = Ag(p, n.api)) } e.setStyle(l), e.style.strokeNoScale = !0, e.ensureState("emphasis").style = c, e.ensureState("select").style = u, e.ensureState("blur").style = d, Gh(e) } function m7(n, e, t, r, i, a, o) { var s = n.data, l = n.isGeo, c = s && isNaN(s.get(s.mapDimension("value"), a)), u = s && s.getItemLayout(a); if (l || c || u && u.showLabel) { var d = l ? t : a, f = void 0; (!s || a >= 0) && (f = i); var h = o ? { normal: { align: "center", verticalAlign: "middle" } } : null; mi(e, Ur(r), { labelFetcher: f, labelDataIndex: d, defaultText: t }, h); var p = e.getTextContent(); if (p && (dae(p).ignore = p.ignore, e.textConfig && o)) { var m = e.getBoundingRect().clone(); e.textConfig.layoutRect = m, e.textConfig.position = [(o[0] - m.x) / m.width * 100 + "%", (o[1] - m.y) / m.height * 100 + "%"] } e.disableLabelAnimation = !0 } else e.removeTextContent(), e.removeTextConfig(), e.disableLabelAnimation = null } function g7(n, e, t, r, i, a) { n.data ? n.data.setItemGraphicEl(a, e) : pt(e).eventData = { componentType: "geo", componentIndex: i.componentIndex, geoIndex: i.componentIndex, name: t, region: r && r.option || {} } } function v7(n, e, t, r, i) { n.data || ip({ el: e, componentModel: i, itemName: t, itemTooltipOption: r.get("tooltip") }) } function y7(n, e, t, r, i) { e.highDownSilentOnTouch = !!i.get("selectedMode"); var a = r.getModel("emphasis"), o = a.get("focus"); return Qn(e, o, a.get("blurScope"), a.get("disabled")), n.isGeo && t6e(e, i, t), o } function _7(n, e, t) { var r = [], i; function a() { i = [] } function o() { i.length && (r.push(i), i = []) } var s = e({ polygonStart: a, polygonEnd: o, lineStart: a, lineEnd: o, point: function (l, c) { isFinite(l) && isFinite(c) && i.push([l, c]) }, sphere: function () { } }); return !t && s.polygonStart(), $(n, function (l) { s.lineStart(); for (var c = 0; c < l.length; c++)s.point(l[c][0], l[c][1]); s.lineEnd() }), !t && s.polygonEnd(), r } const fae = eqe; var tqe = function (n) { te(e, n); function e() { var t = n !== null && n.apply(this, arguments) || this; return t.type = e.type, t } return e.prototype.render = function (t, r, i, a) { if (!(a && a.type === "mapToggleSelect" && a.from === this.uid)) { var o = this.group; if (o.removeAll(), !t.getHostGeoModel()) { if (this._mapDraw && a && a.type === "geoRoam" && this._mapDraw.resetForLabelLayout(), a && a.type === "geoRoam" && a.componentType === "series" && a.seriesId === t.id) { var s = this._mapDraw; s && o.add(s.group) } else if (t.needsDrawMap) { var s = this._mapDraw || new fae(i); o.add(s.group), s.draw(t, r, i, this, a), this._mapDraw = s } else this._mapDraw && this._mapDraw.remove(), this._mapDraw = null; t.get("showLegendSymbol") && r.getComponent("legend") && this._renderSymbols(t, r, i) } } }, e.prototype.remove = function () { this._mapDraw && this._mapDraw.remove(), this._mapDraw = null, this.group.removeAll() }, e.prototype.dispose = function () { this._mapDraw && this._mapDraw.remove(), this._mapDraw = null }, e.prototype._renderSymbols = function (t, r, i) { var a = t.originalData, o = this.group; a.each(a.mapDimension("value"), function (s, l) { if (!isNaN(s)) { var c = a.getItemLayout(l); if (!(!c || !c.point)) { var u = c.point, d = c.offset, f = new Ud({ style: { fill: t.getData().getVisual("style").fill }, shape: { cx: u[0] + d * 9, cy: u[1], r: 3 }, silent: !0, z2: 8 + (d ? 0 : Zg + 1) }); if (!d) { var h = t.mainSeries.getData(), p = a.getName(l), m = h.indexOfName(p), g = a.getItemModel(l), y = g.getModel("label"), b = h.getItemGraphicEl(m); mi(f, Ur(g), { labelFetcher: { getFormattedLabel: function (w, v) { return t.getFormattedLabel(m, v) } }, defaultText: p }), f.disableLabelAnimation = !0, y.get("position") || f.setTextConfig({ position: "bottom" }), b.onHoverStateChange = function (w) { X2(f, w) } } o.add(f) } } }) }, e.type = "map", e }(Nn); const nqe = tqe; var rqe = function (n) { te(e, n); function e() { var t = n !== null && n.apply(this, arguments) || this; return t.type = e.type, t.needsDrawMap = !1, t.seriesGroup = [], t.getTooltipPosition = function (r) { if (r != null) { var i = this.getData().getName(r), a = this.coordinateSystem, o = a.getRegion(i); return o && a.dataToPoint(o.getCenter()) } }, t } return e.prototype.getInitialData = function (t) { for (var r = lv(this, { coordDimensions: ["value"], encodeDefaulter: wt(e3, this) }), i = Ze(), a = [], o = 0, s = r.count(); o < s; o++) { var l = r.getName(o); i.set(l, o) } var c = Nc.load(this.getMapType(), this.option.nameMap, this.option.nameProperty); return $(c.regions, function (u) { var d = u.name, f = i.get(d), h = u.properties && u.properties.echartsStyle, p; f == null ? (p = { name: d }, a.push(p)) : p = r.getRawDataItem(f), h && xt(p, h) }), r.appendData(a), r }, e.prototype.getHostGeoModel = function () { var t = this.option.geoIndex; return t != null ? this.ecModel.getComponent("geo", t) : null }, e.prototype.getMapType = function () { return (this.getHostGeoModel() || this).option.map }, e.prototype.getRawValue = function (t) { var r = this.getData(); return r.get(r.mapDimension("value"), t) }, e.prototype.getRegionModel = function (t) { var r = this.getData(); return r.getItemModel(r.indexOfName(t)) }, e.prototype.formatTooltip = function (t, r, i) { for (var a = this.getData(), o = this.getRawValue(t), s = a.getName(t), l = this.seriesGroup, c = [], u = 0; u < l.length; u++) { var d = l[u].originalData.indexOfName(s), f = a.mapDimension("value"); isNaN(l[u].originalData.get(f, d)) || c.push(l[u].name) } return Gr("section", { header: c.join(", "), noHeader: !c.length, blocks: [Gr("nameValue", { name: s, value: o })] }) }, e.prototype.setZoom = function (t) { this.option.zoom = t }, e.prototype.setCenter = function (t) { this.option.center = t }, e.prototype.getLegendIcon = function (t) { var r = t.icon || "roundRect", i = Tr(r, 0, 0, t.itemWidth, t.itemHeight, t.itemStyle.fill); return i.setStyle(t.itemStyle), i.style.stroke = "none", r.indexOf("empty") > -1 && (i.style.stroke = i.style.fill, i.style.fill = "#fff", i.style.lineWidth = 2), i }, e.type = "series.map", e.dependencies = ["geo"], e.layoutMode = "box", e.defaultOption = { z: 2, coordinateSystem: "geo", map: "", left: "center", top: "center", aspectScale: null, showLegendSymbol: !0, boundingCoords: null, center: null, zoom: 1, scaleLimit: null, selectedMode: !0, label: { show: !1, color: "#000" }, itemStyle: { borderWidth: .5, borderColor: "#444", areaColor: "#eee" }, emphasis: { label: { show: !0, color: "rgb(100,0,0)" }, itemStyle: { areaColor: "rgba(255,215,0,0.8)" } }, select: { label: { show: !0, color: "rgb(100,0,0)" }, itemStyle: { color: "rgba(255,215,0,0.8)" } }, nameProperty: "name" }, e }(Yn); const iqe = rqe; function aqe(n, e) { var t = {}; return $(n, function (r) { r.each(r.mapDimension("value"), function (i, a) { var o = "ec-" + r.getName(a); t[o] = t[o] || [], isNaN(i) || t[o].push(i) }) }), n[0].map(n[0].mapDimension("value"), function (r, i) { for (var a = "ec-" + n[0].getName(i), o = 0, s = 1 / 0, l = -1 / 0, c = t[a].length, u = 0; u < c; u++)s = Math.min(s, t[a][u]), l = Math.max(l, t[a][u]), o += t[a][u]; var d; return e === "min" ? d = s : e === "max" ? d = l : e === "average" ? d = o / c : d = o, c === 0 ? NaN : d }) } function oqe(n) { var e = {}; n.eachSeriesByType("map", function (t) { var r = t.getHostGeoModel(), i = r ? "o" + r.id : "i" + t.getMapType(); (e[i] = e[i] || []).push(t) }), $(e, function (t, r) { for (var i = aqe(Ae(t, function (o) { return o.getData() }), t[0].get("mapValueCalculation")), a = 0; a < t.length; a++)t[a].originalData = t[a].getData(); for (var a = 0; a < t.length; a++)t[a].seriesGroup = t, t[a].needsDrawMap = a === 0 && !t[a].getHostGeoModel(), t[a].setData(i.cloneShallow()), t[a].mainSeries = t[0] }) } function sqe(n) { var e = {}; n.eachSeriesByType("map", function (t) { var r = t.getMapType(); if (!(t.getHostGeoModel() || e[r])) { var i = {}; $(t.seriesGroup, function (o) { var s = o.coordinateSystem, l = o.originalData; o.get("showLegendSymbol") && n.getComponent("legend") && l.each(l.mapDimension("value"), function (c, u) { var d = l.getName(u), f = s.getRegion(d); if (!(!f || isNaN(c))) { var h = i[d] || 0, p = s.dataToPoint(f.getCenter()); i[d] = h + 1, l.setItemLayout(u, { point: p, offset: h }) } }) }); var a = t.getData(); a.each(function (o) { var s = a.getName(o), l = a.getItemLayout(o) || {}; l.showLabel = !i[s], a.setItemLayout(o, l) }), e[r] = !0 } }) } var b7 = fi, lqe = function (n) { te(e, n); function e(t) { var r = n.call(this) || this; return r.type = "view", r.dimensions = ["x", "y"], r._roamTransformable = new mc, r._rawTransformable = new mc, r.name = t, r } return e.prototype.setBoundingRect = function (t, r, i, a) { return this._rect = new kt(t, r, i, a), this._rect }, e.prototype.getBoundingRect = function () { return this._rect }, e.prototype.setViewRect = function (t, r, i, a) { this._transformTo(t, r, i, a), this._viewRect = new kt(t, r, i, a) }, e.prototype._transformTo = function (t, r, i, a) { var o = this.getBoundingRect(), s = this._rawTransformable; s.transform = o.calculateTransform(new kt(t, r, i, a)); var l = s.parent; s.parent = null, s.decomposeTransform(), s.parent = l, this._updateTransform() }, e.prototype.setCenter = function (t, r) { t && (this._center = [Ne(t[0], r.getWidth()), Ne(t[1], r.getHeight())], this._updateCenterAndZoom()) }, e.prototype.setZoom = function (t) { t = t || 1; var r = this.zoomLimit; r && (r.max != null && (t = Math.min(r.max, t)), r.min != null && (t = Math.max(r.min, t))), this._zoom = t, this._updateCenterAndZoom() }, e.prototype.getDefaultCenter = function () { var t = this.getBoundingRect(), r = t.x + t.width / 2, i = t.y + t.height / 2; return [r, i] }, e.prototype.getCenter = function () { return this._center || this.getDefaultCenter() }, e.prototype.getZoom = function () { return this._zoom || 1 }, e.prototype.getRoamTransform = function () { return this._roamTransformable.getLocalTransform() }, e.prototype._updateCenterAndZoom = function () { var t = this._rawTransformable.getLocalTransform(), r = this._roamTransformable, i = this.getDefaultCenter(), a = this.getCenter(), o = this.getZoom(); a = fi([], a, t), i = fi([], i, t), r.originX = a[0], r.originY = a[1], r.x = i[0] - a[0], r.y = i[1] - a[1], r.scaleX = r.scaleY = o, this._updateTransform() }, e.prototype._updateTransform = function () { var t = this._roamTransformable, r = this._rawTransformable; r.parent = t, t.updateTransform(), r.updateTransform(), TN(this.transform || (this.transform = []), r.transform || Va()), this._rawTransform = r.getLocalTransform(), this.invTransform = this.invTransform || [], qg(this.invTransform, this.transform), this.decomposeTransform() }, e.prototype.getTransformInfo = function () { var t = this._rawTransformable, r = this._roamTransformable, i = new mc; return i.transform = r.transform, i.decomposeTransform(), { roam: { x: i.x, y: i.y, scaleX: i.scaleX, scaleY: i.scaleY }, raw: { x: t.x, y: t.y, scaleX: t.scaleX, scaleY: t.scaleY } } }, e.prototype.getViewRect = function () { return this._viewRect }, e.prototype.getViewRectAfterRoam = function () { var t = this.getBoundingRect().clone(); return t.applyTransform(this.transform), t }, e.prototype.dataToPoint = function (t, r, i) { var a = r ? this._rawTransform : this.transform; return i = i || [], a ? b7(i, t, a) : Wi(i, t) }, e.prototype.pointToData = function (t) { var r = this.invTransform; return r ? b7([], t, r) : [t[0], t[1]] }, e.prototype.convertToPixel = function (t, r, i) { var a = w7(r); return a === this ? a.dataToPoint(i) : null }, e.prototype.convertFromPixel = function (t, r, i) { var a = w7(r); return a === this ? a.pointToData(i) : null }, e.prototype.containPoint = function (t) { return this.getViewRectAfterRoam().contain(t[0], t[1]) }, e.dimensions = ["x", "y"], e }(mc); function w7(n) { var e = n.seriesModel; return e ? e.coordinateSystem : null } const Nb = lqe; var cqe = { geoJSON: { aspectScale: .75, invertLongitute: !0 }, geoSVG: { aspectScale: 1, invertLongitute: !1 } }, hae = ["lng", "lat"], pae = function (n) { te(e, n); function e(t, r, i) { var a = n.call(this, t) || this; a.dimensions = hae, a.type = "geo", a._nameCoordMap = Ze(), a.map = r; var o = i.projection, s = Nc.load(r, i.nameMap, i.nameProperty), l = Nc.getGeoResource(r); a.resourceType = l ? l.type : null; var c = a.regions = s.regions, u = cqe[l.type]; a._regionsMap = s.regionsMap, a.regions = s.regions, a.projection = o; var d; if (o) for (var f = 0; f < c.length; f++) { var h = c[f].getBoundingRect(o); d = d || h.clone(), d.union(h) } else d = s.boundingRect; return a.setBoundingRect(d.x, d.y, d.width, d.height), a.aspectScale = o ? 1 : yt(i.aspectScale, u.aspectScale), a._invertLongitute = o ? !1 : u.invertLongitute, a } return e.prototype._transformTo = function (t, r, i, a) { var o = this.getBoundingRect(), s = this._invertLongitute; o = o.clone(), s && (o.y = -o.y - o.height); var l = this._rawTransformable; l.transform = o.calculateTransform(new kt(t, r, i, a)); var c = l.parent; l.parent = null, l.decomposeTransform(), l.parent = c, s && (l.scaleY = -l.scaleY), this._updateTransform() }, e.prototype.getRegion = function (t) { return this._regionsMap.get(t) }, e.prototype.getRegionByCoord = function (t) { for (var r = this.regions, i = 0; i < r.length; i++) { var a = r[i]; if (a.type === "geoJSON" && a.contain(t)) return r[i] } }, e.prototype.addGeoCoord = function (t, r) { this._nameCoordMap.set(t, r) }, e.prototype.getGeoCoord = function (t) { var r = this._regionsMap.get(t); return this._nameCoordMap.get(t) || r && r.getCenter() }, e.prototype.dataToPoint = function (t, r, i) { if (Fe(t) && (t = this.getGeoCoord(t)), t) { var a = this.projection; return a && (t = a.project(t)), t && this.projectedToPoint(t, r, i) } }, e.prototype.pointToData = function (t) { var r = this.projection; return r && (t = r.unproject(t)), t && this.pointToProjected(t) }, e.prototype.pointToProjected = function (t) { return n.prototype.pointToData.call(this, t) }, e.prototype.projectedToPoint = function (t, r, i) { return n.prototype.dataToPoint.call(this, t, r, i) }, e.prototype.convertToPixel = function (t, r, i) { var a = x7(r); return a === this ? a.dataToPoint(i) : null }, e.prototype.convertFromPixel = function (t, r, i) { var a = x7(r); return a === this ? a.pointToData(i) : null }, e }(Nb); Cr(pae, Nb); function x7(n) { var e = n.geoModel, t = n.seriesModel; return e ? e.coordinateSystem : t ? t.coordinateSystem || (t.getReferringComponents("geo", xr).models[0] || {}).coordinateSystem : null } const S7 = pae; function T7(n, e) { var t = n.get("boundingCoords"); if (t != null) { var r = t[0], i = t[1]; if (isFinite(r[0]) && isFinite(r[1]) && isFinite(i[0]) && isFinite(i[1])) { var a = this.projection; if (a) { var o = r[0], s = r[1], l = i[0], c = i[1]; r = [1 / 0, 1 / 0], i = [-1 / 0, -1 / 0]; var u = function (x, k, A, C) { for (var E = A - x, O = C - k, j = 0; j <= 100; j++) { var I = j / 100, L = a.project([x + E * I, k + O * I]); Uu(r, r, L), Gu(i, i, L) } }; u(o, s, l, s), u(l, s, l, c), u(l, c, o, c), u(o, c, l, s) } this.setBoundingRect(r[0], r[1], i[0] - r[0], i[1] - r[1]) } } var d = this.getBoundingRect(), f = n.get("layoutCenter"), h = n.get("layoutSize"), p = e.getWidth(), m = e.getHeight(), g = d.width / d.height * this.aspectScale, y = !1, b, w; f && h && (b = [Ne(f[0], p), Ne(f[1], m)], w = Ne(h, Math.min(p, m)), !isNaN(b[0]) && !isNaN(b[1]) && !isNaN(w) && (y = !0)); var v; if (y) v = {}, g > 1 ? (v.width = w, v.height = w / g) : (v.height = w, v.width = w * g), v.y = b[1] - v.height / 2, v.x = b[0] - v.width / 2; else { var S = n.getBoxLayoutParams(); S.aspect = g, v = jr(S, { width: p, height: m }) } this.setViewRect(v.x, v.y, v.width, v.height), this.setCenter(n.get("center"), e), this.setZoom(n.get("zoom")) } function uqe(n, e) { $(e.get("geoCoord"), function (t, r) { n.addGeoCoord(r, t) }) } var dqe = function () { function n() { this.dimensions = hae } return n.prototype.create = function (e, t) { var r = []; function i(o) { return { nameProperty: o.get("nameProperty"), aspectScale: o.get("aspectScale"), projection: o.get("projection") } } e.eachComponent("geo", function (o, s) { var l = o.get("map"), c = new S7(l + s, l, be({ nameMap: o.get("nameMap") }, i(o))); c.zoomLimit = o.get("scaleLimit"), r.push(c), o.coordinateSystem = c, c.model = o, c.resize = T7, c.resize(o, t) }), e.eachSeries(function (o) { var s = o.get("coordinateSystem"); if (s === "geo") { var l = o.get("geoIndex") || 0; o.coordinateSystem = r[l] } }); var a = {}; return e.eachSeriesByType("map", function (o) { if (!o.getHostGeoModel()) { var s = o.getMapType(); a[s] = a[s] || [], a[s].push(o) } }), $(a, function (o, s) { var l = Ae(o, function (u) { return u.get("nameMap") }), c = new S7(s, s, be({ nameMap: bN(l) }, i(o[0]))); c.zoomLimit = Xr.apply(null, Ae(o, function (u) { return u.get("scaleLimit") })), r.push(c), c.resize = T7, c.resize(o[0], t), $(o, function (u) { u.coordinateSystem = c, uqe(c, u) }) }), r }, n.prototype.getFilledRegions = function (e, t, r, i) { for (var a = (e || []).slice(), o = Ze(), s = 0; s < a.length; s++)o.set(a[s].name, a[s]); var l = Nc.load(t, r, i); return $(l.regions, function (c) { var u = c.name, d = o.get(u), f = c.properties && c.properties.echartsStyle; d || (d = { name: u }, a.push(d)), f && xt(d, f) }), a }, n }(), fqe = new dqe; const mae = fqe; var hqe = function (n) { te(e, n); function e() { var t = n !== null && n.apply(this, arguments) || this; return t.type = e.type, t } return e.prototype.init = function (t, r, i) { var a = Nc.getGeoResource(t.map); if (a && a.type === "geoJSON") { var o = t.itemStyle = t.itemStyle || {}; "color" in o || (o.color = "#eee") } this.mergeDefaultAndTheme(t, i), Vh(t, "label", ["show"]) }, e.prototype.optionUpdated = function () { var t = this, r = this.option; r.regions = mae.getFilledRegions(r.regions, r.map, r.nameMap, r.nameProperty); var i = {}; this._optionModelMap = xl(r.regions || [], function (a, o) { var s = o.name; return s && (a.set(s, new Rn(o, t, t.ecModel)), o.selected && (i[s] = !0)), a }, Ze()), r.selectedMap || (r.selectedMap = i) }, e.prototype.getRegionModel = function (t) { return this._optionModelMap.get(t) || new Rn(null, this, this.ecModel) }, e.prototype.getFormattedLabel = function (t, r) { var i = this.getRegionModel(t), a = r === "normal" ? i.get(["label", "formatter"]) : i.get(["emphasis", "label", "formatter"]), o = { name: t }; if (tt(a)) return o.status = r, a(o); if (Fe(a)) return a.replace("{a}", t ?? "") }, e.prototype.setZoom = function (t) { this.option.zoom = t }, e.prototype.setCenter = function (t) { this.option.center = t }, e.prototype.select = function (t) { var r = this.option, i = r.selectedMode; if (i) { i !== "multiple" && (r.selectedMap = null); var a = r.selectedMap || (r.selectedMap = {}); a[t] = !0 } }, e.prototype.unSelect = function (t) { var r = this.option.selectedMap; r && (r[t] = !1) }, e.prototype.toggleSelected = function (t) { this[this.isSelected(t) ? "unSelect" : "select"](t) }, e.prototype.isSelected = function (t) { var r = this.option.selectedMap; return !!(r && r[t]) }, e.type = "geo", e.layoutMode = "box", e.defaultOption = { z: 0, show: !0, left: "center", top: "center", aspectScale: null, silent: !1, map: "", boundingCoords: null, center: null, zoom: 1, scaleLimit: null, label: { show: !1, color: "#000" }, itemStyle: { borderWidth: .5, borderColor: "#444" }, emphasis: { label: { show: !0, color: "rgb(100,0,0)" }, itemStyle: { color: "rgba(255,215,0,0.8)" } }, select: { label: { show: !0, color: "rgb(100,0,0)" }, itemStyle: { color: "rgba(255,215,0,0.8)" } }, regions: [] }, e }(Jt); const pqe = hqe; function k7(n, e) { return n.pointToProjected ? n.pointToProjected(e) : n.pointToData(e) } function R3(n, e, t, r) { var i = n.getZoom(), a = n.getCenter(), o = e.zoom, s = n.projectedToPoint ? n.projectedToPoint(a) : n.dataToPoint(a); if (e.dx != null && e.dy != null && (s[0] -= e.dx, s[1] -= e.dy, n.setCenter(k7(n, s), r)), o != null) { if (t) { var l = t.min || 0, c = t.max || 1 / 0; o = Math.max(Math.min(i * o, c), l) / i } n.scaleX *= o, n.scaleY *= o; var u = (e.originX - n.x) * (o - 1), d = (e.originY - n.y) * (o - 1); n.x -= u, n.y -= d, n.updateTransform(), n.setCenter(k7(n, s), r), n.setZoom(o * i) } return { center: n.getCenter(), zoom: n.getZoom() } } var mqe = function (n) { te(e, n); function e() { var t = n !== null && n.apply(this, arguments) || this; return t.type = e.type, t.focusBlurEnabled = !0, t } return e.prototype.init = function (t, r) { this._api = r }, e.prototype.render = function (t, r, i, a) { if (this._model = t, !t.get("show")) { this._mapDraw && this._mapDraw.remove(), this._mapDraw = null; return } this._mapDraw || (this._mapDraw = new fae(i)); var o = this._mapDraw; o.draw(t, r, i, this, a), o.group.on("click", this._handleRegionClick, this), o.group.silent = t.get("silent"), this.group.add(o.group), this.updateSelectStatus(t, r, i) }, e.prototype._handleRegionClick = function (t) { var r; rh(t.target, function (i) { return (r = pt(i).eventData) != null }, !0), r && this._api.dispatchAction({ type: "geoToggleSelect", geoId: this._model.id, name: r.name }) }, e.prototype.updateSelectStatus = function (t, r, i) { var a = this; this._mapDraw.group.traverse(function (o) { var s = pt(o).eventData; if (s) return a._model.isSelected(s.name) ? i.enterSelect(o) : i.leaveSelect(o), !0 }) }, e.prototype.findHighDownDispatchers = function (t) { return this._mapDraw && this._mapDraw.findHighDownDispatchers(t, this._model) }, e.prototype.dispose = function () { this._mapDraw && this._mapDraw.remove() }, e.type = "geo", e }(nr); const gqe = mqe; function vqe(n, e, t) { Nc.registerMap(n, e, t) } function gae(n) { n.registerCoordinateSystem("geo", mae), n.registerComponentModel(pqe), n.registerComponentView(gqe), n.registerImpl("registerMap", vqe), n.registerImpl("getMap", function (t) { return Nc.getMapForUser(t) }); function e(t, r) { r.update = "geo:updateSelectStatus", n.registerAction(r, function (i, a) { var o = {}, s = []; return a.eachComponent({ mainType: "geo", query: i }, function (l) { l[t](i.name); var c = l.coordinateSystem; $(c.regions, function (d) { o[d.name] = l.isSelected(d.name) || !1 }); var u = []; $(o, function (d, f) { o[f] && u.push(f) }), s.push({ geoIndex: l.componentIndex, name: u }) }), { selected: o, allSelected: s, name: i.name } }) } e("toggleSelected", { type: "geoToggleSelect", event: "geoselectchanged" }), e("select", { type: "geoSelect", event: "geoselected" }), e("unSelect", { type: "geoUnSelect", event: "geounselected" }), n.registerAction({ type: "geoRoam", event: "geoRoam", update: "updateTransform" }, function (t, r, i) { var a = t.componentType || "series"; r.eachComponent({ mainType: a, query: t }, function (o) { var s = o.coordinateSystem; if (s.type === "geo") { var l = R3(s, t, o.get("scaleLimit"), i); o.setCenter && o.setCenter(l.center), o.setZoom && o.setZoom(l.zoom), a === "series" && $(o.seriesGroup, function (c) { c.setCenter(l.center), c.setZoom(l.zoom) }) } }) }) } function yqe(n) { It(gae), n.registerChartView(nqe), n.registerSeriesModel(iqe), n.registerLayout(sqe), n.registerProcessor(n.PRIORITY.PROCESSOR.STATISTIC, oqe), dre("map", n.registerAction) } function _qe(n) { var e = n; e.hierNode = { defaultAncestor: null, ancestor: e, prelim: 0, modifier: 0, change: 0, shift: 0, i: 0, thread: null }; for (var t = [e], r, i; r = t.pop();)if (i = r.children, r.isExpand && i.length) for (var a = i.length, o = a - 1; o >= 0; o--) { var s = i[o]; s.hierNode = { defaultAncestor: null, ancestor: s, prelim: 0, modifier: 0, change: 0, shift: 0, i: o, thread: null }, t.push(s) } } function bqe(n, e) { var t = n.isExpand ? n.children : [], r = n.parentNode.children, i = n.hierNode.i ? r[n.hierNode.i - 1] : null; if (t.length) { Sqe(n); var a = (t[0].hierNode.prelim + t[t.length - 1].hierNode.prelim) / 2; i ? (n.hierNode.prelim = i.hierNode.prelim + e(n, i), n.hierNode.modifier = n.hierNode.prelim - a) : n.hierNode.prelim = a } else i && (n.hierNode.prelim = i.hierNode.prelim + e(n, i)); n.parentNode.hierNode.defaultAncestor = Tqe(n, i, n.parentNode.hierNode.defaultAncestor || r[0], e) } function wqe(n) { var e = n.hierNode.prelim + n.parentNode.hierNode.modifier; n.setLayout({ x: e }, !0), n.hierNode.modifier += n.parentNode.hierNode.modifier } function C7(n) { return arguments.length ? n : Aqe } function Dy(n, e) { return n -= Math.PI / 2, { x: e * Math.cos(n), y: e * Math.sin(n) } } function xqe(n, e) { return jr(n.getBoxLayoutParams(), { width: e.getWidth(), height: e.getHeight() }) } function Sqe(n) { for (var e = n.children, t = e.length, r = 0, i = 0; --t >= 0;) { var a = e[t]; a.hierNode.prelim += r, a.hierNode.modifier += r, i += a.hierNode.change, r += a.hierNode.shift + i } } function Tqe(n, e, t, r) { if (e) { for (var i = n, a = n, o = a.parentNode.children[0], s = e, l = i.hierNode.modifier, c = a.hierNode.modifier, u = o.hierNode.modifier, d = s.hierNode.modifier; s = EO(s), a = MO(a), s && a;) { i = EO(i), o = MO(o), i.hierNode.ancestor = n; var f = s.hierNode.prelim + d - a.hierNode.prelim - c + r(s, a); f > 0 && (Cqe(kqe(s, n, t), n, f), c += f, l += f), d += s.hierNode.modifier, c += a.hierNode.modifier, l += i.hierNode.modifier, u += o.hierNode.modifier } s && !EO(i) && (i.hierNode.thread = s, i.hierNode.modifier += d - l), a && !MO(o) && (o.hierNode.thread = a, o.hierNode.modifier += c - u, t = n) } return t } function EO(n) { var e = n.children; return e.length && n.isExpand ? e[e.length - 1] : n.hierNode.thread } function MO(n) { var e = n.children; return e.length && n.isExpand ? e[0] : n.hierNode.thread } function kqe(n, e, t) { return n.hierNode.ancestor.parentNode === e.parentNode ? n.hierNode.ancestor : t } function Cqe(n, e, t) { var r = t / (e.hierNode.i - n.hierNode.i); e.hierNode.change -= r, e.hierNode.shift += t, e.hierNode.modifier += t, e.hierNode.prelim += t, n.hierNode.change += r } function Aqe(n, e) { return n.parentNode === e.parentNode ? 1 : 2 } var Eqe = function () { function n() { this.parentPoint = [], this.childPoints = [] } return n }(), Mqe = function (n) { te(e, n); function e(t) { return n.call(this, t) || this } return e.prototype.getDefaultStyle = function () { return { stroke: "#000", fill: null } }, e.prototype.getDefaultShape = function () { return new Eqe }, e.prototype.buildPath = function (t, r) { var i = r.childPoints, a = i.length, o = r.parentPoint, s = i[0], l = i[a - 1]; if (a === 1) { t.moveTo(o[0], o[1]), t.lineTo(s[0], s[1]); return } var c = r.orient, u = c === "TB" || c === "BT" ? 0 : 1, d = 1 - u, f = Ne(r.forkPosition, 1), h = []; h[u] = o[u], h[d] = o[d] + (l[d] - o[d]) * f, t.moveTo(o[0], o[1]), t.lineTo(h[0], h[1]), t.moveTo(s[0], s[1]), h[u] = s[u], t.lineTo(h[0], h[1]), h[u] = l[u], t.lineTo(h[0], h[1]), t.lineTo(l[0], l[1]); for (var p = 1; p < a - 1; p++) { var m = i[p]; t.moveTo(m[0], m[1]), h[u] = m[u], t.lineTo(h[0], h[1]) } }, e }(Nt), Oqe = function (n) { te(e, n); function e() { var t = n !== null && n.apply(this, arguments) || this; return t.type = e.type, t._mainGroup = new ft, t } return e.prototype.init = function (t, r) { this._controller = new Rb(r.getZr()), this._controllerHost = { target: this.group }, this.group.add(this._mainGroup) }, e.prototype.render = function (t, r, i) { var a = t.getData(), o = t.layoutInfo, s = this._mainGroup, l = t.get("layout"); l === "radial" ? (s.x = o.x + o.width / 2, s.y = o.y + o.height / 2) : (s.x = o.x, s.y = o.y), this._updateViewCoordSys(t, i), this._updateController(t, r, i); var c = this._data; a.diff(c).add(function (u) { A7(a, u) && E7(a, u, null, s, t) }).update(function (u, d) { var f = c.getItemGraphicEl(d); if (!A7(a, u)) { f && O7(c, d, f, s, t); return } E7(a, u, f, s, t) }).remove(function (u) { var d = c.getItemGraphicEl(u); d && O7(c, u, d, s, t) }).execute(), this._nodeScaleRatio = t.get("nodeScaleRatio"), this._updateNodeAndLinkScale(t), t.get("expandAndCollapse") === !0 && a.eachItemGraphicEl(function (u, d) { u.off("click").on("click", function () { i.dispatchAction({ type: "treeExpandAndCollapse", seriesId: t.id, dataIndex: d }) }) }), this._data = a }, e.prototype._updateViewCoordSys = function (t, r) { var i = t.getData(), a = []; i.each(function (d) { var f = i.getItemLayout(d); f && !isNaN(f.x) && !isNaN(f.y) && a.push([+f.x, +f.y]) }); var o = [], s = []; eC(a, o, s); var l = this._min, c = this._max; s[0] - o[0] === 0 && (o[0] = l ? l[0] : o[0] - 1, s[0] = c ? c[0] : s[0] + 1), s[1] - o[1] === 0 && (o[1] = l ? l[1] : o[1] - 1, s[1] = c ? c[1] : s[1] + 1); var u = t.coordinateSystem = new Nb; u.zoomLimit = t.get("scaleLimit"), u.setBoundingRect(o[0], o[1], s[0] - o[0], s[1] - o[1]), u.setCenter(t.get("center"), r), u.setZoom(t.get("zoom")), this.group.attr({ x: u.x, y: u.y, scaleX: u.scaleX, scaleY: u.scaleY }), this._min = o, this._max = s }, e.prototype._updateController = function (t, r, i) { var a = this, o = this._controller, s = this._controllerHost, l = this.group; o.setPointerChecker(function (c, u, d) { var f = l.getBoundingRect(); return f.applyTransform(l.transform), f.contain(u, d) && !TC(c, i, t) }), o.enable(t.get("roam")), s.zoomLimit = t.get("scaleLimit"), s.zoom = t.coordinateSystem.getZoom(), o.off("pan").off("zoom").on("pan", function (c) { P3(s, c.dx, c.dy), i.dispatchAction({ seriesId: t.id, type: "treeRoam", dx: c.dx, dy: c.dy }) }).on("zoom", function (c) { I3(s, c.scale, c.originX, c.originY), i.dispatchAction({ seriesId: t.id, type: "treeRoam", zoom: c.scale, originX: c.originX, originY: c.originY }), a._updateNodeAndLinkScale(t), i.updateLabelLayout() }) }, e.prototype._updateNodeAndLinkScale = function (t) { var r = t.getData(), i = this._getNodeGlobalScale(t); r.eachItemGraphicEl(function (a, o) { a.setSymbolScale(i) }) }, e.prototype._getNodeGlobalScale = function (t) { var r = t.coordinateSystem; if (r.type !== "view") return 1; var i = this._nodeScaleRatio, a = r.scaleX || 1, o = r.getZoom(), s = (o - 1) * i + 1; return s / a }, e.prototype.dispose = function () { this._controller && this._controller.dispose(), this._controllerHost = null }, e.prototype.remove = function () { this._mainGroup.removeAll(), this._data = null }, e.type = "tree", e }(Nn); function A7(n, e) { var t = n.getItemLayout(e); return t && !isNaN(t.x) && !isNaN(t.y) } function E7(n, e, t, r, i) { var a = !t, o = n.tree.getNodeByDataIndex(e), s = o.getModel(), l = o.getVisual("style").fill, c = o.isExpand === !1 && o.children.length !== 0 ? l : "#fff", u = n.tree.root, d = o.parentNode === u ? o : o.parentNode || o, f = n.getItemGraphicEl(d.dataIndex), h = d.getLayout(), p = f ? { x: f.__oldX, y: f.__oldY, rawX: f.__radialOldRawX, rawY: f.__radialOldRawY } : h, m = o.getLayout(); a ? (t = new Ob(n, e, null, { symbolInnerColor: c, useNameLabel: !0 }), t.x = p.x, t.y = p.y) : t.updateData(n, e, null, { symbolInnerColor: c, useNameLabel: !0 }), t.__radialOldRawX = t.__radialRawX, t.__radialOldRawY = t.__radialRawY, t.__radialRawX = m.rawX, t.__radialRawY = m.rawY, r.add(t), n.setItemGraphicEl(e, t), t.__oldX = t.x, t.__oldY = t.y, on(t, { x: m.x, y: m.y }, i); var g = t.getSymbolPath(); if (i.get("layout") === "radial") { var y = u.children[0], b = y.getLayout(), w = y.children.length, v = void 0, S = void 0; if (m.x === b.x && o.isExpand === !0 && y.children.length) { var x = { x: (y.children[0].getLayout().x + y.children[w - 1].getLayout().x) / 2, y: (y.children[0].getLayout().y + y.children[w - 1].getLayout().y) / 2 }; v = Math.atan2(x.y - b.y, x.x - b.x), v < 0 && (v = Math.PI * 2 + v), S = x.x < b.x, S && (v = v - Math.PI) } else v = Math.atan2(m.y - b.y, m.x - b.x), v < 0 && (v = Math.PI * 2 + v), o.children.length === 0 || o.children.length !== 0 && o.isExpand === !1 ? (S = m.x < b.x, S && (v = v - Math.PI)) : (S = m.x > b.x, S || (v = v - Math.PI)); var k = S ? "left" : "right", A = s.getModel("label"), C = A.get("rotate"), E = C * (Math.PI / 180), O = g.getTextContent(); O && (g.setTextConfig({ position: A.get("position") || k, rotation: C == null ? -v : E, origin: "center" }), O.setStyle("verticalAlign", "middle")) } var j = s.get(["emphasis", "focus"]), I = j === "relative" ? u_(o.getAncestorsIndices(), o.getDescendantIndices()) : j === "ancestor" ? o.getAncestorsIndices() : j === "descendant" ? o.getDescendantIndices() : null; I && (pt(t).focus = I), Dqe(i, o, u, t, p, h, m, r), t.__edge && (t.onHoverStateChange = function (L) { if (L !== "blur") { var R = o.parentNode && n.getItemGraphicEl(o.parentNode.dataIndex); R && R.hoverState === xb || X2(t.__edge, L) } }) } function Dqe(n, e, t, r, i, a, o, s) { var l = e.getModel(), c = n.get("edgeShape"), u = n.get("layout"), d = n.getOrient(), f = n.get(["lineStyle", "curveness"]), h = n.get("edgeForkPosition"), p = l.getModel("lineStyle").getLineStyle(), m = r.__edge; if (c === "curve") e.parentNode && e.parentNode !== t && (m || (m = r.__edge = new iC({ shape: OI(u, d, f, i, i) })), on(m, { shape: OI(u, d, f, a, o) }, n)); else if (c === "polyline" && u === "orthogonal" && e !== t && e.children && e.children.length !== 0 && e.isExpand === !0) { for (var g = e.children, y = [], b = 0; b < g.length; b++) { var w = g[b].getLayout(); y.push([w.x, w.y]) } m || (m = r.__edge = new Mqe({ shape: { parentPoint: [o.x, o.y], childPoints: [[o.x, o.y]], orient: d, forkPosition: h } })), on(m, { shape: { parentPoint: [o.x, o.y], childPoints: y } }, n) } m && !(c === "polyline" && !e.isExpand) && (m.useStyle(rt({ strokeNoScale: !0, fill: null }, p)), pi(m, l, "lineStyle"), Gh(m), s.add(m)) } function M7(n, e, t, r, i) { var a = e.tree.root, o = vae(a, n), s = o.source, l = o.sourceLayout, c = e.getItemGraphicEl(n.dataIndex); if (c) { var u = e.getItemGraphicEl(s.dataIndex), d = u.__edge, f = c.__edge || (s.isExpand === !1 || s.children.length === 1 ? d : void 0), h = r.get("edgeShape"), p = r.get("layout"), m = r.get("orient"), g = r.get(["lineStyle", "curveness"]); f && (h === "curve" ? Ad(f, { shape: OI(p, m, g, l, l), style: { opacity: 0 } }, r, { cb: function () { t.remove(f) }, removeOpt: i }) : h === "polyline" && r.get("layout") === "orthogonal" && Ad(f, { shape: { parentPoint: [l.x, l.y], childPoints: [[l.x, l.y]] }, style: { opacity: 0 } }, r, { cb: function () { t.remove(f) }, removeOpt: i })) } } function vae(n, e) { for (var t = e.parentNode === n ? e : e.parentNode || e, r; r = t.getLayout(), r == null;)t = t.parentNode === n ? t : t.parentNode || t; return { source: t, sourceLayout: r } } function O7(n, e, t, r, i) { var a = n.tree.getNodeByDataIndex(e), o = n.tree.root, s = vae(o, a).sourceLayout, l = { duration: i.get("animationDurationUpdate"), easing: i.get("animationEasingUpdate") }; Ad(t, { x: s.x + 1, y: s.y + 1 }, i, { cb: function () { r.remove(t), n.setItemGraphicEl(e, null) }, removeOpt: l }), t.fadeOut(null, n.hostModel, { fadeLabel: !0, animation: l }), a.children.forEach(function (c) { M7(c, n, r, i, l) }), M7(a, n, r, i, l) } function OI(n, e, t, r, i) { var a, o, s, l, c, u, d, f; if (n === "radial") { c = r.rawX, d = r.rawY, u = i.rawX, f = i.rawY; var h = Dy(c, d), p = Dy(c, d + (f - d) * t), m = Dy(u, f + (d - f) * t), g = Dy(u, f); return { x1: h.x || 0, y1: h.y || 0, x2: g.x || 0, y2: g.y || 0, cpx1: p.x || 0, cpy1: p.y || 0, cpx2: m.x || 0, cpy2: m.y || 0 } } else c = r.x, d = r.y, u = i.x, f = i.y, (e === "LR" || e === "RL") && (a = c + (u - c) * t, o = d, s = u + (c - u) * t, l = f), (e === "TB" || e === "BT") && (a = c, o = d + (f - d) * t, s = u, l = f + (d - f) * t); return { x1: c, y1: d, x2: u, y2: f, cpx1: a, cpy1: o, cpx2: s, cpy2: l } } const jqe = Oqe; var Bo = Kt(); function yae(n) { var e = n.mainData, t = n.datas; t || (t = { main: e }, n.datasAttr = { main: "data" }), n.datas = n.mainData = null, _ae(e, t, n), $(t, function (r) { $(e.TRANSFERABLE_METHODS, function (i) { r.wrapMethod(i, wt(Pqe, n)) }) }), e.wrapMethod("cloneShallow", wt(Lqe, n)), $(e.CHANGABLE_METHODS, function (r) { e.wrapMethod(r, wt(Iqe, n)) }), na(t[e.dataType] === e) } function Pqe(n, e) { if (Bqe(this)) { var t = be({}, Bo(this).datas); t[this.dataType] = e, _ae(e, t, n) } else N3(e, this.dataType, Bo(this).mainData, n); return e } function Iqe(n, e) { return n.struct && n.struct.update(), e } function Lqe(n, e) { return $(Bo(e).datas, function (t, r) { t !== e && N3(t.cloneShallow(), r, e, n) }), e } function Rqe(n) { var e = Bo(this).mainData; return n == null || e == null ? e : Bo(e).datas[n] } function Nqe() { var n = Bo(this).mainData; return n == null ? [{ data: n }] : Ae(Bt(Bo(n).datas), function (e) { return { type: e, data: Bo(n).datas[e] } }) } function Bqe(n) { return Bo(n).mainData === n } function _ae(n, e, t) { Bo(n).datas = {}, $(e, function (r, i) { N3(r, i, n, t) }) } function N3(n, e, t, r) { Bo(t).datas[e] = n, Bo(n).mainData = t, n.dataType = e, r.struct && (n[r.structAttr] = r.struct, r.struct[r.datasAttr[e]] = n), n.getLinkedData = Rqe, n.getLinkedDataAll = Nqe } var $qe = function () { function n(e, t) { this.depth = 0, this.height = 0, this.dataIndex = -1, this.children = [], this.viewChildren = [], this.isExpand = !1, this.name = e || "", this.hostTree = t } return n.prototype.isRemoved = function () { return this.dataIndex < 0 }, n.prototype.eachNode = function (e, t, r) { tt(e) && (r = t, t = e, e = null), e = e || {}, Fe(e) && (e = { order: e }); var i = e.order || "preorder", a = this[e.attr || "children"], o; i === "preorder" && (o = t.call(r, this)); for (var s = 0; !o && s < a.length; s++)a[s].eachNode(e, t, r); i === "postorder" && t.call(r, this) }, n.prototype.updateDepthAndHeight = function (e) { var t = 0; this.depth = e; for (var r = 0; r < this.children.length; r++) { var i = this.children[r]; i.updateDepthAndHeight(e + 1), i.height > t && (t = i.height) } this.height = t + 1 }, n.prototype.getNodeById = function (e) { if (this.getId() === e) return this; for (var t = 0, r = this.children, i = r.length; t < i; t++) { var a = r[t].getNodeById(e); if (a) return a } }, n.prototype.contains = function (e) { if (e === this) return !0; for (var t = 0, r = this.children, i = r.length; t < i; t++) { var a = r[t].contains(e); if (a) return a } }, n.prototype.getAncestors = function (e) { for (var t = [], r = e ? this : this.parentNode; r;)t.push(r), r = r.parentNode; return t.reverse(), t }, n.prototype.getAncestorsIndices = function () { for (var e = [], t = this; t;)e.push(t.dataIndex), t = t.parentNode; return e.reverse(), e }, n.prototype.getDescendantIndices = function () { var e = []; return this.eachNode(function (t) { e.push(t.dataIndex) }), e }, n.prototype.getValue = function (e) { var t = this.hostTree.data; return t.getStore().get(t.getDimensionIndex(e || "value"), this.dataIndex) }, n.prototype.setLayout = function (e, t) { this.dataIndex >= 0 && this.hostTree.data.setItemLayout(this.dataIndex, e, t) }, n.prototype.getLayout = function () { return this.hostTree.data.getItemLayout(this.dataIndex) }, n.prototype.getModel = function (e) { if (!(this.dataIndex < 0)) { var t = this.hostTree, r = t.data.getItemModel(this.dataIndex); return r.getModel(e) } }, n.prototype.getLevelModel = function () { return (this.hostTree.levelModels || [])[this.depth] }, n.prototype.setVisual = function (e, t) { this.dataIndex >= 0 && this.hostTree.data.setItemVisual(this.dataIndex, e, t) }, n.prototype.getVisual = function (e) { return this.hostTree.data.getItemVisual(this.dataIndex, e) }, n.prototype.getRawIndex = function () { return this.hostTree.data.getRawIndex(this.dataIndex) }, n.prototype.getId = function () { return this.hostTree.data.getId(this.dataIndex) }, n.prototype.getChildIndex = function () { if (this.parentNode) { for (var e = this.parentNode.children, t = 0; t < e.length; ++t)if (e[t] === this) return t; return -1 } return -1 }, n.prototype.isAncestorOf = function (e) { for (var t = e.parentNode; t;) { if (t === this) return !0; t = t.parentNode } return !1 }, n.prototype.isDescendantOf = function (e) { return e !== this && e.isAncestorOf(this) }, n }(), Fqe = function () { function n(e) { this.type = "tree", this._nodes = [], this.hostModel = e } return n.prototype.eachNode = function (e, t, r) { this.root.eachNode(e, t, r) }, n.prototype.getNodeByDataIndex = function (e) { var t = this.data.getRawIndex(e); return this._nodes[t] }, n.prototype.getNodeById = function (e) { return this.root.getNodeById(e) }, n.prototype.update = function () { for (var e = this.data, t = this._nodes, r = 0, i = t.length; r < i; r++)t[r].dataIndex = -1; for (var r = 0, i = e.count(); r < i; r++)t[e.getRawIndex(r)].dataIndex = r }, n.prototype.clearLayouts = function () { this.data.clearItemLayouts() }, n.createTree = function (e, t, r) { var i = new n(t), a = [], o = 1; s(e); function s(u, d) { var f = u.value; o = Math.max(o, ke(f) ? f.length : 1), a.push(u); var h = new $qe(Er(u.name, ""), i); d ? zqe(h, d) : i.root = h, i._nodes.push(h); var p = u.children; if (p) for (var m = 0; m < p.length; m++)s(p[m], h) } i.root.updateDepthAndHeight(0); var l = Eb(a, { coordDimensions: ["value"], dimensionsCount: o }).dimensions, c = new Ji(l, t); return c.initData(a), r && r(c), yae({ mainData: c, struct: i, structAttr: "tree" }), i.update(), i }, n }(); function zqe(n, e) { var t = e.children; n.parentNode !== e && (t.push(n), n.parentNode = e) } const B3 = Fqe; function O_(n, e, t) { if (n && Et(e, n.type) >= 0) { var r = t.getData().tree.root, i = n.targetNode; if (Fe(i) && (i = r.getNodeById(i)), i && r.contains(i)) return { node: i }; var a = n.targetNodeId; if (a != null && (i = r.getNodeById(a))) return { node: i } } } function bae(n) { for (var e = []; n;)n = n.parentNode, n && e.push(n); return e.reverse() } function $3(n, e) { var t = bae(n); return Et(t, e) >= 0 } function CC(n, e) { for (var t = []; n;) { var r = n.dataIndex; t.push({ name: n.name, dataIndex: r, value: e.getRawValue(r) }), n = n.parentNode } return t.reverse(), t } var Vqe = function (n) { te(e, n); function e() { var t = n !== null && n.apply(this, arguments) || this; return t.hasSymbolVisual = !0, t.ignoreStyleOnData = !0, t } return e.prototype.getInitialData = function (t) { var r = { name: t.name, children: t.data }, i = t.leaves || {}, a = new Rn(i, this, this.ecModel), o = B3.createTree(r, this, s); function s(d) { d.wrapMethod("getItemModel", function (f, h) { var p = o.getNodeByDataIndex(h); return p && p.children.length && p.isExpand || (f.parentModel = a), f }) } var l = 0; o.eachNode("preorder", function (d) { d.depth > l && (l = d.depth) }); var c = t.expandAndCollapse, u = c && t.initialTreeDepth >= 0 ? t.initialTreeDepth : l; return o.root.eachNode("preorder", function (d) { var f = d.hostTree.data.getRawDataItem(d.dataIndex); d.isExpand = f && f.collapsed != null ? !f.collapsed : d.depth <= u }), o.data }, e.prototype.getOrient = function () { var t = this.get("orient"); return t === "horizontal" ? t = "LR" : t === "vertical" && (t = "TB"), t }, e.prototype.setZoom = function (t) { this.option.zoom = t }, e.prototype.setCenter = function (t) { this.option.center = t }, e.prototype.formatTooltip = function (t, r, i) { for (var a = this.getData().tree, o = a.root.children[0], s = a.getNodeByDataIndex(t), l = s.getValue(), c = s.name; s && s !== o;)c = s.parentNode.name + "." + c, s = s.parentNode; return Gr("nameValue", { name: c, value: l, noValue: isNaN(l) || l == null }) }, e.prototype.getDataParams = function (t) { var r = n.prototype.getDataParams.apply(this, arguments), i = this.getData().tree.getNodeByDataIndex(t); return r.treeAncestors = CC(i, this), r.collapsed = !i.isExpand, r }, e.type = "series.tree", e.layoutMode = "box", e.defaultOption = { z: 2, coordinateSystem: "view", left: "12%", top: "12%", right: "12%", bottom: "12%", layout: "orthogonal", edgeShape: "curve", edgeForkPosition: "50%", roam: !1, nodeScaleRatio: .4, center: null, zoom: 1, orient: "LR", symbol: "emptyCircle", symbolSize: 7, expandAndCollapse: !0, initialTreeDepth: 2, lineStyle: { color: "#ccc", width: 1.5, curveness: .5 }, itemStyle: { color: "lightsteelblue", borderWidth: 1.5 }, label: { show: !0 }, animationEasing: "linear", animationDuration: 700, animationDurationUpdate: 500 }, e }(Yn); const Hqe = Vqe; function Uqe(n, e, t) { for (var r = [n], i = [], a; a = r.pop();)if (i.push(a), a.isExpand) { var o = a.children; if (o.length) for (var s = 0; s < o.length; s++)r.push(o[s]) } for (; a = i.pop();)e(a, t) } function sy(n, e) { for (var t = [n], r; r = t.pop();)if (e(r), r.isExpand) { var i = r.children; if (i.length) for (var a = i.length - 1; a >= 0; a--)t.push(i[a]) } } function Gqe(n, e) { n.eachSeriesByType("tree", function (t) { Wqe(t, e) }) } function Wqe(n, e) { var t = xqe(n, e); n.layoutInfo = t; var r = n.get("layout"), i = 0, a = 0, o = null; r === "radial" ? (i = 2 * Math.PI, a = Math.min(t.height, t.width) / 2, o = C7(function (w, v) { return (w.parentNode === v.parentNode ? 1 : 2) / w.depth })) : (i = t.width, a = t.height, o = C7()); var s = n.getData().tree.root, l = s.children[0]; if (l) { _qe(s), Uqe(l, bqe, o), s.hierNode.modifier = -l.hierNode.prelim, sy(l, wqe); var c = l, u = l, d = l; sy(l, function (w) { var v = w.getLayout().x; v < c.getLayout().x && (c = w), v > u.getLayout().x && (u = w), w.depth > d.depth && (d = w) }); var f = c === u ? 1 : o(c, u) / 2, h = f - c.getLayout().x, p = 0, m = 0, g = 0, y = 0; if (r === "radial") p = i / (u.getLayout().x + f + h), m = a / (d.depth - 1 || 1), sy(l, function (w) { g = (w.getLayout().x + h) * p, y = (w.depth - 1) * m; var v = Dy(g, y); w.setLayout({ x: v.x, y: v.y, rawX: g, rawY: y }, !0) }); else { var b = n.getOrient(); b === "RL" || b === "LR" ? (m = a / (u.getLayout().x + f + h), p = i / (d.depth - 1 || 1), sy(l, function (w) { y = (w.getLayout().x + h) * m, g = b === "LR" ? (w.depth - 1) * p : i - (w.depth - 1) * p, w.setLayout({ x: g, y }, !0) })) : (b === "TB" || b === "BT") && (p = i / (u.getLayout().x + f + h), m = a / (d.depth - 1 || 1), sy(l, function (w) { g = (w.getLayout().x + h) * p, y = b === "TB" ? (w.depth - 1) * m : a - (w.depth - 1) * m, w.setLayout({ x: g, y }, !0) })) } } } function Kqe(n) { n.eachSeriesByType("tree", function (e) { var t = e.getData(), r = t.tree; r.eachNode(function (i) { var a = i.getModel(), o = a.getModel("itemStyle").getItemStyle(), s = t.ensureUniqueItemVisual(i.dataIndex, "style"); be(s, o) }) }) } function qqe(n) { n.registerAction({ type: "treeExpandAndCollapse", event: "treeExpandAndCollapse", update: "update" }, function (e, t) { t.eachComponent({ mainType: "series", subType: "tree", query: e }, function (r) { var i = e.dataIndex, a = r.getData().tree, o = a.getNodeByDataIndex(i); o.isExpand = !o.isExpand }) }), n.registerAction({ type: "treeRoam", event: "treeRoam", update: "none" }, function (e, t, r) { t.eachComponent({ mainType: "series", subType: "tree", query: e }, function (i) { var a = i.coordinateSystem, o = R3(a, e, void 0, r); i.setCenter && i.setCenter(o.center), i.setZoom && i.setZoom(o.zoom) }) }) } function Yqe(n) { n.registerChartView(jqe), n.registerSeriesModel(Hqe), n.registerLayout(Gqe), n.registerVisual(Kqe), qqe(n) } var D7 = ["treemapZoomToNode", "treemapRender", "treemapMove"]; function Zqe(n) { for (var e = 0; e < D7.length; e++)n.registerAction({ type: D7[e], update: "updateView" }, gr); n.registerAction({ type: "treemapRootToNode", update: "updateView" }, function (t, r) { r.eachComponent({ mainType: "series", subType: "treemap", query: t }, i); function i(a, o) { var s = ["treemapZoomToNode", "treemapRootToNode"], l = O_(t, s, a); if (l) { var c = a.getViewRoot(); c && (t.direction = $3(c, l.node) ? "rollUp" : "drillDown"), a.resetViewRoot(l.node) } } }) } function wae(n) { var e = n.getData(), t = e.tree, r = {}; t.eachNode(function (i) { for (var a = i; a && a.depth > 1;)a = a.parentNode; var o = aI(n.ecModel, a.name || a.dataIndex + "", r); i.setVisual("decal", o) }) } var Xqe = function (n) { te(e, n); function e() { var t = n !== null && n.apply(this, arguments) || this; return t.type = e.type, t.preventUsingHoverLayer = !0, t } return e.prototype.getInitialData = function (t, r) { var i = { name: t.name, children: t.data }; xae(i); var a = t.levels || [], o = this.designatedVisualItemStyle = {}, s = new Rn({ itemStyle: o }, this, r); a = t.levels = Jqe(a, r); var l = Ae(a || [], function (d) { return new Rn(d, s, r) }, this), c = B3.createTree(i, this, u); function u(d) { d.wrapMethod("getItemModel", function (f, h) { var p = c.getNodeByDataIndex(h), m = p ? l[p.depth] : null; return f.parentModel = m || s, f }) } return c.data }, e.prototype.optionUpdated = function () { this.resetViewRoot() }, e.prototype.formatTooltip = function (t, r, i) { var a = this.getData(), o = this.getRawValue(t), s = a.getName(t); return Gr("nameValue", { name: s, value: o }) }, e.prototype.getDataParams = function (t) { var r = n.prototype.getDataParams.apply(this, arguments), i = this.getData().tree.getNodeByDataIndex(t); return r.treeAncestors = CC(i, this), r.treePathInfo = r.treeAncestors, r }, e.prototype.setLayoutInfo = function (t) { this.layoutInfo = this.layoutInfo || {}, be(this.layoutInfo, t) }, e.prototype.mapIdToIndex = function (t) { var r = this._idIndexMap; r || (r = this._idIndexMap = Ze(), this._idIndexMapCount = 0); var i = r.get(t); return i == null && r.set(t, i = this._idIndexMapCount++), i }, e.prototype.getViewRoot = function () { return this._viewRoot }, e.prototype.resetViewRoot = function (t) { t ? this._viewRoot = t : t = this._viewRoot; var r = this.getRawData().tree.root; (!t || t !== r && !r.contains(t)) && (this._viewRoot = r) }, e.prototype.enableAriaDecal = function () { wae(this) }, e.type = "series.treemap", e.layoutMode = "box", e.defaultOption = { progressive: 0, left: "center", top: "middle", width: "80%", height: "80%", sort: !0, clipWindow: "origin", squareRatio: .5 * (1 + Math.sqrt(5)), leafDepth: null, drillDownIcon: "", zoomToNodeRatio: .32 * .32, scaleLimit: null, roam: !0, nodeClick: "zoomToNode", animation: !0, animationDurationUpdate: 900, animationEasing: "quinticInOut", breadcrumb: { show: !0, height: 22, left: "center", top: "bottom", emptyItemWidth: 25, itemStyle: { color: "rgba(0,0,0,0.7)", textStyle: { color: "#fff" } }, emphasis: { itemStyle: { color: "rgba(0,0,0,0.9)" } } }, label: { show: !0, distance: 0, padding: 5, position: "inside", color: "#fff", overflow: "truncate" }, upperLabel: { show: !1, position: [0, "50%"], height: 20, overflow: "truncate", verticalAlign: "middle" }, itemStyle: { color: null, colorAlpha: null, colorSaturation: null, borderWidth: 0, gapWidth: 0, borderColor: "#fff", borderColorSaturation: null }, emphasis: { upperLabel: { show: !0, position: [0, "50%"], overflow: "truncate", verticalAlign: "middle" } }, visualDimension: 0, visualMin: null, visualMax: null, color: [], colorAlpha: null, colorSaturation: null, colorMappingBy: "index", visibleMin: 10, childrenVisibleMin: null, levels: [] }, e }(Yn); function xae(n) { var e = 0; $(n.children, function (r) { xae(r); var i = r.value; ke(i) && (i = i[0]), e += i }); var t = n.value; ke(t) && (t = t[0]), (t == null || isNaN(t)) && (t = e), t < 0 && (t = 0), ke(n.value) ? n.value[0] = t : n.value = t } function Jqe(n, e) { var t = Cn(e.get("color")), r = Cn(e.get(["aria", "decal", "decals"])); if (t) { n = n || []; var i, a; $(n, function (s) { var l = new Rn(s), c = l.get("color"), u = l.get("decal"); (l.get(["itemStyle", "color"]) || c && c !== "none") && (i = !0), (l.get(["itemStyle", "decal"]) || u && u !== "none") && (a = !0) }); var o = n[0] || (n[0] = {}); return i || (o.color = t.slice()), !a && r && (o.decal = r.slice()), n } } const Qqe = Xqe; var eYe = 8, j7 = 8, OO = 5, tYe = function () { function n(e) { this.group = new ft, e.add(this.group) } return n.prototype.render = function (e, t, r, i) { var a = e.getModel("breadcrumb"), o = this.group; if (o.removeAll(), !(!a.get("show") || !r)) { var s = a.getModel("itemStyle"), l = a.getModel("emphasis"), c = s.getModel("textStyle"), u = l.getModel(["itemStyle", "textStyle"]), d = { pos: { left: a.get("left"), right: a.get("right"), top: a.get("top"), bottom: a.get("bottom") }, box: { width: t.getWidth(), height: t.getHeight() }, emptyItemWidth: a.get("emptyItemWidth"), totalWidth: 0, renderList: [] }; this._prepare(r, d, c), this._renderContent(e, d, s, l, c, u, i), hC(o, d.pos, d.box) } }, n.prototype._prepare = function (e, t, r) { for (var i = e; i; i = i.parentNode) { var a = Er(i.getModel().get("name"), ""), o = r.getTextRect(a), s = Math.max(o.width + eYe * 2, t.emptyItemWidth); t.totalWidth += s + j7, t.renderList.push({ node: i, text: a, width: s }) } }, n.prototype._renderContent = function (e, t, r, i, a, o, s) { for (var l = 0, c = t.emptyItemWidth, u = e.get(["breadcrumb", "height"]), d = uVe(t.pos, t.box), f = t.totalWidth, h = t.renderList, p = i.getModel("itemStyle").getItemStyle(), m = h.length - 1; m >= 0; m--) { var g = h[m], y = g.node, b = g.width, w = g.text; f > d.width && (f -= b - c, b = c, w = null); var v = new Aa({ shape: { points: nYe(l, 0, b, u, m === h.length - 1, m === 0) }, style: rt(r.getItemStyle(), { lineJoin: "bevel" }), textContent: new tn({ style: Ln(a, { text: w }) }), textConfig: { position: "inside" }, z2: Zg * 1e4, onclick: wt(s, y) }); v.disableLabelAnimation = !0, v.getTextContent().ensureState("emphasis").style = Ln(o, { text: w }), v.ensureState("emphasis").style = p, Qn(v, i.get("focus"), i.get("blurScope"), i.get("disabled")), this.group.add(v), rYe(v, e, y), l += b + j7 } }, n.prototype.remove = function () { this.group.removeAll() }, n }(); function nYe(n, e, t, r, i, a) { var o = [[i ? n : n - OO, e], [n + t, e], [n + t, e + r], [i ? n : n - OO, e + r]]; return !a && o.splice(2, 0, [n + t + OO, e + r / 2]), !i && o.push([n, e + r / 2]), o } function rYe(n, e, t) { pt(n).eventData = { componentType: "series", componentSubType: "treemap", componentIndex: e.componentIndex, seriesIndex: e.seriesIndex, seriesName: e.name, seriesType: "treemap", selfType: "breadcrumb", nodeData: { dataIndex: t && t.dataIndex, name: t && t.name }, treePathInfo: t && CC(t, e) } } const iYe = tYe; var aYe = function () { function n() { this._storage = [], this._elExistsMap = {} } return n.prototype.add = function (e, t, r, i, a) { return this._elExistsMap[e.id] ? !1 : (this._elExistsMap[e.id] = !0, this._storage.push({ el: e, target: t, duration: r, delay: i, easing: a }), !0) }, n.prototype.finished = function (e) { return this._finishedCallback = e, this }, n.prototype.start = function () { for (var e = this, t = this._storage.length, r = function () { t--, t <= 0 && (e._storage.length = 0, e._elExistsMap = {}, e._finishedCallback && e._finishedCallback()) }, i = 0, a = this._storage.length; i < a; i++) { var o = this._storage[i]; o.el.animateTo(o.target, { duration: o.duration, delay: o.delay, easing: o.easing, setToFinal: !0, done: r, aborted: r }) } return this }, n }(); function oYe() { return new aYe } var DI = ft, P7 = Yt, I7 = 3, L7 = "label", R7 = "upperLabel", sYe = Zg * 10, lYe = Zg * 2, cYe = Zg * 3, Rf = Uh([["fill", "color"], ["stroke", "strokeColor"], ["lineWidth", "strokeWidth"], ["shadowBlur"], ["shadowOffsetX"], ["shadowOffsetY"], ["shadowColor"]]), N7 = function (n) { var e = Rf(n); return e.stroke = e.fill = e.lineWidth = null, e }, bT = Kt(), uYe = function (n) { te(e, n); function e() { var t = n !== null && n.apply(this, arguments) || this; return t.type = e.type, t._state = "ready", t._storage = ly(), t } return e.prototype.render = function (t, r, i, a) { var o = r.findComponents({ mainType: "series", subType: "treemap", query: a }); if (!(Et(o, t) < 0)) { this.seriesModel = t, this.api = i, this.ecModel = r; var s = ["treemapZoomToNode", "treemapRootToNode"], l = O_(a, s, t), c = a && a.type, u = t.layoutInfo, d = !this._oldTree, f = this._storage, h = c === "treemapRootToNode" && l && f ? { rootNodeGroup: f.nodeGroup[l.node.getRawIndex()], direction: a.direction } : null, p = this._giveContainerGroup(u), m = t.get("animation"), g = this._doRender(p, t, h); m && !d && (!c || c === "treemapZoomToNode" || c === "treemapRootToNode") ? this._doAnimation(p, g, t, h) : g.renderFinally(), this._resetController(i), this._renderBreadcrumb(t, i, l) } }, e.prototype._giveContainerGroup = function (t) { var r = this._containerGroup; return r || (r = this._containerGroup = new DI, this._initEvents(r), this.group.add(r)), r.x = t.x, r.y = t.y, r }, e.prototype._doRender = function (t, r, i) { var a = r.getData().tree, o = this._oldTree, s = ly(), l = ly(), c = this._storage, u = []; function d(b, w, v, S) { return dYe(r, l, c, i, s, u, b, w, v, S) } m(a.root ? [a.root] : [], o && o.root ? [o.root] : [], t, a === o || !o, 0); var f = g(c); if (this._oldTree = a, this._storage = l, this._controllerHost) { var h = this.seriesModel.layoutInfo, p = a.root.getLayout(); p.width === h.width && p.height === h.height && (this._controllerHost.zoom = 1) } return { lastsForAnimation: s, willDeleteEls: f, renderFinally: y }; function m(b, w, v, S, x) { S ? (w = b, $(b, function (C, E) { !C.isRemoved() && A(E, E) })) : new Lc(w, b, k, k).add(A).update(A).remove(wt(A, null)).execute(); function k(C) { return C.getId() } function A(C, E) { var O = C != null ? b[C] : null, j = E != null ? w[E] : null, I = d(O, j, v, x); I && m(O && O.viewChildren || [], j && j.viewChildren || [], I, S, x + 1) } } function g(b) { var w = ly(); return b && $(b, function (v, S) { var x = w[S]; $(v, function (k) { k && (x.push(k), bT(k).willDelete = !0) }) }), w } function y() { $(f, function (b) { $(b, function (w) { w.parent && w.parent.remove(w) }) }), $(u, function (b) { b.invisible = !0, b.dirty() }) } }, e.prototype._doAnimation = function (t, r, i, a) { var o = i.get("animationDurationUpdate"), s = i.get("animationEasing"), l = (tt(o) ? 0 : o) || 0, c = (tt(s) ? null : s) || "cubicOut", u = oYe(); $(r.willDeleteEls, function (d, f) { $(d, function (h, p) { if (!h.invisible) { var m = h.parent, g, y = bT(m); if (a && a.direction === "drillDown") g = m === a.rootNodeGroup ? { shape: { x: 0, y: 0, width: y.nodeWidth, height: y.nodeHeight }, style: { opacity: 0 } } : { style: { opacity: 0 } }; else { var b = 0, w = 0; y.willDelete || (b = y.nodeWidth / 2, w = y.nodeHeight / 2), g = f === "nodeGroup" ? { x: b, y: w, style: { opacity: 0 } } : { shape: { x: b, y: w, width: 0, height: 0 }, style: { opacity: 0 } } } g && u.add(h, g, l, 0, c) } }) }), $(this._storage, function (d, f) { $(d, function (h, p) { var m = r.lastsForAnimation[f][p], g = {}; m && (h instanceof ft ? m.oldX != null && (g.x = h.x, g.y = h.y, h.x = m.oldX, h.y = m.oldY) : (m.oldShape && (g.shape = be({}, h.shape), h.setShape(m.oldShape)), m.fadein ? (h.setStyle("opacity", 0), g.style = { opacity: 1 }) : h.style.opacity !== 1 && (g.style = { opacity: 1 })), u.add(h, g, l, 0, c)) }) }, this), this._state = "animating", u.finished(He(function () { this._state = "ready", r.renderFinally() }, this)).start() }, e.prototype._resetController = function (t) { var r = this._controller, i = this._controllerHost; i || (this._controllerHost = { target: this.group }, i = this._controllerHost), r || (r = this._controller = new Rb(t.getZr()), r.enable(this.seriesModel.get("roam")), i.zoomLimit = this.seriesModel.get("scaleLimit"), i.zoom = this.seriesModel.get("zoom"), r.on("pan", He(this._onPan, this)), r.on("zoom", He(this._onZoom, this))); var a = new kt(0, 0, t.getWidth(), t.getHeight()); r.setPointerChecker(function (o, s, l) { return a.contain(s, l) }) }, e.prototype._clearController = function () { var t = this._controller; this._controllerHost = null, t && (t.dispose(), t = null) }, e.prototype._onPan = function (t) { if (this._state !== "animating" && (Math.abs(t.dx) > I7 || Math.abs(t.dy) > I7)) { var r = this.seriesModel.getData().tree.root; if (!r) return; var i = r.getLayout(); if (!i) return; this.api.dispatchAction({ type: "treemapMove", from: this.uid, seriesId: this.seriesModel.id, rootRect: { x: i.x + t.dx, y: i.y + t.dy, width: i.width, height: i.height } }) } }, e.prototype._onZoom = function (t) { var r = t.originX, i = t.originY, a = t.scale; if (this._state !== "animating") { var o = this.seriesModel.getData().tree.root; if (!o) return; var s = o.getLayout(); if (!s) return; var l = new kt(s.x, s.y, s.width, s.height), c = null, u = this._controllerHost; c = u.zoomLimit; var d = u.zoom = u.zoom || 1; if (d *= a, c) { var f = c.min || 0, h = c.max || 1 / 0; d = Math.max(Math.min(h, d), f) } var p = d / u.zoom; u.zoom = d; var m = this.seriesModel.layoutInfo; r -= m.x, i -= m.y; var g = Va(); Sl(g, g, [-r, -i]), kN(g, g, [p, p]), Sl(g, g, [r, i]), l.applyTransform(g), this.api.dispatchAction({ type: "treemapRender", from: this.uid, seriesId: this.seriesModel.id, rootRect: { x: l.x, y: l.y, width: l.width, height: l.height } }) } }, e.prototype._initEvents = function (t) { var r = this; t.on("click", function (i) { if (r._state === "ready") { var a = r.seriesModel.get("nodeClick", !0); if (a) { var o = r.findTarget(i.offsetX, i.offsetY); if (o) { var s = o.node; if (s.getLayout().isLeafRoot) r._rootToNode(o); else if (a === "zoomToNode") r._zoomToNode(o); else if (a === "link") { var l = s.hostTree.data.getItemModel(s.dataIndex), c = l.get("link", !0), u = l.get("target", !0) || "blank"; c && rT(c, u) } } } } }, this) }, e.prototype._renderBreadcrumb = function (t, r, i) { var a = this; i || (i = t.get("leafDepth", !0) != null ? { node: t.getViewRoot() } : this.findTarget(r.getWidth() / 2, r.getHeight() / 2), i || (i = { node: t.getData().tree.root })), (this._breadcrumb || (this._breadcrumb = new iYe(this.group))).render(t, r, i.node, function (o) { a._state !== "animating" && ($3(t.getViewRoot(), o) ? a._rootToNode({ node: o }) : a._zoomToNode({ node: o })) }) }, e.prototype.remove = function () { this._clearController(), this._containerGroup && this._containerGroup.removeAll(), this._storage = ly(), this._state = "ready", this._breadcrumb && this._breadcrumb.remove() }, e.prototype.dispose = function () { this._clearController() }, e.prototype._zoomToNode = function (t) { this.api.dispatchAction({ type: "treemapZoomToNode", from: this.uid, seriesId: this.seriesModel.id, targetNode: t.node }) }, e.prototype._rootToNode = function (t) { this.api.dispatchAction({ type: "treemapRootToNode", from: this.uid, seriesId: this.seriesModel.id, targetNode: t.node }) }, e.prototype.findTarget = function (t, r) { var i, a = this.seriesModel.getViewRoot(); return a.eachNode({ attr: "viewChildren", order: "preorder" }, function (o) { var s = this._storage.background[o.getRawIndex()]; if (s) { var l = s.transformCoordToLocal(t, r), c = s.shape; if (c.x <= l[0] && l[0] <= c.x + c.width && c.y <= l[1] && l[1] <= c.y + c.height) i = { node: o, offsetX: l[0], offsetY: l[1] }; else return !1 } }, this), i }, e.type = "treemap", e }(Nn); function ly() { return { nodeGroup: [], background: [], content: [] } } function dYe(n, e, t, r, i, a, o, s, l, c) { if (!o) return; var u = o.getLayout(), d = n.getData(), f = o.getModel(); if (d.setItemGraphicEl(o.dataIndex, null), !u || !u.isInView) return; var h = u.width, p = u.height, m = u.borderWidth, g = u.invisible, y = o.getRawIndex(), b = s && s.getRawIndex(), w = o.viewChildren, v = u.upperHeight, S = w && w.length, x = f.getModel("itemStyle"), k = f.getModel(["emphasis", "itemStyle"]), A = f.getModel(["blur", "itemStyle"]), C = f.getModel(["select", "itemStyle"]), E = x.get("borderRadius") || 0, O = le("nodeGroup", DI); if (!O) return; if (l.add(O), O.x = u.x || 0, O.y = u.y || 0, O.markRedraw(), bT(O).nodeWidth = h, bT(O).nodeHeight = p, u.isAboveViewRoot) return O; var j = le("background", P7, c, lYe); j && K(O, j, S && u.upperLabelHeight); var I = f.getModel("emphasis"), L = I.get("focus"), R = I.get("blurScope"), D = I.get("disabled"), P = L === "ancestor" ? o.getAncestorsIndices() : L === "descendant" ? o.getDescendantIndices() : L; if (S) y_(O) && th(O, !1), j && (th(j, !D), d.setItemGraphicEl(o.dataIndex, j), XP(j, P, R)); else { var B = le("content", P7, c, cYe); B && V(O, B), j.disableMorphing = !0, j && y_(j) && th(j, !1), th(O, !D), d.setItemGraphicEl(o.dataIndex, O); var F = f.getShallow("cursor"); F && B.attr("cursor", F), XP(O, P, R) } return O; function K(pe, se, ge) { var _e = pt(se); if (_e.dataIndex = o.dataIndex, _e.seriesIndex = n.seriesIndex, se.setShape({ x: 0, y: 0, width: h, height: p, r: E }), g) W(se); else { se.invisible = !1; var je = o.getVisual("style"), U = je.stroke, q = N7(x); q.fill = U; var ee = Rf(k); ee.fill = k.get("borderColor"); var de = Rf(A); de.fill = A.get("borderColor"); var me = Rf(C); if (me.fill = C.get("borderColor"), ge) { var fe = h - 2 * m; J(se, U, je.opacity, { x: m, y: 0, width: fe, height: v }) } else se.removeTextContent(); se.setStyle(q), se.ensureState("emphasis").style = ee, se.ensureState("blur").style = de, se.ensureState("select").style = me, Gh(se) } pe.add(se) } function V(pe, se) { var ge = pt(se); ge.dataIndex = o.dataIndex, ge.seriesIndex = n.seriesIndex; var _e = Math.max(h - 2 * m, 0), je = Math.max(p - 2 * m, 0); if (se.culling = !0, se.setShape({ x: m, y: m, width: _e, height: je, r: E }), g) W(se); else { se.invisible = !1; var U = o.getVisual("style"), q = U.fill, ee = N7(x); ee.fill = q, ee.decal = U.decal; var de = Rf(k), me = Rf(A), fe = Rf(C); J(se, q, U.opacity, null), se.setStyle(ee), se.ensureState("emphasis").style = de, se.ensureState("blur").style = me, se.ensureState("select").style = fe, Gh(se) } pe.add(se) } function W(pe) { !pe.invisible && a.push(pe) } function J(pe, se, ge, _e) { var je = f.getModel(_e ? R7 : L7), U = Er(f.get("name"), null), q = je.getShallow("show"); mi(pe, Ur(f, _e ? R7 : L7), { defaultText: q ? U : null, inheritColor: se, defaultOpacity: ge, labelFetcher: n, labelDataIndex: o.dataIndex }); var ee = pe.getTextContent(); if (ee) { var de = ee.style, me = xN(de.padding || 0); _e && (pe.setTextConfig({ layoutRect: _e }), ee.disableLabelLayout = !0), ee.beforeUpdate = function () { var we = Math.max((_e ? _e.width : pe.shape.width) - me[1] - me[3], 0), Oe = Math.max((_e ? _e.height : pe.shape.height) - me[0] - me[2], 0); (de.width !== we || de.height !== Oe) && ee.setStyle({ width: we, height: Oe }) }, de.truncateMinChar = 2, de.lineOverflow = "truncate", ie(de, _e, u); var fe = ee.getState("emphasis"); ie(fe ? fe.style : null, _e, u) } } function ie(pe, se, ge) { var _e = pe ? pe.text : null; if (!se && ge.isLeafRoot && _e != null) { var je = n.get("drillDownIcon", !0); pe.text = je ? je + " " + _e : _e } } function le(pe, se, ge, _e) { var je = b != null && t[pe][b], U = i[pe]; return je ? (t[pe][b] = null, De(U, je)) : g || (je = new se, je instanceof Ho && (je.z2 = fYe(ge, _e)), ae(U, je)), e[pe][y] = je } function De(pe, se) { var ge = pe[y] = {}; se instanceof DI ? (ge.oldX = se.x, ge.oldY = se.y) : ge.oldShape = be({}, se.shape) } function ae(pe, se) { var ge = pe[y] = {}, _e = o.parentNode, je = se instanceof ft; if (_e && (!r || r.direction === "drillDown")) { var U = 0, q = 0, ee = i.background[_e.getRawIndex()]; !r && ee && ee.oldShape && (U = ee.oldShape.width, q = ee.oldShape.height), je ? (ge.oldX = 0, ge.oldY = q) : ge.oldShape = { x: U, y: q, width: 0, height: 0 } } ge.fadein = !je } } function fYe(n, e) { return n * sYe + e } const hYe = uYe; var D_ = $, pYe = ot, wT = -1, F3 = function () { function n(e) { var t = e.mappingMethod, r = e.type, i = this.option = lt(e); this.type = r, this.mappingMethod = t, this._normalizeData = vYe[t]; var a = n.visualHandlers[r]; this.applyVisual = a.applyVisual, this.getColorMapper = a.getColorMapper, this._normalizedToVisual = a._normalizedToVisual[t], t === "piecewise" ? (DO(i), mYe(i)) : t === "category" ? i.categories ? gYe(i) : DO(i, !0) : (na(t !== "linear" || i.dataExtent), DO(i)) } return n.prototype.mapValueToVisual = function (e) { var t = this._normalizeData(e); return this._normalizedToVisual(t, e) }, n.prototype.getNormalizer = function () { return He(this._normalizeData, this) }, n.listVisualTypes = function () { return Bt(n.visualHandlers) }, n.isValidType = function (e) { return n.visualHandlers.hasOwnProperty(e) }, n.eachVisual = function (e, t, r) { ot(e) ? $(e, t, r) : t.call(r, e) }, n.mapVisual = function (e, t, r) { var i, a = ke(e) ? [] : ot(e) ? {} : (i = !0, null); return n.eachVisual(e, function (o, s) { var l = t.call(r, o, s); i ? a = l : a[s] = l }), a }, n.retrieveVisuals = function (e) { var t = {}, r; return e && D_(n.visualHandlers, function (i, a) { e.hasOwnProperty(a) && (t[a] = e[a], r = !0) }), r ? t : null }, n.prepareVisualTypes = function (e) { if (ke(e)) e = e.slice(); else if (pYe(e)) { var t = []; D_(e, function (r, i) { t.push(i) }), e = t } else return []; return e.sort(function (r, i) { return i === "color" && r !== "color" && r.indexOf("color") === 0 ? 1 : -1 }), e }, n.dependsOn = function (e, t) { return t === "color" ? !!(e && e.indexOf(t) === 0) : e === t }, n.findPieceIndex = function (e, t, r) { for (var i, a = 1 / 0, o = 0, s = t.length; o < s; o++) { var l = t[o].value; if (l != null) { if (l === e || Fe(l) && l === e + "") return o; r && f(l, o) } } for (var o = 0, s = t.length; o < s; o++) { var c = t[o], u = c.interval, d = c.close; if (u) { if (u[0] === -1 / 0) { if (dx(d[1], e, u[1])) return o } else if (u[1] === 1 / 0) { if (dx(d[0], u[0], e)) return o } else if (dx(d[0], u[0], e) && dx(d[1], e, u[1])) return o; r && f(u[0], o), r && f(u[1], o) } } if (r) return e === 1 / 0 ? t.length - 1 : e === -1 / 0 ? 0 : i; function f(h, p) { var m = Math.abs(h - e); m < a && (a = m, i = p) } }, n.visualHandlers = { color: { applyVisual: cy("color"), getColorMapper: function () { var e = this.option; return He(e.mappingMethod === "category" ? function (t, r) { return !r && (t = this._normalizeData(t)), jy.call(this, t) } : function (t, r, i) { var a = !!i; return !r && (t = this._normalizeData(t)), i = dM(t, e.parsedVisual, i), a ? i : wc(i, "rgba") }, this) }, _normalizedToVisual: { linear: function (e) { return wc(dM(e, this.option.parsedVisual), "rgba") }, category: jy, piecewise: function (e, t) { var r = PI.call(this, t); return r == null && (r = wc(dM(e, this.option.parsedVisual), "rgba")), r }, fixed: Nf } }, colorHue: ux(function (e, t) { return u0(e, t) }), colorSaturation: ux(function (e, t) { return u0(e, null, t) }), colorLightness: ux(function (e, t) { return u0(e, null, null, t) }), colorAlpha: ux(function (e, t) { return G2(e, t) }), decal: { applyVisual: cy("decal"), _normalizedToVisual: { linear: null, category: jy, piecewise: null, fixed: null } }, opacity: { applyVisual: cy("opacity"), _normalizedToVisual: jI([0, 1]) }, liftZ: { applyVisual: cy("liftZ"), _normalizedToVisual: { linear: Nf, category: Nf, piecewise: Nf, fixed: Nf } }, symbol: { applyVisual: function (e, t, r) { var i = this.mapValueToVisual(e); r("symbol", i) }, _normalizedToVisual: { linear: B7, category: jy, piecewise: function (e, t) { var r = PI.call(this, t); return r == null && (r = B7.call(this, e)), r }, fixed: Nf } }, symbolSize: { applyVisual: cy("symbolSize"), _normalizedToVisual: jI([0, 1]) } }, n }(); function mYe(n) { var e = n.pieceList; n.hasSpecialVisual = !1, $(e, function (t, r) { t.originIndex = r, t.visual != null && (n.hasSpecialVisual = !0) }) } function gYe(n) { var e = n.categories, t = n.categoryMap = {}, r = n.visual; if (D_(e, function (o, s) { t[o] = s }), !ke(r)) { var i = []; ot(r) ? D_(r, function (o, s) { var l = t[s]; i[l ?? wT] = o }) : i[wT] = r, r = Sae(n, i) } for (var a = e.length - 1; a >= 0; a--)r[a] == null && (delete t[e[a]], e.pop()) } function DO(n, e) { var t = n.visual, r = []; ot(t) ? D_(t, function (a) { r.push(a) }) : t != null && r.push(t); var i = { color: 1, symbol: 1 }; !e && r.length === 1 && !i.hasOwnProperty(n.type) && (r[1] = r[0]), Sae(n, r) } function ux(n) { return { applyVisual: function (e, t, r) { var i = this.mapValueToVisual(e); r("color", n(t("color"), i)) }, _normalizedToVisual: jI([0, 1]) } } function B7(n) { var e = this.option.visual; return e[Math.round(vn(n, [0, 1], [0, e.length - 1], !0))] || {} } function cy(n) { return function (e, t, r) { r(n, this.mapValueToVisual(e)) } } function jy(n) { var e = this.option.visual; return e[this.option.loop && n !== wT ? n % e.length : n] } function Nf() { return this.option.visual[0] } function jI(n) { return { linear: function (e) { return vn(e, n, this.option.visual, !0) }, category: jy, piecewise: function (e, t) { var r = PI.call(this, t); return r == null && (r = vn(e, n, this.option.visual, !0)), r }, fixed: Nf } } function PI(n) { var e = this.option, t = e.pieceList; if (e.hasSpecialVisual) { var r = F3.findPieceIndex(n, t), i = t[r]; if (i && i.visual) return i.visual[this.type] } } function Sae(n, e) { return n.visual = e, n.type === "color" && (n.parsedVisual = Ae(e, function (t) { var r = Ha(t); return r || [0, 0, 0, 1] })), e } var vYe = { linear: function (n) { return vn(n, this.option.dataExtent, [0, 1], !0) }, piecewise: function (n) { var e = this.option.pieceList, t = F3.findPieceIndex(n, e, !0); if (t != null) return vn(t, [0, e.length - 1], [0, 1], !0) }, category: function (n) { var e = this.option.categories ? this.option.categoryMap[n] : n; return e ?? wT }, fixed: gr }; function dx(n, e, t) { return n ? e <= t : e < t } const hi = F3; var yYe = "itemStyle", Tae = Kt(); const _Ye = { seriesType: "treemap", reset: function (n) { var e = n.getData().tree, t = e.root; t.isRemoved() || kae(t, {}, n.getViewRoot().getAncestors(), n) } }; function kae(n, e, t, r) { var i = n.getModel(), a = n.getLayout(), o = n.hostTree.data; if (!(!a || a.invisible || !a.isInView)) { var s = i.getModel(yYe), l = bYe(s, e, r), c = o.ensureUniqueItemVisual(n.dataIndex, "style"), u = s.get("borderColor"), d = s.get("borderColorSaturation"), f; d != null && (f = $7(l), u = wYe(d, f)), c.stroke = u; var h = n.viewChildren; if (!h || !h.length) f = $7(l), c.fill = f; else { var p = xYe(n, i, a, s, l, h); $(h, function (m, g) { if (m.depth >= t.length || m === t[m.depth]) { var y = SYe(i, l, m, g, p, r); kae(m, y, t, r) } }) } } } function bYe(n, e, t) { var r = be({}, e), i = t.designatedVisualItemStyle; return $(["color", "colorAlpha", "colorSaturation"], function (a) { i[a] = e[a]; var o = n.get(a); i[a] = null, o != null && (r[a] = o) }), r } function $7(n) { var e = jO(n, "color"); if (e) { var t = jO(n, "colorAlpha"), r = jO(n, "colorSaturation"); return r && (e = u0(e, null, null, r)), t && (e = G2(e, t)), e } } function wYe(n, e) { return e != null ? u0(e, null, null, n) : null } function jO(n, e) { var t = n[e]; if (t != null && t !== "none") return t } function xYe(n, e, t, r, i, a) { if (!(!a || !a.length)) { var o = PO(e, "color") || i.color != null && i.color !== "none" && (PO(e, "colorAlpha") || PO(e, "colorSaturation")); if (o) { var s = e.get("visualMin"), l = e.get("visualMax"), c = t.dataExtent.slice(); s != null && s < c[0] && (c[0] = s), l != null && l > c[1] && (c[1] = l); var u = e.get("colorMappingBy"), d = { type: o.name, dataExtent: c, visual: o.range }; d.type === "color" && (u === "index" || u === "id") ? (d.mappingMethod = "category", d.loop = !0) : d.mappingMethod = "linear"; var f = new hi(d); return Tae(f).drColorMappingBy = u, f } } } function PO(n, e) { var t = n.get(e); return ke(t) && t.length ? { name: e, range: t } : null } function SYe(n, e, t, r, i, a) { var o = be({}, e); if (i) { var s = i.type, l = s === "color" && Tae(i).drColorMappingBy, c = l === "index" ? r : l === "id" ? a.mapIdToIndex(t.getId()) : t.getValue(n.get("visualDimension")); o[s] = i.mapValueToVisual(c) } return o } var j_ = Math.max, xT = Math.min, F7 = Xr, z3 = $, Cae = ["itemStyle", "borderWidth"], TYe = ["itemStyle", "gapWidth"], kYe = ["upperLabel", "show"], CYe = ["upperLabel", "height"]; const AYe = { seriesType: "treemap", reset: function (n, e, t, r) { var i = t.getWidth(), a = t.getHeight(), o = n.option, s = jr(n.getBoxLayoutParams(), { width: t.getWidth(), height: t.getHeight() }), l = o.size || [], c = Ne(F7(s.width, l[0]), i), u = Ne(F7(s.height, l[1]), a), d = r && r.type, f = ["treemapZoomToNode", "treemapRootToNode"], h = O_(r, f, n), p = d === "treemapRender" || d === "treemapMove" ? r.rootRect : null, m = n.getViewRoot(), g = bae(m); if (d !== "treemapMove") { var y = d === "treemapZoomToNode" ? PYe(n, h, m, c, u) : p ? [p.width, p.height] : [c, u], b = o.sort; b && b !== "asc" && b !== "desc" && (b = "desc"); var w = { squareRatio: o.squareRatio, sort: b, leafDepth: o.leafDepth }; m.hostTree.clearLayouts(); var v = { x: 0, y: 0, width: y[0], height: y[1], area: y[0] * y[1] }; m.setLayout(v), Aae(m, w, !1, 0), v = m.getLayout(), z3(g, function (x, k) { var A = (g[k + 1] || m).getValue(); x.setLayout(be({ dataExtent: [A, A], borderWidth: 0, upperHeight: 0 }, v)) }) } var S = n.getData().tree.root; S.setLayout(IYe(s, p, h), !0), n.setLayoutInfo(s), Eae(S, new kt(-s.x, -s.y, i, a), g, m, 0) } }; function Aae(n, e, t, r) { var i, a; if (!n.isRemoved()) { var o = n.getLayout(); i = o.width, a = o.height; var s = n.getModel(), l = s.get(Cae), c = s.get(TYe) / 2, u = Mae(s), d = Math.max(l, u), f = l - c, h = d - c; n.setLayout({ borderWidth: l, upperHeight: d, upperLabelHeight: u }, !0), i = j_(i - 2 * f, 0), a = j_(a - f - h, 0); var p = i * a, m = EYe(n, s, p, e, t, r); if (m.length) { var g = { x: f, y: h, width: i, height: a }, y = xT(i, a), b = 1 / 0, w = []; w.area = 0; for (var v = 0, S = m.length; v < S;) { var x = m[v]; w.push(x), w.area += x.getLayout().area; var k = jYe(w, y, e.squareRatio); k <= b ? (v++, b = k) : (w.area -= w.pop().getLayout().area, z7(w, y, g, c, !1), y = xT(g.width, g.height), w.length = w.area = 0, b = 1 / 0) } if (w.length && z7(w, y, g, c, !0), !t) { var A = s.get("childrenVisibleMin"); A != null && p < A && (t = !0) } for (var v = 0, S = m.length; v < S; v++)Aae(m[v], e, t, r + 1) } } } function EYe(n, e, t, r, i, a) { var o = n.children || [], s = r.sort; s !== "asc" && s !== "desc" && (s = null); var l = r.leafDepth != null && r.leafDepth <= a; if (i && !l) return n.viewChildren = []; o = pn(o, function (h) { return !h.isRemoved() }), OYe(o, s); var c = DYe(e, o, s); if (c.sum === 0) return n.viewChildren = []; if (c.sum = MYe(e, t, c.sum, s, o), c.sum === 0) return n.viewChildren = []; for (var u = 0, d = o.length; u < d; u++) { var f = o[u].getValue() / c.sum * t; o[u].setLayout({ area: f }) } return l && (o.length && n.setLayout({ isLeafRoot: !0 }, !0), o.length = 0), n.viewChildren = o, n.setLayout({ dataExtent: c.dataExtent }, !0), o } function MYe(n, e, t, r, i) { if (!r) return t; for (var a = n.get("visibleMin"), o = i.length, s = o, l = o - 1; l >= 0; l--) { var c = i[r === "asc" ? o - l - 1 : l].getValue(); c / t * e < a && (s = l, t -= c) } return r === "asc" ? i.splice(0, o - s) : i.splice(s, o - s), t } function OYe(n, e) { return e && n.sort(function (t, r) { var i = e === "asc" ? t.getValue() - r.getValue() : r.getValue() - t.getValue(); return i === 0 ? e === "asc" ? t.dataIndex - r.dataIndex : r.dataIndex - t.dataIndex : i }), n } function DYe(n, e, t) { for (var r = 0, i = 0, a = e.length; i < a; i++)r += e[i].getValue(); var o = n.get("visualDimension"), s; return !e || !e.length ? s = [NaN, NaN] : o === "value" && t ? (s = [e[e.length - 1].getValue(), e[0].getValue()], t === "asc" && s.reverse()) : (s = [1 / 0, -1 / 0], z3(e, function (l) { var c = l.getValue(o); c < s[0] && (s[0] = c), c > s[1] && (s[1] = c) })), { sum: r, dataExtent: s } } function jYe(n, e, t) { for (var r = 0, i = 1 / 0, a = 0, o = void 0, s = n.length; a < s; a++)o = n[a].getLayout().area, o && (o < i && (i = o), o > r && (r = o)); var l = n.area * n.area, c = e * e * t; return l ? j_(c * r / l, l / (c * i)) : 1 / 0 } function z7(n, e, t, r, i) { var a = e === t.width ? 0 : 1, o = 1 - a, s = ["x", "y"], l = ["width", "height"], c = t[s[a]], u = e ? n.area / e : 0; (i || u > t[l[o]]) && (u = t[l[o]]); for (var d = 0, f = n.length; d < f; d++) { var h = n[d], p = {}, m = u ? h.getLayout().area / u : 0, g = p[l[o]] = j_(u - 2 * r, 0), y = t[s[a]] + t[l[a]] - c, b = d === f - 1 || y < m ? y : m, w = p[l[a]] = j_(b - 2 * r, 0); p[s[o]] = t[s[o]] + xT(r, g / 2), p[s[a]] = c + xT(r, w / 2), c += b, h.setLayout(p, !0) } t[s[o]] += u, t[l[o]] -= u } function PYe(n, e, t, r, i) { var a = (e || {}).node, o = [r, i]; if (!a || a === t) return o; for (var s, l = r * i, c = l * n.option.zoomToNodeRatio; s = a.parentNode;) { for (var u = 0, d = s.children, f = 0, h = d.length; f < h; f++)u += d[f].getValue(); var p = a.getValue(); if (p === 0) return o; c *= u / p; var m = s.getModel(), g = m.get(Cae), y = Math.max(g, Mae(m)); c += 4 * g * g + (3 * g + y) * Math.pow(c, .5), c > Q6 && (c = Q6), a = s } c < l && (c = l); var b = Math.pow(c / l, .5); return [r * b, i * b] } function IYe(n, e, t) { if (e) return { x: e.x, y: e.y }; var r = { x: 0, y: 0 }; if (!t) return r; var i = t.node, a = i.getLayout(); if (!a) return r; for (var o = [a.width / 2, a.height / 2], s = i; s;) { var l = s.getLayout(); o[0] += l.x, o[1] += l.y, s = s.parentNode } return { x: n.width / 2 - o[0], y: n.height / 2 - o[1] } } function Eae(n, e, t, r, i) { var a = n.getLayout(), o = t[i], s = o && o === n; if (!(o && !s || i === t.length && n !== r)) { n.setLayout({ isInView: !0, invisible: !s && !e.intersect(a), isAboveViewRoot: s }, !0); var l = new kt(e.x - a.x, e.y - a.y, e.width, e.height); z3(n.viewChildren || [], function (c) { Eae(c, l, t, r, i + 1) }) } } function Mae(n) { return n.get(kYe) ? n.get(CYe) : 0 } function LYe(n) { n.registerSeriesModel(Qqe), n.registerChartView(hYe), n.registerVisual(_Ye), n.registerLayout(AYe), Zqe(n) } function RYe(n) { var e = n.findComponents({ mainType: "legend" }); !e || !e.length || n.eachSeriesByType("graph", function (t) { var r = t.getCategoriesData(), i = t.getGraph(), a = i.data, o = r.mapArray(r.getName); a.filterSelf(function (s) { var l = a.getItemModel(s), c = l.getShallow("category"); if (c != null) { nn(c) && (c = o[c]); for (var u = 0; u < e.length; u++)if (!e[u].isSelected(c)) return !1 } return !0 }) }) } function NYe(n) { var e = {}; n.eachSeriesByType("graph", function (t) { var r = t.getCategoriesData(), i = t.getData(), a = {}; r.each(function (o) { var s = r.getName(o); a["ec-" + s] = o; var l = r.getItemModel(o), c = l.getModel("itemStyle").getItemStyle(); c.fill || (c.fill = t.getColorFromPalette(s, e)), r.setItemVisual(o, "style", c); for (var u = ["symbol", "symbolSize", "symbolKeepAspect"], d = 0; d < u.length; d++) { var f = l.getShallow(u[d], !0); f != null && r.setItemVisual(o, u[d], f) } }), r.count() && i.each(function (o) { var s = i.getItemModel(o), l = s.getShallow("category"); if (l != null) { Fe(l) && (l = a["ec-" + l]); var c = r.getItemVisual(l, "style"), u = i.ensureUniqueItemVisual(o, "style"); be(u, c); for (var d = ["symbol", "symbolSize", "symbolKeepAspect"], f = 0; f < d.length; f++)i.setItemVisual(o, d[f], r.getItemVisual(l, d[f])) } }) }) } function fx(n) { return n instanceof Array || (n = [n, n]), n } function BYe(n) { n.eachSeriesByType("graph", function (e) { var t = e.getGraph(), r = e.getEdgeData(), i = fx(e.get("edgeSymbol")), a = fx(e.get("edgeSymbolSize")); r.setVisual("fromSymbol", i && i[0]), r.setVisual("toSymbol", i && i[1]), r.setVisual("fromSymbolSize", a && a[0]), r.setVisual("toSymbolSize", a && a[1]), r.setVisual("style", e.getModel("lineStyle").getLineStyle()), r.each(function (o) { var s = r.getItemModel(o), l = t.getEdgeByIndex(o), c = fx(s.getShallow("symbol", !0)), u = fx(s.getShallow("symbolSize", !0)), d = s.getModel("lineStyle").getLineStyle(), f = r.ensureUniqueItemVisual(o, "style"); switch (be(f, d), f.stroke) { case "source": { var h = l.node1.getVisual("style"); f.stroke = h && h.fill; break } case "target": { var h = l.node2.getVisual("style"); f.stroke = h && h.fill; break } }c[0] && l.setVisual("fromSymbol", c[0]), c[1] && l.setVisual("toSymbol", c[1]), u[0] && l.setVisual("fromSymbolSize", u[0]), u[1] && l.setVisual("toSymbolSize", u[1]) }) }) } var II = "-->", AC = function (n) { return n.get("autoCurveness") || null }, Oae = function (n, e) { var t = AC(n), r = 20, i = []; if (nn(t)) r = t; else if (ke(t)) { n.__curvenessList = t; return } e > r && (r = e); var a = r % 2 ? r + 2 : r + 3; i = []; for (var o = 0; o < a; o++)i.push((o % 2 ? o + 1 : o) / 10 * (o % 2 ? -1 : 1)); n.__curvenessList = i }, P_ = function (n, e, t) { var r = [n.id, n.dataIndex].join("."), i = [e.id, e.dataIndex].join("."); return [t.uid, r, i].join(II) }, Dae = function (n) { var e = n.split(II); return [e[0], e[2], e[1]].join(II) }, $Ye = function (n, e) { var t = P_(n.node1, n.node2, e); return e.__edgeMap[t] }, FYe = function (n, e) { var t = LI(P_(n.node1, n.node2, e), e), r = LI(P_(n.node2, n.node1, e), e); return t + r }, LI = function (n, e) { var t = e.__edgeMap; return t[n] ? t[n].length : 0 }; function zYe(n) { AC(n) && (n.__curvenessList = [], n.__edgeMap = {}, Oae(n)) } function VYe(n, e, t, r) { if (AC(t)) { var i = P_(n, e, t), a = t.__edgeMap, o = a[Dae(i)]; a[i] && !o ? a[i].isForward = !0 : o && a[i] && (o.isForward = !0, a[i].isForward = !1), a[i] = a[i] || [], a[i].push(r) } } function V3(n, e, t, r) { var i = AC(e), a = ke(i); if (!i) return null; var o = $Ye(n, e); if (!o) return null; for (var s = -1, l = 0; l < o.length; l++)if (o[l] === t) { s = l; break } var c = FYe(n, e); Oae(e, c), n.lineStyle = n.lineStyle || {}; var u = P_(n.node1, n.node2, e), d = e.__curvenessList, f = a || c % 2 ? 0 : 1; if (o.isForward) return d[f + s]; var h = Dae(u), p = LI(h, e), m = d[s + p + f]; return r ? a ? i && i[0] === 0 ? (p + f) % 2 ? m : -m : ((p % 2 ? 0 : 1) + f) % 2 ? m : -m : (p + f) % 2 ? m : -m : d[s + p + f] } function jae(n) { var e = n.coordinateSystem; if (!(e && e.type !== "view")) { var t = n.getGraph(); t.eachNode(function (r) { var i = r.getModel(); r.setLayout([+i.get("x"), +i.get("y")]) }), H3(t, n) } } function H3(n, e) { n.eachEdge(function (t, r) { var i = pl(t.getModel().get(["lineStyle", "curveness"]), -V3(t, e, r, !0), 0), a = _c(t.node1.getLayout()), o = _c(t.node2.getLayout()), s = [a, o]; +i && s.push([(a[0] + o[0]) / 2 - (a[1] - o[1]) * i, (a[1] + o[1]) / 2 - (o[0] - a[0]) * i]), t.setLayout(s) }) } function HYe(n, e) { n.eachSeriesByType("graph", function (t) { var r = t.get("layout"), i = t.coordinateSystem; if (i && i.type !== "view") { var a = t.getData(), o = []; $(i.dimensions, function (f) { o = o.concat(a.mapDimensionsAll(f)) }); for (var s = 0; s < a.count(); s++) { for (var l = [], c = !1, u = 0; u < o.length; u++) { var d = a.get(o[u], s); isNaN(d) || (c = !0), l.push(d) } c ? a.setItemLayout(s, i.dataToPoint(l)) : a.setItemLayout(s, [NaN, NaN]) } H3(a.graph, t) } else (!r || r === "none") && jae(t) }) } function Py(n) { var e = n.coordinateSystem; if (e.type !== "view") return 1; var t = n.option.nodeScaleRatio, r = e.scaleX, i = e.getZoom(), a = (i - 1) * t + 1; return a / r } function Iy(n) { var e = n.getVisual("symbolSize"); return e instanceof Array && (e = (e[0] + e[1]) / 2), +e } var V7 = Math.PI, IO = []; function U3(n, e, t, r) { var i = n.coordinateSystem; if (!(i && i.type !== "view")) { var a = i.getBoundingRect(), o = n.getData(), s = o.graph, l = a.width / 2 + a.x, c = a.height / 2 + a.y, u = Math.min(a.width, a.height) / 2, d = o.count(); if (o.setLayout({ cx: l, cy: c }), !!d) { if (t) { var f = i.pointToData(r), h = f[0], p = f[1], m = [h - l, p - c]; Kg(m, m), Kx(m, m, u), t.setLayout([l + m[0], c + m[1]], !0); var g = n.get(["circular", "rotateLabel"]); Pae(t, g, l, c) } UYe[e](n, s, o, u, l, c, d), s.eachEdge(function (y, b) { var w = pl(y.getModel().get(["lineStyle", "curveness"]), V3(y, n, b), 0), v = _c(y.node1.getLayout()), S = _c(y.node2.getLayout()), x, k = (v[0] + S[0]) / 2, A = (v[1] + S[1]) / 2; +w && (w *= 3, x = [l * w + k * (1 - w), c * w + A * (1 - w)]), y.setLayout([v, S, x]) }) } } } var UYe = { value: function (n, e, t, r, i, a, o) { var s = 0, l = t.getSum("value"), c = Math.PI * 2 / (l || o); e.eachNode(function (u) { var d = u.getValue("value"), f = c * (l ? d : 1) / 2; s += f, u.setLayout([r * Math.cos(s) + i, r * Math.sin(s) + a]), s += f }) }, symbolSize: function (n, e, t, r, i, a, o) { var s = 0; IO.length = o; var l = Py(n); e.eachNode(function (d) { var f = Iy(d); isNaN(f) && (f = 2), f < 0 && (f = 0), f *= l; var h = Math.asin(f / 2 / r); isNaN(h) && (h = V7 / 2), IO[d.dataIndex] = h, s += h * 2 }); var c = (2 * V7 - s) / o / 2, u = 0; e.eachNode(function (d) { var f = c + IO[d.dataIndex]; u += f, (!d.getLayout() || !d.getLayout().fixed) && d.setLayout([r * Math.cos(u) + i, r * Math.sin(u) + a]), u += f }) } }; function Pae(n, e, t, r) { var i = n.getGraphicEl(); if (i) { var a = n.getModel(), o = a.get(["label", "rotate"]) || 0, s = i.getSymbolPath(); if (e) { var l = n.getLayout(), c = Math.atan2(l[1] - r, l[0] - t); c < 0 && (c = Math.PI * 2 + c); var u = l[0] < t; u && (c = c - Math.PI); var d = u ? "left" : "right"; s.setTextConfig({ rotation: -c, position: d, origin: "center" }); var f = s.ensureState("emphasis"); be(f.textConfig || (f.textConfig = {}), { position: d }) } else s.setTextConfig({ rotation: o *= Math.PI / 180 }) } } function GYe(n) { n.eachSeriesByType("graph", function (e) { e.get("layout") === "circular" && U3(e, "symbolSize") }) } var em = wP; function WYe(n, e, t) { for (var r = n, i = e, a = t.rect, o = a.width, s = a.height, l = [a.x + o / 2, a.y + s / 2], c = t.gravity == null ? .1 : t.gravity, u = 0; u < r.length; u++) { var d = r[u]; d.p || (d.p = np(o * (Math.random() - .5) + l[0], s * (Math.random() - .5) + l[1])), d.pp = _c(d.p), d.edges = null } var f = t.friction == null ? .6 : t.friction, h = f, p, m; return { warmUp: function () { h = f * .8 }, setFixed: function (g) { r[g].fixed = !0 }, setUnfixed: function (g) { r[g].fixed = !1 }, beforeStep: function (g) { p = g }, afterStep: function (g) { m = g }, step: function (g) { p && p(r, i); for (var y = [], b = r.length, w = 0; w < i.length; w++) { var v = i[w]; if (!v.ignoreForceLayout) { var S = v.n1, x = v.n2; Qf(y, x.p, S.p); var k = xP(y) - v.d, A = x.w / (S.w + x.w); isNaN(A) && (A = 0), Kg(y, y), !S.fixed && em(S.p, S.p, y, A * k * h), !x.fixed && em(x.p, x.p, y, -(1 - A) * k * h) } } for (var w = 0; w < b; w++) { var C = r[w]; C.fixed || (Qf(y, l, C.p), em(C.p, C.p, y, c * h)) } for (var w = 0; w < b; w++)for (var S = r[w], E = w + 1; E < b; E++) { var x = r[E]; Qf(y, x.p, S.p); var k = xP(y); k === 0 && (Q4e(y, Math.random() - .5, Math.random() - .5), k = 1); var O = (S.rep + x.rep) / k / k; !S.fixed && em(S.pp, S.pp, y, O), !x.fixed && em(x.pp, x.pp, y, -O) } for (var j = [], w = 0; w < b; w++) { var C = r[w]; C.fixed || (Qf(j, C.p, C.pp), em(C.p, C.p, j, h), Wi(C.pp, C.p)) } h = h * .992; var I = h < .01; m && m(r, i, I), g && g(I) } } } function KYe(n) { n.eachSeriesByType("graph", function (e) { var t = e.coordinateSystem; if (!(t && t.type !== "view")) if (e.get("layout") === "force") { var r = e.preservedPoints || {}, i = e.getGraph(), a = i.data, o = i.edgeData, s = e.getModel("force"), l = s.get("initLayout"); e.preservedPoints ? a.each(function (w) { var v = a.getId(w); a.setItemLayout(w, r[v] || [NaN, NaN]) }) : !l || l === "none" ? jae(e) : l === "circular" && U3(e, "value"); var c = a.getDataExtent("value"), u = o.getDataExtent("value"), d = s.get("repulsion"), f = s.get("edgeLength"), h = ke(d) ? d : [d, d], p = ke(f) ? f : [f, f]; p = [p[1], p[0]]; var m = a.mapArray("value", function (w, v) { var S = a.getItemLayout(v), x = vn(w, c, h); return isNaN(x) && (x = (h[0] + h[1]) / 2), { w: x, rep: x, fixed: a.getItemModel(v).get("fixed"), p: !S || isNaN(S[0]) || isNaN(S[1]) ? null : S } }), g = o.mapArray("value", function (w, v) { var S = i.getEdgeByIndex(v), x = vn(w, u, p); isNaN(x) && (x = (p[0] + p[1]) / 2); var k = S.getModel(), A = pl(S.getModel().get(["lineStyle", "curveness"]), -V3(S, e, v, !0), 0); return { n1: m[S.node1.dataIndex], n2: m[S.node2.dataIndex], d: x, curveness: A, ignoreForceLayout: k.get("ignoreForceLayout") } }), y = t.getBoundingRect(), b = WYe(m, g, { rect: y, gravity: s.get("gravity"), friction: s.get("friction") }); b.beforeStep(function (w, v) { for (var S = 0, x = w.length; S < x; S++)w[S].fixed && Wi(w[S].p, i.getNodeByIndex(S).getLayout()) }), b.afterStep(function (w, v, S) { for (var x = 0, k = w.length; x < k; x++)w[x].fixed || i.getNodeByIndex(x).setLayout(w[x].p), r[a.getId(x)] = w[x].p; for (var x = 0, k = v.length; x < k; x++) { var A = v[x], C = i.getEdgeByIndex(x), E = A.n1.p, O = A.n2.p, j = C.getLayout(); j = j ? j.slice() : [], j[0] = j[0] || [], j[1] = j[1] || [], Wi(j[0], E), Wi(j[1], O), +A.curveness && (j[2] = [(E[0] + O[0]) / 2 - (E[1] - O[1]) * A.curveness, (E[1] + O[1]) / 2 - (O[0] - E[0]) * A.curveness]), C.setLayout(j) } }), e.forceLayout = b, e.preservedPoints = r, b.step() } else e.forceLayout = null }) } function qYe(n, e, t) { var r = be(n.getBoxLayoutParams(), { aspect: t }); return jr(r, { width: e.getWidth(), height: e.getHeight() }) } function YYe(n, e) { var t = []; return n.eachSeriesByType("graph", function (r) { var i = r.get("coordinateSystem"); if (!i || i === "view") { var a = r.getData(), o = a.mapArray(function (g) { var y = a.getItemModel(g); return [+y.get("x"), +y.get("y")] }), s = [], l = []; eC(o, s, l), l[0] - s[0] === 0 && (l[0] += 1, s[0] -= 1), l[1] - s[1] === 0 && (l[1] += 1, s[1] -= 1); var c = (l[0] - s[0]) / (l[1] - s[1]), u = qYe(r, e, c); isNaN(c) && (s = [u.x, u.y], l = [u.x + u.width, u.y + u.height]); var d = l[0] - s[0], f = l[1] - s[1], h = u.width, p = u.height, m = r.coordinateSystem = new Nb; m.zoomLimit = r.get("scaleLimit"), m.setBoundingRect(s[0], s[1], d, f), m.setViewRect(u.x, u.y, h, p), m.setCenter(r.get("center"), e), m.setZoom(r.get("zoom")), t.push(m) } }), t } var H7 = Jr.prototype, LO = iC.prototype, Iae = function () { function n() { this.x1 = 0, this.y1 = 0, this.x2 = 0, this.y2 = 0, this.percent = 1 } return n }(); (function (n) { te(e, n); function e() { return n !== null && n.apply(this, arguments) || this } return e })(Iae); function RO(n) { return isNaN(+n.cpx1) || isNaN(+n.cpy1) } var ZYe = function (n) { te(e, n); function e(t) { var r = n.call(this, t) || this; return r.type = "ec-line", r } return e.prototype.getDefaultStyle = function () { return { stroke: "#000", fill: null } }, e.prototype.getDefaultShape = function () { return new Iae }, e.prototype.buildPath = function (t, r) { RO(r) ? H7.buildPath.call(this, t, r) : LO.buildPath.call(this, t, r) }, e.prototype.pointAt = function (t) { return RO(this.shape) ? H7.pointAt.call(this, t) : LO.pointAt.call(this, t) }, e.prototype.tangentAt = function (t) { var r = this.shape, i = RO(r) ? [r.x2 - r.x1, r.y2 - r.y1] : LO.tangentAt.call(this, t); return Kg(i, i) }, e }(Nt); const XYe = ZYe; var NO = ["fromSymbol", "toSymbol"]; function U7(n) { return "_" + n + "Type" } function G7(n, e, t) { var r = e.getItemVisual(t, n); if (!r || r === "none") return r; var i = e.getItemVisual(t, n + "Size"), a = e.getItemVisual(t, n + "Rotate"), o = e.getItemVisual(t, n + "Offset"), s = e.getItemVisual(t, n + "KeepAspect"), l = ov(i), c = sp(o || 0, l); return r + l + c + (a || "") + (s || "") } function W7(n, e, t) { var r = e.getItemVisual(t, n); if (!(!r || r === "none")) { var i = e.getItemVisual(t, n + "Size"), a = e.getItemVisual(t, n + "Rotate"), o = e.getItemVisual(t, n + "Offset"), s = e.getItemVisual(t, n + "KeepAspect"), l = ov(i), c = sp(o || 0, l), u = Tr(r, -l[0] / 2 + c[0], -l[1] / 2 + c[1], l[0], l[1], null, s); return u.__specifiedRotation = a == null || isNaN(a) ? void 0 : +a * Math.PI / 180 || 0, u.name = n, u } } function JYe(n) { var e = new XYe({ name: "line", subPixelOptimize: !0 }); return RI(e.shape, n), e } function RI(n, e) { n.x1 = e[0][0], n.y1 = e[0][1], n.x2 = e[1][0], n.y2 = e[1][1], n.percent = 1; var t = e[2]; t ? (n.cpx1 = t[0], n.cpy1 = t[1]) : (n.cpx1 = NaN, n.cpy1 = NaN) } var QYe = function (n) { te(e, n); function e(t, r, i) { var a = n.call(this) || this; return a._createLine(t, r, i), a } return e.prototype._createLine = function (t, r, i) { var a = t.hostModel, o = t.getItemLayout(r), s = JYe(o); s.shape.percent = 0, Un(s, { shape: { percent: 1 } }, a, r), this.add(s), $(NO, function (l) { var c = W7(l, t, r); this.add(c), this[U7(l)] = G7(l, t, r) }, this), this._updateCommonStl(t, r, i) }, e.prototype.updateData = function (t, r, i) { var a = t.hostModel, o = this.childOfName("line"), s = t.getItemLayout(r), l = { shape: {} }; RI(l.shape, s), on(o, l, a, r), $(NO, function (c) { var u = G7(c, t, r), d = U7(c); if (this[d] !== u) { this.remove(this.childOfName(c)); var f = W7(c, t, r); this.add(f) } this[d] = u }, this), this._updateCommonStl(t, r, i) }, e.prototype.getLinePath = function () { return this.childAt(0) }, e.prototype._updateCommonStl = function (t, r, i) { var a = t.hostModel, o = this.childOfName("line"), s = i && i.emphasisLineStyle, l = i && i.blurLineStyle, c = i && i.selectLineStyle, u = i && i.labelStatesModels, d = i && i.emphasisDisabled, f = i && i.focus, h = i && i.blurScope; if (!i || t.hasItemOption) { var p = t.getItemModel(r), m = p.getModel("emphasis"); s = m.getModel("lineStyle").getLineStyle(), l = p.getModel(["blur", "lineStyle"]).getLineStyle(), c = p.getModel(["select", "lineStyle"]).getLineStyle(), d = m.get("disabled"), f = m.get("focus"), h = m.get("blurScope"), u = Ur(p) } var g = t.getItemVisual(r, "style"), y = g.stroke; o.useStyle(g), o.style.fill = null, o.style.strokeNoScale = !0, o.ensureState("emphasis").style = s, o.ensureState("blur").style = l, o.ensureState("select").style = c, $(NO, function (x) { var k = this.childOfName(x); if (k) { k.setColor(y), k.style.opacity = g.opacity; for (var A = 0; A < ra.length; A++) { var C = ra[A], E = o.getState(C); if (E) { var O = E.style || {}, j = k.ensureState(C), I = j.style || (j.style = {}); O.stroke != null && (I[k.__isEmptyBrush ? "stroke" : "fill"] = O.stroke), O.opacity != null && (I.opacity = O.opacity) } } k.markRedraw() } }, this); var b = a.getRawValue(r); mi(this, u, { labelDataIndex: r, labelFetcher: { getFormattedLabel: function (x, k) { return a.getFormattedLabel(x, k, t.dataType) } }, inheritColor: y || "#000", defaultOpacity: g.opacity, defaultText: (b == null ? t.getName(r) : isFinite(b) ? lr(b) : b) + "" }); var w = this.getTextContent(); if (w) { var v = u.normal; w.__align = w.style.align, w.__verticalAlign = w.style.verticalAlign, w.__position = v.get("position") || "middle"; var S = v.get("distance"); ke(S) || (S = [S, S]), w.__labelDistance = S } this.setTextConfig({ position: null, local: !0, inside: !1 }), Qn(this, f, h, d) }, e.prototype.highlight = function () { Pc(this) }, e.prototype.downplay = function () { Ic(this) }, e.prototype.updateLayout = function (t, r) { this.setLinePoints(t.getItemLayout(r)) }, e.prototype.setLinePoints = function (t) { var r = this.childOfName("line"); RI(r.shape, t), r.dirty() }, e.prototype.beforeUpdate = function () { var t = this, r = t.childOfName("fromSymbol"), i = t.childOfName("toSymbol"), a = t.getTextContent(); if (!r && !i && (!a || a.ignore)) return; for (var o = 1, s = this.parent; s;)s.scaleX && (o /= s.scaleX), s = s.parent; var l = t.childOfName("line"); if (!this.__dirty && !l.__dirty) return; var c = l.shape.percent, u = l.pointAt(0), d = l.pointAt(c), f = Qf([], d, u); Kg(f, f); function h(E, O) { var j = E.__specifiedRotation; if (j == null) { var I = l.tangentAt(O); E.attr("rotation", (O === 1 ? -1 : 1) * Math.PI / 2 - Math.atan2(I[1], I[0])) } else E.attr("rotation", j) } if (r && (r.setPosition(u), h(r, 0), r.scaleX = r.scaleY = o * c, r.markRedraw()), i && (i.setPosition(d), h(i, 1), i.scaleX = i.scaleY = o * c, i.markRedraw()), a && !a.ignore) { a.x = a.y = 0, a.originX = a.originY = 0; var p = void 0, m = void 0, g = a.__labelDistance, y = g[0] * o, b = g[1] * o, w = c / 2, v = l.tangentAt(w), S = [v[1], -v[0]], x = l.pointAt(w); S[1] > 0 && (S[0] = -S[0], S[1] = -S[1]); var k = v[0] < 0 ? -1 : 1; if (a.__position !== "start" && a.__position !== "end") { var A = -Math.atan2(v[1], v[0]); d[0] < u[0] && (A = Math.PI + A), a.rotation = A } var C = void 0; switch (a.__position) { case "insideStartTop": case "insideMiddleTop": case "insideEndTop": case "middle": C = -b, m = "bottom"; break; case "insideStartBottom": case "insideMiddleBottom": case "insideEndBottom": C = b, m = "top"; break; default: C = 0, m = "middle" }switch (a.__position) { case "end": a.x = f[0] * y + d[0], a.y = f[1] * b + d[1], p = f[0] > .8 ? "left" : f[0] < -.8 ? "right" : "center", m = f[1] > .8 ? "top" : f[1] < -.8 ? "bottom" : "middle"; break; case "start": a.x = -f[0] * y + u[0], a.y = -f[1] * b + u[1], p = f[0] > .8 ? "right" : f[0] < -.8 ? "left" : "center", m = f[1] > .8 ? "bottom" : f[1] < -.8 ? "top" : "middle"; break; case "insideStartTop": case "insideStart": case "insideStartBottom": a.x = y * k + u[0], a.y = u[1] + C, p = v[0] < 0 ? "right" : "left", a.originX = -y * k, a.originY = -C; break; case "insideMiddleTop": case "insideMiddle": case "insideMiddleBottom": case "middle": a.x = x[0], a.y = x[1] + C, p = "center", a.originY = -C; break; case "insideEndTop": case "insideEnd": case "insideEndBottom": a.x = -y * k + d[0], a.y = d[1] + C, p = v[0] >= 0 ? "right" : "left", a.originX = y * k, a.originY = -C; break }a.scaleX = a.scaleY = o, a.setStyle({ verticalAlign: a.__verticalAlign || m, align: a.__align || p }) } }, e }(ft); const G3 = QYe; var eZe = function () { function n(e) { this.group = new ft, this._LineCtor = e || G3 } return n.prototype.updateData = function (e) { var t = this; this._progressiveEls = null; var r = this, i = r.group, a = r._lineData; r._lineData = e, a || i.removeAll(); var o = K7(e); e.diff(a).add(function (s) { t._doAdd(e, s, o) }).update(function (s, l) { t._doUpdate(a, e, l, s, o) }).remove(function (s) { i.remove(a.getItemGraphicEl(s)) }).execute() }, n.prototype.updateLayout = function () { var e = this._lineData; e && e.eachItemGraphicEl(function (t, r) { t.updateLayout(e, r) }, this) }, n.prototype.incrementalPrepareUpdate = function (e) { this._seriesScope = K7(e), this._lineData = null, this.group.removeAll() }, n.prototype.incrementalUpdate = function (e, t) { this._progressiveEls = []; function r(s) { !s.isGroup && !tZe(s) && (s.incremental = !0, s.ensureState("emphasis").hoverLayer = !0) } for (var i = e.start; i < e.end; i++) { var a = t.getItemLayout(i); if (BO(a)) { var o = new this._LineCtor(t, i, this._seriesScope); o.traverse(r), this.group.add(o), t.setItemGraphicEl(i, o), this._progressiveEls.push(o) } } }, n.prototype.remove = function () { this.group.removeAll() }, n.prototype.eachRendered = function (e) { Gd(this._progressiveEls || this.group, e) }, n.prototype._doAdd = function (e, t, r) { var i = e.getItemLayout(t); if (BO(i)) { var a = new this._LineCtor(e, t, r); e.setItemGraphicEl(t, a), this.group.add(a) } }, n.prototype._doUpdate = function (e, t, r, i, a) { var o = e.getItemGraphicEl(r); if (!BO(t.getItemLayout(i))) { this.group.remove(o); return } o ? o.updateData(t, i, a) : o = new this._LineCtor(t, i, a), t.setItemGraphicEl(i, o), this.group.add(o) }, n }(); function tZe(n) { return n.animators && n.animators.length > 0 } function K7(n) { var e = n.hostModel, t = e.getModel("emphasis"); return { lineStyle: e.getModel("lineStyle").getLineStyle(), emphasisLineStyle: t.getModel(["lineStyle"]).getLineStyle(), blurLineStyle: e.getModel(["blur", "lineStyle"]).getLineStyle(), selectLineStyle: e.getModel(["select", "lineStyle"]).getLineStyle(), emphasisDisabled: t.get("disabled"), blurScope: t.get("blurScope"), focus: t.get("focus"), labelStatesModels: Ur(e) } } function q7(n) { return isNaN(n[0]) || isNaN(n[1]) } function BO(n) { return n && !q7(n[0]) && !q7(n[1]) } const W3 = eZe; var $O = [], FO = [], zO = [], tm = qr, VO = bh, Y7 = Math.abs; function Z7(n, e, t) { for (var r = n[0], i = n[1], a = n[2], o = 1 / 0, s, l = t * t, c = .1, u = .1; u <= .9; u += .1) { $O[0] = tm(r[0], i[0], a[0], u), $O[1] = tm(r[1], i[1], a[1], u); var d = Y7(VO($O, e) - l); d < o && (o = d, s = u) } for (var f = 0; f < 32; f++) { var h = s + c; FO[0] = tm(r[0], i[0], a[0], s), FO[1] = tm(r[1], i[1], a[1], s), zO[0] = tm(r[0], i[0], a[0], h), zO[1] = tm(r[1], i[1], a[1], h); var d = VO(FO, e) - l; if (Y7(d) < .01) break; var p = VO(zO, e) - l; c /= 2, d < 0 ? p >= 0 ? s = s + c : s = s - c : p >= 0 ? s = s - c : s = s + c } return s } function HO(n, e) { var t = [], r = d_, i = [[], [], []], a = [[], []], o = []; e /= 2, n.eachEdge(function (s, l) { var c = s.getLayout(), u = s.getVisual("fromSymbol"), d = s.getVisual("toSymbol"); c.__original || (c.__original = [_c(c[0]), _c(c[1])], c[2] && c.__original.push(_c(c[2]))); var f = c.__original; if (c[2] != null) { if (Wi(i[0], f[0]), Wi(i[1], f[2]), Wi(i[2], f[1]), u && u !== "none") { var h = Iy(s.node1), p = Z7(i, f[0], h * e); r(i[0][0], i[1][0], i[2][0], p, t), i[0][0] = t[3], i[1][0] = t[4], r(i[0][1], i[1][1], i[2][1], p, t), i[0][1] = t[3], i[1][1] = t[4] } if (d && d !== "none") { var h = Iy(s.node2), p = Z7(i, f[1], h * e); r(i[0][0], i[1][0], i[2][0], p, t), i[1][0] = t[1], i[2][0] = t[2], r(i[0][1], i[1][1], i[2][1], p, t), i[1][1] = t[1], i[2][1] = t[2] } Wi(c[0], i[0]), Wi(c[1], i[2]), Wi(c[2], i[1]) } else { if (Wi(a[0], f[0]), Wi(a[1], f[1]), Qf(o, a[1], a[0]), Kg(o, o), u && u !== "none") { var h = Iy(s.node1); wP(a[0], a[0], o, h * e) } if (d && d !== "none") { var h = Iy(s.node2); wP(a[1], a[1], o, -h * e) } Wi(c[0], a[0]), Wi(c[1], a[1]) } }) } function X7(n) { return n.type === "view" } var nZe = function (n) { te(e, n); function e() { var t = n !== null && n.apply(this, arguments) || this; return t.type = e.type, t } return e.prototype.init = function (t, r) { var i = new Db, a = new W3, o = this.group; this._controller = new Rb(r.getZr()), this._controllerHost = { target: o }, o.add(i.group), o.add(a.group), this._symbolDraw = i, this._lineDraw = a, this._firstRender = !0 }, e.prototype.render = function (t, r, i) { var a = this, o = t.coordinateSystem; this._model = t; var s = this._symbolDraw, l = this._lineDraw, c = this.group; if (X7(o)) { var u = { x: o.x, y: o.y, scaleX: o.scaleX, scaleY: o.scaleY }; this._firstRender ? c.attr(u) : on(c, u, t) } HO(t.getGraph(), Py(t)); var d = t.getData(); s.updateData(d); var f = t.getEdgeData(); l.updateData(f), this._updateNodeAndLinkScale(), this._updateController(t, r, i), clearTimeout(this._layoutTimeout); var h = t.forceLayout, p = t.get(["force", "layoutAnimation"]); h && this._startForceLayoutIteration(h, p); var m = t.get("layout"); d.graph.eachNode(function (w) { var v = w.dataIndex, S = w.getGraphicEl(), x = w.getModel(); if (S) { S.off("drag").off("dragend"); var k = x.get("draggable"); k && S.on("drag", function (C) { switch (m) { case "force": h.warmUp(), !a._layouting && a._startForceLayoutIteration(h, p), h.setFixed(v), d.setItemLayout(v, [S.x, S.y]); break; case "circular": d.setItemLayout(v, [S.x, S.y]), w.setLayout({ fixed: !0 }, !0), U3(t, "symbolSize", w, [C.offsetX, C.offsetY]), a.updateLayout(t); break; case "none": default: d.setItemLayout(v, [S.x, S.y]), H3(t.getGraph(), t), a.updateLayout(t); break } }).on("dragend", function () { h && h.setUnfixed(v) }), S.setDraggable(k, !!x.get("cursor")); var A = x.get(["emphasis", "focus"]); A === "adjacency" && (pt(S).focus = w.getAdjacentDataIndices()) } }), d.graph.eachEdge(function (w) { var v = w.getGraphicEl(), S = w.getModel().get(["emphasis", "focus"]); v && S === "adjacency" && (pt(v).focus = { edge: [w.dataIndex], node: [w.node1.dataIndex, w.node2.dataIndex] }) }); var g = t.get("layout") === "circular" && t.get(["circular", "rotateLabel"]), y = d.getLayout("cx"), b = d.getLayout("cy"); d.graph.eachNode(function (w) { Pae(w, g, y, b) }), this._firstRender = !1 }, e.prototype.dispose = function () { this.remove(), this._controller && this._controller.dispose(), this._controllerHost = null }, e.prototype._startForceLayoutIteration = function (t, r) { var i = this; (function a() { t.step(function (o) { i.updateLayout(i._model), (i._layouting = !o) && (r ? i._layoutTimeout = setTimeout(a, 16) : a()) }) })() }, e.prototype._updateController = function (t, r, i) { var a = this, o = this._controller, s = this._controllerHost, l = this.group; if (o.setPointerChecker(function (c, u, d) { var f = l.getBoundingRect(); return f.applyTransform(l.transform), f.contain(u, d) && !TC(c, i, t) }), !X7(t.coordinateSystem)) { o.disable(); return } o.enable(t.get("roam")), s.zoomLimit = t.get("scaleLimit"), s.zoom = t.coordinateSystem.getZoom(), o.off("pan").off("zoom").on("pan", function (c) { P3(s, c.dx, c.dy), i.dispatchAction({ seriesId: t.id, type: "graphRoam", dx: c.dx, dy: c.dy }) }).on("zoom", function (c) { I3(s, c.scale, c.originX, c.originY), i.dispatchAction({ seriesId: t.id, type: "graphRoam", zoom: c.scale, originX: c.originX, originY: c.originY }), a._updateNodeAndLinkScale(), HO(t.getGraph(), Py(t)), a._lineDraw.updateLayout(), i.updateLabelLayout() }) }, e.prototype._updateNodeAndLinkScale = function () { var t = this._model, r = t.getData(), i = Py(t); r.eachItemGraphicEl(function (a, o) { a && a.setSymbolScale(i) }) }, e.prototype.updateLayout = function (t) { HO(t.getGraph(), Py(t)), this._symbolDraw.updateLayout(), this._lineDraw.updateLayout() }, e.prototype.remove = function () { clearTimeout(this._layoutTimeout), this._layouting = !1, this._layoutTimeout = null, this._symbolDraw && this._symbolDraw.remove(), this._lineDraw && this._lineDraw.remove() }, e.type = "graph", e }(Nn); const rZe = nZe; function nm(n) { return "_EC_" + n } var iZe = function () { function n(e) { this.type = "graph", this.nodes = [], this.edges = [], this._nodesMap = {}, this._edgesMap = {}, this._directed = e || !1 } return n.prototype.isDirected = function () { return this._directed }, n.prototype.addNode = function (e, t) { e = e == null ? "" + t : "" + e; var r = this._nodesMap; if (!r[nm(e)]) { var i = new Bf(e, t); return i.hostGraph = this, this.nodes.push(i), r[nm(e)] = i, i } }, n.prototype.getNodeByIndex = function (e) { var t = this.data.getRawIndex(e); return this.nodes[t] }, n.prototype.getNodeById = function (e) { return this._nodesMap[nm(e)] }, n.prototype.addEdge = function (e, t, r) { var i = this._nodesMap, a = this._edgesMap; if (nn(e) && (e = this.nodes[e]), nn(t) && (t = this.nodes[t]), e instanceof Bf || (e = i[nm(e)]), t instanceof Bf || (t = i[nm(t)]), !(!e || !t)) { var o = e.id + "-" + t.id, s = new Lae(e, t, r); return s.hostGraph = this, this._directed && (e.outEdges.push(s), t.inEdges.push(s)), e.edges.push(s), e !== t && t.edges.push(s), this.edges.push(s), a[o] = s, s } }, n.prototype.getEdgeByIndex = function (e) { var t = this.edgeData.getRawIndex(e); return this.edges[t] }, n.prototype.getEdge = function (e, t) { e instanceof Bf && (e = e.id), t instanceof Bf && (t = t.id); var r = this._edgesMap; return this._directed ? r[e + "-" + t] : r[e + "-" + t] || r[t + "-" + e] }, n.prototype.eachNode = function (e, t) { for (var r = this.nodes, i = r.length, a = 0; a < i; a++)r[a].dataIndex >= 0 && e.call(t, r[a], a) }, n.prototype.eachEdge = function (e, t) { for (var r = this.edges, i = r.length, a = 0; a < i; a++)r[a].dataIndex >= 0 && r[a].node1.dataIndex >= 0 && r[a].node2.dataIndex >= 0 && e.call(t, r[a], a) }, n.prototype.breadthFirstTraverse = function (e, t, r, i) { if (t instanceof Bf || (t = this._nodesMap[nm(t)]), !!t) { for (var a = r === "out" ? "outEdges" : r === "in" ? "inEdges" : "edges", o = 0; o < this.nodes.length; o++)this.nodes[o].__visited = !1; if (!e.call(i, t, null)) for (var s = [t]; s.length;)for (var l = s.shift(), c = l[a], o = 0; o < c.length; o++) { var u = c[o], d = u.node1 === l ? u.node2 : u.node1; if (!d.__visited) { if (e.call(i, d, l)) return; s.push(d), d.__visited = !0 } } } }, n.prototype.update = function () { for (var e = this.data, t = this.edgeData, r = this.nodes, i = this.edges, a = 0, o = r.length; a < o; a++)r[a].dataIndex = -1; for (var a = 0, o = e.count(); a < o; a++)r[e.getRawIndex(a)].dataIndex = a; t.filterSelf(function (s) { var l = i[t.getRawIndex(s)]; return l.node1.dataIndex >= 0 && l.node2.dataIndex >= 0 }); for (var a = 0, o = i.length; a < o; a++)i[a].dataIndex = -1; for (var a = 0, o = t.count(); a < o; a++)i[t.getRawIndex(a)].dataIndex = a }, n.prototype.clone = function () { for (var e = new n(this._directed), t = this.nodes, r = this.edges, i = 0; i < t.length; i++)e.addNode(t[i].id, t[i].dataIndex); for (var i = 0; i < r.length; i++) { var a = r[i]; e.addEdge(a.node1.id, a.node2.id, a.dataIndex) } return e }, n }(), Bf = function () { function n(e, t) { this.inEdges = [], this.outEdges = [], this.edges = [], this.dataIndex = -1, this.id = e ?? "", this.dataIndex = t ?? -1 } return n.prototype.degree = function () { return this.edges.length }, n.prototype.inDegree = function () { return this.inEdges.length }, n.prototype.outDegree = function () { return this.outEdges.length }, n.prototype.getModel = function (e) { if (!(this.dataIndex < 0)) { var t = this.hostGraph, r = t.data.getItemModel(this.dataIndex); return r.getModel(e) } }, n.prototype.getAdjacentDataIndices = function () { for (var e = { edge: [], node: [] }, t = 0; t < this.edges.length; t++) { var r = this.edges[t]; r.dataIndex < 0 || (e.edge.push(r.dataIndex), e.node.push(r.node1.dataIndex, r.node2.dataIndex)) } return e }, n.prototype.getTrajectoryDataIndices = function () { for (var e = Ze(), t = Ze(), r = 0; r < this.edges.length; r++) { var i = this.edges[r]; if (!(i.dataIndex < 0)) { e.set(i.dataIndex, !0); for (var a = [i.node1], o = [i.node2], s = 0; s < a.length;) { var l = a[s]; s++, t.set(l.dataIndex, !0); for (var c = 0; c < l.inEdges.length; c++)e.set(l.inEdges[c].dataIndex, !0), a.push(l.inEdges[c].node1) } for (s = 0; s < o.length;) { var u = o[s]; s++, t.set(u.dataIndex, !0); for (var c = 0; c < u.outEdges.length; c++)e.set(u.outEdges[c].dataIndex, !0), o.push(u.outEdges[c].node2) } } } return { edge: e.keys(), node: t.keys() } }, n }(), Lae = function () { function n(e, t, r) { this.dataIndex = -1, this.node1 = e, this.node2 = t, this.dataIndex = r ?? -1 } return n.prototype.getModel = function (e) { if (!(this.dataIndex < 0)) { var t = this.hostGraph, r = t.edgeData.getItemModel(this.dataIndex); return r.getModel(e) } }, n.prototype.getAdjacentDataIndices = function () { return { edge: [this.dataIndex], node: [this.node1.dataIndex, this.node2.dataIndex] } }, n.prototype.getTrajectoryDataIndices = function () { var e = Ze(), t = Ze(); e.set(this.dataIndex, !0); for (var r = [this.node1], i = [this.node2], a = 0; a < r.length;) { var o = r[a]; a++, t.set(o.dataIndex, !0); for (var s = 0; s < o.inEdges.length; s++)e.set(o.inEdges[s].dataIndex, !0), r.push(o.inEdges[s].node1) } for (a = 0; a < i.length;) { var l = i[a]; a++, t.set(l.dataIndex, !0); for (var s = 0; s < l.outEdges.length; s++)e.set(l.outEdges[s].dataIndex, !0), i.push(l.outEdges[s].node2) } return { edge: e.keys(), node: t.keys() } }, n }(); function Rae(n, e) { return { getValue: function (t) { var r = this[n][e]; return r.getStore().get(r.getDimensionIndex(t || "value"), this.dataIndex) }, setVisual: function (t, r) { this.dataIndex >= 0 && this[n][e].setItemVisual(this.dataIndex, t, r) }, getVisual: function (t) { return this[n][e].getItemVisual(this.dataIndex, t) }, setLayout: function (t, r) { this.dataIndex >= 0 && this[n][e].setItemLayout(this.dataIndex, t, r) }, getLayout: function () { return this[n][e].getItemLayout(this.dataIndex) }, getGraphicEl: function () { return this[n][e].getItemGraphicEl(this.dataIndex) }, getRawIndex: function () { return this[n][e].getRawIndex(this.dataIndex) } } } Cr(Bf, Rae("hostGraph", "data")); Cr(Lae, Rae("hostGraph", "edgeData")); const aZe = iZe; function Nae(n, e, t, r, i) { for (var a = new aZe(r), o = 0; o < n.length; o++)a.addNode(Xr(n[o].id, n[o].name, o), o); for (var s = [], l = [], c = 0, o = 0; o < e.length; o++) { var u = e[o], d = u.source, f = u.target; a.addEdge(d, f, c) && (l.push(u), s.push(Xr(Er(u.id, null), d + " > " + f)), c++) } var h = t.get("coordinateSystem"), p; if (h === "cartesian2d" || h === "polar") p = Hc(n, t); else { var m = Cb.get(h), g = m ? m.dimensions || [] : []; Et(g, "value") < 0 && g.concat(["value"]); var y = Eb(n, { coordDimensions: g, encodeDefine: t.getEncode() }).dimensions; p = new Ji(y, t), p.initData(n) } var b = new Ji(["value"], t); return b.initData(l, s), i && i(p, b), yae({ mainData: p, struct: a, structAttr: "graph", datas: { node: p, edge: b }, datasAttr: { node: "data", edge: "edgeData" } }), a.update(), a } var oZe = function (n) { te(e, n); function e() { var t = n !== null && n.apply(this, arguments) || this; return t.type = e.type, t.hasSymbolVisual = !0, t } return e.prototype.init = function (t) { n.prototype.init.apply(this, arguments); var r = this; function i() { return r._categoriesData } this.legendVisualProvider = new Lb(i, i), this.fillDataTextStyle(t.edges || t.links), this._updateCategoriesData() }, e.prototype.mergeOption = function (t) { n.prototype.mergeOption.apply(this, arguments), this.fillDataTextStyle(t.edges || t.links), this._updateCategoriesData() }, e.prototype.mergeDefaultAndTheme = function (t) { n.prototype.mergeDefaultAndTheme.apply(this, arguments), Vh(t, "edgeLabel", ["show"]) }, e.prototype.getInitialData = function (t, r) { var i = t.edges || t.links || [], a = t.data || t.nodes || [], o = this; if (a && i) { zYe(this); var s = Nae(a, i, this, !0, l); return $(s.edges, function (c) { VYe(c.node1, c.node2, this, c.dataIndex) }, this), s.data } function l(c, u) { c.wrapMethod("getItemModel", function (p) { var m = o._categoriesModels, g = p.getShallow("category"), y = m[g]; return y && (y.parentModel = p.parentModel, p.parentModel = y), p }); var d = Rn.prototype.getModel; function f(p, m) { var g = d.call(this, p, m); return g.resolveParentPath = h, g } u.wrapMethod("getItemModel", function (p) { return p.resolveParentPath = h, p.getModel = f, p }); function h(p) { if (p && (p[0] === "label" || p[1] === "label")) { var m = p.slice(); return p[0] === "label" ? m[0] = "edgeLabel" : p[1] === "label" && (m[1] = "edgeLabel"), m } return p } } }, e.prototype.getGraph = function () { return this.getData().graph }, e.prototype.getEdgeData = function () { return this.getGraph().edgeData }, e.prototype.getCategoriesData = function () { return this._categoriesData }, e.prototype.formatTooltip = function (t, r, i) { if (i === "edge") { var a = this.getData(), o = this.getDataParams(t, i), s = a.graph.getEdgeByIndex(t), l = a.getName(s.node1.dataIndex), c = a.getName(s.node2.dataIndex), u = []; return l != null && u.push(l), c != null && u.push(c), Gr("nameValue", { name: u.join(" > "), value: o.value, noValue: o.value == null }) } var d = tre({ series: this, dataIndex: t, multipleSeries: r }); return d }, e.prototype._updateCategoriesData = function () { var t = Ae(this.option.categories || [], function (i) { return i.value != null ? i : be({ value: 0 }, i) }), r = new Ji(["value"], this); r.initData(t), this._categoriesData = r, this._categoriesModels = r.mapArray(function (i) { return r.getItemModel(i) }) }, e.prototype.setZoom = function (t) { this.option.zoom = t }, e.prototype.setCenter = function (t) { this.option.center = t }, e.prototype.isAnimationEnabled = function () { return n.prototype.isAnimationEnabled.call(this) && !(this.get("layout") === "force" && this.get(["force", "layoutAnimation"])) }, e.type = "series.graph", e.dependencies = ["grid", "polar", "geo", "singleAxis", "calendar"], e.defaultOption = { z: 2, coordinateSystem: "view", legendHoverLink: !0, layout: null, circular: { rotateLabel: !1 }, force: { initLayout: null, repulsion: [0, 50], gravity: .1, friction: .6, edgeLength: 30, layoutAnimation: !0 }, left: "center", top: "center", symbol: "circle", symbolSize: 10, edgeSymbol: ["none", "none"], edgeSymbolSize: 10, edgeLabel: { position: "middle", distance: 5 }, draggable: !1, roam: !1, center: null, zoom: 1, nodeScaleRatio: .6, label: { show: !1, formatter: "{b}" }, itemStyle: {}, lineStyle: { color: "#aaa", width: 1, opacity: .5 }, emphasis: { scale: !0, label: { show: !0 } }, select: { itemStyle: { borderColor: "#212121" } } }, e }(Yn); const sZe = oZe; var lZe = { type: "graphRoam", event: "graphRoam", update: "none" }; function cZe(n) { n.registerChartView(rZe), n.registerSeriesModel(sZe), n.registerProcessor(RYe), n.registerVisual(NYe), n.registerVisual(BYe), n.registerLayout(HYe), n.registerLayout(n.PRIORITY.VISUAL.POST_CHART_LAYOUT, GYe), n.registerLayout(KYe), n.registerCoordinateSystem("graphView", { dimensions: Nb.dimensions, create: YYe }), n.registerAction({ type: "focusNodeAdjacency", event: "focusNodeAdjacency", update: "series:focusNodeAdjacency" }, gr), n.registerAction({ type: "unfocusNodeAdjacency", event: "unfocusNodeAdjacency", update: "series:unfocusNodeAdjacency" }, gr), n.registerAction(lZe, function (e, t, r) { t.eachComponent({ mainType: "series", query: e }, function (i) { var a = i.coordinateSystem, o = R3(a, e, void 0, r); i.setCenter && i.setCenter(o.center), i.setZoom && i.setZoom(o.zoom) }) }) } var uZe = function () { function n() { this.angle = 0, this.width = 10, this.r = 10, this.x = 0, this.y = 0 } return n }(), dZe = function (n) { te(e, n); function e(t) { var r = n.call(this, t) || this; return r.type = "pointer", r } return e.prototype.getDefaultShape = function () { return new uZe }, e.prototype.buildPath = function (t, r) { var i = Math.cos, a = Math.sin, o = r.r, s = r.width, l = r.angle, c = r.x - i(l) * s * (s >= o / 3 ? 1 : 2), u = r.y - a(l) * s * (s >= o / 3 ? 1 : 2); l = r.angle - Math.PI / 2, t.moveTo(c, u), t.lineTo(r.x + i(l) * s, r.y + a(l) * s), t.lineTo(r.x + i(r.angle) * o, r.y + a(r.angle) * o), t.lineTo(r.x - i(l) * s, r.y - a(l) * s), t.lineTo(c, u) }, e }(Nt); const fZe = dZe; function hZe(n, e) { var t = n.get("center"), r = e.getWidth(), i = e.getHeight(), a = Math.min(r, i), o = Ne(t[0], e.getWidth()), s = Ne(t[1], e.getHeight()), l = Ne(n.get("radius"), a / 2); return { cx: o, cy: s, r: l } } function hx(n, e) { var t = n == null ? "" : n + ""; return e && (Fe(e) ? t = e.replace("{value}", t) : tt(e) && (t = e(n))), t } var pZe = function (n) { te(e, n); function e() { var t = n !== null && n.apply(this, arguments) || this; return t.type = e.type, t } return e.prototype.render = function (t, r, i) { this.group.removeAll(); var a = t.get(["axisLine", "lineStyle", "color"]), o = hZe(t, i); this._renderMain(t, r, i, a, o), this._data = t.getData() }, e.prototype.dispose = function () { }, e.prototype._renderMain = function (t, r, i, a, o) { var s = this.group, l = t.get("clockwise"), c = -t.get("startAngle") / 180 * Math.PI, u = -t.get("endAngle") / 180 * Math.PI, d = t.getModel("axisLine"), f = d.get("roundCap"), h = f ? vT : Ca, p = d.get("show"), m = d.getModel("lineStyle"), g = m.get("width"), y = [c, u]; LN(y, !l), c = y[0], u = y[1]; for (var b = u - c, w = c, v = [], S = 0; p && S < a.length; S++) { var x = Math.min(Math.max(a[S][0], 0), 1); u = c + b * x; var k = new h({ shape: { startAngle: w, endAngle: u, cx: o.cx, cy: o.cy, clockwise: l, r0: o.r - g, r: o.r }, silent: !0 }); k.setStyle({ fill: a[S][1] }), k.setStyle(m.getLineStyle(["color", "width"])), v.push(k), w = u } v.reverse(), $(v, function (C) { return s.add(C) }); var A = function (C) { if (C <= 0) return a[0][1]; var E; for (E = 0; E < a.length; E++)if (a[E][0] >= C && (E === 0 ? 0 : a[E - 1][0]) < C) return a[E][1]; return a[E - 1][1] }; this._renderTicks(t, r, i, A, o, c, u, l, g), this._renderTitleAndDetail(t, r, i, A, o), this._renderAnchor(t, o), this._renderPointer(t, r, i, A, o, c, u, l, g) }, e.prototype._renderTicks = function (t, r, i, a, o, s, l, c, u) { for (var d = this.group, f = o.cx, h = o.cy, p = o.r, m = +t.get("min"), g = +t.get("max"), y = t.getModel("splitLine"), b = t.getModel("axisTick"), w = t.getModel("axisLabel"), v = t.get("splitNumber"), S = b.get("splitNumber"), x = Ne(y.get("length"), p), k = Ne(b.get("length"), p), A = s, C = (l - s) / v, E = C / S, O = y.getModel("lineStyle").getLineStyle(), j = b.getModel("lineStyle").getLineStyle(), I = y.get("distance"), L, R, D = 0; D <= v; D++) { if (L = Math.cos(A), R = Math.sin(A), y.get("show")) { var P = I ? I + u : u, B = new Jr({ shape: { x1: L * (p - P) + f, y1: R * (p - P) + h, x2: L * (p - x - P) + f, y2: R * (p - x - P) + h }, style: O, silent: !0 }); O.stroke === "auto" && B.setStyle({ stroke: a(D / v) }), d.add(B) } if (w.get("show")) { var P = w.get("distance") + I, F = hx(lr(D / v * (g - m) + m), w.get("formatter")), K = a(D / v), V = L * (p - x - P) + f, W = R * (p - x - P) + h, J = w.get("rotate"), ie = 0; J === "radial" ? (ie = -A + 2 * Math.PI, ie > Math.PI / 2 && (ie += Math.PI)) : J === "tangential" ? ie = -A - Math.PI / 2 : nn(J) && (ie = J * Math.PI / 180), ie === 0 ? d.add(new tn({ style: Ln(w, { text: F, x: V, y: W, verticalAlign: R < -.8 ? "top" : R > .8 ? "bottom" : "middle", align: L < -.4 ? "left" : L > .4 ? "right" : "center" }, { inheritColor: K }), silent: !0 })) : d.add(new tn({ style: Ln(w, { text: F, x: V, y: W, verticalAlign: "middle", align: "center" }, { inheritColor: K }), silent: !0, originX: V, originY: W, rotation: ie })) } if (b.get("show") && D !== v) { var P = b.get("distance"); P = P ? P + u : u; for (var le = 0; le <= S; le++) { L = Math.cos(A), R = Math.sin(A); var De = new Jr({ shape: { x1: L * (p - P) + f, y1: R * (p - P) + h, x2: L * (p - k - P) + f, y2: R * (p - k - P) + h }, silent: !0, style: j }); j.stroke === "auto" && De.setStyle({ stroke: a((D + le / S) / v) }), d.add(De), A += E } A -= E } else A += C } }, e.prototype._renderPointer = function (t, r, i, a, o, s, l, c, u) { var d = this.group, f = this._data, h = this._progressEls, p = [], m = t.get(["pointer", "show"]), g = t.getModel("progress"), y = g.get("show"), b = t.getData(), w = b.mapDimension("value"), v = +t.get("min"), S = +t.get("max"), x = [v, S], k = [s, l]; function A(E, O) { var j = b.getItemModel(E), I = j.getModel("pointer"), L = Ne(I.get("width"), o.r), R = Ne(I.get("length"), o.r), D = t.get(["pointer", "icon"]), P = I.get("offsetCenter"), B = Ne(P[0], o.r), F = Ne(P[1], o.r), K = I.get("keepAspect"), V; return D ? V = Tr(D, B - L / 2, F - R, L, R, null, K) : V = new fZe({ shape: { angle: -Math.PI / 2, width: L, r: R, x: B, y: F } }), V.rotation = -(O + Math.PI / 2), V.x = o.cx, V.y = o.cy, V } function C(E, O) { var j = g.get("roundCap"), I = j ? vT : Ca, L = g.get("overlap"), R = L ? g.get("width") : u / b.count(), D = L ? o.r - R : o.r - (E + 1) * R, P = L ? o.r : o.r - E * R, B = new I({ shape: { startAngle: s, endAngle: O, cx: o.cx, cy: o.cy, clockwise: c, r0: D, r: P } }); return L && (B.z2 = vn(b.get(w, E), [v, S], [100, 0], !0)), B } (y || m) && (b.diff(f).add(function (E) { var O = b.get(w, E); if (m) { var j = A(E, s); Un(j, { rotation: -((isNaN(+O) ? k[0] : vn(O, x, k, !0)) + Math.PI / 2) }, t), d.add(j), b.setItemGraphicEl(E, j) } if (y) { var I = C(E, s), L = g.get("clip"); Un(I, { shape: { endAngle: vn(O, x, k, L) } }, t), d.add(I), qP(t.seriesIndex, b.dataType, E, I), p[E] = I } }).update(function (E, O) { var j = b.get(w, E); if (m) { var I = f.getItemGraphicEl(O), L = I ? I.rotation : s, R = A(E, L); R.rotation = L, on(R, { rotation: -((isNaN(+j) ? k[0] : vn(j, x, k, !0)) + Math.PI / 2) }, t), d.add(R), b.setItemGraphicEl(E, R) } if (y) { var D = h[O], P = D ? D.shape.endAngle : s, B = C(E, P), F = g.get("clip"); on(B, { shape: { endAngle: vn(j, x, k, F) } }, t), d.add(B), qP(t.seriesIndex, b.dataType, E, B), p[E] = B } }).execute(), b.each(function (E) { var O = b.getItemModel(E), j = O.getModel("emphasis"), I = j.get("focus"), L = j.get("blurScope"), R = j.get("disabled"); if (m) { var D = b.getItemGraphicEl(E), P = b.getItemVisual(E, "style"), B = P.fill; if (D instanceof gi) { var F = D.style; D.useStyle(be({ image: F.image, x: F.x, y: F.y, width: F.width, height: F.height }, P)) } else D.useStyle(P), D.type !== "pointer" && D.setColor(B); D.setStyle(O.getModel(["pointer", "itemStyle"]).getItemStyle()), D.style.fill === "auto" && D.setStyle("fill", a(vn(b.get(w, E), x, [0, 1], !0))), D.z2EmphasisLift = 0, pi(D, O), Qn(D, I, L, R) } if (y) { var K = p[E]; K.useStyle(b.getItemVisual(E, "style")), K.setStyle(O.getModel(["progress", "itemStyle"]).getItemStyle()), K.z2EmphasisLift = 0, pi(K, O), Qn(K, I, L, R) } }), this._progressEls = p) }, e.prototype._renderAnchor = function (t, r) { var i = t.getModel("anchor"), a = i.get("show"); if (a) { var o = i.get("size"), s = i.get("icon"), l = i.get("offsetCenter"), c = i.get("keepAspect"), u = Tr(s, r.cx - o / 2 + Ne(l[0], r.r), r.cy - o / 2 + Ne(l[1], r.r), o, o, null, c); u.z2 = i.get("showAbove") ? 1 : 0, u.setStyle(i.getModel("itemStyle").getItemStyle()), this.group.add(u) } }, e.prototype._renderTitleAndDetail = function (t, r, i, a, o) { var s = this, l = t.getData(), c = l.mapDimension("value"), u = +t.get("min"), d = +t.get("max"), f = new ft, h = [], p = [], m = t.isAnimationEnabled(), g = t.get(["pointer", "showAbove"]); l.diff(this._data).add(function (y) { h[y] = new tn({ silent: !0 }), p[y] = new tn({ silent: !0 }) }).update(function (y, b) { h[y] = s._titleEls[b], p[y] = s._detailEls[b] }).execute(), l.each(function (y) { var b = l.getItemModel(y), w = l.get(c, y), v = new ft, S = a(vn(w, [u, d], [0, 1], !0)), x = b.getModel("title"); if (x.get("show")) { var k = x.get("offsetCenter"), A = o.cx + Ne(k[0], o.r), C = o.cy + Ne(k[1], o.r), E = h[y]; E.attr({ z2: g ? 0 : 2, style: Ln(x, { x: A, y: C, text: l.getName(y), align: "center", verticalAlign: "middle" }, { inheritColor: S }) }), v.add(E) } var O = b.getModel("detail"); if (O.get("show")) { var j = O.get("offsetCenter"), I = o.cx + Ne(j[0], o.r), L = o.cy + Ne(j[1], o.r), R = Ne(O.get("width"), o.r), D = Ne(O.get("height"), o.r), P = t.get(["progress", "show"]) ? l.getItemVisual(y, "style").fill : S, E = p[y], B = O.get("formatter"); E.attr({ z2: g ? 0 : 2, style: Ln(O, { x: I, y: L, text: hx(w, B), width: isNaN(R) ? null : R, height: isNaN(D) ? null : D, align: "center", verticalAlign: "middle" }, { inheritColor: P }) }), rne(E, { normal: O }, w, function (K) { return hx(K, B) }), m && ine(E, y, l, t, { getFormattedLabel: function (K, V, W, J, ie, le) { return hx(le ? le.interpolatedValue : w, B) } }), v.add(E) } f.add(v) }), this.group.add(f), this._titleEls = h, this._detailEls = p }, e.type = "gauge", e }(Nn); const mZe = pZe; var gZe = function (n) { te(e, n); function e() { var t = n !== null && n.apply(this, arguments) || this; return t.type = e.type, t.visualStyleAccessPath = "itemStyle", t } return e.prototype.getInitialData = function (t, r) { return lv(this, ["value"]) }, e.type = "series.gauge", e.defaultOption = { z: 2, colorBy: "data", center: ["50%", "50%"], legendHoverLink: !0, radius: "75%", startAngle: 225, endAngle: -45, clockwise: !0, min: 0, max: 100, splitNumber: 10, axisLine: { show: !0, roundCap: !1, lineStyle: { color: [[1, "#E6EBF8"]], width: 10 } }, progress: { show: !1, overlap: !0, width: 10, roundCap: !1, clip: !0 }, splitLine: { show: !0, length: 10, distance: 10, lineStyle: { color: "#63677A", width: 3, type: "solid" } }, axisTick: { show: !0, splitNumber: 5, length: 6, distance: 10, lineStyle: { color: "#63677A", width: 1, type: "solid" } }, axisLabel: { show: !0, distance: 15, color: "#464646", fontSize: 12, rotate: 0 }, pointer: { icon: null, offsetCenter: [0, 0], show: !0, showAbove: !0, length: "60%", width: 6, keepAspect: !1 }, anchor: { show: !1, showAbove: !1, size: 6, icon: "circle", offsetCenter: [0, 0], keepAspect: !1, itemStyle: { color: "#fff", borderWidth: 0, borderColor: "#5470c6" } }, title: { show: !0, offsetCenter: [0, "20%"], color: "#464646", fontSize: 16, valueAnimation: !1 }, detail: { show: !0, backgroundColor: "rgba(0,0,0,0)", borderWidth: 0, borderColor: "#ccc", width: 100, height: null, padding: [5, 10], offsetCenter: [0, "40%"], color: "#464646", fontSize: 30, fontWeight: "bold", lineHeight: 30, valueAnimation: !1 } }, e }(Yn); const vZe = gZe; function yZe(n) { n.registerChartView(mZe), n.registerSeriesModel(vZe) } var _Ze = ["itemStyle", "opacity"], bZe = function (n) { te(e, n); function e(t, r) { var i = n.call(this) || this, a = i, o = new Ea, s = new tn; return a.setTextContent(s), i.setTextGuideLine(o), i.updateData(t, r, !0), i } return e.prototype.updateData = function (t, r, i) { var a = this, o = t.hostModel, s = t.getItemModel(r), l = t.getItemLayout(r), c = s.getModel("emphasis"), u = s.get(_Ze); u = u ?? 1, i || Ms(a), a.useStyle(t.getItemVisual(r, "style")), a.style.lineJoin = "round", i ? (a.setShape({ points: l.points }), a.style.opacity = 0, Un(a, { style: { opacity: u } }, o, r)) : on(a, { style: { opacity: u }, shape: { points: l.points } }, o, r), pi(a, s), this._updateLabel(t, r), Qn(this, c.get("focus"), c.get("blurScope"), c.get("disabled")) }, e.prototype._updateLabel = function (t, r) { var i = this, a = this.getTextGuideLine(), o = i.getTextContent(), s = t.hostModel, l = t.getItemModel(r), c = t.getItemLayout(r), u = c.label, d = t.getItemVisual(r, "style"), f = d.fill; mi(o, Ur(l), { labelFetcher: t.hostModel, labelDataIndex: r, defaultOpacity: d.opacity, defaultText: t.getName(r) }, { normal: { align: u.textAlign, verticalAlign: u.verticalAlign } }), i.setTextConfig({ local: !0, inside: !!u.inside, insideStroke: f, outsideFill: f }); var h = u.linePoints; a.setShape({ points: h }), i.textGuideLineConfig = { anchor: h ? new St(h[0][0], h[0][1]) : null }, on(o, { style: { x: u.x, y: u.y } }, s, r), o.attr({ rotation: u.rotation, originX: u.x, originY: u.y, z2: 10 }), S3(i, T3(l), { stroke: f }) }, e }(Aa), wZe = function (n) { te(e, n); function e() { var t = n !== null && n.apply(this, arguments) || this; return t.type = e.type, t.ignoreLabelLineUpdate = !0, t } return e.prototype.render = function (t, r, i) { var a = t.getData(), o = this._data, s = this.group; a.diff(o).add(function (l) { var c = new bZe(a, l); a.setItemGraphicEl(l, c), s.add(c) }).update(function (l, c) { var u = o.getItemGraphicEl(c); u.updateData(a, l), s.add(u), a.setItemGraphicEl(l, u) }).remove(function (l) { var c = o.getItemGraphicEl(l); __(c, t, l) }).execute(), this._data = a }, e.prototype.remove = function () { this.group.removeAll(), this._data = null }, e.prototype.dispose = function () { }, e.type = "funnel", e }(Nn); const xZe = wZe; var SZe = function (n) { te(e, n); function e() { var t = n !== null && n.apply(this, arguments) || this; return t.type = e.type, t } return e.prototype.init = function (t) { n.prototype.init.apply(this, arguments), this.legendVisualProvider = new Lb(He(this.getData, this), He(this.getRawData, this)), this._defaultLabelLine(t) }, e.prototype.getInitialData = function (t, r) { return lv(this, { coordDimensions: ["value"], encodeDefaulter: wt(e3, this) }) }, e.prototype._defaultLabelLine = function (t) { Vh(t, "labelLine", ["show"]); var r = t.labelLine, i = t.emphasis.labelLine; r.show = r.show && t.label.show, i.show = i.show && t.emphasis.label.show }, e.prototype.getDataParams = function (t) { var r = this.getData(), i = n.prototype.getDataParams.call(this, t), a = r.mapDimension("value"), o = r.getSum(a); return i.percent = o ? +(r.get(a, t) / o * 100).toFixed(2) : 0, i.$vars.push("percent"), i }, e.type = "series.funnel", e.defaultOption = { z: 2, legendHoverLink: !0, colorBy: "data", left: 80, top: 60, right: 80, bottom: 60, minSize: "0%", maxSize: "100%", sort: "descending", orient: "vertical", gap: 0, funnelAlign: "center", label: { show: !0, position: "outer" }, labelLine: { show: !0, length: 20, lineStyle: { width: 1 } }, itemStyle: { borderColor: "#fff", borderWidth: 1 }, emphasis: { label: { show: !0 } }, select: { itemStyle: { borderColor: "#212121" } } }, e }(Yn); const TZe = SZe; function kZe(n, e) { return jr(n.getBoxLayoutParams(), { width: e.getWidth(), height: e.getHeight() }) } function CZe(n, e) { for (var t = n.mapDimension("value"), r = n.mapArray(t, function (l) { return l }), i = [], a = e === "ascending", o = 0, s = n.count(); o < s; o++)i[o] = o; return tt(e) ? i.sort(e) : e !== "none" && i.sort(function (l, c) { return a ? r[l] - r[c] : r[c] - r[l] }), i } function AZe(n) { var e = n.hostModel, t = e.get("orient"); n.each(function (r) { var i = n.getItemModel(r), a = i.getModel("label"), o = a.get("position"), s = i.getModel("labelLine"), l = n.getItemLayout(r), c = l.points, u = o === "inner" || o === "inside" || o === "center" || o === "insideLeft" || o === "insideRight", d, f, h, p; if (u) o === "insideLeft" ? (f = (c[0][0] + c[3][0]) / 2 + 5, h = (c[0][1] + c[3][1]) / 2, d = "left") : o === "insideRight" ? (f = (c[1][0] + c[2][0]) / 2 - 5, h = (c[1][1] + c[2][1]) / 2, d = "right") : (f = (c[0][0] + c[1][0] + c[2][0] + c[3][0]) / 4, h = (c[0][1] + c[1][1] + c[2][1] + c[3][1]) / 4, d = "center"), p = [[f, h], [f, h]]; else { var m = void 0, g = void 0, y = void 0, b = void 0, w = s.get("length"); o === "left" ? (m = (c[3][0] + c[0][0]) / 2, g = (c[3][1] + c[0][1]) / 2, y = m - w, f = y - 5, d = "right") : o === "right" ? (m = (c[1][0] + c[2][0]) / 2, g = (c[1][1] + c[2][1]) / 2, y = m + w, f = y + 5, d = "left") : o === "top" ? (m = (c[3][0] + c[0][0]) / 2, g = (c[3][1] + c[0][1]) / 2, b = g - w, h = b - 5, d = "center") : o === "bottom" ? (m = (c[1][0] + c[2][0]) / 2, g = (c[1][1] + c[2][1]) / 2, b = g + w, h = b + 5, d = "center") : o === "rightTop" ? (m = t === "horizontal" ? c[3][0] : c[1][0], g = t === "horizontal" ? c[3][1] : c[1][1], t === "horizontal" ? (b = g - w, h = b - 5, d = "center") : (y = m + w, f = y + 5, d = "top")) : o === "rightBottom" ? (m = c[2][0], g = c[2][1], t === "horizontal" ? (b = g + w, h = b + 5, d = "center") : (y = m + w, f = y + 5, d = "bottom")) : o === "leftTop" ? (m = c[0][0], g = t === "horizontal" ? c[0][1] : c[1][1], t === "horizontal" ? (b = g - w, h = b - 5, d = "center") : (y = m - w, f = y - 5, d = "right")) : o === "leftBottom" ? (m = t === "horizontal" ? c[1][0] : c[3][0], g = t === "horizontal" ? c[1][1] : c[2][1], t === "horizontal" ? (b = g + w, h = b + 5, d = "center") : (y = m - w, f = y - 5, d = "right")) : (m = (c[1][0] + c[2][0]) / 2, g = (c[1][1] + c[2][1]) / 2, t === "horizontal" ? (b = g + w, h = b + 5, d = "center") : (y = m + w, f = y + 5, d = "left")), t === "horizontal" ? (y = m, f = y) : (b = g, h = b), p = [[m, g], [y, b]] } l.label = { linePoints: p, x: f, y: h, verticalAlign: "middle", textAlign: d, inside: u } }) } function EZe(n, e) { n.eachSeriesByType("funnel", function (t) { var r = t.getData(), i = r.mapDimension("value"), a = t.get("sort"), o = kZe(t, e), s = t.get("orient"), l = o.width, c = o.height, u = CZe(r, a), d = o.x, f = o.y, h = s === "horizontal" ? [Ne(t.get("minSize"), c), Ne(t.get("maxSize"), c)] : [Ne(t.get("minSize"), l), Ne(t.get("maxSize"), l)], p = r.getDataExtent(i), m = t.get("min"), g = t.get("max"); m == null && (m = Math.min(p[0], 0)), g == null && (g = p[1]); var y = t.get("funnelAlign"), b = t.get("gap"), w = s === "horizontal" ? l : c, v = (w - b * (r.count() - 1)) / r.count(), S = function (L, R) { if (s === "horizontal") { var D = r.get(i, L) || 0, P = vn(D, [m, g], h, !0), B = void 0; switch (y) { case "top": B = f; break; case "center": B = f + (c - P) / 2; break; case "bottom": B = f + (c - P); break }return [[R, B], [R, B + P]] } var F = r.get(i, L) || 0, K = vn(F, [m, g], h, !0), V; switch (y) { case "left": V = d; break; case "center": V = d + (l - K) / 2; break; case "right": V = d + l - K; break }return [[V, R], [V + K, R]] }; a === "ascending" && (v = -v, b = -b, s === "horizontal" ? d += l : f += c, u = u.reverse()); for (var x = 0; x < u.length; x++) { var k = u[x], A = u[x + 1], C = r.getItemModel(k); if (s === "horizontal") { var E = C.get(["itemStyle", "width"]); E == null ? E = v : (E = Ne(E, l), a === "ascending" && (E = -E)); var O = S(k, d), j = S(A, d + E); d += E + b, r.setItemLayout(k, { points: O.concat(j.slice().reverse()) }) } else { var I = C.get(["itemStyle", "height"]); I == null ? I = v : (I = Ne(I, c), a === "ascending" && (I = -I)); var O = S(k, f), j = S(A, f + I); f += I + b, r.setItemLayout(k, { points: O.concat(j.slice().reverse()) }) } } AZe(r) }) } function MZe(n) { n.registerChartView(xZe), n.registerSeriesModel(TZe), n.registerLayout(EZe), n.registerProcessor(Ib("funnel")) } var OZe = .3, DZe = function (n) { te(e, n); function e() { var t = n !== null && n.apply(this, arguments) || this; return t.type = e.type, t._dataGroup = new ft, t._initialized = !1, t } return e.prototype.init = function () { this.group.add(this._dataGroup) }, e.prototype.render = function (t, r, i, a) { this._progressiveEls = null; var o = this._dataGroup, s = t.getData(), l = this._data, c = t.coordinateSystem, u = c.dimensions, d = Q7(t); s.diff(l).add(f).update(h).remove(p).execute(); function f(g) { var y = J7(s, o, g, u, c); UO(y, s, g, d) } function h(g, y) { var b = l.getItemGraphicEl(y), w = Bae(s, g, u, c); s.setItemGraphicEl(g, b), on(b, { shape: { points: w } }, t, g), Ms(b), UO(b, s, g, d) } function p(g) { var y = l.getItemGraphicEl(g); o.remove(y) } if (!this._initialized) { this._initialized = !0; var m = jZe(c, t, function () { setTimeout(function () { o.removeClipPath() }) }); o.setClipPath(m) } this._data = s }, e.prototype.incrementalPrepareRender = function (t, r, i) { this._initialized = !0, this._data = null, this._dataGroup.removeAll() }, e.prototype.incrementalRender = function (t, r, i) { for (var a = r.getData(), o = r.coordinateSystem, s = o.dimensions, l = Q7(r), c = this._progressiveEls = [], u = t.start; u < t.end; u++) { var d = J7(a, this._dataGroup, u, s, o); d.incremental = !0, UO(d, a, u, l), c.push(d) } }, e.prototype.remove = function () { this._dataGroup && this._dataGroup.removeAll(), this._data = null }, e.type = "parallel", e }(Nn); function jZe(n, e, t) { var r = n.model, i = n.getRect(), a = new Yt({ shape: { x: i.x, y: i.y, width: i.width, height: i.height } }), o = r.get("layout") === "horizontal" ? "width" : "height"; return a.setShape(o, 0), Un(a, { shape: { width: i.width, height: i.height } }, e, t), a } function Bae(n, e, t, r) { for (var i = [], a = 0; a < t.length; a++) { var o = t[a], s = n.get(n.mapDimension(o), e); PZe(s, r.getAxis(o).type) || i.push(r.dataToPoint(s, o)) } return i } function J7(n, e, t, r, i) { var a = Bae(n, t, r, i), o = new Ea({ shape: { points: a }, z2: 10 }); return e.add(o), n.setItemGraphicEl(t, o), o } function Q7(n) { var e = n.get("smooth", !0); return e === !0 && (e = OZe), e = jc(e), c_(e) && (e = 0), { smooth: e } } function UO(n, e, t, r) { n.useStyle(e.getItemVisual(t, "style")), n.style.fill = null, n.setShape("smooth", r.smooth); var i = e.getItemModel(t), a = i.getModel("emphasis"); pi(n, i, "lineStyle"), Qn(n, a.get("focus"), a.get("blurScope"), a.get("disabled")) } function PZe(n, e) { return e === "category" ? n == null : n == null || isNaN(n) } const IZe = DZe; var LZe = function (n) { te(e, n); function e() { var t = n !== null && n.apply(this, arguments) || this; return t.type = e.type, t.visualStyleAccessPath = "lineStyle", t.visualDrawType = "stroke", t } return e.prototype.getInitialData = function (t, r) { return Hc(null, this, { useEncodeDefaulter: He(RZe, null, this) }) }, e.prototype.getRawIndicesByActiveState = function (t) { var r = this.coordinateSystem, i = this.getData(), a = []; return r.eachActiveState(i, function (o, s) { t === o && a.push(i.getRawIndex(s)) }), a }, e.type = "series.parallel", e.dependencies = ["parallel"], e.defaultOption = { z: 2, coordinateSystem: "parallel", parallelIndex: 0, label: { show: !1 }, inactiveOpacity: .05, activeOpacity: 1, lineStyle: { width: 1, opacity: .45, type: "solid" }, emphasis: { label: { show: !1 } }, progressive: 500, smooth: !1, animationEasing: "linear" }, e }(Yn); function RZe(n) { var e = n.ecModel.getComponent("parallel", n.get("parallelIndex")); if (e) { var t = {}; return $(e.dimensions, function (r) { var i = NZe(r); t[r] = i }), t } } function NZe(n) { return +n.replace("dim", "") } const BZe = LZe; var $Ze = ["lineStyle", "opacity"], FZe = { seriesType: "parallel", reset: function (n, e) { var t = n.coordinateSystem, r = { normal: n.get(["lineStyle", "opacity"]), active: n.get("activeOpacity"), inactive: n.get("inactiveOpacity") }; return { progress: function (i, a) { t.eachActiveState(a, function (o, s) { var l = r[o]; if (o === "normal" && a.hasItemOption) { var c = a.getItemModel(s).get($Ze, !0); c != null && (l = c) } var u = a.ensureUniqueItemVisual(s, "style"); u.opacity = l }, i.start, i.end) } } } }; const zZe = FZe; function VZe(n) { HZe(n), UZe(n) } function HZe(n) { if (!n.parallel) { var e = !1; $(n.series, function (t) { t && t.type === "parallel" && (e = !0) }), e && (n.parallel = [{}]) } } function UZe(n) { var e = Cn(n.parallelAxis); $(e, function (t) { if (ot(t)) { var r = t.parallelIndex || 0, i = Cn(n.parallel)[r]; i && i.parallelAxisDefault && xt(t, i.parallelAxisDefault, !1) } }) } var GZe = 5, WZe = function (n) { te(e, n); function e() { var t = n !== null && n.apply(this, arguments) || this; return t.type = e.type, t } return e.prototype.render = function (t, r, i) { this._model = t, this._api = i, this._handlers || (this._handlers = {}, $(KZe, function (a, o) { i.getZr().on(o, this._handlers[o] = He(a, this)) }, this)), av(this, "_throttledDispatchExpand", t.get("axisExpandRate"), "fixRate") }, e.prototype.dispose = function (t, r) { S_(this, "_throttledDispatchExpand"), $(this._handlers, function (i, a) { r.getZr().off(a, i) }), this._handlers = null }, e.prototype._throttledDispatchExpand = function (t) { this._dispatchExpand(t) }, e.prototype._dispatchExpand = function (t) { t && this._api.dispatchAction(be({ type: "parallelAxisExpand" }, t)) }, e.type = "parallel", e }(nr), KZe = { mousedown: function (n) { GO(this, "click") && (this._mouseDownPoint = [n.offsetX, n.offsetY]) }, mouseup: function (n) { var e = this._mouseDownPoint; if (GO(this, "click") && e) { var t = [n.offsetX, n.offsetY], r = Math.pow(e[0] - t[0], 2) + Math.pow(e[1] - t[1], 2); if (r > GZe) return; var i = this._model.coordinateSystem.getSlidedAxisExpandWindow([n.offsetX, n.offsetY]); i.behavior !== "none" && this._dispatchExpand({ axisExpandWindow: i.axisExpandWindow }) } this._mouseDownPoint = null }, mousemove: function (n) { if (!(this._mouseDownPoint || !GO(this, "mousemove"))) { var e = this._model, t = e.coordinateSystem.getSlidedAxisExpandWindow([n.offsetX, n.offsetY]), r = t.behavior; r === "jump" && this._throttledDispatchExpand.debounceNextCall(e.get("axisExpandDebounce")), this._throttledDispatchExpand(r === "none" ? null : { axisExpandWindow: t.axisExpandWindow, animation: r === "jump" ? null : { duration: 0 } }) } } }; function GO(n, e) { var t = n._model; return t.get("axisExpandable") && t.get("axisExpandTriggerOn") === e } const qZe = WZe; var YZe = function (n) { te(e, n); function e() { var t = n !== null && n.apply(this, arguments) || this; return t.type = e.type, t } return e.prototype.init = function () { n.prototype.init.apply(this, arguments), this.mergeOption({}) }, e.prototype.mergeOption = function (t) { var r = this.option; t && xt(r, t, !0), this._initDimensions() }, e.prototype.contains = function (t, r) { var i = t.get("parallelIndex"); return i != null && r.getComponent("parallel", i) === this }, e.prototype.setAxisExpand = function (t) { $(["axisExpandable", "axisExpandCenter", "axisExpandCount", "axisExpandWidth", "axisExpandWindow"], function (r) { t.hasOwnProperty(r) && (this.option[r] = t[r]) }, this) }, e.prototype._initDimensions = function () { var t = this.dimensions = [], r = this.parallelAxisIndex = [], i = pn(this.ecModel.queryComponents({ mainType: "parallelAxis" }), function (a) { return (a.get("parallelIndex") || 0) === this.componentIndex }, this); $(i, function (a) { t.push("dim" + a.get("dim")), r.push(a.componentIndex) }) }, e.type = "parallel", e.dependencies = ["parallelAxis"], e.layoutMode = "box", e.defaultOption = { z: 0, left: 80, top: 60, right: 80, bottom: 60, layout: "horizontal", axisExpandable: !1, axisExpandCenter: null, axisExpandCount: 0, axisExpandWidth: 50, axisExpandRate: 17, axisExpandDebounce: 50, axisExpandSlideTriggerArea: [-.15, .05, .4], axisExpandTriggerOn: "click", parallelAxisDefault: null }, e }(Jt); const ZZe = YZe; var XZe = function (n) { te(e, n); function e(t, r, i, a, o) { var s = n.call(this, t, r, i) || this; return s.type = a || "value", s.axisIndex = o, s } return e.prototype.isHorizontal = function () { return this.coordinateSystem.getModel().get("layout") !== "horizontal" }, e }(Ps); const JZe = XZe; function dp(n, e, t, r, i, a) { n = n || 0; var o = t[1] - t[0]; if (i != null && (i = rm(i, [0, o])), a != null && (a = Math.max(a, i ?? 0)), r === "all") { var s = Math.abs(e[1] - e[0]); s = rm(s, [0, o]), i = a = rm(s, [i, a]), r = 0 } e[0] = rm(e[0], t), e[1] = rm(e[1], t); var l = WO(e, r); e[r] += n; var c = i || 0, u = t.slice(); l.sign < 0 ? u[0] += c : u[1] -= c, e[r] = rm(e[r], u); var d; return d = WO(e, r), i != null && (d.sign !== l.sign || d.span < i) && (e[1 - r] = e[r] + l.sign * i), d = WO(e, r), a != null && d.span > a && (e[1 - r] = e[r] + d.sign * a), e } function WO(n, e) { var t = n[e] - n[1 - e]; return { span: Math.abs(t), sign: t > 0 ? -1 : t < 0 ? 1 : e ? -1 : 1 } } function rm(n, e) { return Math.min(e[1] != null ? e[1] : 1 / 0, Math.max(e[0] != null ? e[0] : -1 / 0, n)) } var KO = $, $ae = Math.min, Fae = Math.max, eU = Math.floor, QZe = Math.ceil, tU = lr, eXe = Math.PI, tXe = function () { function n(e, t, r) { this.type = "parallel", this._axesMap = Ze(), this._axesLayout = {}, this.dimensions = e.dimensions, this._model = e, this._init(e, t, r) } return n.prototype._init = function (e, t, r) { var i = e.dimensions, a = e.parallelAxisIndex; KO(i, function (o, s) { var l = a[s], c = t.getComponent("parallelAxis", l), u = this._axesMap.set(o, new JZe(o, xC(c), [0, 0], c.get("type"), l)), d = u.type === "category"; u.onBand = d && c.get("boundaryGap"), u.inverse = c.get("inverse"), c.axis = u, u.model = c, u.coordinateSystem = c.coordinateSystem = this }, this) }, n.prototype.update = function (e, t) { this._updateAxesFromSeries(this._model, e) }, n.prototype.containPoint = function (e) { var t = this._makeLayoutInfo(), r = t.axisBase, i = t.layoutBase, a = t.pixelDimIndex, o = e[1 - a], s = e[a]; return o >= r && o <= r + t.axisLength && s >= i && s <= i + t.layoutLength }, n.prototype.getModel = function () { return this._model }, n.prototype._updateAxesFromSeries = function (e, t) { t.eachSeries(function (r) { if (e.contains(r, t)) { var i = r.getData(); KO(this.dimensions, function (a) { var o = this._axesMap.get(a); o.scale.unionExtentFromData(i, i.mapDimension(a)), Eg(o.scale, o.model) }, this) } }, this) }, n.prototype.resize = function (e, t) { this._rect = jr(e.getBoxLayoutParams(), { width: t.getWidth(), height: t.getHeight() }), this._layoutAxes() }, n.prototype.getRect = function () { return this._rect }, n.prototype._makeLayoutInfo = function () { var e = this._model, t = this._rect, r = ["x", "y"], i = ["width", "height"], a = e.get("layout"), o = a === "horizontal" ? 0 : 1, s = t[i[o]], l = [0, s], c = this.dimensions.length, u = px(e.get("axisExpandWidth"), l), d = px(e.get("axisExpandCount") || 0, [0, c]), f = e.get("axisExpandable") && c > 3 && c > d && d > 1 && u > 0 && s > 0, h = e.get("axisExpandWindow"), p; if (h) p = px(h[1] - h[0], l), h[1] = h[0] + p; else { p = px(u * (d - 1), l); var m = e.get("axisExpandCenter") || eU(c / 2); h = [u * m - p / 2], h[1] = h[0] + p } var g = (s - p) / (c - d); g < 3 && (g = 0); var y = [eU(tU(h[0] / u, 1)) + 1, QZe(tU(h[1] / u, 1)) - 1], b = g / u * h[0]; return { layout: a, pixelDimIndex: o, layoutBase: t[r[o]], layoutLength: s, axisBase: t[r[1 - o]], axisLength: t[i[1 - o]], axisExpandable: f, axisExpandWidth: u, axisCollapseWidth: g, axisExpandWindow: h, axisCount: c, winInnerIndices: y, axisExpandWindow0Pos: b } }, n.prototype._layoutAxes = function () { var e = this._rect, t = this._axesMap, r = this.dimensions, i = this._makeLayoutInfo(), a = i.layout; t.each(function (o) { var s = [0, i.axisLength], l = o.inverse ? 1 : 0; o.setExtent(s[l], s[1 - l]) }), KO(r, function (o, s) { var l = (i.axisExpandable ? rXe : nXe)(s, i), c = { horizontal: { x: l.position, y: i.axisLength }, vertical: { x: 0, y: l.position } }, u = { horizontal: eXe / 2, vertical: 0 }, d = [c[a].x + e.x, c[a].y + e.y], f = u[a], h = Va(); rp(h, h, f), Sl(h, h, d), this._axesLayout[o] = { position: d, rotation: f, transform: h, axisNameAvailableWidth: l.axisNameAvailableWidth, axisLabelShow: l.axisLabelShow, nameTruncateMaxWidth: l.nameTruncateMaxWidth, tickDirection: 1, labelDirection: 1 } }, this) }, n.prototype.getAxis = function (e) { return this._axesMap.get(e) }, n.prototype.dataToPoint = function (e, t) { return this.axisCoordToPoint(this._axesMap.get(t).dataToCoord(e), t) }, n.prototype.eachActiveState = function (e, t, r, i) { r == null && (r = 0), i == null && (i = e.count()); var a = this._axesMap, o = this.dimensions, s = [], l = []; $(o, function (g) { s.push(e.mapDimension(g)), l.push(a.get(g).model) }); for (var c = this.hasAxisBrushed(), u = r; u < i; u++) { var d = void 0; if (!c) d = "normal"; else { d = "active"; for (var f = e.getValues(s, u), h = 0, p = o.length; h < p; h++) { var m = l[h].getActiveState(f[h]); if (m === "inactive") { d = "inactive"; break } } } t(d, u) } }, n.prototype.hasAxisBrushed = function () { for (var e = this.dimensions, t = this._axesMap, r = !1, i = 0, a = e.length; i < a; i++)t.get(e[i]).model.getActiveState() !== "normal" && (r = !0); return r }, n.prototype.axisCoordToPoint = function (e, t) { var r = this._axesLayout[t]; return bs([e, 0], r.transform) }, n.prototype.getAxisLayout = function (e) { return lt(this._axesLayout[e]) }, n.prototype.getSlidedAxisExpandWindow = function (e) { var t = this._makeLayoutInfo(), r = t.pixelDimIndex, i = t.axisExpandWindow.slice(), a = i[1] - i[0], o = [0, t.axisExpandWidth * (t.axisCount - 1)]; if (!this.containPoint(e)) return { behavior: "none", axisExpandWindow: i }; var s = e[r] - t.layoutBase - t.axisExpandWindow0Pos, l, c = "slide", u = t.axisCollapseWidth, d = this._model.get("axisExpandSlideTriggerArea"), f = d[0] != null; if (u) f && u && s < a * d[0] ? (c = "jump", l = s - a * d[2]) : f && u && s > a * (1 - d[0]) ? (c = "jump", l = s - a * (1 - d[2])) : (l = s - a * d[1]) >= 0 && (l = s - a * (1 - d[1])) <= 0 && (l = 0), l *= t.axisExpandWidth / u, l ? dp(l, i, o, "all") : c = "none"; else { var h = i[1] - i[0], p = o[1] * s / h; i = [Fae(0, p - h / 2)], i[1] = $ae(o[1], i[0] + h), i[0] = i[1] - h } return { axisExpandWindow: i, behavior: c } }, n }(); function px(n, e) { return $ae(Fae(n, e[0]), e[1]) } function nXe(n, e) { var t = e.layoutLength / (e.axisCount - 1); return { position: t * n, axisNameAvailableWidth: t, axisLabelShow: !0 } } function rXe(n, e) { var t = e.layoutLength, r = e.axisExpandWidth, i = e.axisCount, a = e.axisCollapseWidth, o = e.winInnerIndices, s, l = a, c = !1, u; return n < o[0] ? (s = n * a, u = a) : n <= o[1] ? (s = e.axisExpandWindow0Pos + n * r - e.axisExpandWindow[0], l = r, c = !0) : (s = t - (i - 1 - n) * a, u = a), { position: s, axisNameAvailableWidth: l, axisLabelShow: c, nameTruncateMaxWidth: u } } const iXe = tXe; function aXe(n, e) { var t = []; return n.eachComponent("parallel", function (r, i) { var a = new iXe(r, n, e); a.name = "parallel_" + i, a.resize(r, e), r.coordinateSystem = a, a.model = r, t.push(a) }), n.eachSeries(function (r) { if (r.get("coordinateSystem") === "parallel") { var i = r.getReferringComponents("parallel", xr).models[0]; r.coordinateSystem = i.coordinateSystem } }), t } var oXe = { create: aXe }; const sXe = oXe; var zae = function (n) { te(e, n); function e() { var t = n !== null && n.apply(this, arguments) || this; return t.type = e.type, t.activeIntervals = [], t } return e.prototype.getAreaSelectStyle = function () { return Uh([["fill", "color"], ["lineWidth", "borderWidth"], ["stroke", "borderColor"], ["width", "width"], ["opacity", "opacity"]])(this.getModel("areaSelectStyle")) }, e.prototype.setActiveIntervals = function (t) { var r = this.activeIntervals = lt(t); if (r) for (var i = r.length - 1; i >= 0; i--)Oo(r[i]) }, e.prototype.getActiveState = function (t) { var r = this.activeIntervals; if (!r.length) return "normal"; if (t == null || isNaN(+t)) return "inactive"; if (r.length === 1) { var i = r[0]; if (i[0] <= t && t <= i[1]) return "active" } else for (var a = 0, o = r.length; a < o; a++)if (r[a][0] <= t && t <= r[a][1]) return "active"; return "inactive" }, e }(Jt); Cr(zae, Mb); const nU = zae; var Kh = !0, I_ = Math.min, Dg = Math.max, lXe = Math.pow, cXe = 1e4, uXe = 6, dXe = 6, rU = "globalPan", fXe = { w: [0, 0], e: [0, 1], n: [1, 0], s: [1, 1] }, hXe = { w: "ew", e: "ew", n: "ns", s: "ns", ne: "nesw", sw: "nesw", nw: "nwse", se: "nwse" }, iU = { brushStyle: { lineWidth: 2, stroke: "rgba(210,219,238,0.3)", fill: "#D2DBEE" }, transformable: !0, brushMode: "single", removeOnClick: !1 }, pXe = 0, mXe = function (n) { te(e, n); function e(t) { var r = n.call(this) || this; return r._track = [], r._covers = [], r._handlers = {}, r._zr = t, r.group = new ft, r._uid = "brushController_" + pXe++, $(xXe, function (i, a) { this._handlers[a] = He(i, this) }, r), r } return e.prototype.enableBrush = function (t) { return this._brushType && this._doDisableBrush(), t.brushType && this._doEnableBrush(t), this }, e.prototype._doEnableBrush = function (t) { var r = this._zr; this._enableGlobalPan || kKe(r, rU, this._uid), $(this._handlers, function (i, a) { r.on(a, i) }), this._brushType = t.brushType, this._brushOption = xt(lt(iU), t, !0) }, e.prototype._doDisableBrush = function () { var t = this._zr; CKe(t, rU, this._uid), $(this._handlers, function (r, i) { t.off(i, r) }), this._brushType = this._brushOption = null }, e.prototype.setPanels = function (t) { if (t && t.length) { var r = this._panels = {}; $(t, function (i) { r[i.panelId] = lt(i) }) } else this._panels = null; return this }, e.prototype.mount = function (t) { t = t || {}, this._enableGlobalPan = t.enableGlobalPan; var r = this.group; return this._zr.add(r), r.attr({ x: t.x || 0, y: t.y || 0, rotation: t.rotation || 0, scaleX: t.scaleX || 1, scaleY: t.scaleY || 1 }), this._transform = r.getLocalTransform(), this }, e.prototype.updateCovers = function (t) { t = Ae(t, function (f) { return xt(lt(iU), f, !0) }); var r = "\0-brush-index-", i = this._covers, a = this._covers = [], o = this, s = this._creatingCover; return new Lc(i, t, c, l).add(u).update(u).remove(d).execute(), this; function l(f, h) { return (f.id != null ? f.id : r + h) + "-" + f.brushType } function c(f, h) { return l(f.__brushOption, h) } function u(f, h) { var p = t[f]; if (h != null && i[h] === s) a[f] = i[h]; else { var m = a[f] = h != null ? (i[h].__brushOption = p, i[h]) : Hae(o, Vae(o, p)); K3(o, m) } } function d(f) { i[f] !== s && o.group.remove(i[f]) } }, e.prototype.unmount = function () { return this.enableBrush(!1), NI(this), this._zr.remove(this.group), this }, e.prototype.dispose = function () { this.unmount(), this.off() }, e }(Go); function Vae(n, e) { var t = EC[e.brushType].createCover(n, e); return t.__brushOption = e, Gae(t, e), n.group.add(t), t } function Hae(n, e) { var t = q3(e); return t.endCreating && (t.endCreating(n, e), Gae(e, e.__brushOption)), e } function Uae(n, e) { var t = e.__brushOption; q3(e).updateCoverShape(n, e, t.range, t) } function Gae(n, e) { var t = e.z; t == null && (t = cXe), n.traverse(function (r) { r.z = t, r.z2 = t }) } function K3(n, e) { q3(e).updateCommon(n, e), Uae(n, e) } function q3(n) { return EC[n.__brushOption.brushType] } function Y3(n, e, t) { var r = n._panels; if (!r) return Kh; var i, a = n._transform; return $(r, function (o) { o.isTargetByCursor(e, t, a) && (i = o) }), i } function Wae(n, e) { var t = n._panels; if (!t) return Kh; var r = e.__brushOption.panelId; return r != null ? t[r] : Kh } function NI(n) { var e = n._covers, t = e.length; return $(e, function (r) { n.group.remove(r) }, n), e.length = 0, !!t } function qh(n, e) { var t = Ae(n._covers, function (r) { var i = r.__brushOption, a = lt(i.range); return { brushType: i.brushType, panelId: i.panelId, range: a } }); n.trigger("brush", { areas: t, isEnd: !!e.isEnd, removeOnClick: !!e.removeOnClick }) } function gXe(n) { var e = n._track; if (!e.length) return !1; var t = e[e.length - 1], r = e[0], i = t[0] - r[0], a = t[1] - r[1], o = lXe(i * i + a * a, .5); return o > uXe } function Kae(n) { var e = n.length - 1; return e < 0 && (e = 0), [n[0], n[e]] } function qae(n, e, t, r) { var i = new ft; return i.add(new Yt({ name: "main", style: Z3(t), silent: !0, draggable: !0, cursor: "move", drift: wt(aU, n, e, i, ["n", "s", "w", "e"]), ondragend: wt(qh, e, { isEnd: !0 }) })), $(r, function (a) { i.add(new Yt({ name: a.join(""), style: { opacity: 0 }, draggable: !0, silent: !0, invisible: !0, drift: wt(aU, n, e, i, a), ondragend: wt(qh, e, { isEnd: !0 }) })) }), i } function Yae(n, e, t, r) { var i = r.brushStyle.lineWidth || 0, a = Dg(i, dXe), o = t[0][0], s = t[1][0], l = o - i / 2, c = s - i / 2, u = t[0][1], d = t[1][1], f = u - a + i / 2, h = d - a + i / 2, p = u - o, m = d - s, g = p + i, y = m + i; Jl(n, e, "main", o, s, p, m), r.transformable && (Jl(n, e, "w", l, c, a, y), Jl(n, e, "e", f, c, a, y), Jl(n, e, "n", l, c, g, a), Jl(n, e, "s", l, h, g, a), Jl(n, e, "nw", l, c, a, a), Jl(n, e, "ne", f, c, a, a), Jl(n, e, "sw", l, h, a, a), Jl(n, e, "se", f, h, a, a)) } function BI(n, e) { var t = e.__brushOption, r = t.transformable, i = e.childAt(0); i.useStyle(Z3(t)), i.attr({ silent: !r, cursor: r ? "move" : "default" }), $([["w"], ["e"], ["n"], ["s"], ["s", "e"], ["s", "w"], ["n", "e"], ["n", "w"]], function (a) { var o = e.childOfName(a.join("")), s = a.length === 1 ? $I(n, a[0]) : yXe(n, a); o && o.attr({ silent: !r, invisible: !r, cursor: r ? hXe[s] + "-resize" : null }) }) } function Jl(n, e, t, r, i, a, o) { var s = e.childOfName(t); s && s.setShape(bXe(X3(n, e, [[r, i], [r + a, i + o]]))) } function Z3(n) { return rt({ strokeNoScale: !0 }, n.brushStyle) } function Zae(n, e, t, r) { var i = [I_(n, t), I_(e, r)], a = [Dg(n, t), Dg(e, r)]; return [[i[0], a[0]], [i[1], a[1]]] } function vXe(n) { return kh(n.group) } function $I(n, e) { var t = { w: "left", e: "right", n: "top", s: "bottom" }, r = { left: "w", right: "e", top: "n", bottom: "s" }, i = oC(t[e], vXe(n)); return r[i] } function yXe(n, e) { var t = [$I(n, e[0]), $I(n, e[1])]; return (t[0] === "e" || t[0] === "w") && t.reverse(), t.join("") } function aU(n, e, t, r, i, a) { var o = t.__brushOption, s = n.toRectRange(o.range), l = Xae(e, i, a); $(r, function (c) { var u = fXe[c]; s[u[0]][u[1]] += l[u[0]] }), o.range = n.fromRectRange(Zae(s[0][0], s[1][0], s[0][1], s[1][1])), K3(e, t), qh(e, { isEnd: !1 }) } function _Xe(n, e, t, r) { var i = e.__brushOption.range, a = Xae(n, t, r); $(i, function (o) { o[0] += a[0], o[1] += a[1] }), K3(n, e), qh(n, { isEnd: !1 }) } function Xae(n, e, t) { var r = n.group, i = r.transformCoordToLocal(e, t), a = r.transformCoordToLocal(0, 0); return [i[0] - a[0], i[1] - a[1]] } function X3(n, e, t) { var r = Wae(n, e); return r && r !== Kh ? r.clipPath(t, n._transform) : lt(t) } function bXe(n) { var e = I_(n[0][0], n[1][0]), t = I_(n[0][1], n[1][1]), r = Dg(n[0][0], n[1][0]), i = Dg(n[0][1], n[1][1]); return { x: e, y: t, width: r - e, height: i - t } } function wXe(n, e, t) { if (!(!n._brushType || SXe(n, e.offsetX, e.offsetY))) { var r = n._zr, i = n._covers, a = Y3(n, e, t); if (!n._dragging) for (var o = 0; o < i.length; o++) { var s = i[o].__brushOption; if (a && (a === Kh || s.panelId === a.panelId) && EC[s.brushType].contain(i[o], t[0], t[1])) return } a && r.setCursorStyle("crosshair") } } function FI(n) { var e = n.event; e.preventDefault && e.preventDefault() } function zI(n, e, t) { return n.childOfName("main").contain(e, t) } function Jae(n, e, t, r) { var i = n._creatingCover, a = n._creatingPanel, o = n._brushOption, s; if (n._track.push(t.slice()), gXe(n) || i) { if (a && !i) { o.brushMode === "single" && NI(n); var l = lt(o); l.brushType = oU(l.brushType, a), l.panelId = a === Kh ? null : a.panelId, i = n._creatingCover = Vae(n, l), n._covers.push(i) } if (i) { var c = EC[oU(n._brushType, a)], u = i.__brushOption; u.range = c.getCreatingRange(X3(n, i, n._track)), r && (Hae(n, i), c.updateCommon(n, i)), Uae(n, i), s = { isEnd: r } } } else r && o.brushMode === "single" && o.removeOnClick && Y3(n, e, t) && NI(n) && (s = { isEnd: r, removeOnClick: !0 }); return s } function oU(n, e) { return n === "auto" ? e.defaultBrushType : n } var xXe = { mousedown: function (n) { if (this._dragging) sU(this, n); else if (!n.target || !n.target.draggable) { FI(n); var e = this.group.transformCoordToLocal(n.offsetX, n.offsetY); this._creatingCover = null; var t = this._creatingPanel = Y3(this, n, e); t && (this._dragging = !0, this._track = [e.slice()]) } }, mousemove: function (n) { var e = n.offsetX, t = n.offsetY, r = this.group.transformCoordToLocal(e, t); if (wXe(this, n, r), this._dragging) { FI(n); var i = Jae(this, n, r, !1); i && qh(this, i) } }, mouseup: function (n) { sU(this, n) } }; function sU(n, e) { if (n._dragging) { FI(e); var t = e.offsetX, r = e.offsetY, i = n.group.transformCoordToLocal(t, r), a = Jae(n, e, i, !0); n._dragging = !1, n._track = [], n._creatingCover = null, a && qh(n, a) } } function SXe(n, e, t) { var r = n._zr; return e < 0 || e > r.getWidth() || t < 0 || t > r.getHeight() } var EC = { lineX: lU(0), lineY: lU(1), rect: { createCover: function (n, e) { function t(r) { return r } return qae({ toRectRange: t, fromRectRange: t }, n, e, [["w"], ["e"], ["n"], ["s"], ["s", "e"], ["s", "w"], ["n", "e"], ["n", "w"]]) }, getCreatingRange: function (n) { var e = Kae(n); return Zae(e[1][0], e[1][1], e[0][0], e[0][1]) }, updateCoverShape: function (n, e, t, r) { Yae(n, e, t, r) }, updateCommon: BI, contain: zI }, polygon: { createCover: function (n, e) { var t = new ft; return t.add(new Ea({ name: "main", style: Z3(e), silent: !0 })), t }, getCreatingRange: function (n) { return n }, endCreating: function (n, e) { e.remove(e.childAt(0)), e.add(new Aa({ name: "main", draggable: !0, drift: wt(_Xe, n, e), ondragend: wt(qh, n, { isEnd: !0 }) })) }, updateCoverShape: function (n, e, t, r) { e.childAt(0).setShape({ points: X3(n, e, t) }) }, updateCommon: BI, contain: zI } }; function lU(n) { return { createCover: function (e, t) { return qae({ toRectRange: function (r) { var i = [r, [0, 100]]; return n && i.reverse(), i }, fromRectRange: function (r) { return r[n] } }, e, t, [[["w"], ["e"]], [["n"], ["s"]]][n]) }, getCreatingRange: function (e) { var t = Kae(e), r = I_(t[0][n], t[1][n]), i = Dg(t[0][n], t[1][n]); return [r, i] }, updateCoverShape: function (e, t, r, i) { var a, o = Wae(e, t); if (o !== Kh && o.getLinearBrushOtherExtent) a = o.getLinearBrushOtherExtent(n); else { var s = e._zr; a = [0, [s.getWidth(), s.getHeight()][1 - n]] } var l = [r, a]; n && l.reverse(), Yae(e, t, l, i) }, updateCommon: BI, contain: zI } } const J3 = mXe; function Qae(n) { return n = Q3(n), function (e) { return ene(e, n) } } function eoe(n, e) { return n = Q3(n), function (t) { var r = e ?? t, i = r ? n.width : n.height, a = r ? n.x : n.y; return [a, a + (i || 0)] } } function toe(n, e, t) { var r = Q3(n); return function (i, a) { return r.contain(a[0], a[1]) && !TC(i, e, t) } } function Q3(n) { return kt.create(n) } var TXe = ["axisLine", "axisTickLabel", "axisName"], kXe = function (n) { te(e, n); function e() { var t = n !== null && n.apply(this, arguments) || this; return t.type = e.type, t } return e.prototype.init = function (t, r) { n.prototype.init.apply(this, arguments), (this._brushController = new J3(r.getZr())).on("brush", He(this._onBrush, this)) }, e.prototype.render = function (t, r, i, a) { if (!CXe(t, r, a)) { this.axisModel = t, this.api = i, this.group.removeAll(); var o = this._axisGroup; if (this._axisGroup = new ft, this.group.add(this._axisGroup), !!t.get("show")) { var s = EXe(t, r), l = s.coordinateSystem, c = t.getAreaSelectStyle(), u = c.width, d = t.axis.dim, f = l.getAxisLayout(d), h = be({ strokeContainThreshold: u }, f), p = new Rc(t, h); $(TXe, p.add, p), this._axisGroup.add(p.getGroup()), this._refreshBrushController(h, c, t, s, u, i), Tb(o, this._axisGroup, t) } } }, e.prototype._refreshBrushController = function (t, r, i, a, o, s) { var l = i.axis.getExtent(), c = l[1] - l[0], u = Math.min(30, Math.abs(c) * .1), d = kt.create({ x: l[0], y: -o / 2, width: c, height: o }); d.x -= u, d.width += 2 * u, this._brushController.mount({ enableGlobalPan: !0, rotation: t.rotation, x: t.position[0], y: t.position[1] }).setPanels([{ panelId: "pl", clipPath: Qae(d), isTargetByCursor: toe(d, s, a), getLinearBrushOtherExtent: eoe(d, 0) }]).enableBrush({ brushType: "lineX", brushStyle: r, removeOnClick: !0 }).updateCovers(AXe(i)) }, e.prototype._onBrush = function (t) { var r = t.areas, i = this.axisModel, a = i.axis, o = Ae(r, function (s) { return [a.coordToData(s.range[0], !0), a.coordToData(s.range[1], !0)] }); (!i.option.realtime === t.isEnd || t.removeOnClick) && this.api.dispatchAction({ type: "axisAreaSelect", parallelAxisId: i.id, intervals: o }) }, e.prototype.dispose = function () { this._brushController.dispose() }, e.type = "parallelAxis", e }(nr); function CXe(n, e, t) { return t && t.type === "axisAreaSelect" && e.findComponents({ mainType: "parallelAxis", query: t })[0] === n } function AXe(n) { var e = n.axis; return Ae(n.activeIntervals, function (t) { return { brushType: "lineX", panelId: "pl", range: [e.dataToCoord(t[0], !0), e.dataToCoord(t[1], !0)] } }) } function EXe(n, e) { return e.getComponent("parallel", n.get("parallelIndex")) } const MXe = kXe; var OXe = { type: "axisAreaSelect", event: "axisAreaSelected" }; function DXe(n) { n.registerAction(OXe, function (e, t) { t.eachComponent({ mainType: "parallelAxis", query: e }, function (r) { r.axis.model.setActiveIntervals(e.intervals) }) }), n.registerAction("parallelAxisExpand", function (e, t) { t.eachComponent({ mainType: "parallel", query: e }, function (r) { r.setAxisExpand(e) }) }) } var jXe = { type: "value", areaSelectStyle: { width: 20, borderWidth: 1, borderColor: "rgba(160,197,232)", color: "rgba(160,197,232)", opacity: .3 }, realtime: !0, z: 10 }; function noe(n) { n.registerComponentView(qZe), n.registerComponentModel(ZZe), n.registerCoordinateSystem("parallel", sXe), n.registerPreprocessor(VZe), n.registerComponentModel(nU), n.registerComponentView(MXe), Og(n, "parallel", nU, jXe), DXe(n) } function PXe(n) { It(noe), n.registerChartView(IZe), n.registerSeriesModel(BZe), n.registerVisual(n.PRIORITY.VISUAL.BRUSH, zZe) } var IXe = function () { function n() { this.x1 = 0, this.y1 = 0, this.x2 = 0, this.y2 = 0, this.cpx1 = 0, this.cpy1 = 0, this.cpx2 = 0, this.cpy2 = 0, this.extent = 0 } return n }(), LXe = function (n) { te(e, n); function e(t) { return n.call(this, t) || this } return e.prototype.getDefaultShape = function () { return new IXe }, e.prototype.buildPath = function (t, r) { var i = r.extent; t.moveTo(r.x1, r.y1), t.bezierCurveTo(r.cpx1, r.cpy1, r.cpx2, r.cpy2, r.x2, r.y2), r.orient === "vertical" ? (t.lineTo(r.x2 + i, r.y2), t.bezierCurveTo(r.cpx2 + i, r.cpy2, r.cpx1 + i, r.cpy1, r.x1 + i, r.y1)) : (t.lineTo(r.x2, r.y2 + i), t.bezierCurveTo(r.cpx2, r.cpy2 + i, r.cpx1, r.cpy1 + i, r.x1, r.y1 + i)), t.closePath() }, e.prototype.highlight = function () { Pc(this) }, e.prototype.downplay = function () { Ic(this) }, e }(Nt), RXe = function (n) { te(e, n); function e() { var t = n !== null && n.apply(this, arguments) || this; return t.type = e.type, t._focusAdjacencyDisabled = !1, t } return e.prototype.render = function (t, r, i) { var a = this, o = t.getGraph(), s = this.group, l = t.layoutInfo, c = l.width, u = l.height, d = t.getData(), f = t.getData("edge"), h = t.get("orient"); this._model = t, s.removeAll(), s.x = l.x, s.y = l.y, o.eachEdge(function (p) { var m = new LXe, g = pt(m); g.dataIndex = p.dataIndex, g.seriesIndex = t.seriesIndex, g.dataType = "edge"; var y = p.getModel(), b = y.getModel("lineStyle"), w = b.get("curveness"), v = p.node1.getLayout(), S = p.node1.getModel(), x = S.get("localX"), k = S.get("localY"), A = p.node2.getLayout(), C = p.node2.getModel(), E = C.get("localX"), O = C.get("localY"), j = p.getLayout(), I, L, R, D, P, B, F, K; m.shape.extent = Math.max(1, j.dy), m.shape.orient = h, h === "vertical" ? (I = (x != null ? x * c : v.x) + j.sy, L = (k != null ? k * u : v.y) + v.dy, R = (E != null ? E * c : A.x) + j.ty, D = O != null ? O * u : A.y, P = I, B = L * (1 - w) + D * w, F = R, K = L * w + D * (1 - w)) : (I = (x != null ? x * c : v.x) + v.dx, L = (k != null ? k * u : v.y) + j.sy, R = E != null ? E * c : A.x, D = (O != null ? O * u : A.y) + j.ty, P = I * (1 - w) + R * w, B = L, F = I * w + R * (1 - w), K = D), m.setShape({ x1: I, y1: L, x2: R, y2: D, cpx1: P, cpy1: B, cpx2: F, cpy2: K }), m.useStyle(b.getItemStyle()), cU(m.style, h, p); var V = "" + y.get("value"), W = Ur(y, "edgeLabel"); mi(m, W, { labelFetcher: { getFormattedLabel: function (le, De, ae, pe, se, ge) { return t.getFormattedLabel(le, De, "edge", pe, pl(se, W.normal && W.normal.get("formatter"), V), ge) } }, labelDataIndex: p.dataIndex, defaultText: V }), m.setTextConfig({ position: "inside" }); var J = y.getModel("emphasis"); pi(m, y, "lineStyle", function (le) { var De = le.getItemStyle(); return cU(De, h, p), De }), s.add(m), f.setItemGraphicEl(p.dataIndex, m); var ie = J.get("focus"); Qn(m, ie === "adjacency" ? p.getAdjacentDataIndices() : ie === "trajectory" ? p.getTrajectoryDataIndices() : ie, J.get("blurScope"), J.get("disabled")) }), o.eachNode(function (p) { var m = p.getLayout(), g = p.getModel(), y = g.get("localX"), b = g.get("localY"), w = g.getModel("emphasis"), v = g.get(["itemStyle", "borderRadius"]) || 0, S = new Yt({ shape: { x: y != null ? y * c : m.x, y: b != null ? b * u : m.y, width: m.dx, height: m.dy, r: v }, style: g.getModel("itemStyle").getItemStyle(), z2: 10 }); mi(S, Ur(g), { labelFetcher: { getFormattedLabel: function (k, A) { return t.getFormattedLabel(k, A, "node") } }, labelDataIndex: p.dataIndex, defaultText: p.id }), S.disableLabelAnimation = !0, S.setStyle("fill", p.getVisual("color")), S.setStyle("decal", p.getVisual("style").decal), pi(S, g), s.add(S), d.setItemGraphicEl(p.dataIndex, S), pt(S).dataType = "node"; var x = w.get("focus"); Qn(S, x === "adjacency" ? p.getAdjacentDataIndices() : x === "trajectory" ? p.getTrajectoryDataIndices() : x, w.get("blurScope"), w.get("disabled")) }), d.eachItemGraphicEl(function (p, m) { var g = d.getItemModel(m); g.get("draggable") && (p.drift = function (y, b) { a._focusAdjacencyDisabled = !0, this.shape.x += y, this.shape.y += b, this.dirty(), i.dispatchAction({ type: "dragNode", seriesId: t.id, dataIndex: d.getRawIndex(m), localX: this.shape.x / c, localY: this.shape.y / u }) }, p.ondragend = function () { a._focusAdjacencyDisabled = !1 }, p.draggable = !0, p.cursor = "move") }), !this._data && t.isAnimationEnabled() && s.setClipPath(NXe(s.getBoundingRect(), t, function () { s.removeClipPath() })), this._data = t.getData() }, e.prototype.dispose = function () { }, e.type = "sankey", e }(Nn); function cU(n, e, t) { switch (n.fill) { case "source": n.fill = t.node1.getVisual("color"), n.decal = t.node1.getVisual("style").decal; break; case "target": n.fill = t.node2.getVisual("color"), n.decal = t.node2.getVisual("style").decal; break; case "gradient": var r = t.node1.getVisual("color"), i = t.node2.getVisual("color"); Fe(r) && Fe(i) && (n.fill = new Sb(0, 0, +(e === "horizontal"), +(e === "vertical"), [{ color: r, offset: 0 }, { color: i, offset: 1 }])) } } function NXe(n, e, t) { var r = new Yt({ shape: { x: n.x - 10, y: n.y - 10, width: 0, height: n.height + 20 } }); return Un(r, { shape: { width: n.width + 20 } }, e, t), r } const BXe = RXe; var $Xe = function (n) { te(e, n); function e() { var t = n !== null && n.apply(this, arguments) || this; return t.type = e.type, t } return e.prototype.getInitialData = function (t, r) { var i = t.edges || t.links || [], a = t.data || t.nodes || [], o = t.levels || []; this.levelModels = []; for (var s = this.levelModels, l = 0; l < o.length; l++)o[l].depth != null && o[l].depth >= 0 && (s[o[l].depth] = new Rn(o[l], this, r)); var c = Nae(a, i, this, !0, u); return c.data; function u(d, f) { d.wrapMethod("getItemModel", function (h, p) { var m = h.parentModel, g = m.getData().getItemLayout(p); if (g) { var y = g.depth, b = m.levelModels[y]; b && (h.parentModel = b) } return h }), f.wrapMethod("getItemModel", function (h, p) { var m = h.parentModel, g = m.getGraph().getEdgeByIndex(p), y = g.node1.getLayout(); if (y) { var b = y.depth, w = m.levelModels[b]; w && (h.parentModel = w) } return h }) } }, e.prototype.setNodePosition = function (t, r) { var i = this.option.data || this.option.nodes, a = i[t]; a.localX = r[0], a.localY = r[1] }, e.prototype.getGraph = function () { return this.getData().graph }, e.prototype.getEdgeData = function () { return this.getGraph().edgeData }, e.prototype.formatTooltip = function (t, r, i) { function a(h) { return isNaN(h) || h == null } if (i === "edge") { var o = this.getDataParams(t, i), s = o.data, l = o.value, c = s.source + " -- " + s.target; return Gr("nameValue", { name: c, value: l, noValue: a(l) }) } else { var u = this.getGraph().getNodeByIndex(t), d = u.getLayout().value, f = this.getDataParams(t, i).data.name; return Gr("nameValue", { name: f != null ? f + "" : null, value: d, noValue: a(d) }) } }, e.prototype.optionUpdated = function () { }, e.prototype.getDataParams = function (t, r) { var i = n.prototype.getDataParams.call(this, t, r); if (i.value == null && r === "node") { var a = this.getGraph().getNodeByIndex(t), o = a.getLayout().value; i.value = o } return i }, e.type = "series.sankey", e.defaultOption = { z: 2, coordinateSystem: "view", left: "5%", top: "5%", right: "20%", bottom: "5%", orient: "horizontal", nodeWidth: 20, nodeGap: 8, draggable: !0, layoutIterations: 32, label: { show: !0, position: "right", fontSize: 12 }, edgeLabel: { show: !1, fontSize: 12 }, levels: [], nodeAlign: "justify", lineStyle: { color: "#314656", opacity: .2, curveness: .5 }, emphasis: { label: { show: !0 }, lineStyle: { opacity: .5 } }, select: { itemStyle: { borderColor: "#212121" } }, animationEasing: "linear", animationDuration: 1e3 }, e }(Yn); const FXe = $Xe; function zXe(n, e) { n.eachSeriesByType("sankey", function (t) { var r = t.get("nodeWidth"), i = t.get("nodeGap"), a = VXe(t, e); t.layoutInfo = a; var o = a.width, s = a.height, l = t.getGraph(), c = l.nodes, u = l.edges; UXe(c); var d = pn(c, function (m) { return m.getLayout().value === 0 }), f = d.length !== 0 ? 0 : t.get("layoutIterations"), h = t.get("orient"), p = t.get("nodeAlign"); HXe(c, u, r, i, o, s, f, h, p) }) } function VXe(n, e) { return jr(n.getBoxLayoutParams(), { width: e.getWidth(), height: e.getHeight() }) } function HXe(n, e, t, r, i, a, o, s, l) { GXe(n, e, t, i, a, s, l), YXe(n, e, a, i, r, o, s), iJe(n, s) } function UXe(n) { $(n, function (e) { var t = cd(e.outEdges, ST), r = cd(e.inEdges, ST), i = e.getValue() || 0, a = Math.max(t, r, i); e.setLayout({ value: a }, !0) }) } function GXe(n, e, t, r, i, a, o) { for (var s = [], l = [], c = [], u = [], d = 0, f = 0; f < e.length; f++)s[f] = 1; for (var f = 0; f < n.length; f++)l[f] = n[f].inEdges.length, l[f] === 0 && c.push(n[f]); for (var h = -1; c.length;) { for (var p = 0; p < c.length; p++) { var m = c[p], g = m.hostGraph.data.getRawDataItem(m.dataIndex), y = g.depth != null && g.depth >= 0; y && g.depth > h && (h = g.depth), m.setLayout({ depth: y ? g.depth : d }, !0), a === "vertical" ? m.setLayout({ dy: t }, !0) : m.setLayout({ dx: t }, !0); for (var b = 0; b < m.outEdges.length; b++) { var w = m.outEdges[b], v = e.indexOf(w); s[v] = 0; var S = w.node2, x = n.indexOf(S); --l[x] === 0 && u.indexOf(S) < 0 && u.push(S) } } ++d, c = u, u = [] } for (var f = 0; f < s.length; f++)if (s[f] === 1) throw new Error("Sankey is a DAG, the original data has cycle!"); var k = h > d - 1 ? h : d - 1; o && o !== "left" && WXe(n, o, a, k); var A = a === "vertical" ? (i - t) / k : (r - t) / k; qXe(n, A, a) } function roe(n) { var e = n.hostGraph.data.getRawDataItem(n.dataIndex); return e.depth != null && e.depth >= 0 } function WXe(n, e, t, r) { if (e === "right") { for (var i = [], a = n, o = 0; a.length;) { for (var s = 0; s < a.length; s++) { var l = a[s]; l.setLayout({ skNodeHeight: o }, !0); for (var c = 0; c < l.inEdges.length; c++) { var u = l.inEdges[c]; i.indexOf(u.node1) < 0 && i.push(u.node1) } } a = i, i = [], ++o } $(n, function (d) { roe(d) || d.setLayout({ depth: Math.max(0, r - d.getLayout().skNodeHeight) }, !0) }) } else e === "justify" && KXe(n, r) } function KXe(n, e) { $(n, function (t) { !roe(t) && !t.outEdges.length && t.setLayout({ depth: e }, !0) }) } function qXe(n, e, t) { $(n, function (r) { var i = r.getLayout().depth * e; t === "vertical" ? r.setLayout({ y: i }, !0) : r.setLayout({ x: i }, !0) }) } function YXe(n, e, t, r, i, a, o) { var s = ZXe(n, o); XXe(s, e, t, r, i, o), qO(s, i, t, r, o); for (var l = 1; a > 0; a--)l *= .99, JXe(s, l, o), qO(s, i, t, r, o), rJe(s, l, o), qO(s, i, t, r, o) } function ZXe(n, e) { var t = [], r = e === "vertical" ? "y" : "x", i = UP(n, function (a) { return a.getLayout()[r] }); return i.keys.sort(function (a, o) { return a - o }), $(i.keys, function (a) { t.push(i.buckets.get(a)) }), t } function XXe(n, e, t, r, i, a) { var o = 1 / 0; $(n, function (s) { var l = s.length, c = 0; $(s, function (d) { c += d.getLayout().value }); var u = a === "vertical" ? (r - (l - 1) * i) / c : (t - (l - 1) * i) / c; u < o && (o = u) }), $(n, function (s) { $(s, function (l, c) { var u = l.getLayout().value * o; a === "vertical" ? (l.setLayout({ x: c }, !0), l.setLayout({ dx: u }, !0)) : (l.setLayout({ y: c }, !0), l.setLayout({ dy: u }, !0)) }) }), $(e, function (s) { var l = +s.getValue() * o; s.setLayout({ dy: l }, !0) }) } function qO(n, e, t, r, i) { var a = i === "vertical" ? "x" : "y"; $(n, function (o) { o.sort(function (m, g) { return m.getLayout()[a] - g.getLayout()[a] }); for (var s, l, c, u = 0, d = o.length, f = i === "vertical" ? "dx" : "dy", h = 0; h < d; h++)l = o[h], c = u - l.getLayout()[a], c > 0 && (s = l.getLayout()[a] + c, i === "vertical" ? l.setLayout({ x: s }, !0) : l.setLayout({ y: s }, !0)), u = l.getLayout()[a] + l.getLayout()[f] + e; var p = i === "vertical" ? r : t; if (c = u - e - p, c > 0) { s = l.getLayout()[a] - c, i === "vertical" ? l.setLayout({ x: s }, !0) : l.setLayout({ y: s }, !0), u = s; for (var h = d - 2; h >= 0; --h)l = o[h], c = l.getLayout()[a] + l.getLayout()[f] + e - u, c > 0 && (s = l.getLayout()[a] - c, i === "vertical" ? l.setLayout({ x: s }, !0) : l.setLayout({ y: s }, !0)), u = l.getLayout()[a] } }) } function JXe(n, e, t) { $(n.slice().reverse(), function (r) { $(r, function (i) { if (i.outEdges.length) { var a = cd(i.outEdges, QXe, t) / cd(i.outEdges, ST); if (isNaN(a)) { var o = i.outEdges.length; a = o ? cd(i.outEdges, eJe, t) / o : 0 } if (t === "vertical") { var s = i.getLayout().x + (a - Dd(i, t)) * e; i.setLayout({ x: s }, !0) } else { var l = i.getLayout().y + (a - Dd(i, t)) * e; i.setLayout({ y: l }, !0) } } }) }) } function QXe(n, e) { return Dd(n.node2, e) * n.getValue() } function eJe(n, e) { return Dd(n.node2, e) } function tJe(n, e) { return Dd(n.node1, e) * n.getValue() } function nJe(n, e) { return Dd(n.node1, e) } function Dd(n, e) { return e === "vertical" ? n.getLayout().x + n.getLayout().dx / 2 : n.getLayout().y + n.getLayout().dy / 2 } function ST(n) { return n.getValue() } function cd(n, e, t) { for (var r = 0, i = n.length, a = -1; ++a < i;) { var o = +e(n[a], t); isNaN(o) || (r += o) } return r } function rJe(n, e, t) { $(n, function (r) { $(r, function (i) { if (i.inEdges.length) { var a = cd(i.inEdges, tJe, t) / cd(i.inEdges, ST); if (isNaN(a)) { var o = i.inEdges.length; a = o ? cd(i.inEdges, nJe, t) / o : 0 } if (t === "vertical") { var s = i.getLayout().x + (a - Dd(i, t)) * e; i.setLayout({ x: s }, !0) } else { var l = i.getLayout().y + (a - Dd(i, t)) * e; i.setLayout({ y: l }, !0) } } }) }) } function iJe(n, e) { var t = e === "vertical" ? "x" : "y"; $(n, function (r) { r.outEdges.sort(function (i, a) { return i.node2.getLayout()[t] - a.node2.getLayout()[t] }), r.inEdges.sort(function (i, a) { return i.node1.getLayout()[t] - a.node1.getLayout()[t] }) }), $(n, function (r) { var i = 0, a = 0; $(r.outEdges, function (o) { o.setLayout({ sy: i }, !0), i += o.getLayout().dy }), $(r.inEdges, function (o) { o.setLayout({ ty: a }, !0), a += o.getLayout().dy }) }) } function aJe(n) { n.eachSeriesByType("sankey", function (e) { var t = e.getGraph(), r = t.nodes, i = t.edges; if (r.length) { var a = 1 / 0, o = -1 / 0; $(r, function (s) { var l = s.getLayout().value; l < a && (a = l), l > o && (o = l) }), $(r, function (s) { var l = new hi({ type: "color", mappingMethod: "linear", dataExtent: [a, o], visual: e.get("color") }), c = l.mapValueToVisual(s.getLayout().value), u = s.getModel().get(["itemStyle", "color"]); u != null ? (s.setVisual("color", u), s.setVisual("style", { fill: u })) : (s.setVisual("color", c), s.setVisual("style", { fill: c })) }) } i.length && $(i, function (s) { var l = s.getModel().get("lineStyle"); s.setVisual("style", l) }) }) } function oJe(n) { n.registerChartView(BXe), n.registerSeriesModel(FXe), n.registerLayout(zXe), n.registerVisual(aJe), n.registerAction({ type: "dragNode", event: "dragnode", update: "update" }, function (e, t) { t.eachComponent({ mainType: "series", subType: "sankey", query: e }, function (r) { r.setNodePosition(e.dataIndex, [e.localX, e.localY]) }) }) } var ioe = function () { function n() { } return n.prototype._hasEncodeRule = function (e) { var t = this.getEncode(); return t && t.get(e) != null }, n.prototype.getInitialData = function (e, t) { var r, i = t.getComponent("xAxis", this.get("xAxisIndex")), a = t.getComponent("yAxis", this.get("yAxisIndex")), o = i.get("type"), s = a.get("type"), l; o === "category" ? (e.layout = "horizontal", r = i.getOrdinalMeta(), l = !this._hasEncodeRule("x")) : s === "category" ? (e.layout = "vertical", r = a.getOrdinalMeta(), l = !this._hasEncodeRule("y")) : e.layout = e.layout || "horizontal"; var c = ["x", "y"], u = e.layout === "horizontal" ? 0 : 1, d = this._baseAxisDim = c[u], f = c[1 - u], h = [i, a], p = h[u].get("type"), m = h[1 - u].get("type"), g = e.data; if (g && l) { var y = []; $(g, function (v, S) { var x; ke(v) ? (x = v.slice(), v.unshift(S)) : ke(v.value) ? (x = be({}, v), x.value = x.value.slice(), v.value.unshift(S)) : x = v, y.push(x) }), e.data = y } var b = this.defaultValueDimensions, w = [{ name: d, type: dT(p), ordinalMeta: r, otherDims: { tooltip: !1, itemName: 0 }, dimsDef: ["base"] }, { name: f, type: dT(m), dimsDef: b.slice() }]; return lv(this, { coordDimensions: w, dimensionsCount: b.length + 1, encodeDefaulter: wt(Cne, w, this) }) }, n.prototype.getBaseAxis = function () { var e = this._baseAxisDim; return this.ecModel.getComponent(e + "Axis", this.get(e + "AxisIndex")).axis }, n }(), aoe = function (n) { te(e, n); function e() { var t = n !== null && n.apply(this, arguments) || this; return t.type = e.type, t.defaultValueDimensions = [{ name: "min", defaultTooltip: !0 }, { name: "Q1", defaultTooltip: !0 }, { name: "median", defaultTooltip: !0 }, { name: "Q3", defaultTooltip: !0 }, { name: "max", defaultTooltip: !0 }], t.visualDrawType = "stroke", t } return e.type = "series.boxplot", e.dependencies = ["xAxis", "yAxis", "grid"], e.defaultOption = { z: 2, coordinateSystem: "cartesian2d", legendHoverLink: !0, layout: null, boxWidth: [7, 50], itemStyle: { color: "#fff", borderWidth: 1 }, emphasis: { scale: !0, itemStyle: { borderWidth: 2, shadowBlur: 5, shadowOffsetX: 1, shadowOffsetY: 1, shadowColor: "rgba(0,0,0,0.2)" } }, animationDuration: 800 }, e }(Yn); Cr(aoe, ioe, !0); const sJe = aoe; var lJe = function (n) { te(e, n); function e() { var t = n !== null && n.apply(this, arguments) || this; return t.type = e.type, t } return e.prototype.render = function (t, r, i) { var a = t.getData(), o = this.group, s = this._data; this._data || o.removeAll(); var l = t.get("layout") === "horizontal" ? 1 : 0; a.diff(s).add(function (c) { if (a.hasValue(c)) { var u = a.getItemLayout(c), d = uU(u, a, c, l, !0); a.setItemGraphicEl(c, d), o.add(d) } }).update(function (c, u) { var d = s.getItemGraphicEl(u); if (!a.hasValue(c)) { o.remove(d); return } var f = a.getItemLayout(c); d ? (Ms(d), ooe(f, d, a, c)) : d = uU(f, a, c, l), o.add(d), a.setItemGraphicEl(c, d) }).remove(function (c) { var u = s.getItemGraphicEl(c); u && o.remove(u) }).execute(), this._data = a }, e.prototype.remove = function (t) { var r = this.group, i = this._data; this._data = null, i && i.eachItemGraphicEl(function (a) { a && r.remove(a) }) }, e.type = "boxplot", e }(Nn), cJe = function () { function n() { } return n }(), uJe = function (n) { te(e, n); function e(t) { var r = n.call(this, t) || this; return r.type = "boxplotBoxPath", r } return e.prototype.getDefaultShape = function () { return new cJe }, e.prototype.buildPath = function (t, r) { var i = r.points, a = 0; for (t.moveTo(i[a][0], i[a][1]), a++; a < 4; a++)t.lineTo(i[a][0], i[a][1]); for (t.closePath(); a < i.length; a++)t.moveTo(i[a][0], i[a][1]), a++, t.lineTo(i[a][0], i[a][1]) }, e }(Nt); function uU(n, e, t, r, i) { var a = n.ends, o = new uJe({ shape: { points: i ? dJe(a, r, n) : a } }); return ooe(n, o, e, t, i), o } function ooe(n, e, t, r, i) { var a = t.hostModel, o = ap[i ? "initProps" : "updateProps"]; o(e, { shape: { points: n.ends } }, a, r), e.useStyle(t.getItemVisual(r, "style")), e.style.strokeNoScale = !0, e.z2 = 100; var s = t.getItemModel(r), l = s.getModel("emphasis"); pi(e, s), Qn(e, l.get("focus"), l.get("blurScope"), l.get("disabled")) } function dJe(n, e, t) { return Ae(n, function (r) { return r = r.slice(), r[e] = t.initBaseline, r }) } const fJe = lJe; var S0 = $; function hJe(n) { var e = pJe(n); S0(e, function (t) { var r = t.seriesModels; r.length && (mJe(t), S0(r, function (i, a) { gJe(i, t.boxOffsetList[a], t.boxWidthList[a]) })) }) } function pJe(n) { var e = [], t = []; return n.eachSeriesByType("boxplot", function (r) { var i = r.getBaseAxis(), a = Et(t, i); a < 0 && (a = t.length, t[a] = i, e[a] = { axis: i, seriesModels: [] }), e[a].seriesModels.push(r) }), e } function mJe(n) { var e = n.axis, t = n.seriesModels, r = t.length, i = n.boxWidthList = [], a = n.boxOffsetList = [], o = [], s; if (e.type === "category") s = e.getBandWidth(); else { var l = 0; S0(t, function (p) { l = Math.max(l, p.getData().count()) }); var c = e.getExtent(); s = Math.abs(c[1] - c[0]) / l } S0(t, function (p) { var m = p.get("boxWidth"); ke(m) || (m = [m, m]), o.push([Ne(m[0], s) || 0, Ne(m[1], s) || 0]) }); var u = s * .8 - 2, d = u / r * .3, f = (u - d * (r - 1)) / r, h = f / 2 - u / 2; S0(t, function (p, m) { a.push(h), h += d + f, i.push(Math.min(Math.max(f, o[m][0]), o[m][1])) }) } function gJe(n, e, t) { var r = n.coordinateSystem, i = n.getData(), a = t / 2, o = n.get("layout") === "horizontal" ? 0 : 1, s = 1 - o, l = ["x", "y"], c = i.mapDimension(l[o]), u = i.mapDimensionsAll(l[s]); if (c == null || u.length < 5) return; for (var d = 0; d < i.count(); d++) { var f = i.get(c, d), h = w(f, u[2], d), p = w(f, u[0], d), m = w(f, u[1], d), g = w(f, u[3], d), y = w(f, u[4], d), b = []; v(b, m, !1), v(b, g, !0), b.push(p, m, y, g), S(b, p), S(b, y), S(b, h), i.setItemLayout(d, { initBaseline: h[s], ends: b }) } function w(x, k, A) { var C = i.get(k, A), E = []; E[o] = x, E[s] = C; var O; return isNaN(x) || isNaN(C) ? O = [NaN, NaN] : (O = r.dataToPoint(E), O[o] += e), O } function v(x, k, A) { var C = k.slice(), E = k.slice(); C[o] += a, E[o] -= a, A ? x.push(C, E) : x.push(E, C) } function S(x, k) { var A = k.slice(), C = k.slice(); A[o] -= a, C[o] += a, x.push(A, C) } } function vJe(n, e) { e = e || {}; for (var t = [], r = [], i = e.boundIQR, a = i === "none" || i === 0, o = 0; o < n.length; o++) { var s = Oo(n[o].slice()), l = SM(s, .25), c = SM(s, .5), u = SM(s, .75), d = s[0], f = s[s.length - 1], h = (i ?? 1.5) * (u - l), p = a ? d : Math.max(d, l - h), m = a ? f : Math.min(f, u + h), g = e.itemNameFormatter, y = tt(g) ? g({ value: o }) : Fe(g) ? g.replace("{value}", o + "") : o + ""; t.push([y, p, l, c, u, m]); for (var b = 0; b < s.length; b++) { var w = s[b]; if (w < p || w > m) { var v = [y, w]; r.push(v) } } } return { boxData: t, outliers: r } } var yJe = { type: "echarts:boxplot", transform: function (e) { var t = e.upstream; if (t.sourceFormat !== Li) { var r = ""; hn(r) } var i = vJe(t.getRawData(), e.config); return [{ dimensions: ["ItemName", "Low", "Q1", "Q2", "Q3", "High"], data: i.boxData }, { data: i.outliers }] } }; function _Je(n) { n.registerSeriesModel(sJe), n.registerChartView(fJe), n.registerLayout(hJe), n.registerTransform(yJe) } var bJe = ["itemStyle", "borderColor"], wJe = ["itemStyle", "borderColor0"], xJe = ["itemStyle", "borderColorDoji"], SJe = ["itemStyle", "color"], TJe = ["itemStyle", "color0"]; function eB(n, e) { return e.get(n > 0 ? SJe : TJe) } function tB(n, e) { return e.get(n === 0 ? xJe : n > 0 ? bJe : wJe) } var kJe = { seriesType: "candlestick", plan: iv(), performRawSeries: !0, reset: function (n, e) { if (!e.isSeriesFiltered(n)) { var t = n.pipelineContext.large; return !t && { progress: function (r, i) { for (var a; (a = r.next()) != null;) { var o = i.getItemModel(a), s = i.getItemLayout(a).sign, l = o.getItemStyle(); l.fill = eB(s, o), l.stroke = tB(s, o) || l.fill; var c = i.ensureUniqueItemVisual(a, "style"); be(c, l) } } } } } }; const CJe = kJe; var AJe = ["color", "borderColor"], EJe = function (n) { te(e, n); function e() { var t = n !== null && n.apply(this, arguments) || this; return t.type = e.type, t } return e.prototype.render = function (t, r, i) { this.group.removeClipPath(), this._progressiveEls = null, this._updateDrawMode(t), this._isLargeDraw ? this._renderLarge(t) : this._renderNormal(t) }, e.prototype.incrementalPrepareRender = function (t, r, i) { this._clear(), this._updateDrawMode(t) }, e.prototype.incrementalRender = function (t, r, i, a) { this._progressiveEls = [], this._isLargeDraw ? this._incrementalRenderLarge(t, r) : this._incrementalRenderNormal(t, r) }, e.prototype.eachRendered = function (t) { Gd(this._progressiveEls || this.group, t) }, e.prototype._updateDrawMode = function (t) { var r = t.pipelineContext.large; (this._isLargeDraw == null || r !== this._isLargeDraw) && (this._isLargeDraw = r, this._clear()) }, e.prototype._renderNormal = function (t) { var r = t.getData(), i = this._data, a = this.group, o = r.getLayout("isSimpleBox"), s = t.get("clip", !0), l = t.coordinateSystem, c = l.getArea && l.getArea(); this._data || a.removeAll(), r.diff(i).add(function (u) { if (r.hasValue(u)) { var d = r.getItemLayout(u); if (s && dU(c, d)) return; var f = YO(d, u, !0); Un(f, { shape: { points: d.ends } }, t, u), ZO(f, r, u, o), a.add(f), r.setItemGraphicEl(u, f) } }).update(function (u, d) { var f = i.getItemGraphicEl(d); if (!r.hasValue(u)) { a.remove(f); return } var h = r.getItemLayout(u); if (s && dU(c, h)) { a.remove(f); return } f ? (on(f, { shape: { points: h.ends } }, t, u), Ms(f)) : f = YO(h), ZO(f, r, u, o), a.add(f), r.setItemGraphicEl(u, f) }).remove(function (u) { var d = i.getItemGraphicEl(u); d && a.remove(d) }).execute(), this._data = r }, e.prototype._renderLarge = function (t) { this._clear(), fU(t, this.group); var r = t.get("clip", !0) ? jb(t.coordinateSystem, !1, t) : null; r ? this.group.setClipPath(r) : this.group.removeClipPath() }, e.prototype._incrementalRenderNormal = function (t, r) { for (var i = r.getData(), a = i.getLayout("isSimpleBox"), o; (o = t.next()) != null;) { var s = i.getItemLayout(o), l = YO(s); ZO(l, i, o, a), l.incremental = !0, this.group.add(l), this._progressiveEls.push(l) } }, e.prototype._incrementalRenderLarge = function (t, r) { fU(r, this.group, this._progressiveEls, !0) }, e.prototype.remove = function (t) { this._clear() }, e.prototype._clear = function () { this.group.removeAll(), this._data = null }, e.type = "candlestick", e }(Nn), MJe = function () { function n() { } return n }(), OJe = function (n) { te(e, n); function e(t) { var r = n.call(this, t) || this; return r.type = "normalCandlestickBox", r } return e.prototype.getDefaultShape = function () { return new MJe }, e.prototype.buildPath = function (t, r) { var i = r.points; this.__simpleBox ? (t.moveTo(i[4][0], i[4][1]), t.lineTo(i[6][0], i[6][1])) : (t.moveTo(i[0][0], i[0][1]), t.lineTo(i[1][0], i[1][1]), t.lineTo(i[2][0], i[2][1]), t.lineTo(i[3][0], i[3][1]), t.closePath(), t.moveTo(i[4][0], i[4][1]), t.lineTo(i[5][0], i[5][1]), t.moveTo(i[6][0], i[6][1]), t.lineTo(i[7][0], i[7][1])) }, e }(Nt); function YO(n, e, t) { var r = n.ends; return new OJe({ shape: { points: t ? DJe(r, n) : r }, z2: 100 }) } function dU(n, e) { for (var t = !0, r = 0; r < e.ends.length; r++)if (n.contain(e.ends[r][0], e.ends[r][1])) { t = !1; break } return t } function ZO(n, e, t, r) { var i = e.getItemModel(t); n.useStyle(e.getItemVisual(t, "style")), n.style.strokeNoScale = !0, n.__simpleBox = r, pi(n, i); var a = e.getItemLayout(t).sign; $(n.states, function (s, l) { var c = i.getModel(l), u = eB(a, c), d = tB(a, c) || u, f = s.style || (s.style = {}); u && (f.fill = u), d && (f.stroke = d) }); var o = i.getModel("emphasis"); Qn(n, o.get("focus"), o.get("blurScope"), o.get("disabled")) } function DJe(n, e) { return Ae(n, function (t) { return t = t.slice(), t[1] = e.initBaseline, t }) } var jJe = function () { function n() { } return n }(), XO = function (n) { te(e, n); function e(t) { var r = n.call(this, t) || this; return r.type = "largeCandlestickBox", r } return e.prototype.getDefaultShape = function () { return new jJe }, e.prototype.buildPath = function (t, r) { for (var i = r.points, a = 0; a < i.length;)if (this.__sign === i[a++]) { var o = i[a++]; t.moveTo(o, i[a++]), t.lineTo(o, i[a++]) } else a += 3 }, e }(Nt); function fU(n, e, t, r) { var i = n.getData(), a = i.getLayout("largePoints"), o = new XO({ shape: { points: a }, __sign: 1, ignoreCoarsePointer: !0 }); e.add(o); var s = new XO({ shape: { points: a }, __sign: -1, ignoreCoarsePointer: !0 }); e.add(s); var l = new XO({ shape: { points: a }, __sign: 0, ignoreCoarsePointer: !0 }); e.add(l), JO(1, o, n), JO(-1, s, n), JO(0, l, n), r && (o.incremental = !0, s.incremental = !0), t && t.push(o, s) } function JO(n, e, t, r) { var i = tB(n, t) || eB(n, t), a = t.getModel("itemStyle").getItemStyle(AJe); e.useStyle(a), e.style.fill = null, e.style.stroke = i } const PJe = EJe; var soe = function (n) { te(e, n); function e() { var t = n !== null && n.apply(this, arguments) || this; return t.type = e.type, t.defaultValueDimensions = [{ name: "open", defaultTooltip: !0 }, { name: "close", defaultTooltip: !0 }, { name: "lowest", defaultTooltip: !0 }, { name: "highest", defaultTooltip: !0 }], t } return e.prototype.getShadowDim = function () { return "open" }, e.prototype.brushSelector = function (t, r, i) { var a = r.getItemLayout(t); return a && i.rect(a.brushRect) }, e.type = "series.candlestick", e.dependencies = ["xAxis", "yAxis", "grid"], e.defaultOption = { z: 2, coordinateSystem: "cartesian2d", legendHoverLink: !0, layout: null, clip: !0, itemStyle: { color: "#eb5454", color0: "#47b262", borderColor: "#eb5454", borderColor0: "#47b262", borderColorDoji: null, borderWidth: 1 }, emphasis: { itemStyle: { borderWidth: 2 } }, barMaxWidth: null, barMinWidth: null, barWidth: null, large: !0, largeThreshold: 600, progressive: 3e3, progressiveThreshold: 1e4, progressiveChunkMode: "mod", animationEasing: "linear", animationDuration: 300 }, e }(Yn); Cr(soe, ioe, !0); const IJe = soe; function LJe(n) { !n || !ke(n.series) || $(n.series, function (e) { ot(e) && e.type === "k" && (e.type = "candlestick") }) } var RJe = { seriesType: "candlestick", plan: iv(), reset: function (n) { var e = n.coordinateSystem, t = n.getData(), r = NJe(n, t), i = 0, a = 1, o = ["x", "y"], s = t.getDimensionIndex(t.mapDimension(o[i])), l = Ae(t.mapDimensionsAll(o[a]), t.getDimensionIndex, t), c = l[0], u = l[1], d = l[2], f = l[3]; if (t.setLayout({ candleWidth: r, isSimpleBox: r <= 1.3 }), s < 0 || l.length < 4) return; return { progress: n.pipelineContext.large ? p : h }; function h(m, g) { for (var y, b = g.getStore(); (y = m.next()) != null;) { var w = b.get(s, y), v = b.get(c, y), S = b.get(u, y), x = b.get(d, y), k = b.get(f, y), A = Math.min(v, S), C = Math.max(v, S), E = P(A, w), O = P(C, w), j = P(x, w), I = P(k, w), L = []; B(L, O, 0), B(L, E, 1), L.push(K(I), K(O), K(j), K(E)); var R = g.getItemModel(y), D = !!R.get(["itemStyle", "borderColorDoji"]); g.setItemLayout(y, { sign: hU(b, y, v, S, u, D), initBaseline: v > S ? O[a] : E[a], ends: L, brushRect: F(x, k, w) }) } function P(V, W) { var J = []; return J[i] = W, J[a] = V, isNaN(W) || isNaN(V) ? [NaN, NaN] : e.dataToPoint(J) } function B(V, W, J) { var ie = W.slice(), le = W.slice(); ie[i] = rS(ie[i] + r / 2, 1, !1), le[i] = rS(le[i] - r / 2, 1, !0), J ? V.push(ie, le) : V.push(le, ie) } function F(V, W, J) { var ie = P(V, J), le = P(W, J); return ie[i] -= r / 2, le[i] -= r / 2, { x: ie[0], y: ie[1], width: r, height: le[1] - ie[1] } } function K(V) { return V[i] = rS(V[i], 1), V } } function p(m, g) { for (var y = ll(m.count * 4), b = 0, w, v = [], S = [], x, k = g.getStore(), A = !!n.get(["itemStyle", "borderColorDoji"]); (x = m.next()) != null;) { var C = k.get(s, x), E = k.get(c, x), O = k.get(u, x), j = k.get(d, x), I = k.get(f, x); if (isNaN(C) || isNaN(j) || isNaN(I)) { y[b++] = NaN, b += 3; continue } y[b++] = hU(k, x, E, O, u, A), v[i] = C, v[a] = j, w = e.dataToPoint(v, null, S), y[b++] = w ? w[0] : NaN, y[b++] = w ? w[1] : NaN, v[a] = I, w = e.dataToPoint(v, null, S), y[b++] = w ? w[1] : NaN } g.setLayout("largePoints", y) } } }; function hU(n, e, t, r, i, a) { var o; return t > r ? o = -1 : t < r ? o = 1 : o = a ? 0 : e > 0 ? n.get(i, e - 1) <= r ? 1 : -1 : 1, o } function NJe(n, e) { var t = n.getBaseAxis(), r, i = t.type === "category" ? t.getBandWidth() : (r = t.getExtent(), Math.abs(r[1] - r[0]) / e.count()), a = Ne(yt(n.get("barMaxWidth"), i), i), o = Ne(yt(n.get("barMinWidth"), 1), i), s = n.get("barWidth"); return s != null ? Ne(s, i) : Math.max(Math.min(i / 2, a), o) } const BJe = RJe; function $Je(n) { n.registerChartView(PJe), n.registerSeriesModel(IJe), n.registerPreprocessor(LJe), n.registerVisual(CJe), n.registerLayout(BJe) } function pU(n, e) { var t = e.rippleEffectColor || e.color; n.eachChild(function (r) { r.attr({ z: e.z, zlevel: e.zlevel, style: { stroke: e.brushType === "stroke" ? t : null, fill: e.brushType === "fill" ? t : null } }) }) } var FJe = function (n) { te(e, n); function e(t, r) { var i = n.call(this) || this, a = new Ob(t, r), o = new ft; return i.add(a), i.add(o), i.updateData(t, r), i } return e.prototype.stopEffectAnimation = function () { this.childAt(1).removeAll() }, e.prototype.startEffectAnimation = function (t) { for (var r = t.symbolType, i = t.color, a = t.rippleNumber, o = this.childAt(1), s = 0; s < a; s++) { var l = Tr(r, -1, -1, 2, 2, i); l.attr({ style: { strokeNoScale: !0 }, z2: 99, silent: !0, scaleX: .5, scaleY: .5 }); var c = -s / a * t.period + t.effectOffset; l.animate("", !0).when(t.period, { scaleX: t.rippleScale / 2, scaleY: t.rippleScale / 2 }).delay(c).start(), l.animateStyle(!0).when(t.period, { opacity: 0 }).delay(c).start(), o.add(l) } pU(o, t) }, e.prototype.updateEffectAnimation = function (t) { for (var r = this._effectCfg, i = this.childAt(1), a = ["symbolType", "period", "rippleScale", "rippleNumber"], o = 0; o < a.length; o++) { var s = a[o]; if (r[s] !== t[s]) { this.stopEffectAnimation(), this.startEffectAnimation(t); return } } pU(i, t) }, e.prototype.highlight = function () { Pc(this) }, e.prototype.downplay = function () { Ic(this) }, e.prototype.getSymbolType = function () { var t = this.childAt(0); return t && t.getSymbolType() }, e.prototype.updateData = function (t, r) { var i = this, a = t.hostModel; this.childAt(0).updateData(t, r); var o = this.childAt(1), s = t.getItemModel(r), l = t.getItemVisual(r, "symbol"), c = ov(t.getItemVisual(r, "symbolSize")), u = t.getItemVisual(r, "style"), d = u && u.fill, f = s.getModel("emphasis"); o.setScale(c), o.traverse(function (g) { g.setStyle("fill", d) }); var h = sp(t.getItemVisual(r, "symbolOffset"), c); h && (o.x = h[0], o.y = h[1]); var p = t.getItemVisual(r, "symbolRotate"); o.rotation = (p || 0) * Math.PI / 180 || 0; var m = {}; m.showEffectOn = a.get("showEffectOn"), m.rippleScale = s.get(["rippleEffect", "scale"]), m.brushType = s.get(["rippleEffect", "brushType"]), m.period = s.get(["rippleEffect", "period"]) * 1e3, m.effectOffset = r / t.count(), m.z = a.getShallow("z") || 0, m.zlevel = a.getShallow("zlevel") || 0, m.symbolType = l, m.color = d, m.rippleEffectColor = s.get(["rippleEffect", "color"]), m.rippleNumber = s.get(["rippleEffect", "number"]), m.showEffectOn === "render" ? (this._effectCfg ? this.updateEffectAnimation(m) : this.startEffectAnimation(m), this._effectCfg = m) : (this._effectCfg = null, this.stopEffectAnimation(), this.onHoverStateChange = function (g) { g === "emphasis" ? m.showEffectOn !== "render" && i.startEffectAnimation(m) : g === "normal" && m.showEffectOn !== "render" && i.stopEffectAnimation() }), this._effectCfg = m, Qn(this, f.get("focus"), f.get("blurScope"), f.get("disabled")) }, e.prototype.fadeOut = function (t) { t && t() }, e }(ft); const zJe = FJe; var VJe = function (n) { te(e, n); function e() { var t = n !== null && n.apply(this, arguments) || this; return t.type = e.type, t } return e.prototype.init = function () { this._symbolDraw = new Db(zJe) }, e.prototype.render = function (t, r, i) { var a = t.getData(), o = this._symbolDraw; o.updateData(a, { clipShape: this._getClipShape(t) }), this.group.add(o.group) }, e.prototype._getClipShape = function (t) { var r = t.coordinateSystem, i = r && r.getArea && r.getArea(); return t.get("clip", !0) ? i : null }, e.prototype.updateTransform = function (t, r, i) { var a = t.getData(); this.group.dirty(); var o = Pb("").reset(t, r, i); o.progress && o.progress({ start: 0, end: a.count(), count: a.count() }, a), this._symbolDraw.updateLayout() }, e.prototype._updateGroupTransform = function (t) { var r = t.coordinateSystem; r && r.getRoamTransform && (this.group.transform = v$e(r.getRoamTransform()), this.group.decomposeTransform()) }, e.prototype.remove = function (t, r) { this._symbolDraw && this._symbolDraw.remove(!0) }, e.type = "effectScatter", e }(Nn); const HJe = VJe; var UJe = function (n) { te(e, n); function e() { var t = n !== null && n.apply(this, arguments) || this; return t.type = e.type, t.hasSymbolVisual = !0, t } return e.prototype.getInitialData = function (t, r) { return Hc(null, this, { useEncodeDefaulter: !0 }) }, e.prototype.brushSelector = function (t, r, i) { return i.point(r.getItemLayout(t)) }, e.type = "series.effectScatter", e.dependencies = ["grid", "polar"], e.defaultOption = { coordinateSystem: "cartesian2d", z: 2, legendHoverLink: !0, effectType: "ripple", progressive: 0, showEffectOn: "render", clip: !0, rippleEffect: { period: 4, scale: 2.5, brushType: "fill", number: 3 }, universalTransition: { divideShape: "clone" }, symbolSize: 10 }, e }(Yn); const GJe = UJe; function WJe(n) { n.registerChartView(HJe), n.registerSeriesModel(GJe), n.registerLayout(Pb("effectScatter")) } var KJe = function (n) { te(e, n); function e(t, r, i) { var a = n.call(this) || this; return a.add(a.createLine(t, r, i)), a._updateEffectSymbol(t, r), a } return e.prototype.createLine = function (t, r, i) { return new G3(t, r, i) }, e.prototype._updateEffectSymbol = function (t, r) { var i = t.getItemModel(r), a = i.getModel("effect"), o = a.get("symbolSize"), s = a.get("symbol"); ke(o) || (o = [o, o]); var l = t.getItemVisual(r, "style"), c = a.get("color") || l && l.stroke, u = this.childAt(1); this._symbolType !== s && (this.remove(u), u = Tr(s, -.5, -.5, 1, 1, c), u.z2 = 100, u.culling = !0, this.add(u)), u && (u.setStyle("shadowColor", c), u.setStyle(a.getItemStyle(["color"])), u.scaleX = o[0], u.scaleY = o[1], u.setColor(c), this._symbolType = s, this._symbolScale = o, this._updateEffectAnimation(t, a, r)) }, e.prototype._updateEffectAnimation = function (t, r, i) { var a = this.childAt(1); if (a) { var o = t.getItemLayout(i), s = r.get("period") * 1e3, l = r.get("loop"), c = r.get("roundTrip"), u = r.get("constantSpeed"), d = Xr(r.get("delay"), function (h) { return h / t.count() * s / 3 }); if (a.ignore = !0, this._updateAnimationPoints(a, o), u > 0 && (s = this._getLineLength(a) / u * 1e3), s !== this._period || l !== this._loop || c !== this._roundTrip) { a.stopAnimation(); var f = void 0; tt(d) ? f = d(i) : f = d, a.__t > 0 && (f = -s * a.__t), this._animateSymbol(a, s, f, l, c) } this._period = s, this._loop = l, this._roundTrip = c } }, e.prototype._animateSymbol = function (t, r, i, a, o) { if (r > 0) { t.__t = 0; var s = this, l = t.animate("", a).when(o ? r * 2 : r, { __t: o ? 2 : 1 }).delay(i).during(function () { s._updateSymbolPosition(t) }); a || l.done(function () { s.remove(t) }), l.start() } }, e.prototype._getLineLength = function (t) { return Hu(t.__p1, t.__cp1) + Hu(t.__cp1, t.__p2) }, e.prototype._updateAnimationPoints = function (t, r) { t.__p1 = r[0], t.__p2 = r[1], t.__cp1 = r[2] || [(r[0][0] + r[1][0]) / 2, (r[0][1] + r[1][1]) / 2] }, e.prototype.updateData = function (t, r, i) { this.childAt(0).updateData(t, r, i), this._updateEffectSymbol(t, r) }, e.prototype._updateSymbolPosition = function (t) { var r = t.__p1, i = t.__p2, a = t.__cp1, o = t.__t < 1 ? t.__t : 2 - t.__t, s = [t.x, t.y], l = s.slice(), c = qr, u = MP; s[0] = c(r[0], a[0], i[0], o), s[1] = c(r[1], a[1], i[1], o); var d = t.__t < 1 ? u(r[0], a[0], i[0], o) : u(i[0], a[0], r[0], 1 - o), f = t.__t < 1 ? u(r[1], a[1], i[1], o) : u(i[1], a[1], r[1], 1 - o); t.rotation = -Math.atan2(f, d) - Math.PI / 2, (this._symbolType === "line" || this._symbolType === "rect" || this._symbolType === "roundRect") && (t.__lastT !== void 0 && t.__lastT < t.__t ? (t.scaleY = Hu(l, s) * 1.05, o === 1 && (s[0] = l[0] + (s[0] - l[0]) / 2, s[1] = l[1] + (s[1] - l[1]) / 2)) : t.__lastT === 1 ? t.scaleY = 2 * Hu(r, s) : t.scaleY = this._symbolScale[1]), t.__lastT = t.__t, t.ignore = !1, t.x = s[0], t.y = s[1] }, e.prototype.updateLayout = function (t, r) { this.childAt(0).updateLayout(t, r); var i = t.getItemModel(r).getModel("effect"); this._updateEffectAnimation(t, i, r) }, e }(ft); const loe = KJe; var qJe = function (n) { te(e, n); function e(t, r, i) { var a = n.call(this) || this; return a._createPolyline(t, r, i), a } return e.prototype._createPolyline = function (t, r, i) { var a = t.getItemLayout(r), o = new Ea({ shape: { points: a } }); this.add(o), this._updateCommonStl(t, r, i) }, e.prototype.updateData = function (t, r, i) { var a = t.hostModel, o = this.childAt(0), s = { shape: { points: t.getItemLayout(r) } }; on(o, s, a, r), this._updateCommonStl(t, r, i) }, e.prototype._updateCommonStl = function (t, r, i) { var a = this.childAt(0), o = t.getItemModel(r), s = i && i.emphasisLineStyle, l = i && i.focus, c = i && i.blurScope, u = i && i.emphasisDisabled; if (!i || t.hasItemOption) { var d = o.getModel("emphasis"); s = d.getModel("lineStyle").getLineStyle(), u = d.get("disabled"), l = d.get("focus"), c = d.get("blurScope") } a.useStyle(t.getItemVisual(r, "style")), a.style.fill = null, a.style.strokeNoScale = !0; var f = a.ensureState("emphasis"); f.style = s, Qn(this, l, c, u) }, e.prototype.updateLayout = function (t, r) { var i = this.childAt(0); i.setShape("points", t.getItemLayout(r)) }, e }(ft); const coe = qJe; var YJe = function (n) { te(e, n); function e() { var t = n !== null && n.apply(this, arguments) || this; return t._lastFrame = 0, t._lastFramePercent = 0, t } return e.prototype.createLine = function (t, r, i) { return new coe(t, r, i) }, e.prototype._updateAnimationPoints = function (t, r) { this._points = r; for (var i = [0], a = 0, o = 1; o < r.length; o++) { var s = r[o - 1], l = r[o]; a += Hu(s, l), i.push(a) } if (a === 0) { this._length = 0; return } for (var o = 0; o < i.length; o++)i[o] /= a; this._offsets = i, this._length = a }, e.prototype._getLineLength = function () { return this._length }, e.prototype._updateSymbolPosition = function (t) { var r = t.__t < 1 ? t.__t : 2 - t.__t, i = this._points, a = this._offsets, o = i.length; if (a) { var s = this._lastFrame, l; if (r < this._lastFramePercent) { var c = Math.min(s + 1, o - 1); for (l = c; l >= 0 && !(a[l] <= r); l--); l = Math.min(l, o - 2) } else { for (l = s; l < o && !(a[l] > r); l++); l = Math.min(l - 1, o - 2) } var u = (r - a[l]) / (a[l + 1] - a[l]), d = i[l], f = i[l + 1]; t.x = d[0] * (1 - u) + u * f[0], t.y = d[1] * (1 - u) + u * f[1]; var h = t.__t < 1 ? f[0] - d[0] : d[0] - f[0], p = t.__t < 1 ? f[1] - d[1] : d[1] - f[1]; t.rotation = -Math.atan2(p, h) - Math.PI / 2, this._lastFrame = l, this._lastFramePercent = r, t.ignore = !1 } }, e }(loe); const ZJe = YJe; var XJe = function () { function n() { this.polyline = !1, this.curveness = 0, this.segs = [] } return n }(), JJe = function (n) { te(e, n); function e(t) { var r = n.call(this, t) || this; return r._off = 0, r.hoverDataIdx = -1, r } return e.prototype.reset = function () { this.notClear = !1, this._off = 0 }, e.prototype.getDefaultStyle = function () { return { stroke: "#000", fill: null } }, e.prototype.getDefaultShape = function () { return new XJe }, e.prototype.buildPath = function (t, r) { var i = r.segs, a = r.curveness, o; if (r.polyline) for (o = this._off; o < i.length;) { var s = i[o++]; if (s > 0) { t.moveTo(i[o++], i[o++]); for (var l = 1; l < s; l++)t.lineTo(i[o++], i[o++]) } } else for (o = this._off; o < i.length;) { var c = i[o++], u = i[o++], d = i[o++], f = i[o++]; if (t.moveTo(c, u), a > 0) { var h = (c + d) / 2 - (u - f) * a, p = (u + f) / 2 - (d - c) * a; t.quadraticCurveTo(h, p, d, f) } else t.lineTo(d, f) } this.incremental && (this._off = o, this.notClear = !0) }, e.prototype.findDataIndex = function (t, r) { var i = this.shape, a = i.segs, o = i.curveness, s = this.style.lineWidth; if (i.polyline) for (var l = 0, c = 0; c < a.length;) { var u = a[c++]; if (u > 0) for (var d = a[c++], f = a[c++], h = 1; h < u; h++) { var p = a[c++], m = a[c++]; if (Au(d, f, p, m, s, t, r)) return l } l++ } else for (var l = 0, c = 0; c < a.length;) { var d = a[c++], f = a[c++], p = a[c++], m = a[c++]; if (o > 0) { var g = (d + p) / 2 - (f - m) * o, y = (f + m) / 2 - (p - d) * o; if (hte(d, f, g, y, p, m, s, t, r)) return l } else if (Au(d, f, p, m, s, t, r)) return l; l++ } return -1 }, e.prototype.contain = function (t, r) { var i = this.transformCoordToLocal(t, r), a = this.getBoundingRect(); if (t = i[0], r = i[1], a.contain(t, r)) { var o = this.hoverDataIdx = this.findDataIndex(t, r); return o >= 0 } return this.hoverDataIdx = -1, !1 }, e.prototype.getBoundingRect = function () { var t = this._rect; if (!t) { for (var r = this.shape, i = r.segs, a = 1 / 0, o = 1 / 0, s = -1 / 0, l = -1 / 0, c = 0; c < i.length;) { var u = i[c++], d = i[c++]; a = Math.min(u, a), s = Math.max(u, s), o = Math.min(d, o), l = Math.max(d, l) } t = this._rect = new kt(a, o, s, l) } return t }, e }(Nt), QJe = function () { function n() { this.group = new ft } return n.prototype.updateData = function (e) { this._clear(); var t = this._create(); t.setShape({ segs: e.getLayout("linesPoints") }), this._setCommon(t, e) }, n.prototype.incrementalPrepareUpdate = function (e) { this.group.removeAll(), this._clear() }, n.prototype.incrementalUpdate = function (e, t) { var r = this._newAdded[0], i = t.getLayout("linesPoints"), a = r && r.shape.segs; if (a && a.length < 2e4) { var o = a.length, s = new Float32Array(o + i.length); s.set(a), s.set(i, o), r.setShape({ segs: s }) } else { this._newAdded = []; var l = this._create(); l.incremental = !0, l.setShape({ segs: i }), this._setCommon(l, t), l.__startIndex = e.start } }, n.prototype.remove = function () { this._clear() }, n.prototype.eachRendered = function (e) { this._newAdded[0] && e(this._newAdded[0]) }, n.prototype._create = function () { var e = new JJe({ cursor: "default", ignoreCoarsePointer: !0 }); return this._newAdded.push(e), this.group.add(e), e }, n.prototype._setCommon = function (e, t, r) { var i = t.hostModel; e.setShape({ polyline: i.get("polyline"), curveness: i.get(["lineStyle", "curveness"]) }), e.useStyle(i.getModel("lineStyle").getLineStyle()), e.style.strokeNoScale = !0; var a = t.getVisual("style"); a && a.stroke && e.setStyle("stroke", a.stroke), e.setStyle("fill", null); var o = pt(e); o.seriesIndex = i.seriesIndex, e.on("mousemove", function (s) { o.dataIndex = null; var l = e.hoverDataIdx; l > 0 && (o.dataIndex = l + e.__startIndex) }) }, n.prototype._clear = function () { this._newAdded = [], this.group.removeAll() }, n }(); const eQe = QJe; var tQe = { seriesType: "lines", plan: iv(), reset: function (n) { var e = n.coordinateSystem; if (e) { var t = n.get("polyline"), r = n.pipelineContext.large; return { progress: function (i, a) { var o = []; if (r) { var s = void 0, l = i.end - i.start; if (t) { for (var c = 0, u = i.start; u < i.end; u++)c += n.getLineCoordsCount(u); s = new Float32Array(l + c * 2) } else s = new Float32Array(l * 4); for (var d = 0, f = [], u = i.start; u < i.end; u++) { var h = n.getLineCoords(u, o); t && (s[d++] = h); for (var p = 0; p < h; p++)f = e.dataToPoint(o[p], !1, f), s[d++] = f[0], s[d++] = f[1] } a.setLayout("linesPoints", s) } else for (var u = i.start; u < i.end; u++) { var m = a.getItemModel(u), h = n.getLineCoords(u, o), g = []; if (t) for (var y = 0; y < h; y++)g.push(e.dataToPoint(o[y])); else { g[0] = e.dataToPoint(o[0]), g[1] = e.dataToPoint(o[1]); var b = m.get(["lineStyle", "curveness"]); +b && (g[2] = [(g[0][0] + g[1][0]) / 2 - (g[0][1] - g[1][1]) * b, (g[0][1] + g[1][1]) / 2 - (g[1][0] - g[0][0]) * b]) } a.setItemLayout(u, g) } } } } } }; const uoe = tQe; var nQe = function (n) { te(e, n); function e() { var t = n !== null && n.apply(this, arguments) || this; return t.type = e.type, t } return e.prototype.render = function (t, r, i) { var a = t.getData(), o = this._updateLineDraw(a, t), s = t.get("zlevel"), l = t.get(["effect", "trailLength"]), c = i.getZr(), u = c.painter.getType() === "svg"; u || c.painter.getLayer(s).clear(!0), this._lastZlevel != null && !u && c.configLayer(this._lastZlevel, { motionBlur: !1 }), this._showEffect(t) && l > 0 && (u || c.configLayer(s, { motionBlur: !0, lastFrameAlpha: Math.max(Math.min(l / 10 + .9, 1), 0) })), o.updateData(a); var d = t.get("clip", !0) && jb(t.coordinateSystem, !1, t); d ? this.group.setClipPath(d) : this.group.removeClipPath(), this._lastZlevel = s, this._finished = !0 }, e.prototype.incrementalPrepareRender = function (t, r, i) { var a = t.getData(), o = this._updateLineDraw(a, t); o.incrementalPrepareUpdate(a), this._clearLayer(i), this._finished = !1 }, e.prototype.incrementalRender = function (t, r, i) { this._lineDraw.incrementalUpdate(t, r.getData()), this._finished = t.end === r.getData().count() }, e.prototype.eachRendered = function (t) { this._lineDraw && this._lineDraw.eachRendered(t) }, e.prototype.updateTransform = function (t, r, i) { var a = t.getData(), o = t.pipelineContext; if (!this._finished || o.large || o.progressiveRender) return { update: !0 }; var s = uoe.reset(t, r, i); s.progress && s.progress({ start: 0, end: a.count(), count: a.count() }, a), this._lineDraw.updateLayout(), this._clearLayer(i) }, e.prototype._updateLineDraw = function (t, r) { var i = this._lineDraw, a = this._showEffect(r), o = !!r.get("polyline"), s = r.pipelineContext, l = s.large; return (!i || a !== this._hasEffet || o !== this._isPolyline || l !== this._isLargeDraw) && (i && i.remove(), i = this._lineDraw = l ? new eQe : new W3(o ? a ? ZJe : coe : a ? loe : G3), this._hasEffet = a, this._isPolyline = o, this._isLargeDraw = l), this.group.add(i.group), i }, e.prototype._showEffect = function (t) { return !!t.get(["effect", "show"]) }, e.prototype._clearLayer = function (t) { var r = t.getZr(), i = r.painter.getType() === "svg"; !i && this._lastZlevel != null && r.painter.getLayer(this._lastZlevel).clear(!0) }, e.prototype.remove = function (t, r) { this._lineDraw && this._lineDraw.remove(), this._lineDraw = null, this._clearLayer(r) }, e.prototype.dispose = function (t, r) { this.remove(t, r) }, e.type = "lines", e }(Nn); const rQe = nQe; var iQe = typeof Uint32Array > "u" ? Array : Uint32Array, aQe = typeof Float64Array > "u" ? Array : Float64Array; function mU(n) { var e = n.data; e && e[0] && e[0][0] && e[0][0].coord && (n.data = Ae(e, function (t) { var r = [t[0].coord, t[1].coord], i = { coords: r }; return t[0].name && (i.fromName = t[0].name), t[1].name && (i.toName = t[1].name), bN([i, t[0], t[1]]) })) } var oQe = function (n) { te(e, n); function e() { var t = n !== null && n.apply(this, arguments) || this; return t.type = e.type, t.visualStyleAccessPath = "lineStyle", t.visualDrawType = "stroke", t } return e.prototype.init = function (t) { t.data = t.data || [], mU(t); var r = this._processFlatCoordsArray(t.data); this._flatCoords = r.flatCoords, this._flatCoordsOffset = r.flatCoordsOffset, r.flatCoords && (t.data = new Float32Array(r.count)), n.prototype.init.apply(this, arguments) }, e.prototype.mergeOption = function (t) { if (mU(t), t.data) { var r = this._processFlatCoordsArray(t.data); this._flatCoords = r.flatCoords, this._flatCoordsOffset = r.flatCoordsOffset, r.flatCoords && (t.data = new Float32Array(r.count)) } n.prototype.mergeOption.apply(this, arguments) }, e.prototype.appendData = function (t) { var r = this._processFlatCoordsArray(t.data); r.flatCoords && (this._flatCoords ? (this._flatCoords = u_(this._flatCoords, r.flatCoords), this._flatCoordsOffset = u_(this._flatCoordsOffset, r.flatCoordsOffset)) : (this._flatCoords = r.flatCoords, this._flatCoordsOffset = r.flatCoordsOffset), t.data = new Float32Array(r.count)), this.getRawData().appendData(t.data) }, e.prototype._getCoordsFromItemModel = function (t) { var r = this.getData().getItemModel(t), i = r.option instanceof Array ? r.option : r.getShallow("coords"); return i }, e.prototype.getLineCoordsCount = function (t) { return this._flatCoordsOffset ? this._flatCoordsOffset[t * 2 + 1] : this._getCoordsFromItemModel(t).length }, e.prototype.getLineCoords = function (t, r) { if (this._flatCoordsOffset) { for (var i = this._flatCoordsOffset[t * 2], a = this._flatCoordsOffset[t * 2 + 1], o = 0; o < a; o++)r[o] = r[o] || [], r[o][0] = this._flatCoords[i + o * 2], r[o][1] = this._flatCoords[i + o * 2 + 1]; return a } else { for (var s = this._getCoordsFromItemModel(t), o = 0; o < s.length; o++)r[o] = r[o] || [], r[o][0] = s[o][0], r[o][1] = s[o][1]; return s.length } }, e.prototype._processFlatCoordsArray = function (t) { var r = 0; if (this._flatCoords && (r = this._flatCoords.length), nn(t[0])) { for (var i = t.length, a = new iQe(i), o = new aQe(i), s = 0, l = 0, c = 0, u = 0; u < i;) { c++; var d = t[u++]; a[l++] = s + r, a[l++] = d; for (var f = 0; f < d; f++) { var h = t[u++], p = t[u++]; o[s++] = h, o[s++] = p } } return { flatCoordsOffset: new Uint32Array(a.buffer, 0, l), flatCoords: o, count: c } } return { flatCoordsOffset: null, flatCoords: null, count: t.length } }, e.prototype.getInitialData = function (t, r) { var i = new Ji(["value"], this); return i.hasItemOption = !1, i.initData(t.data, [], function (a, o, s, l) { if (a instanceof Array) return NaN; i.hasItemOption = !0; var c = a.value; if (c != null) return c instanceof Array ? c[l] : c }), i }, e.prototype.formatTooltip = function (t, r, i) { var a = this.getData(), o = a.getItemModel(t), s = o.get("name"); if (s) return s; var l = o.get("fromName"), c = o.get("toName"), u = []; return l != null && u.push(l), c != null && u.push(c), Gr("nameValue", { name: u.join(" > ") }) }, e.prototype.preventIncremental = function () { return !!this.get(["effect", "show"]) }, e.prototype.getProgressive = function () { var t = this.option.progressive; return t ?? (this.option.large ? 1e4 : this.get("progressive")) }, e.prototype.getProgressiveThreshold = function () { var t = this.option.progressiveThreshold; return t ?? (this.option.large ? 2e4 : this.get("progressiveThreshold")) }, e.prototype.getZLevelKey = function () { var t = this.getModel("effect"), r = t.get("trailLength"); return this.getData().count() > this.getProgressiveThreshold() ? this.id : t.get("show") && r > 0 ? r + "" : "" }, e.type = "series.lines", e.dependencies = ["grid", "polar", "geo", "calendar"], e.defaultOption = { coordinateSystem: "geo", z: 2, legendHoverLink: !0, xAxisIndex: 0, yAxisIndex: 0, symbol: ["none", "none"], symbolSize: [10, 10], geoIndex: 0, effect: { show: !1, period: 4, constantSpeed: 0, symbol: "circle", symbolSize: 3, loop: !0, trailLength: .2 }, large: !1, largeThreshold: 2e3, polyline: !1, clip: !0, label: { show: !1, position: "end" }, lineStyle: { opacity: .5 } }, e }(Yn); const sQe = oQe; function mx(n) { return n instanceof Array || (n = [n, n]), n } var lQe = { seriesType: "lines", reset: function (n) { var e = mx(n.get("symbol")), t = mx(n.get("symbolSize")), r = n.getData(); r.setVisual("fromSymbol", e && e[0]), r.setVisual("toSymbol", e && e[1]), r.setVisual("fromSymbolSize", t && t[0]), r.setVisual("toSymbolSize", t && t[1]); function i(a, o) { var s = a.getItemModel(o), l = mx(s.getShallow("symbol", !0)), c = mx(s.getShallow("symbolSize", !0)); l[0] && a.setItemVisual(o, "fromSymbol", l[0]), l[1] && a.setItemVisual(o, "toSymbol", l[1]), c[0] && a.setItemVisual(o, "fromSymbolSize", c[0]), c[1] && a.setItemVisual(o, "toSymbolSize", c[1]) } return { dataEach: r.hasItemOption ? i : null } } }; const cQe = lQe; function uQe(n) { n.registerChartView(rQe), n.registerSeriesModel(sQe), n.registerLayout(uoe), n.registerVisual(cQe) } var dQe = 256, fQe = function () { function n() { this.blurSize = 30, this.pointSize = 20, this.maxOpacity = 1, this.minOpacity = 0, this._gradientPixels = { inRange: null, outOfRange: null }; var e = kd.createCanvas(); this.canvas = e } return n.prototype.update = function (e, t, r, i, a, o) { var s = this._getBrush(), l = this._getGradient(a, "inRange"), c = this._getGradient(a, "outOfRange"), u = this.pointSize + this.blurSize, d = this.canvas, f = d.getContext("2d"), h = e.length; d.width = t, d.height = r; for (var p = 0; p < h; ++p) { var m = e[p], g = m[0], y = m[1], b = m[2], w = i(b); f.globalAlpha = w, f.drawImage(s, g - u, y - u) } if (!d.width || !d.height) return d; for (var v = f.getImageData(0, 0, d.width, d.height), S = v.data, x = 0, k = S.length, A = this.minOpacity, C = this.maxOpacity, E = C - A; x < k;) { var w = S[x + 3] / 256, O = Math.floor(w * (dQe - 1)) * 4; if (w > 0) { var j = o(w) ? l : c; w > 0 && (w = w * E + A), S[x++] = j[O], S[x++] = j[O + 1], S[x++] = j[O + 2], S[x++] = j[O + 3] * w * 256 } else x += 4 } return f.putImageData(v, 0, 0), d }, n.prototype._getBrush = function () { var e = this._brushCanvas || (this._brushCanvas = kd.createCanvas()), t = this.pointSize + this.blurSize, r = t * 2; e.width = r, e.height = r; var i = e.getContext("2d"); return i.clearRect(0, 0, r, r), i.shadowOffsetX = r, i.shadowBlur = this.blurSize, i.shadowColor = "#000", i.beginPath(), i.arc(-t, t, this.pointSize, 0, Math.PI * 2, !0), i.closePath(), i.fill(), e }, n.prototype._getGradient = function (e, t) { for (var r = this._gradientPixels, i = r[t] || (r[t] = new Uint8ClampedArray(256 * 4)), a = [0, 0, 0, 0], o = 0, s = 0; s < 256; s++)e[t](s / 255, !0, a), i[o++] = a[0], i[o++] = a[1], i[o++] = a[2], i[o++] = a[3]; return i }, n }(); const hQe = fQe; function pQe(n, e, t) { var r = n[1] - n[0]; e = Ae(e, function (o) { return { interval: [(o.interval[0] - n[0]) / r, (o.interval[1] - n[0]) / r] } }); var i = e.length, a = 0; return function (o) { var s; for (s = a; s < i; s++) { var l = e[s].interval; if (l[0] <= o && o <= l[1]) { a = s; break } } if (s === i) for (s = a - 1; s >= 0; s--) { var l = e[s].interval; if (l[0] <= o && o <= l[1]) { a = s; break } } return s >= 0 && s < i && t[s] } } function mQe(n, e) { var t = n[1] - n[0]; return e = [(e[0] - n[0]) / t, (e[1] - n[0]) / t], function (r) { return r >= e[0] && r <= e[1] } } function gU(n) { var e = n.dimensions; return e[0] === "lng" && e[1] === "lat" } var gQe = function (n) { te(e, n); function e() { var t = n !== null && n.apply(this, arguments) || this; return t.type = e.type, t } return e.prototype.render = function (t, r, i) { var a; r.eachComponent("visualMap", function (s) { s.eachTargetSeries(function (l) { l === t && (a = s) }) }), this._progressiveEls = null, this.group.removeAll(); var o = t.coordinateSystem; o.type === "cartesian2d" || o.type === "calendar" ? this._renderOnCartesianAndCalendar(t, i, 0, t.getData().count()) : gU(o) && this._renderOnGeo(o, t, a, i) }, e.prototype.incrementalPrepareRender = function (t, r, i) { this.group.removeAll() }, e.prototype.incrementalRender = function (t, r, i, a) { var o = r.coordinateSystem; o && (gU(o) ? this.render(r, i, a) : (this._progressiveEls = [], this._renderOnCartesianAndCalendar(r, a, t.start, t.end, !0))) }, e.prototype.eachRendered = function (t) { Gd(this._progressiveEls || this.group, t) }, e.prototype._renderOnCartesianAndCalendar = function (t, r, i, a, o) { var s = t.coordinateSystem, l = cp(s, "cartesian2d"), c, u, d, f; if (l) { var h = s.getAxis("x"), p = s.getAxis("y"); c = h.getBandWidth() + .5, u = p.getBandWidth() + .5, d = h.scale.getExtent(), f = p.scale.getExtent() } for (var m = this.group, g = t.getData(), y = t.getModel(["emphasis", "itemStyle"]).getItemStyle(), b = t.getModel(["blur", "itemStyle"]).getItemStyle(), w = t.getModel(["select", "itemStyle"]).getItemStyle(), v = t.get(["itemStyle", "borderRadius"]), S = Ur(t), x = t.getModel("emphasis"), k = x.get("focus"), A = x.get("blurScope"), C = x.get("disabled"), E = l ? [g.mapDimension("x"), g.mapDimension("y"), g.mapDimension("value")] : [g.mapDimension("time"), g.mapDimension("value")], O = i; O < a; O++) { var j = void 0, I = g.getItemVisual(O, "style"); if (l) { var L = g.get(E[0], O), R = g.get(E[1], O); if (isNaN(g.get(E[2], O)) || isNaN(L) || isNaN(R) || L < d[0] || L > d[1] || R < f[0] || R > f[1]) continue; var D = s.dataToPoint([L, R]); j = new Yt({ shape: { x: D[0] - c / 2, y: D[1] - u / 2, width: c, height: u }, style: I }) } else { if (isNaN(g.get(E[1], O))) continue; j = new Yt({ z2: 1, shape: s.dataToRect([g.get(E[0], O)]).contentShape, style: I }) } if (g.hasItemOption) { var P = g.getItemModel(O), B = P.getModel("emphasis"); y = B.getModel("itemStyle").getItemStyle(), b = P.getModel(["blur", "itemStyle"]).getItemStyle(), w = P.getModel(["select", "itemStyle"]).getItemStyle(), v = P.get(["itemStyle", "borderRadius"]), k = B.get("focus"), A = B.get("blurScope"), C = B.get("disabled"), S = Ur(P) } j.shape.r = v; var F = t.getRawValue(O), K = "-"; F && F[2] != null && (K = F[2] + ""), mi(j, S, { labelFetcher: t, labelDataIndex: O, defaultOpacity: I.opacity, defaultText: K }), j.ensureState("emphasis").style = y, j.ensureState("blur").style = b, j.ensureState("select").style = w, Qn(j, k, A, C), j.incremental = o, o && (j.states.emphasis.hoverLayer = !0), m.add(j), g.setItemGraphicEl(O, j), this._progressiveEls && this._progressiveEls.push(j) } }, e.prototype._renderOnGeo = function (t, r, i, a) { var o = i.targetVisuals.inRange, s = i.targetVisuals.outOfRange, l = r.getData(), c = this._hmLayer || this._hmLayer || new hQe; c.blurSize = r.get("blurSize"), c.pointSize = r.get("pointSize"), c.minOpacity = r.get("minOpacity"), c.maxOpacity = r.get("maxOpacity"); var u = t.getViewRect().clone(), d = t.getRoamTransform(); u.applyTransform(d); var f = Math.max(u.x, 0), h = Math.max(u.y, 0), p = Math.min(u.width + u.x, a.getWidth()), m = Math.min(u.height + u.y, a.getHeight()), g = p - f, y = m - h, b = [l.mapDimension("lng"), l.mapDimension("lat"), l.mapDimension("value")], w = l.mapArray(b, function (k, A, C) { var E = t.dataToPoint([k, A]); return E[0] -= f, E[1] -= h, E.push(C), E }), v = i.getExtent(), S = i.type === "visualMap.continuous" ? mQe(v, i.option.range) : pQe(v, i.getPieceList(), i.option.selected); c.update(w, g, y, o.color.getNormalizer(), { inRange: o.color.getColorMapper(), outOfRange: s.color.getColorMapper() }, S); var x = new gi({ style: { width: g, height: y, x: f, y: h, image: c.canvas }, silent: !0 }); this.group.add(x) }, e.type = "heatmap", e }(Nn); const vQe = gQe; var yQe = function (n) { te(e, n); function e() { var t = n !== null && n.apply(this, arguments) || this; return t.type = e.type, t } return e.prototype.getInitialData = function (t, r) { return Hc(null, this, { generateCoord: "value" }) }, e.prototype.preventIncremental = function () { var t = Cb.get(this.get("coordinateSystem")); if (t && t.dimensions) return t.dimensions[0] === "lng" && t.dimensions[1] === "lat" }, e.type = "series.heatmap", e.dependencies = ["grid", "geo", "calendar"], e.defaultOption = { coordinateSystem: "cartesian2d", z: 2, geoIndex: 0, blurSize: 30, pointSize: 20, maxOpacity: 1, minOpacity: 0, select: { itemStyle: { borderColor: "#212121" } } }, e }(Yn); const _Qe = yQe; function bQe(n) { n.registerChartView(vQe), n.registerSeriesModel(_Qe) } var wQe = ["itemStyle", "borderWidth"], vU = [{ xy: "x", wh: "width", index: 0, posDesc: ["left", "right"] }, { xy: "y", wh: "height", index: 1, posDesc: ["top", "bottom"] }], QO = new Ud, xQe = function (n) { te(e, n); function e() { var t = n !== null && n.apply(this, arguments) || this; return t.type = e.type, t } return e.prototype.render = function (t, r, i) { var a = this.group, o = t.getData(), s = this._data, l = t.coordinateSystem, c = l.getBaseAxis(), u = c.isHorizontal(), d = l.master.getRect(), f = { ecSize: { width: i.getWidth(), height: i.getHeight() }, seriesModel: t, coordSys: l, coordSysExtent: [[d.x, d.x + d.width], [d.y, d.y + d.height]], isHorizontal: u, valueDim: vU[+u], categoryDim: vU[1 - +u] }; o.diff(s).add(function (p) { if (o.hasValue(p)) { var m = _U(o, p), g = yU(o, p, m, f), y = bU(o, f, g); o.setItemGraphicEl(p, y), a.add(y), xU(y, f, g) } }).update(function (p, m) { var g = s.getItemGraphicEl(m); if (!o.hasValue(p)) { a.remove(g); return } var y = _U(o, p), b = yU(o, p, y, f), w = goe(o, b); g && w !== g.__pictorialShapeStr && (a.remove(g), o.setItemGraphicEl(p, null), g = null), g ? MQe(g, f, b) : g = bU(o, f, b, !0), o.setItemGraphicEl(p, g), g.__pictorialSymbolMeta = b, a.add(g), xU(g, f, b) }).remove(function (p) { var m = s.getItemGraphicEl(p); m && wU(s, p, m.__pictorialSymbolMeta.animationModel, m) }).execute(); var h = t.get("clip", !0) ? jb(t.coordinateSystem, !1, t) : null; return h ? a.setClipPath(h) : a.removeClipPath(), this._data = o, this.group }, e.prototype.remove = function (t, r) { var i = this.group, a = this._data; t.get("animation") ? a && a.eachItemGraphicEl(function (o) { wU(a, pt(o).dataIndex, t, o) }) : i.removeAll() }, e.type = "pictorialBar", e }(Nn); function yU(n, e, t, r) { var i = n.getItemLayout(e), a = t.get("symbolRepeat"), o = t.get("symbolClip"), s = t.get("symbolPosition") || "start", l = t.get("symbolRotate"), c = (l || 0) * Math.PI / 180 || 0, u = t.get("symbolPatternSize") || 2, d = t.isAnimationEnabled(), f = { dataIndex: e, layout: i, itemModel: t, symbolType: n.getItemVisual(e, "symbol") || "circle", style: n.getItemVisual(e, "style"), symbolClip: o, symbolRepeat: a, symbolRepeatDirection: t.get("symbolRepeatDirection"), symbolPatternSize: u, rotation: c, animationModel: d ? t : null, hoverScale: d && t.get(["emphasis", "scale"]), z2: t.getShallow("z", !0) || 0 }; SQe(t, a, i, r, f), TQe(n, e, i, a, o, f.boundingLength, f.pxSign, u, r, f), kQe(t, f.symbolScale, c, r, f); var h = f.symbolSize, p = sp(t.get("symbolOffset"), h); return CQe(t, h, i, a, o, p, s, f.valueLineWidth, f.boundingLength, f.repeatCutLength, r, f), f } function SQe(n, e, t, r, i) { var a = r.valueDim, o = n.get("symbolBoundingData"), s = r.coordSys.getOtherAxis(r.coordSys.getBaseAxis()), l = s.toGlobalCoord(s.dataToCoord(0)), c = 1 - +(t[a.wh] <= 0), u; if (ke(o)) { var d = [eD(s, o[0]) - l, eD(s, o[1]) - l]; d[1] < d[0] && d.reverse(), u = d[c] } else o != null ? u = eD(s, o) - l : e ? u = r.coordSysExtent[a.index][c] - l : u = t[a.wh]; i.boundingLength = u, e && (i.repeatCutLength = t[a.wh]); var f = a.xy === "x", h = s.inverse; i.pxSign = f && !h || !f && h ? u >= 0 ? 1 : -1 : u > 0 ? 1 : -1 } function eD(n, e) { return n.toGlobalCoord(n.dataToCoord(n.scale.parse(e))) } function TQe(n, e, t, r, i, a, o, s, l, c) { var u = l.valueDim, d = l.categoryDim, f = Math.abs(t[d.wh]), h = n.getItemVisual(e, "symbolSize"), p; ke(h) ? p = h.slice() : h == null ? p = ["100%", "100%"] : p = [h, h], p[d.index] = Ne(p[d.index], f), p[u.index] = Ne(p[u.index], r ? f : Math.abs(a)), c.symbolSize = p; var m = c.symbolScale = [p[0] / s, p[1] / s]; m[u.index] *= (l.isHorizontal ? -1 : 1) * o } function kQe(n, e, t, r, i) { var a = n.get(wQe) || 0; a && (QO.attr({ scaleX: e[0], scaleY: e[1], rotation: t }), QO.updateTransform(), a /= QO.getLineScale(), a *= e[r.valueDim.index]), i.valueLineWidth = a || 0 } function CQe(n, e, t, r, i, a, o, s, l, c, u, d) { var f = u.categoryDim, h = u.valueDim, p = d.pxSign, m = Math.max(e[h.index] + s, 0), g = m; if (r) { var y = Math.abs(l), b = Xr(n.get("symbolMargin"), "15%") + "", w = !1; b.lastIndexOf("!") === b.length - 1 && (w = !0, b = b.slice(0, b.length - 1)); var v = Ne(b, e[h.index]), S = Math.max(m + v * 2, 0), x = w ? 0 : v * 2, k = Qee(r), A = k ? r : SU((y + x) / S), C = y - A * m; v = C / 2 / (w ? A : Math.max(A - 1, 1)), S = m + v * 2, x = w ? 0 : v * 2, !k && r !== "fixed" && (A = c ? SU((Math.abs(c) + x) / S) : 0), g = A * S - x, d.repeatTimes = A, d.symbolMargin = v } var E = p * (g / 2), O = d.pathPosition = []; O[f.index] = t[f.wh] / 2, O[h.index] = o === "start" ? E : o === "end" ? l - E : l / 2, a && (O[0] += a[0], O[1] += a[1]); var j = d.bundlePosition = []; j[f.index] = t[f.xy], j[h.index] = t[h.xy]; var I = d.barRectShape = be({}, t); I[h.wh] = p * Math.max(Math.abs(t[h.wh]), Math.abs(O[h.index] + E)), I[f.wh] = t[f.wh]; var L = d.clipShape = {}; L[f.xy] = -t[f.xy], L[f.wh] = u.ecSize[f.wh], L[h.xy] = 0, L[h.wh] = t[h.wh] } function doe(n) { var e = n.symbolPatternSize, t = Tr(n.symbolType, -e / 2, -e / 2, e, e); return t.attr({ culling: !0 }), t.type !== "image" && t.setStyle({ strokeNoScale: !0 }), t } function foe(n, e, t, r) { var i = n.__pictorialBundle, a = t.symbolSize, o = t.valueLineWidth, s = t.pathPosition, l = e.valueDim, c = t.repeatTimes || 0, u = 0, d = a[e.valueDim.index] + o + t.symbolMargin * 2; for (nB(n, function (m) { m.__pictorialAnimationIndex = u, m.__pictorialRepeatTimes = c, u < c ? Jm(m, null, p(u), t, r) : Jm(m, null, { scaleX: 0, scaleY: 0 }, t, r, function () { i.remove(m) }), u++ }); u < c; u++) { var f = doe(t); f.__pictorialAnimationIndex = u, f.__pictorialRepeatTimes = c, i.add(f); var h = p(u); Jm(f, { x: h.x, y: h.y, scaleX: 0, scaleY: 0 }, { scaleX: h.scaleX, scaleY: h.scaleY, rotation: h.rotation }, t, r) } function p(m) { var g = s.slice(), y = t.pxSign, b = m; return (t.symbolRepeatDirection === "start" ? y > 0 : y < 0) && (b = c - 1 - m), g[l.index] = d * (b - c / 2 + .5) + s[l.index], { x: g[0], y: g[1], scaleX: t.symbolScale[0], scaleY: t.symbolScale[1], rotation: t.rotation } } } function hoe(n, e, t, r) { var i = n.__pictorialBundle, a = n.__pictorialMainPath; a ? Jm(a, null, { x: t.pathPosition[0], y: t.pathPosition[1], scaleX: t.symbolScale[0], scaleY: t.symbolScale[1], rotation: t.rotation }, t, r) : (a = n.__pictorialMainPath = doe(t), i.add(a), Jm(a, { x: t.pathPosition[0], y: t.pathPosition[1], scaleX: 0, scaleY: 0, rotation: t.rotation }, { scaleX: t.symbolScale[0], scaleY: t.symbolScale[1] }, t, r)) } function poe(n, e, t) { var r = be({}, e.barRectShape), i = n.__pictorialBarRect; i ? Jm(i, null, { shape: r }, e, t) : (i = n.__pictorialBarRect = new Yt({ z2: 2, shape: r, silent: !0, style: { stroke: "transparent", fill: "transparent", lineWidth: 0 } }), i.disableMorphing = !0, n.add(i)) } function moe(n, e, t, r) { if (t.symbolClip) { var i = n.__pictorialClipPath, a = be({}, t.clipShape), o = e.valueDim, s = t.animationModel, l = t.dataIndex; if (i) on(i, { shape: a }, s, l); else { a[o.wh] = 0, i = new Yt({ shape: a }), n.__pictorialBundle.setClipPath(i), n.__pictorialClipPath = i; var c = {}; c[o.wh] = t.clipShape[o.wh], ap[r ? "updateProps" : "initProps"](i, { shape: c }, s, l) } } } function _U(n, e) { var t = n.getItemModel(e); return t.getAnimationDelayParams = AQe, t.isAnimationEnabled = EQe, t } function AQe(n) { return { index: n.__pictorialAnimationIndex, count: n.__pictorialRepeatTimes } } function EQe() { return this.parentModel.isAnimationEnabled() && !!this.getShallow("animation") } function bU(n, e, t, r) { var i = new ft, a = new ft; return i.add(a), i.__pictorialBundle = a, a.x = t.bundlePosition[0], a.y = t.bundlePosition[1], t.symbolRepeat ? foe(i, e, t) : hoe(i, e, t), poe(i, t, r), moe(i, e, t, r), i.__pictorialShapeStr = goe(n, t), i.__pictorialSymbolMeta = t, i } function MQe(n, e, t) { var r = t.animationModel, i = t.dataIndex, a = n.__pictorialBundle; on(a, { x: t.bundlePosition[0], y: t.bundlePosition[1] }, r, i), t.symbolRepeat ? foe(n, e, t, !0) : hoe(n, e, t, !0), poe(n, t, !0), moe(n, e, t, !0) } function wU(n, e, t, r) { var i = r.__pictorialBarRect; i && i.removeTextContent(); var a = []; nB(r, function (o) { a.push(o) }), r.__pictorialMainPath && a.push(r.__pictorialMainPath), r.__pictorialClipPath && (t = null), $(a, function (o) { Ad(o, { scaleX: 0, scaleY: 0 }, t, e, function () { r.parent && r.parent.remove(r) }) }), n.setItemGraphicEl(e, null) } function goe(n, e) { return [n.getItemVisual(e.dataIndex, "symbol") || "none", !!e.symbolRepeat, !!e.symbolClip].join(":") } function nB(n, e, t) { $(n.__pictorialBundle.children(), function (r) { r !== n.__pictorialBarRect && e.call(t, r) }) } function Jm(n, e, t, r, i, a) { e && n.attr(e), r.symbolClip && !i ? t && n.attr(t) : t && ap[i ? "updateProps" : "initProps"](n, t, r.animationModel, r.dataIndex, a) } function xU(n, e, t) { var r = t.dataIndex, i = t.itemModel, a = i.getModel("emphasis"), o = a.getModel("itemStyle").getItemStyle(), s = i.getModel(["blur", "itemStyle"]).getItemStyle(), l = i.getModel(["select", "itemStyle"]).getItemStyle(), c = i.getShallow("cursor"), u = a.get("focus"), d = a.get("blurScope"), f = a.get("scale"); nB(n, function (m) { if (m instanceof gi) { var g = m.style; m.useStyle(be({ image: g.image, x: g.x, y: g.y, width: g.width, height: g.height }, t.style)) } else m.useStyle(t.style); var y = m.ensureState("emphasis"); y.style = o, f && (y.scaleX = m.scaleX * 1.1, y.scaleY = m.scaleY * 1.1), m.ensureState("blur").style = s, m.ensureState("select").style = l, c && (m.cursor = c), m.z2 = t.z2 }); var h = e.valueDim.posDesc[+(t.boundingLength > 0)], p = n.__pictorialBarRect; p.ignoreClip = !0, mi(p, Ur(i), { labelFetcher: e.seriesModel, labelDataIndex: r, defaultText: Mg(e.seriesModel.getData(), r), inheritColor: t.style.fill, defaultOpacity: t.style.opacity, defaultOutsidePosition: h }), Qn(n, u, d, a.get("disabled")) } function SU(n) { var e = Math.round(n); return Math.abs(n - e) < 1e-4 ? e : Math.ceil(n) } const OQe = xQe; var DQe = function (n) { te(e, n); function e() { var t = n !== null && n.apply(this, arguments) || this; return t.type = e.type, t.hasSymbolVisual = !0, t.defaultSymbol = "roundRect", t } return e.prototype.getInitialData = function (t) { return t.stack = null, n.prototype.getInitialData.apply(this, arguments) }, e.type = "series.pictorialBar", e.dependencies = ["grid"], e.defaultOption = Wd(gT.defaultOption, { symbol: "circle", symbolSize: null, symbolRotate: null, symbolPosition: null, symbolOffset: null, symbolMargin: null, symbolRepeat: !1, symbolRepeatDirection: "end", symbolClip: !1, symbolBoundingData: null, symbolPatternSize: 400, barGap: "-100%", clip: !1, progressive: 0, emphasis: { scale: !1 }, select: { itemStyle: { borderColor: "#212121" } } }), e }(gT); const jQe = DQe; function PQe(n) { n.registerChartView(OQe), n.registerSeriesModel(jQe), n.registerLayout(n.PRIORITY.VISUAL.LAYOUT, wt(qre, "pictorialBar")), n.registerLayout(n.PRIORITY.VISUAL.PROGRESSIVE_LAYOUT, Yre("pictorialBar")) } var IQe = function (n) { te(e, n); function e() { var t = n !== null && n.apply(this, arguments) || this; return t.type = e.type, t._layers = [], t } return e.prototype.render = function (t, r, i) { var a = t.getData(), o = this, s = this.group, l = t.getLayerSeries(), c = a.getLayout("layoutInfo"), u = c.rect, d = c.boundaryGap; s.x = 0, s.y = u.y + d[0]; function f(g) { return g.name } var h = new Lc(this._layersSeries || [], l, f, f), p = []; h.add(He(m, this, "add")).update(He(m, this, "update")).remove(He(m, this, "remove")).execute(); function m(g, y, b) { var w = o._layers; if (g === "remove") { s.remove(w[y]); return } for (var v = [], S = [], x, k = l[y].indices, A = 0; A < k.length; A++) { var C = a.getItemLayout(k[A]), E = C.x, O = C.y0, j = C.y; v.push(E, O), S.push(E, O + j), x = a.getItemVisual(k[A], "style") } var I, L = a.getItemLayout(k[0]), R = t.getModel("label"), D = R.get("margin"), P = t.getModel("emphasis"); if (g === "add") { var B = p[y] = new ft; I = new $ie({ shape: { points: v, stackedOnPoints: S, smooth: .4, stackedOnSmooth: .4, smoothConstraint: !1 }, z2: 0 }), B.add(I), s.add(B), t.isAnimationEnabled() && I.setClipPath(LQe(I.getBoundingRect(), t, function () { I.removeClipPath() })) } else { var B = w[b]; I = B.childAt(0), s.add(B), p[y] = B, on(I, { shape: { points: v, stackedOnPoints: S } }, t), Ms(I) } mi(I, Ur(t), { labelDataIndex: k[A - 1], defaultText: a.getName(k[A - 1]), inheritColor: x.fill }, { normal: { verticalAlign: "middle" } }), I.setTextConfig({ position: null, local: !0 }); var F = I.getTextContent(); F && (F.x = L.x - D, F.y = L.y0 + L.y / 2), I.useStyle(x), a.setItemGraphicEl(y, I), pi(I, t), Qn(I, P.get("focus"), P.get("blurScope"), P.get("disabled")) } this._layersSeries = l, this._layers = p }, e.type = "themeRiver", e }(Nn); function LQe(n, e, t) { var r = new Yt({ shape: { x: n.x - 10, y: n.y - 10, width: 0, height: n.height + 20 } }); return Un(r, { shape: { x: n.x - 50, width: n.width + 100, height: n.height + 20 } }, e, t), r } const RQe = IQe; var tD = 2, NQe = function (n) { te(e, n); function e() { var t = n !== null && n.apply(this, arguments) || this; return t.type = e.type, t } return e.prototype.init = function (t) { n.prototype.init.apply(this, arguments), this.legendVisualProvider = new Lb(He(this.getData, this), He(this.getRawData, this)) }, e.prototype.fixData = function (t) { var r = t.length, i = {}, a = UP(t, function (f) { return i.hasOwnProperty(f[0] + "") || (i[f[0] + ""] = -1), f[2] }), o = []; a.buckets.each(function (f, h) { o.push({ name: h, dataList: f }) }); for (var s = o.length, l = 0; l < s; ++l) { for (var c = o[l].name, u = 0; u < o[l].dataList.length; ++u) { var d = o[l].dataList[u][0] + ""; i[d] = l } for (var d in i) i.hasOwnProperty(d) && i[d] !== l && (i[d] = l, t[r] = [d, 0, c], r++) } return t }, e.prototype.getInitialData = function (t, r) { for (var i = this.getReferringComponents("singleAxis", xr).models[0], a = i.get("type"), o = pn(t.data, function (p) { return p[2] !== void 0 }), s = this.fixData(o || []), l = [], c = this.nameMap = Ze(), u = 0, d = 0; d < s.length; ++d)l.push(s[d][tD]), c.get(s[d][tD]) || (c.set(s[d][tD], u), u++); var f = Eb(s, { coordDimensions: ["single"], dimensionsDefine: [{ name: "time", type: dT(a) }, { name: "value", type: "float" }, { name: "name", type: "ordinal" }], encodeDefine: { single: 0, value: 1, itemName: 2 } }).dimensions, h = new Ji(f, this); return h.initData(s), h }, e.prototype.getLayerSeries = function () { for (var t = this.getData(), r = t.count(), i = [], a = 0; a < r; ++a)i[a] = a; var o = t.mapDimension("single"), s = UP(i, function (c) { return t.get("name", c) }), l = []; return s.buckets.each(function (c, u) { c.sort(function (d, f) { return t.get(o, d) - t.get(o, f) }), l.push({ name: u, indices: c }) }), l }, e.prototype.getAxisTooltipData = function (t, r, i) { ke(t) || (t = t ? [t] : []); for (var a = this.getData(), o = this.getLayerSeries(), s = [], l = o.length, c, u = 0; u < l; ++u) { for (var d = Number.MAX_VALUE, f = -1, h = o[u].indices.length, p = 0; p < h; ++p) { var m = a.get(t[0], o[u].indices[p]), g = Math.abs(m - r); g <= d && (c = m, d = g, f = o[u].indices[p]) } s.push(f) } return { dataIndices: s, nestestValue: c } }, e.prototype.formatTooltip = function (t, r, i) { var a = this.getData(), o = a.getName(t), s = a.get(a.mapDimension("value"), t); return Gr("nameValue", { name: o, value: s }) }, e.type = "series.themeRiver", e.dependencies = ["singleAxis"], e.defaultOption = { z: 2, colorBy: "data", coordinateSystem: "singleAxis", boundaryGap: ["10%", "10%"], singleAxisIndex: 0, animationEasing: "linear", label: { margin: 4, show: !0, position: "left", fontSize: 11 }, emphasis: { label: { show: !0 } } }, e }(Yn); const BQe = NQe; function $Qe(n, e) { n.eachSeriesByType("themeRiver", function (t) { var r = t.getData(), i = t.coordinateSystem, a = {}, o = i.getRect(); a.rect = o; var s = t.get("boundaryGap"), l = i.getAxis(); if (a.boundaryGap = s, l.orient === "horizontal") { s[0] = Ne(s[0], o.height), s[1] = Ne(s[1], o.height); var c = o.height - s[0] - s[1]; TU(r, t, c) } else { s[0] = Ne(s[0], o.width), s[1] = Ne(s[1], o.width); var u = o.width - s[0] - s[1]; TU(r, t, u) } r.setLayout("layoutInfo", a) }) } function TU(n, e, t) { if (n.count()) for (var r = e.coordinateSystem, i = e.getLayerSeries(), a = n.mapDimension("single"), o = n.mapDimension("value"), s = Ae(i, function (g) { return Ae(g.indices, function (y) { var b = r.dataToPoint(n.get(a, y)); return b[1] = n.get(o, y), b }) }), l = FQe(s), c = l.y0, u = t / l.max, d = i.length, f = i[0].indices.length, h, p = 0; p < f; ++p) { h = c[p] * u, n.setItemLayout(i[0].indices[p], { layerIndex: 0, x: s[0][p][0], y0: h, y: s[0][p][1] * u }); for (var m = 1; m < d; ++m)h += s[m - 1][p][1] * u, n.setItemLayout(i[m].indices[p], { layerIndex: m, x: s[m][p][0], y0: h, y: s[m][p][1] * u }) } } function FQe(n) { for (var e = n.length, t = n[0].length, r = [], i = [], a = 0, o = 0; o < t; ++o) { for (var s = 0, l = 0; l < e; ++l)s += n[l][o][1]; s > a && (a = s), r.push(s) } for (var c = 0; c < t; ++c)i[c] = (a - r[c]) / 2; a = 0; for (var u = 0; u < t; ++u) { var d = r[u] + i[u]; d > a && (a = d) } return { y0: i, max: a } } function zQe(n) { n.registerChartView(RQe), n.registerSeriesModel(BQe), n.registerLayout($Qe), n.registerProcessor(Ib("themeRiver")) } var VQe = 2, HQe = 4, UQe = function (n) { te(e, n); function e(t, r, i, a) { var o = n.call(this) || this; o.z2 = VQe, o.textConfig = { inside: !0 }, pt(o).seriesIndex = r.seriesIndex; var s = new tn({ z2: HQe, silent: t.getModel().get(["label", "silent"]) }); return o.setTextContent(s), o.updateData(!0, t, r, i, a), o } return e.prototype.updateData = function (t, r, i, a, o) { this.node = r, r.piece = this, i = i || this._seriesModel, a = a || this._ecModel; var s = this; pt(s).dataIndex = r.dataIndex; var l = r.getModel(), c = l.getModel("emphasis"), u = r.getLayout(), d = be({}, u); d.label = null; var f = r.getVisual("style"); f.lineJoin = "bevel"; var h = r.getVisual("decal"); h && (f.decal = Ag(h, o)); var p = oh(l.getModel("itemStyle"), d, !0); be(d, p), $(ra, function (b) { var w = s.ensureState(b), v = l.getModel([b, "itemStyle"]); w.style = v.getItemStyle(); var S = oh(v, d); S && (w.shape = S) }), t ? (s.setShape(d), s.shape.r = u.r0, Un(s, { shape: { r: u.r } }, i, r.dataIndex)) : (on(s, { shape: d }, i), Ms(s)), s.useStyle(f), this._updateLabel(i); var m = l.getShallow("cursor"); m && s.attr("cursor", m), this._seriesModel = i || this._seriesModel, this._ecModel = a || this._ecModel; var g = c.get("focus"), y = g === "relative" ? u_(r.getAncestorsIndices(), r.getDescendantIndices()) : g === "ancestor" ? r.getAncestorsIndices() : g === "descendant" ? r.getDescendantIndices() : g; Qn(this, y, c.get("blurScope"), c.get("disabled")) }, e.prototype._updateLabel = function (t) { var r = this, i = this.node.getModel(), a = i.getModel("label"), o = this.node.getLayout(), s = o.endAngle - o.startAngle, l = (o.startAngle + o.endAngle) / 2, c = Math.cos(l), u = Math.sin(l), d = this, f = d.getTextContent(), h = this.node.dataIndex, p = a.get("minAngle") / 180 * Math.PI, m = a.get("show") && !(p != null && Math.abs(s) < p); f.ignore = !m, $(v_, function (y) { var b = y === "normal" ? i.getModel("label") : i.getModel([y, "label"]), w = y === "normal", v = w ? f : f.ensureState(y), S = t.getFormattedLabel(h, y); w && (S = S || r.node.name), v.style = Ln(b, {}, null, y !== "normal", !0), S && (v.style.text = S); var x = b.get("show"); x != null && !w && (v.ignore = !x); var k = g(b, "position"), A = w ? d : d.states[y], C = A.style.fill; A.textConfig = { outsideFill: b.get("color") === "inherit" ? C : null, inside: k !== "outside" }; var E, O = g(b, "distance") || 0, j = g(b, "align"), I = g(b, "rotate"), L = Math.PI * .5, R = Math.PI * 1.5, D = $a(I === "tangential" ? Math.PI / 2 - l : l), P = D > L && !p_(D - L) && D < R; k === "outside" ? (E = o.r + O, j = P ? "right" : "left") : !j || j === "center" ? (s === 2 * Math.PI && o.r0 === 0 ? E = 0 : E = (o.r + o.r0) / 2, j = "center") : j === "left" ? (E = o.r0 + O, j = P ? "right" : "left") : j === "right" && (E = o.r - O, j = P ? "left" : "right"), v.style.align = j, v.style.verticalAlign = g(b, "verticalAlign") || "middle", v.x = E * c + o.cx, v.y = E * u + o.cy; var B = 0; I === "radial" ? B = $a(-l) + (P ? Math.PI : 0) : I === "tangential" ? B = $a(Math.PI / 2 - l) + (P ? Math.PI : 0) : nn(I) && (B = I * Math.PI / 180), v.rotation = $a(B) }); function g(y, b) { var w = y.get(b); return w ?? a.get(b) } f.dirtyStyle() }, e }(Ca); const kU = UQe; var VI = "sunburstRootToNode", CU = "sunburstHighlight", GQe = "sunburstUnhighlight"; function WQe(n) { n.registerAction({ type: VI, update: "updateView" }, function (e, t) { t.eachComponent({ mainType: "series", subType: "sunburst", query: e }, r); function r(i, a) { var o = O_(e, [VI], i); if (o) { var s = i.getViewRoot(); s && (e.direction = $3(s, o.node) ? "rollUp" : "drillDown"), i.resetViewRoot(o.node) } } }), n.registerAction({ type: CU, update: "none" }, function (e, t, r) { e = be({}, e), t.eachComponent({ mainType: "series", subType: "sunburst", query: e }, i); function i(a) { var o = O_(e, [CU], a); o && (e.dataIndex = o.node.dataIndex) } r.dispatchAction(be(e, { type: "highlight" })) }), n.registerAction({ type: GQe, update: "updateView" }, function (e, t, r) { e = be({}, e), r.dispatchAction(be(e, { type: "downplay" })) }) } var KQe = function (n) { te(e, n); function e() { var t = n !== null && n.apply(this, arguments) || this; return t.type = e.type, t } return e.prototype.render = function (t, r, i, a) { var o = this; this.seriesModel = t, this.api = i, this.ecModel = r; var s = t.getData(), l = s.tree.root, c = t.getViewRoot(), u = this.group, d = t.get("renderLabelForZeroData"), f = []; c.eachNode(function (b) { f.push(b) }); var h = this._oldChildren || []; p(f, h), y(l, c), this._initEvents(), this._oldChildren = f; function p(b, w) { if (b.length === 0 && w.length === 0) return; new Lc(w, b, v, v).add(S).update(S).remove(wt(S, null)).execute(); function v(x) { return x.getId() } function S(x, k) { var A = x == null ? null : b[x], C = k == null ? null : w[k]; m(A, C) } } function m(b, w) { if (!d && b && !b.getValue() && (b = null), b !== l && w !== l) { if (w && w.piece) b ? (w.piece.updateData(!1, b, t, r, i), s.setItemGraphicEl(b.dataIndex, w.piece)) : g(w); else if (b) { var v = new kU(b, t, r, i); u.add(v), s.setItemGraphicEl(b.dataIndex, v) } } } function g(b) { b && b.piece && (u.remove(b.piece), b.piece = null) } function y(b, w) { w.depth > 0 ? (o.virtualPiece ? o.virtualPiece.updateData(!1, b, t, r, i) : (o.virtualPiece = new kU(b, t, r, i), u.add(o.virtualPiece)), w.piece.off("click"), o.virtualPiece.on("click", function (v) { o._rootToNode(w.parentNode) })) : o.virtualPiece && (u.remove(o.virtualPiece), o.virtualPiece = null) } }, e.prototype._initEvents = function () { var t = this; this.group.off("click"), this.group.on("click", function (r) { var i = !1, a = t.seriesModel.getViewRoot(); a.eachNode(function (o) { if (!i && o.piece && o.piece === r.target) { var s = o.getModel().get("nodeClick"); if (s === "rootToNode") t._rootToNode(o); else if (s === "link") { var l = o.getModel(), c = l.get("link"); if (c) { var u = l.get("target", !0) || "_blank"; rT(c, u) } } i = !0 } }) }) }, e.prototype._rootToNode = function (t) { t !== this.seriesModel.getViewRoot() && this.api.dispatchAction({ type: VI, from: this.uid, seriesId: this.seriesModel.id, targetNode: t }) }, e.prototype.containPoint = function (t, r) { var i = r.getData(), a = i.getItemLayout(0); if (a) { var o = t[0] - a.cx, s = t[1] - a.cy, l = Math.sqrt(o * o + s * s); return l <= a.r && l >= a.r0 } }, e.type = "sunburst", e }(Nn); const qQe = KQe; var YQe = function (n) { te(e, n); function e() { var t = n !== null && n.apply(this, arguments) || this; return t.type = e.type, t.ignoreStyleOnData = !0, t } return e.prototype.getInitialData = function (t, r) { var i = { name: t.name, children: t.data }; voe(i); var a = this._levelModels = Ae(t.levels || [], function (l) { return new Rn(l, this, r) }, this), o = B3.createTree(i, this, s); function s(l) { l.wrapMethod("getItemModel", function (c, u) { var d = o.getNodeByDataIndex(u), f = a[d.depth]; return f && (c.parentModel = f), c }) } return o.data }, e.prototype.optionUpdated = function () { this.resetViewRoot() }, e.prototype.getDataParams = function (t) { var r = n.prototype.getDataParams.apply(this, arguments), i = this.getData().tree.getNodeByDataIndex(t); return r.treePathInfo = CC(i, this), r }, e.prototype.getLevelModel = function (t) { return this._levelModels && this._levelModels[t.depth] }, e.prototype.getViewRoot = function () { return this._viewRoot }, e.prototype.resetViewRoot = function (t) { t ? this._viewRoot = t : t = this._viewRoot; var r = this.getRawData().tree.root; (!t || t !== r && !r.contains(t)) && (this._viewRoot = r) }, e.prototype.enableAriaDecal = function () { wae(this) }, e.type = "series.sunburst", e.defaultOption = { z: 2, center: ["50%", "50%"], radius: [0, "75%"], clockwise: !0, startAngle: 90, minAngle: 0, stillShowZeroSum: !0, nodeClick: "rootToNode", renderLabelForZeroData: !1, label: { rotate: "radial", show: !0, opacity: 1, align: "center", position: "inside", distance: 5, silent: !0 }, itemStyle: { borderWidth: 1, borderColor: "white", borderType: "solid", shadowBlur: 0, shadowColor: "rgba(0, 0, 0, 0.2)", shadowOffsetX: 0, shadowOffsetY: 0, opacity: 1 }, emphasis: { focus: "descendant" }, blur: { itemStyle: { opacity: .2 }, label: { opacity: .1 } }, animationType: "expansion", animationDuration: 1e3, animationDurationUpdate: 500, data: [], sort: "desc" }, e }(Yn); function voe(n) { var e = 0; $(n.children, function (r) { voe(r); var i = r.value; ke(i) && (i = i[0]), e += i }); var t = n.value; ke(t) && (t = t[0]), (t == null || isNaN(t)) && (t = e), t < 0 && (t = 0), ke(n.value) ? n.value[0] = t : n.value = t } const ZQe = YQe; var AU = Math.PI / 180; function XQe(n, e, t) { e.eachSeriesByType(n, function (r) { var i = r.get("center"), a = r.get("radius"); ke(a) || (a = [0, a]), ke(i) || (i = [i, i]); var o = t.getWidth(), s = t.getHeight(), l = Math.min(o, s), c = Ne(i[0], o), u = Ne(i[1], s), d = Ne(a[0], l / 2), f = Ne(a[1], l / 2), h = -r.get("startAngle") * AU, p = r.get("minAngle") * AU, m = r.getData().tree.root, g = r.getViewRoot(), y = g.depth, b = r.get("sort"); b != null && yoe(g, b); var w = 0; $(g.children, function (D) { !isNaN(D.getValue()) && w++ }); var v = g.getValue(), S = Math.PI / (v || w) * 2, x = g.depth > 0, k = g.height - (x ? -1 : 1), A = (f - d) / (k || 1), C = r.get("clockwise"), E = r.get("stillShowZeroSum"), O = C ? 1 : -1, j = function (D, P) { if (D) { var B = P; if (D !== m) { var F = D.getValue(), K = v === 0 && E ? S : F * S; K < p && (K = p), B = P + O * K; var V = D.depth - y - (x ? -1 : 1), W = d + A * V, J = d + A * (V + 1), ie = r.getLevelModel(D); if (ie) { var le = ie.get("r0", !0), De = ie.get("r", !0), ae = ie.get("radius", !0); ae != null && (le = ae[0], De = ae[1]), le != null && (W = Ne(le, l / 2)), De != null && (J = Ne(De, l / 2)) } D.setLayout({ angle: K, startAngle: P, endAngle: B, clockwise: C, cx: c, cy: u, r0: W, r: J }) } if (D.children && D.children.length) { var pe = 0; $(D.children, function (se) { pe += j(se, P + pe) }) } return B - P } }; if (x) { var I = d, L = d + A, R = Math.PI * 2; m.setLayout({ angle: R, startAngle: h, endAngle: h + R, clockwise: C, cx: c, cy: u, r0: I, r: L }) } j(g, h) }) } function yoe(n, e) { var t = n.children || []; n.children = JQe(t, e), t.length && $(n.children, function (r) { yoe(r, e) }) } function JQe(n, e) { if (tt(e)) { var t = Ae(n, function (i, a) { var o = i.getValue(); return { params: { depth: i.depth, height: i.height, dataIndex: i.dataIndex, getValue: function () { return o } }, index: a } }); return t.sort(function (i, a) { return e(i.params, a.params) }), Ae(t, function (i) { return n[i.index] }) } else { var r = e === "asc"; return n.sort(function (i, a) { var o = (i.getValue() - a.getValue()) * (r ? 1 : -1); return o === 0 ? (i.dataIndex - a.dataIndex) * (r ? -1 : 1) : o }) } } function QQe(n) { var e = {}; function t(r, i, a) { for (var o = r; o && o.depth > 1;)o = o.parentNode; var s = i.getColorFromPalette(o.name || o.dataIndex + "", e); return r.depth > 1 && Fe(s) && (s = jP(s, (r.depth - 1) / (a - 1) * .5)), s } n.eachSeriesByType("sunburst", function (r) { var i = r.getData(), a = i.tree; a.eachNode(function (o) { var s = o.getModel(), l = s.getModel("itemStyle").getItemStyle(); l.fill || (l.fill = t(o, r, a.root.height)); var c = i.ensureUniqueItemVisual(o.dataIndex, "style"); be(c, l) }) }) } function eet(n) { n.registerChartView(qQe), n.registerSeriesModel(ZQe), n.registerLayout(wt(XQe, "sunburst")), n.registerProcessor(wt(Ib, "sunburst")), n.registerVisual(QQe), WQe(n) } var EU = { color: "fill", borderColor: "stroke" }, tet = { symbol: 1, symbolSize: 1, symbolKeepAspect: 1, legendIcon: 1, visualMeta: 1, liftZ: 1, decal: 1 }, xc = Kt(), net = function (n) { te(e, n); function e() { var t = n !== null && n.apply(this, arguments) || this; return t.type = e.type, t } return e.prototype.optionUpdated = function () { this.currentZLevel = this.get("zlevel", !0), this.currentZ = this.get("z", !0) }, e.prototype.getInitialData = function (t, r) { return Hc(null, this) }, e.prototype.getDataParams = function (t, r, i) { var a = n.prototype.getDataParams.call(this, t, r); return i && (a.info = xc(i).info), a }, e.type = "series.custom", e.dependencies = ["grid", "polar", "geo", "singleAxis", "calendar"], e.defaultOption = { coordinateSystem: "cartesian2d", z: 2, legendHoverLink: !0, clip: !1 }, e }(Yn); const ret = net; function iet(n, e) { return e = e || [0, 0], Ae(["x", "y"], function (t, r) { var i = this.getAxis(t), a = e[r], o = n[r] / 2; return i.type === "category" ? i.getBandWidth() : Math.abs(i.dataToCoord(a - o) - i.dataToCoord(a + o)) }, this) } function aet(n) { var e = n.master.getRect(); return { coordSys: { type: "cartesian2d", x: e.x, y: e.y, width: e.width, height: e.height }, api: { coord: function (t) { return n.dataToPoint(t) }, size: He(iet, n) } } } function oet(n, e) { return e = e || [0, 0], Ae([0, 1], function (t) { var r = e[t], i = n[t] / 2, a = [], o = []; return a[t] = r - i, o[t] = r + i, a[1 - t] = o[1 - t] = e[1 - t], Math.abs(this.dataToPoint(a)[t] - this.dataToPoint(o)[t]) }, this) } function set(n) { var e = n.getBoundingRect(); return { coordSys: { type: "geo", x: e.x, y: e.y, width: e.width, height: e.height, zoom: n.getZoom() }, api: { coord: function (t) { return n.dataToPoint(t) }, size: He(oet, n) } } } function cet(n, e) { var t = this.getAxis(), r = e instanceof Array ? e[0] : e, i = (n instanceof Array ? n[0] : n) / 2; return t.type === "category" ? t.getBandWidth() : Math.abs(t.dataToCoord(r - i) - t.dataToCoord(r + i)) } function uet(n) { var e = n.getRect(); return { coordSys: { type: "singleAxis", x: e.x, y: e.y, width: e.width, height: e.height }, api: { coord: function (t) { return n.dataToPoint(t) }, size: He(cet, n) } } } function det(n, e) { return e = e || [0, 0], Ae(["Radius", "Angle"], function (t, r) { var i = "get" + t + "Axis", a = this[i](), o = e[r], s = n[r] / 2, l = a.type === "category" ? a.getBandWidth() : Math.abs(a.dataToCoord(o - s) - a.dataToCoord(o + s)); return t === "Angle" && (l = l * Math.PI / 180), l }, this) } function fet(n) { var e = n.getRadiusAxis(), t = n.getAngleAxis(), r = e.getExtent(); return r[0] > r[1] && r.reverse(), { coordSys: { type: "polar", cx: n.cx, cy: n.cy, r: r[1], r0: r[0] }, api: { coord: function (i) { var a = e.dataToRadius(i[0]), o = t.dataToAngle(i[1]), s = n.coordToPoint([a, o]); return s.push(a, o * Math.PI / 180), s }, size: He(det, n) } } } function het(n) { var e = n.getRect(), t = n.getRangeInfo(); return { coordSys: { type: "calendar", x: e.x, y: e.y, width: e.width, height: e.height, cellWidth: n.getCellWidth(), cellHeight: n.getCellHeight(), rangeInfo: { start: t.start, end: t.end, weeks: t.weeks, dayCount: t.allDay } }, api: { coord: function (r, i) { return n.dataToPoint(r, i) } } } } function _oe(n, e, t, r) { return n && (n.legacy || n.legacy !== !1 && !t && !r && e !== "tspan" && (e === "text" || Ge(n, "text"))) } function boe(n, e, t) { var r = n, i, a, o; if (e === "text") o = r; else { o = {}, Ge(r, "text") && (o.text = r.text), Ge(r, "rich") && (o.rich = r.rich), Ge(r, "textFill") && (o.fill = r.textFill), Ge(r, "textStroke") && (o.stroke = r.textStroke), Ge(r, "fontFamily") && (o.fontFamily = r.fontFamily), Ge(r, "fontSize") && (o.fontSize = r.fontSize), Ge(r, "fontStyle") && (o.fontStyle = r.fontStyle), Ge(r, "fontWeight") && (o.fontWeight = r.fontWeight), a = { type: "text", style: o, silent: !0 }, i = {}; var s = Ge(r, "textPosition"); t ? i.position = s ? r.textPosition : "inside" : s && (i.position = r.textPosition), Ge(r, "textPosition") && (i.position = r.textPosition), Ge(r, "textOffset") && (i.offset = r.textOffset), Ge(r, "textRotation") && (i.rotation = r.textRotation), Ge(r, "textDistance") && (i.distance = r.textDistance) } return MU(o, n), $(o.rich, function (l) { MU(l, l) }), { textConfig: i, textContent: a } } function MU(n, e) { e && (e.font = e.textFont || e.font, Ge(e, "textStrokeWidth") && (n.lineWidth = e.textStrokeWidth), Ge(e, "textAlign") && (n.align = e.textAlign), Ge(e, "textVerticalAlign") && (n.verticalAlign = e.textVerticalAlign), Ge(e, "textLineHeight") && (n.lineHeight = e.textLineHeight), Ge(e, "textWidth") && (n.width = e.textWidth), Ge(e, "textHeight") && (n.height = e.textHeight), Ge(e, "textBackgroundColor") && (n.backgroundColor = e.textBackgroundColor), Ge(e, "textPadding") && (n.padding = e.textPadding), Ge(e, "textBorderColor") && (n.borderColor = e.textBorderColor), Ge(e, "textBorderWidth") && (n.borderWidth = e.textBorderWidth), Ge(e, "textBorderRadius") && (n.borderRadius = e.textBorderRadius), Ge(e, "textBoxShadowColor") && (n.shadowColor = e.textBoxShadowColor), Ge(e, "textBoxShadowBlur") && (n.shadowBlur = e.textBoxShadowBlur), Ge(e, "textBoxShadowOffsetX") && (n.shadowOffsetX = e.textBoxShadowOffsetX), Ge(e, "textBoxShadowOffsetY") && (n.shadowOffsetY = e.textBoxShadowOffsetY)) } function OU(n, e, t) { var r = n; r.textPosition = r.textPosition || t.position || "inside", t.offset != null && (r.textOffset = t.offset), t.rotation != null && (r.textRotation = t.rotation), t.distance != null && (r.textDistance = t.distance); var i = r.textPosition.indexOf("inside") >= 0, a = n.fill || "#000"; DU(r, e); var o = r.textFill == null; return i ? o && (r.textFill = t.insideFill || "#fff", !r.textStroke && t.insideStroke && (r.textStroke = t.insideStroke), !r.textStroke && (r.textStroke = a), r.textStrokeWidth == null && (r.textStrokeWidth = 2)) : (o && (r.textFill = n.fill || t.outsideFill || "#000"), !r.textStroke && t.outsideStroke && (r.textStroke = t.outsideStroke)), r.text = e.text, r.rich = e.rich, $(e.rich, function (s) { DU(s, s) }), r } function DU(n, e) { e && (Ge(e, "fill") && (n.textFill = e.fill), Ge(e, "stroke") && (n.textStroke = e.fill), Ge(e, "lineWidth") && (n.textStrokeWidth = e.lineWidth), Ge(e, "font") && (n.font = e.font), Ge(e, "fontStyle") && (n.fontStyle = e.fontStyle), Ge(e, "fontWeight") && (n.fontWeight = e.fontWeight), Ge(e, "fontSize") && (n.fontSize = e.fontSize), Ge(e, "fontFamily") && (n.fontFamily = e.fontFamily), Ge(e, "align") && (n.textAlign = e.align), Ge(e, "verticalAlign") && (n.textVerticalAlign = e.verticalAlign), Ge(e, "lineHeight") && (n.textLineHeight = e.lineHeight), Ge(e, "width") && (n.textWidth = e.width), Ge(e, "height") && (n.textHeight = e.height), Ge(e, "backgroundColor") && (n.textBackgroundColor = e.backgroundColor), Ge(e, "padding") && (n.textPadding = e.padding), Ge(e, "borderColor") && (n.textBorderColor = e.borderColor), Ge(e, "borderWidth") && (n.textBorderWidth = e.borderWidth), Ge(e, "borderRadius") && (n.textBorderRadius = e.borderRadius), Ge(e, "shadowColor") && (n.textBoxShadowColor = e.shadowColor), Ge(e, "shadowBlur") && (n.textBoxShadowBlur = e.shadowBlur), Ge(e, "shadowOffsetX") && (n.textBoxShadowOffsetX = e.shadowOffsetX), Ge(e, "shadowOffsetY") && (n.textBoxShadowOffsetY = e.shadowOffsetY), Ge(e, "textShadowColor") && (n.textShadowColor = e.textShadowColor), Ge(e, "textShadowBlur") && (n.textShadowBlur = e.textShadowBlur), Ge(e, "textShadowOffsetX") && (n.textShadowOffsetX = e.textShadowOffsetX), Ge(e, "textShadowOffsetY") && (n.textShadowOffsetY = e.textShadowOffsetY)) } var woe = { position: ["x", "y"], scale: ["scaleX", "scaleY"], origin: ["originX", "originY"] }, jU = Bt(woe); xl(Tl, function (n, e) { return n[e] = 1, n }, {}); Tl.join(", "); var TT = ["", "style", "shape", "extra"], jg = Kt(); function rB(n, e, t, r, i) { var a = n + "Animation", o = Xg(n, r, i) || {}, s = jg(e).userDuring; return o.duration > 0 && (o.during = s ? He(yet, { el: e, userDuring: s }) : null, o.setToFinal = !0, o.scope = n), be(o, t[a]), o } function cS(n, e, t, r) { r = r || {}; var i = r.dataIndex, a = r.isInit, o = r.clearStyle, s = t.isAnimationEnabled(), l = jg(n), c = e.style; l.userDuring = e.during; var u = {}, d = {}; if (bet(n, e, d), IU("shape", e, d), IU("extra", e, d), !a && s && (_et(n, e, u), PU("shape", n, e, u), PU("extra", n, e, u), wet(n, e, c, u)), d.style = c, pet(n, d, o), get(n, e), s) if (a) { var f = {}; $(TT, function (p) { var m = p ? e[p] : e; m && m.enterFrom && (p && (f[p] = f[p] || {}), be(p ? f[p] : f, m.enterFrom)) }); var h = rB("enter", n, e, t, i); h.duration > 0 && n.animateFrom(f, h) } else met(n, e, i || 0, t, u); xoe(n, e), c ? n.dirty() : n.markRedraw() } function xoe(n, e) { for (var t = jg(n).leaveToProps, r = 0; r < TT.length; r++) { var i = TT[r], a = i ? e[i] : e; a && a.leaveTo && (t || (t = jg(n).leaveToProps = {}), i && (t[i] = t[i] || {}), be(i ? t[i] : t, a.leaveTo)) } } function MC(n, e, t, r) { if (n) { var i = n.parent, a = jg(n).leaveToProps; if (a) { var o = rB("update", n, e, t, 0); o.done = function () { i.remove(n), r && r() }, n.animateTo(a, o) } else i.remove(n), r && r() } } function Mh(n) { return n === "all" } function pet(n, e, t) { var r = e.style; if (!n.isGroup && r) { if (t) { n.useStyle({}); for (var i = n.animators, a = 0; a < i.length; a++) { var o = i[a]; o.targetName === "style" && o.changeTarget(n.style) } } n.setStyle(r) } e && (e.style = null, e && n.attr(e), e.style = r) } function met(n, e, t, r, i) { if (i) { var a = rB("update", n, e, r, t); a.duration > 0 && n.animateFrom(i, a) } } function get(n, e) { Ge(e, "silent") && (n.silent = e.silent), Ge(e, "ignore") && (n.ignore = e.ignore), n instanceof Ho && Ge(e, "invisible") && (n.invisible = e.invisible), n instanceof Nt && Ge(e, "autoBatch") && (n.autoBatch = e.autoBatch) } var Us = {}, vet = { setTransform: function (n, e) { return Us.el[n] = e, this }, getTransform: function (n) { return Us.el[n] }, setShape: function (n, e) { var t = Us.el, r = t.shape || (t.shape = {}); return r[n] = e, t.dirtyShape && t.dirtyShape(), this }, getShape: function (n) { var e = Us.el.shape; if (e) return e[n] }, setStyle: function (n, e) { var t = Us.el, r = t.style; return r && (r[n] = e, t.dirtyStyle && t.dirtyStyle()), this }, getStyle: function (n) { var e = Us.el.style; if (e) return e[n] }, setExtra: function (n, e) { var t = Us.el.extra || (Us.el.extra = {}); return t[n] = e, this }, getExtra: function (n) { var e = Us.el.extra; if (e) return e[n] } }; function yet() { var n = this, e = n.el; if (e) { var t = jg(e).userDuring, r = n.userDuring; if (t !== r) { n.el = n.userDuring = null; return } Us.el = e, r(vet) } } function PU(n, e, t, r) { var i = t[n]; if (i) { var a = e[n], o; if (a) { var s = t.transition, l = i.transition; if (l) if (!o && (o = r[n] = {}), Mh(l)) be(o, a); else for (var c = Cn(l), u = 0; u < c.length; u++) { var d = c[u], f = a[d]; o[d] = f } else if (Mh(s) || Et(s, n) >= 0) { !o && (o = r[n] = {}); for (var h = Bt(a), u = 0; u < h.length; u++) { var d = h[u], f = a[d]; xet(i[d], f) && (o[d] = f) } } } } } function IU(n, e, t) { var r = e[n]; if (r) for (var i = t[n] = {}, a = Bt(r), o = 0; o < a.length; o++) { var s = a[o]; i[s] = d0(r[s]) } } function _et(n, e, t) { for (var r = e.transition, i = Mh(r) ? Tl : Cn(r || []), a = 0; a < i.length; a++) { var o = i[a]; if (!(o === "style" || o === "shape" || o === "extra")) { var s = n[o]; t[o] = s } } } function bet(n, e, t) { for (var r = 0; r < jU.length; r++) { var i = jU[r], a = woe[i], o = e[i]; o && (t[a[0]] = o[0], t[a[1]] = o[1]) } for (var r = 0; r < Tl.length; r++) { var s = Tl[r]; e[s] != null && (t[s] = e[s]) } } function wet(n, e, t, r) { if (t) { var i = n.style, a; if (i) { var o = t.transition, s = e.transition; if (o && !Mh(o)) { var l = Cn(o); !a && (a = r.style = {}); for (var c = 0; c < l.length; c++) { var u = l[c], d = i[u]; a[u] = d } } else if (n.getAnimationStyleProps && (Mh(s) || Mh(o) || Et(s, "style") >= 0)) { var f = n.getAnimationStyleProps(), h = f ? f.style : null; if (h) { !a && (a = r.style = {}); for (var p = Bt(t), c = 0; c < p.length; c++) { var u = p[c]; if (h[u]) { var d = i[u]; a[u] = d } } } } } } } function xet(n, e) { return Ii(n) ? n !== e : n != null && isFinite(n) } var Soe = Kt(), Tet = ["percent", "easing", "shape", "style", "extra"]; function Toe(n) { n.stopAnimation("keyframe"), n.attr(Soe(n)) } function kT(n, e, t) { if (!(!t.isAnimationEnabled() || !e)) { if (ke(e)) { $(e, function (s) { kT(n, s, t) }); return } var r = e.keyframes, i = e.duration; if (t && i == null) { var a = Xg("enter", t, 0); i = a && a.duration } if (!(!r || !i)) { var o = Soe(n); $(TT, function (s) { if (!(s && !n[s])) { var l; r.sort(function (c, u) { return c.percent - u.percent }), $(r, function (c) { var u = n.animators, d = s ? c[s] : c; if (d) { var f = Bt(d); if (s || (f = pn(f, function (m) { return Et(Tet, m) < 0 })), !!f.length) { l || (l = n.animate(s, e.loop, !0), l.scope = "keyframe"); for (var h = 0; h < u.length; h++)u[h] !== l && u[h].targetName === l.targetName && u[h].stopTracks(f); s && (o[s] = o[s] || {}); var p = s ? o[s] : o; $(f, function (m) { p[m] = ((s ? n[s] : n) || {})[m] }), l.whenWithKeys(i * c.percent, d, f, c.easing) } } }), l && l.delay(e.delay || 0).duration(i).start(e.easing) } }) } } } var Sc = "emphasis", Zu = "normal", iB = "blur", aB = "select", jd = [Zu, Sc, iB, aB], nD = { normal: ["itemStyle"], emphasis: [Sc, "itemStyle"], blur: [iB, "itemStyle"], select: [aB, "itemStyle"] }, rD = { normal: ["label"], emphasis: [Sc, "label"], blur: [iB, "label"], select: [aB, "label"] }, ket = ["x", "y"], Cet = "e\0\0", fo = { normal: {}, emphasis: {}, blur: {}, select: {} }, Aet = { cartesian2d: aet, geo: set, single: uet, polar: fet, calendar: het }; function HI(n) { return n instanceof Nt } function UI(n) { return n instanceof Ho } function Eet(n, e) { e.copyTransform(n), UI(e) && UI(n) && (e.setStyle(n.style), e.z = n.z, e.z2 = n.z2, e.zlevel = n.zlevel, e.invisible = n.invisible, e.ignore = n.ignore, HI(e) && HI(n) && e.setShape(n.shape)) } var Met = function (n) { te(e, n); function e() { var t = n !== null && n.apply(this, arguments) || this; return t.type = e.type, t } return e.prototype.render = function (t, r, i, a) { this._progressiveEls = null; var o = this._data, s = t.getData(), l = this.group, c = LU(t, s, r, i); o || l.removeAll(), s.diff(o).add(function (d) { iD(i, null, d, c(d, a), t, l, s) }).remove(function (d) { var f = o.getItemGraphicEl(d); f && MC(f, xc(f).option, t) }).update(function (d, f) { var h = o.getItemGraphicEl(f); iD(i, h, d, c(d, a), t, l, s) }).execute(); var u = t.get("clip", !0) ? jb(t.coordinateSystem, !1, t) : null; u ? l.setClipPath(u) : l.removeClipPath(), this._data = s }, e.prototype.incrementalPrepareRender = function (t, r, i) { this.group.removeAll(), this._data = null }, e.prototype.incrementalRender = function (t, r, i, a, o) { var s = r.getData(), l = LU(r, s, i, a), c = this._progressiveEls = []; function u(h) { h.isGroup || (h.incremental = !0, h.ensureState("emphasis").hoverLayer = !0) } for (var d = t.start; d < t.end; d++) { var f = iD(null, null, d, l(d, o), r, this.group, s); f && (f.traverse(u), c.push(f)) } }, e.prototype.eachRendered = function (t) { Gd(this._progressiveEls || this.group, t) }, e.prototype.filterForExposedEvent = function (t, r, i, a) { var o = r.element; if (o == null || i.name === o) return !0; for (; (i = i.__hostTarget || i.parent) && i !== this.group;)if (i.name === o) return !0; return !1 }, e.type = "custom", e }(Nn); const Oet = Met; function oB(n) { var e = n.type, t; if (e === "path") { var r = n.shape, i = r.width != null && r.height != null ? { x: r.x || 0, y: r.y || 0, width: r.width, height: r.height } : null, a = Aoe(r); t = aC(a, null, i, r.layout || "center"), xc(t).customPathData = a } else if (e === "image") t = new gi({}), xc(t).customImagePath = n.style.image; else if (e === "text") t = new tn({}); else if (e === "group") t = new ft; else { if (e === "compoundPath") throw new Error('"compoundPath" is not supported yet.'); var o = WN(e); if (!o) { var s = ""; hn(s) } t = new o } return xc(t).customGraphicType = e, t.name = n.name, t.z2EmphasisLift = 1, t.z2SelectLift = 1, t } function sB(n, e, t, r, i, a, o) { Toe(e); var s = i && i.normal.cfg; s && e.setTextConfig(s), r && r.transition == null && (r.transition = ket); var l = r && r.style; if (l) { if (e.type === "text") { var c = l; Ge(c, "textFill") && (c.fill = c.textFill), Ge(c, "textStroke") && (c.stroke = c.textStroke) } var u = void 0, d = HI(e) ? l.decal : null; n && d && (d.dirty = !0, u = Ag(d, n)), l.__decalPattern = u } if (UI(e) && l) { var u = l.__decalPattern; u && (l.decal = u) } cS(e, r, a, { dataIndex: t, isInit: o, clearStyle: !0 }), kT(e, r.keyframeAnimation, a) } function koe(n, e, t, r, i) { var a = e.isGroup ? null : e, o = i && i[n].cfg; if (a) { var s = a.ensureState(n); if (r === !1) { var l = a.getState(n); l && (l.style = null) } else s.style = r || null; o && (s.textConfig = o), Gh(a) } } function Det(n, e, t) { if (!n.isGroup) { var r = n, i = t.currentZ, a = t.currentZLevel; r.z = i, r.zlevel = a; var o = e.z2; o != null && (r.z2 = o || 0); for (var s = 0; s < jd.length; s++)jet(r, e, jd[s]) } } function jet(n, e, t) { var r = t === Zu, i = r ? e : CT(e, t), a = i ? i.z2 : null, o; a != null && (o = r ? n : n.ensureState(t), o.z2 = a || 0) } function LU(n, e, t, r) { var i = n.get("renderItem"), a = n.coordinateSystem, o = {}; a && (o = a.prepareCustoms ? a.prepareCustoms(a) : Aet[a.type](a)); for (var s = rt({ getWidth: r.getWidth, getHeight: r.getHeight, getZr: r.getZr, getDevicePixelRatio: r.getDevicePixelRatio, value: v, style: x, ordinalRawValue: S, styleEmphasis: k, visual: E, barLayout: O, currentSeriesIndices: j, font: I }, o.api || {}), l = { context: {}, seriesId: n.id, seriesName: n.name, seriesIndex: n.seriesIndex, coordSys: o.coordSys, dataInsideLength: e.count(), encode: Pet(n.getData()) }, c, u, d = {}, f = {}, h = {}, p = {}, m = 0; m < jd.length; m++) { var g = jd[m]; h[g] = n.getModel(nD[g]), p[g] = n.getModel(rD[g]) } function y(L) { return L === c ? u || (u = e.getItemModel(L)) : e.getItemModel(L) } function b(L, R) { return e.hasItemOption ? L === c ? d[R] || (d[R] = y(L).getModel(nD[R])) : y(L).getModel(nD[R]) : h[R] } function w(L, R) { return e.hasItemOption ? L === c ? f[R] || (f[R] = y(L).getModel(rD[R])) : y(L).getModel(rD[R]) : p[R] } return function (L, R) { return c = L, u = null, d = {}, f = {}, i && i(rt({ dataIndexInside: L, dataIndex: e.getRawIndex(L), actionType: R ? R.type : null }, l), s) }; function v(L, R) { return R == null && (R = c), e.getStore().get(e.getDimensionIndex(L || 0), R) } function S(L, R) { R == null && (R = c), L = L || 0; var D = e.getDimensionInfo(L); if (!D) { var P = e.getDimensionIndex(L); return P >= 0 ? e.getStore().get(P, R) : void 0 } var B = e.get(D.name, R), F = D && D.ordinalMeta; return F ? F.categories[B] : B } function x(L, R) { R == null && (R = c); var D = e.getItemVisual(R, "style"), P = D && D.fill, B = D && D.opacity, F = b(R, Zu).getItemStyle(); P != null && (F.fill = P), B != null && (F.opacity = B); var K = { inheritColor: Fe(P) ? P : "#000" }, V = w(R, Zu), W = Ln(V, null, K, !1, !0); W.text = V.getShallow("show") ? yt(n.getFormattedLabel(R, Zu), Mg(e, R)) : null; var J = tT(V, K, !1); return C(L, F), F = OU(F, W, J), L && A(F, L), F.legacy = !0, F } function k(L, R) { R == null && (R = c); var D = b(R, Sc).getItemStyle(), P = w(R, Sc), B = Ln(P, null, null, !0, !0); B.text = P.getShallow("show") ? pl(n.getFormattedLabel(R, Sc), n.getFormattedLabel(R, Zu), Mg(e, R)) : null; var F = tT(P, null, !0); return C(L, D), D = OU(D, B, F), L && A(D, L), D.legacy = !0, D } function A(L, R) { for (var D in R) Ge(R, D) && (L[D] = R[D]) } function C(L, R) { L && (L.textFill && (R.textFill = L.textFill), L.textPosition && (R.textPosition = L.textPosition)) } function E(L, R) { if (R == null && (R = c), Ge(EU, L)) { var D = e.getItemVisual(R, "style"); return D ? D[EU[L]] : null } if (Ge(tet, L)) return e.getItemVisual(R, L) } function O(L) { if (a.type === "cartesian2d") { var R = a.getBaseAxis(); return D7e(rt({ axis: R }, L)) } } function j() { return t.getCurrentSeriesIndices() } function I(L) { return KN(L, t) } } function Pet(n) { var e = {}; return $(n.dimensions, function (t) { var r = n.getDimensionInfo(t); if (!r.isExtraCoord) { var i = r.coordDim, a = e[i] = e[i] || []; a[r.coordDimIndex] = n.getDimensionIndex(t) } }), e } function iD(n, e, t, r, i, a, o) { if (!r) { a.remove(e); return } var s = lB(n, e, t, r, i, a); return s && o.setItemGraphicEl(t, s), s && Qn(s, r.focus, r.blurScope, r.emphasisDisabled), s } function lB(n, e, t, r, i, a) { var o = -1, s = e; e && Coe(e, r, i) && (o = Et(a.childrenRef(), e), e = null); var l = !e, c = e; c ? c.clearStates() : (c = oB(r), s && Eet(s, c)), r.morph === !1 ? c.disableMorphing = !0 : c.disableMorphing && (c.disableMorphing = !1), fo.normal.cfg = fo.normal.conOpt = fo.emphasis.cfg = fo.emphasis.conOpt = fo.blur.cfg = fo.blur.conOpt = fo.select.cfg = fo.select.conOpt = null, fo.isLegacy = !1, Let(c, t, r, i, l, fo), Iet(c, t, r, i, l), sB(n, c, t, r, fo, i, l), Ge(r, "info") && (xc(c).info = r.info); for (var u = 0; u < jd.length; u++) { var d = jd[u]; if (d !== Zu) { var f = CT(r, d), h = cB(r, f, d); koe(d, c, f, h, fo) } } return Det(c, r, i), r.type === "group" && Ret(n, c, t, r, i), o >= 0 ? a.replaceAt(c, o) : a.add(c), c } function Coe(n, e, t) { var r = xc(n), i = e.type, a = e.shape, o = e.style; return t.isUniversalTransitionEnabled() || i != null && i !== r.customGraphicType || i === "path" && Fet(a) && Aoe(a) !== r.customPathData || i === "image" && Ge(o, "image") && o.image !== r.customImagePath } function Iet(n, e, t, r, i) { var a = t.clipPath; if (a === !1) n && n.getClipPath() && n.removeClipPath(); else if (a) { var o = n.getClipPath(); o && Coe(o, a, r) && (o = null), o || (o = oB(a), n.setClipPath(o)), sB(null, o, e, a, null, r, i) } } function Let(n, e, t, r, i, a) { if (!n.isGroup) { RU(t, null, a), RU(t, Sc, a); var o = a.normal.conOpt, s = a.emphasis.conOpt, l = a.blur.conOpt, c = a.select.conOpt; if (o != null || s != null || c != null || l != null) { var u = n.getTextContent(); if (o === !1) u && n.removeTextContent(); else { o = a.normal.conOpt = o || { type: "text" }, u ? u.clearStates() : (u = oB(o), n.setTextContent(u)), sB(null, u, e, o, null, r, i); for (var d = o && o.style, f = 0; f < jd.length; f++) { var h = jd[f]; if (h !== Zu) { var p = a[h].conOpt; koe(h, u, p, cB(o, p, h), null) } } d ? u.dirty() : u.markRedraw() } } } } function RU(n, e, t) { var r = e ? CT(n, e) : n, i = e ? cB(n, r, Sc) : n.style, a = n.type, o = r ? r.textConfig : null, s = n.textContent, l = s ? e ? CT(s, e) : s : null; if (i && (t.isLegacy || _oe(i, a, !!o, !!l))) { t.isLegacy = !0; var c = boe(i, a, !e); !o && c.textConfig && (o = c.textConfig), !l && c.textContent && (l = c.textContent) } if (!e && l) { var u = l; !u.type && (u.type = "text") } var d = e ? t[e] : t.normal; d.cfg = o, d.conOpt = l } function CT(n, e) { return e ? n ? n[e] : null : n } function cB(n, e, t) { var r = e && e.style; return r == null && t === Sc && n && (r = n.styleEmphasis), r } function Ret(n, e, t, r, i) { var a = r.children, o = a ? a.length : 0, s = r.$mergeChildren, l = s === "byName" || r.diffChildrenByName, c = s === !1; if (!(!o && !l && !c)) { if (l) { Bet({ api: n, oldChildren: e.children() || [], newChildren: a || [], dataIndex: t, seriesModel: i, group: e }); return } c && e.removeAll(); for (var u = 0; u < o; u++) { var d = a[u], f = e.childAt(u); d ? (d.ignore == null && (d.ignore = !1), lB(n, f, t, d, i, e)) : f.ignore = !0 } for (var h = e.childCount() - 1; h >= u; h--) { var p = e.childAt(h); Net(e, p, i) } } } function Net(n, e, t) { e && MC(e, xc(n).option, t) } function Bet(n) { new Lc(n.oldChildren, n.newChildren, NU, NU, n).add(BU).update(BU).remove($et).execute() } function NU(n, e) { var t = n && n.name; return t ?? Cet + e } function BU(n, e) { var t = this.context, r = n != null ? t.newChildren[n] : null, i = e != null ? t.oldChildren[e] : null; lB(t.api, i, t.dataIndex, r, t.seriesModel, t.group) } function $et(n) { var e = this.context, t = e.oldChildren[n]; t && MC(t, xc(t).option, e.seriesModel) } function Aoe(n) { return n && (n.pathData || n.d) } function Fet(n) { return n && (Ge(n, "pathData") || Ge(n, "d")) } function zet(n) { n.registerChartView(Oet), n.registerSeriesModel(ret) } var Uf = Kt(), $U = lt, aD = He, Vet = function () { function n() { this._dragging = !1, this.animationThreshold = 15 } return n.prototype.render = function (e, t, r, i) { var a = t.get("value"), o = t.get("status"); if (this._axisModel = e, this._axisPointerModel = t, this._api = r, !(!i && this._lastValue === a && this._lastStatus === o)) { this._lastValue = a, this._lastStatus = o; var s = this._group, l = this._handle; if (!o || o === "hide") { s && s.hide(), l && l.hide(); return } s && s.show(), l && l.show(); var c = {}; this.makeElOption(c, a, e, t, r); var u = c.graphicKey; u !== this._lastGraphicKey && this.clear(r), this._lastGraphicKey = u; var d = this._moveAnimation = this.determineAnimation(e, t); if (!s) s = this._group = new ft, this.createPointerEl(s, c, e, t), this.createLabelEl(s, c, e, t), r.getZr().add(s); else { var f = wt(FU, t, d); this.updatePointerEl(s, c, f), this.updateLabelEl(s, c, f, t) } VU(s, t, !0), this._renderHandle(a) } }, n.prototype.remove = function (e) { this.clear(e) }, n.prototype.dispose = function (e) { this.clear(e) }, n.prototype.determineAnimation = function (e, t) { var r = t.get("animation"), i = e.axis, a = i.type === "category", o = t.get("snap"); if (!o && !a) return !1; if (r === "auto" || r == null) { var s = this.animationThreshold; if (a && i.getBandWidth() > s) return !0; if (o) { var l = D3(e).seriesDataCount, c = i.getExtent(); return Math.abs(c[0] - c[1]) / l > s } return !1 } return r === !0 }, n.prototype.makeElOption = function (e, t, r, i, a) { }, n.prototype.createPointerEl = function (e, t, r, i) { var a = t.pointer; if (a) { var o = Uf(e).pointerEl = new ap[a.type]($U(t.pointer)); e.add(o) } }, n.prototype.createLabelEl = function (e, t, r, i) { if (t.label) { var a = Uf(e).labelEl = new tn($U(t.label)); e.add(a), zU(a, i) } }, n.prototype.updatePointerEl = function (e, t, r) { var i = Uf(e).pointerEl; i && t.pointer && (i.setStyle(t.pointer.style), r(i, { shape: t.pointer.shape })) }, n.prototype.updateLabelEl = function (e, t, r, i) { var a = Uf(e).labelEl; a && (a.setStyle(t.label.style), r(a, { x: t.label.x, y: t.label.y }), zU(a, i)) }, n.prototype._renderHandle = function (e) { if (!(this._dragging || !this.updateHandleTransform)) { var t = this._axisPointerModel, r = this._api.getZr(), i = this._handle, a = t.getModel("handle"), o = t.get("status"); if (!a.get("show") || !o || o === "hide") { i && r.remove(i), this._handle = null; return } var s; this._handle || (s = !0, i = this._handle = kb(a.get("icon"), { cursor: "move", draggable: !0, onmousemove: function (c) { Dc(c.event) }, onmousedown: aD(this._onHandleDragMove, this, 0, 0), drift: aD(this._onHandleDragMove, this), ondragend: aD(this._onHandleDragEnd, this) }), r.add(i)), VU(i, t, !1), i.setStyle(a.getItemStyle(null, ["color", "borderColor", "borderWidth", "opacity", "shadowColor", "shadowBlur", "shadowOffsetX", "shadowOffsetY"])); var l = a.get("size"); ke(l) || (l = [l, l]), i.scaleX = l[0] / 2, i.scaleY = l[1] / 2, av(this, "_doDispatchAxisPointer", a.get("throttle") || 0, "fixRate"), this._moveHandleToValue(e, s) } }, n.prototype._moveHandleToValue = function (e, t) { FU(this._axisPointerModel, !t && this._moveAnimation, this._handle, oD(this.getHandleTransform(e, this._axisModel, this._axisPointerModel))) }, n.prototype._onHandleDragMove = function (e, t) { var r = this._handle; if (r) { this._dragging = !0; var i = this.updateHandleTransform(oD(r), [e, t], this._axisModel, this._axisPointerModel); this._payloadInfo = i, r.stopAnimation(), r.attr(oD(i)), Uf(r).lastProp = null, this._doDispatchAxisPointer() } }, n.prototype._doDispatchAxisPointer = function () { var e = this._handle; if (e) { var t = this._payloadInfo, r = this._axisModel; this._api.dispatchAction({ type: "updateAxisPointer", x: t.cursorPoint[0], y: t.cursorPoint[1], tooltipOption: t.tooltipOption, axesInfo: [{ axisDim: r.axis.dim, axisIndex: r.componentIndex }] }) } }, n.prototype._onHandleDragEnd = function () { this._dragging = !1; var e = this._handle; if (e) { var t = this._axisPointerModel.get("value"); this._moveHandleToValue(t), this._api.dispatchAction({ type: "hideTip" }) } }, n.prototype.clear = function (e) { this._lastValue = null, this._lastStatus = null; var t = e.getZr(), r = this._group, i = this._handle; t && r && (this._lastGraphicKey = null, r && t.remove(r), i && t.remove(i), this._group = null, this._handle = null, this._payloadInfo = null), S_(this, "_doDispatchAxisPointer") }, n.prototype.doClear = function () { }, n.prototype.buildLabel = function (e, t, r) { return r = r || 0, { x: e[r], y: e[1 - r], width: t[r], height: t[1 - r] } }, n }(); function FU(n, e, t, r) { Eoe(Uf(t).lastProp, r) || (Uf(t).lastProp = r, e ? on(t, r, n) : (t.stopAnimation(), t.attr(r))) } function Eoe(n, e) { if (ot(n) && ot(e)) { var t = !0; return $(e, function (r, i) { t = t && Eoe(n[i], r) }), !!t } else return n === e } function zU(n, e) { n[e.get(["label", "show"]) ? "show" : "hide"]() } function oD(n) { return { x: n.x || 0, y: n.y || 0, rotation: n.rotation || 0 } } function VU(n, e, t) { var r = e.get("z"), i = e.get("zlevel"); n && n.traverse(function (a) { a.type !== "group" && (r != null && (a.z = r), i != null && (a.zlevel = i), a.silent = t) }) } const uB = Vet; function dB(n) { var e = n.get("type"), t = n.getModel(e + "Style"), r; return e === "line" ? (r = t.getLineStyle(), r.fill = null) : e === "shadow" && (r = t.getAreaStyle(), r.stroke = null), r } function Moe(n, e, t, r, i) { var a = t.get("value"), o = Ooe(a, e.axis, e.ecModel, t.get("seriesDataIndices"), { precision: t.get(["label", "precision"]), formatter: t.get(["label", "formatter"]) }), s = t.getModel("label"), l = ev(s.get("padding") || 0), c = s.getFont(), u = bb(o, c), d = i.position, f = u.width + l[1] + l[3], h = u.height + l[0] + l[2], p = i.align; p === "right" && (d[0] -= f), p === "center" && (d[0] -= f / 2); var m = i.verticalAlign; m === "bottom" && (d[1] -= h), m === "middle" && (d[1] -= h / 2), Het(d, f, h, r); var g = s.get("backgroundColor"); (!g || g === "auto") && (g = e.get(["axisLine", "lineStyle", "color"])), n.label = { x: d[0], y: d[1], style: Ln(s, { text: o, font: c, fill: s.getTextColor(), padding: l, backgroundColor: g }), z2: 10 } } function Het(n, e, t, r) { var i = r.getWidth(), a = r.getHeight(); n[0] = Math.min(n[0] + e, i) - e, n[1] = Math.min(n[1] + t, a) - t, n[0] = Math.max(n[0], 0), n[1] = Math.max(n[1], 0) } function Ooe(n, e, t, r, i) { n = e.scale.parse(n); var a = e.scale.getLabel({ value: n }, { precision: i.precision }), o = i.formatter; if (o) { var s = { value: w3(e, { value: n }), axisDimension: e.dim, axisIndex: e.index, seriesData: [] }; $(r, function (l) { var c = t.getSeriesByIndex(l.seriesIndex), u = l.dataIndexInside, d = c && c.getDataParams(u); d && s.seriesData.push(d) }), Fe(o) ? a = o.replace("{value}", a) : tt(o) && (a = o(s)) } return a } function fB(n, e, t) { var r = Va(); return rp(r, r, t.rotation), Sl(r, r, t.position), bs([n.dataToCoord(e), (t.labelOffset || 0) + (t.labelDirection || 1) * (t.labelMargin || 0)], r) } function Doe(n, e, t, r, i, a) { var o = Rc.innerTextLayout(t.rotation, 0, t.labelDirection); t.labelMargin = i.get(["label", "margin"]), Moe(e, r, i, a, { position: fB(r.axis, n, t), align: o.textAlign, verticalAlign: o.textVerticalAlign }) } function hB(n, e, t) { return t = t || 0, { x1: n[t], y1: n[1 - t], x2: e[t], y2: e[1 - t] } } function joe(n, e, t) { return t = t || 0, { x: n[t], y: n[1 - t], width: e[t], height: e[1 - t] } } function HU(n, e, t, r, i, a) { return { cx: n, cy: e, r0: t, r, startAngle: i, endAngle: a, clockwise: !0 } } var Uet = function (n) { te(e, n); function e() { return n !== null && n.apply(this, arguments) || this } return e.prototype.makeElOption = function (t, r, i, a, o) { var s = i.axis, l = s.grid, c = a.get("type"), u = UU(l, s).getOtherAxis(s).getGlobalExtent(), d = s.toGlobalCoord(s.dataToCoord(r, !0)); if (c && c !== "none") { var f = dB(a), h = Get[c](s, d, u); h.style = f, t.graphicKey = h.type, t.pointer = h } var p = CI(l.model, i); Doe(r, t, p, i, a, o) }, e.prototype.getHandleTransform = function (t, r, i) { var a = CI(r.axis.grid.model, r, { labelInside: !1 }); a.labelMargin = i.get(["handle", "margin"]); var o = fB(r.axis, t, a); return { x: o[0], y: o[1], rotation: a.rotation + (a.labelDirection < 0 ? Math.PI : 0) } }, e.prototype.updateHandleTransform = function (t, r, i, a) { var o = i.axis, s = o.grid, l = o.getGlobalExtent(!0), c = UU(s, o).getOtherAxis(o).getGlobalExtent(), u = o.dim === "x" ? 0 : 1, d = [t.x, t.y]; d[u] += r[u], d[u] = Math.min(l[1], d[u]), d[u] = Math.max(l[0], d[u]); var f = (c[1] + c[0]) / 2, h = [f, f]; h[u] = d[u]; var p = [{ verticalAlign: "middle" }, { align: "center" }]; return { x: d[0], y: d[1], rotation: t.rotation, cursorPoint: h, tooltipOption: p[u] } }, e }(uB); function UU(n, e) { var t = {}; return t[e.dim + "AxisIndex"] = e.index, n.getCartesian(t) } var Get = { line: function (n, e, t) { var r = hB([e, t[0]], [e, t[1]], GU(n)); return { type: "Line", subPixelOptimize: !0, shape: r } }, shadow: function (n, e, t) { var r = Math.max(1, n.getBandWidth()), i = t[1] - t[0]; return { type: "Rect", shape: joe([e - r / 2, t[0]], [r, i], GU(n)) } } }; function GU(n) { return n.dim === "x" ? 0 : 1 } const Wet = Uet; var Ket = function (n) { te(e, n); function e() { var t = n !== null && n.apply(this, arguments) || this; return t.type = e.type, t } return e.type = "axisPointer", e.defaultOption = { show: "auto", z: 50, type: "line", snap: !1, triggerTooltip: !0, triggerEmphasis: !0, value: null, status: null, link: [], animation: null, animationDurationUpdate: 200, lineStyle: { color: "#B9BEC9", width: 1, type: "dashed" }, shadowStyle: { color: "rgba(210,219,238,0.2)" }, label: { show: !0, formatter: null, precision: "auto", margin: 3, color: "#fff", padding: [5, 7, 5, 7], backgroundColor: "auto", borderColor: null, borderWidth: 0, borderRadius: 3 }, handle: { show: !1, icon: "M10.7,11.9v-1.3H9.3v1.3c-4.9,0.3-8.8,4.4-8.8,9.4c0,5,3.9,9.1,8.8,9.4h1.3c4.9-0.3,8.8-4.4,8.8-9.4C19.5,16.3,15.6,12.2,10.7,11.9z M13.3,24.4H6.7v-1.2h6.6z M13.3,22H6.7v-1.2h6.6z M13.3,19.6H6.7v-1.2h6.6z", size: 45, margin: 50, color: "#333", shadowBlur: 3, shadowColor: "#aaa", shadowOffsetX: 0, shadowOffsetY: 2, throttle: 40 } }, e }(Jt); const qet = Ket; var gc = Kt(), Yet = $; function Poe(n, e, t) { if (!en.node) { var r = e.getZr(); gc(r).records || (gc(r).records = {}), Zet(r, e); var i = gc(r).records[n] || (gc(r).records[n] = {}); i.handler = t } } function Zet(n, e) { if (gc(n).initialized) return; gc(n).initialized = !0, t("click", wt(WU, "click")), t("mousemove", wt(WU, "mousemove")), t("globalout", Jet); function t(r, i) { n.on(r, function (a) { var o = Qet(e); Yet(gc(n).records, function (s) { s && i(s, a, o.dispatchAction) }), Xet(o.pendings, e) }) } } function Xet(n, e) { var t = n.showTip.length, r = n.hideTip.length, i; t ? i = n.showTip[t - 1] : r && (i = n.hideTip[r - 1]), i && (i.dispatchAction = null, e.dispatchAction(i)) } function Jet(n, e, t) { n.handler("leave", null, t) } function WU(n, e, t, r) { e.handler(n, t, r) } function Qet(n) { var e = { showTip: [], hideTip: [] }, t = function (r) { var i = e[r.type]; i ? i.push(r) : (r.dispatchAction = t, n.dispatchAction(r)) }; return { dispatchAction: t, pendings: e } } function GI(n, e) { if (!en.node) { var t = e.getZr(), r = (gc(t).records || {})[n]; r && (gc(t).records[n] = null) } } var ett = function (n) { te(e, n); function e() { var t = n !== null && n.apply(this, arguments) || this; return t.type = e.type, t } return e.prototype.render = function (t, r, i) { var a = r.getComponent("tooltip"), o = t.get("triggerOn") || a && a.get("triggerOn") || "mousemove|click"; Poe("axisPointer", i, function (s, l, c) { o !== "none" && (s === "leave" || o.indexOf(s) >= 0) && c({ type: "updateAxisPointer", currTrigger: s, x: l && l.offsetX, y: l && l.offsetY }) }) }, e.prototype.remove = function (t, r) { GI("axisPointer", r) }, e.prototype.dispose = function (t, r) { GI("axisPointer", r) }, e.type = "axisPointer", e }(nr); const ttt = ett; function Ioe(n, e) { var t = [], r = n.seriesIndex, i; if (r == null || !(i = e.getSeriesByIndex(r))) return { point: [] }; var a = i.getData(), o = Hh(a, n); if (o == null || o < 0 || ke(o)) return { point: [] }; var s = a.getItemGraphicEl(o), l = i.coordinateSystem; if (i.getTooltipPosition) t = i.getTooltipPosition(o) || []; else if (l && l.dataToPoint) if (n.isStacked) { var c = l.getBaseAxis(), u = l.getOtherAxis(c), d = u.dim, f = c.dim, h = d === "x" || d === "radius" ? 1 : 0, p = a.mapDimension(f), m = []; m[h] = a.get(p, o), m[1 - h] = a.get(a.getCalculationInfo("stackResultDimension"), o), t = l.dataToPoint(m) || [] } else t = l.dataToPoint(a.getValues(Ae(l.dimensions, function (y) { return a.mapDimension(y) }), o)) || []; else if (s) { var g = s.getBoundingRect().clone(); g.applyTransform(s.transform), t = [g.x + g.width / 2, g.y + g.height / 2] } return { point: t, el: s } } var KU = Kt(); function ntt(n, e, t) { var r = n.currTrigger, i = [n.x, n.y], a = n, o = n.dispatchAction || He(t.dispatchAction, t), s = e.getComponent("axisPointer").coordSysAxesInfo; if (s) { uS(i) && (i = Ioe({ seriesIndex: a.seriesIndex, dataIndex: a.dataIndex }, e).point); var l = uS(i), c = a.axesInfo, u = s.axesInfo, d = r === "leave" || uS(i), f = {}, h = {}, p = { list: [], map: {} }, m = { showPointer: wt(itt, h), showTooltip: wt(att, p) }; $(s.coordSysMap, function (y, b) { var w = l || y.containPoint(i); $(s.coordSysAxesInfo[b], function (v, S) { var x = v.axis, k = ctt(c, v); if (!d && w && (!c || k)) { var A = k && k.value; A == null && !l && (A = x.pointToData(i)), A != null && qU(v, A, m, !1, f) } }) }); var g = {}; return $(u, function (y, b) { var w = y.linkGroup; w && !h[b] && $(w.axesInfo, function (v, S) { var x = h[S]; if (v !== y && x) { var k = x.value; w.mapper && (k = y.axis.scale.parse(w.mapper(k, YU(v), YU(y)))), g[y.key] = k } }) }), $(g, function (y, b) { qU(u[b], y, m, !0, f) }), ott(h, u, f), stt(p, i, n, o), ltt(u, o, t), f } } function qU(n, e, t, r, i) { var a = n.axis; if (!(a.scale.isBlank() || !a.containData(e))) { if (!n.involveSeries) { t.showPointer(n, e); return } var o = rtt(e, n), s = o.payloadBatch, l = o.snapToValue; s[0] && i.seriesIndex == null && be(i, s[0]), !r && n.snap && a.containData(l) && l != null && (e = l), t.showPointer(n, e, s), t.showTooltip(n, o, l) } } function rtt(n, e) { var t = e.axis, r = t.dim, i = n, a = [], o = Number.MAX_VALUE, s = -1; return $(e.seriesModels, function (l, c) { var u = l.getData().mapDimensionsAll(r), d, f; if (l.getAxisTooltipData) { var h = l.getAxisTooltipData(u, n, t); f = h.dataIndices, d = h.nestestValue } else { if (f = l.getData().indicesOfNearest(u[0], n, t.type === "category" ? .5 : null), !f.length) return; d = l.getData().get(u[0], f[0]) } if (!(d == null || !isFinite(d))) { var p = n - d, m = Math.abs(p); m <= o && ((m < o || p >= 0 && s < 0) && (o = m, s = p, i = d, a.length = 0), $(f, function (g) { a.push({ seriesIndex: l.seriesIndex, dataIndexInside: g, dataIndex: l.getData().getRawIndex(g) }) })) } }), { payloadBatch: a, snapToValue: i } } function itt(n, e, t, r) { n[e.key] = { value: t, payloadBatch: r } } function att(n, e, t, r) { var i = t.payloadBatch, a = e.axis, o = a.model, s = e.axisPointerModel; if (!(!e.triggerTooltip || !i.length)) { var l = e.coordSys.model, c = M_(l), u = n.map[c]; u || (u = n.map[c] = { coordSysId: l.id, coordSysIndex: l.componentIndex, coordSysType: l.type, coordSysMainType: l.mainType, dataByAxis: [] }, n.list.push(u)), u.dataByAxis.push({ axisDim: a.dim, axisIndex: o.componentIndex, axisType: o.type, axisId: o.id, value: r, valueLabelOpt: { precision: s.get(["label", "precision"]), formatter: s.get(["label", "formatter"]) }, seriesDataIndices: i.slice() }) } } function ott(n, e, t) { var r = t.axesInfo = []; $(e, function (i, a) { var o = i.axisPointerModel.option, s = n[a]; s ? (!i.useHandle && (o.status = "show"), o.value = s.value, o.seriesDataIndices = (s.payloadBatch || []).slice()) : !i.useHandle && (o.status = "hide"), o.status === "show" && r.push({ axisDim: i.axis.dim, axisIndex: i.axis.model.componentIndex, value: o.value }) }) } function stt(n, e, t, r) { if (uS(e) || !n.list.length) { r({ type: "hideTip" }); return } var i = ((n.list[0].dataByAxis[0] || {}).seriesDataIndices || [])[0] || {}; r({ type: "showTip", escapeConnect: !0, x: e[0], y: e[1], tooltipOption: t.tooltipOption, position: t.position, dataIndexInside: i.dataIndexInside, dataIndex: i.dataIndex, seriesIndex: i.seriesIndex, dataByCoordSys: n.list }) } function ltt(n, e, t) { var r = t.getZr(), i = "axisPointerLastHighlights", a = KU(r)[i] || {}, o = KU(r)[i] = {}; $(n, function (c, u) { var d = c.axisPointerModel.option; d.status === "show" && c.triggerEmphasis && $(d.seriesDataIndices, function (f) { var h = f.seriesIndex + " | " + f.dataIndex; o[h] = f }) }); var s = [], l = []; $(a, function (c, u) { !o[u] && l.push(c) }), $(o, function (c, u) { !a[u] && s.push(c) }), l.length && t.dispatchAction({ type: "downplay", escapeConnect: !0, notBlur: !0, batch: l }), s.length && t.dispatchAction({ type: "highlight", escapeConnect: !0, notBlur: !0, batch: s }) } function ctt(n, e) { for (var t = 0; t < (n || []).length; t++) { var r = n[t]; if (e.axis.dim === r.axisDim && e.axis.model.componentIndex === r.axisIndex) return r } } function YU(n) { var e = n.axis.model, t = {}, r = t.axisDim = n.axis.dim; return t.axisIndex = t[r + "AxisIndex"] = e.componentIndex, t.axisName = t[r + "AxisName"] = e.name, t.axisId = t[r + "AxisId"] = e.id, t } function uS(n) { return !n || n[0] == null || isNaN(n[0]) || n[1] == null || isNaN(n[1]) } function Bb(n) { up.registerAxisPointerClass("CartesianAxisPointer", Wet), n.registerComponentModel(qet), n.registerComponentView(ttt), n.registerPreprocessor(function (e) { if (e) { (!e.axisPointer || e.axisPointer.length === 0) && (e.axisPointer = {}); var t = e.axisPointer.link; t && !ke(t) && (e.axisPointer.link = [t]) } }), n.registerProcessor(n.PRIORITY.PROCESSOR.STATISTIC, function (e, t) { e.getComponent("axisPointer").coordSysAxesInfo = qWe(e, t) }), n.registerAction({ type: "updateAxisPointer", event: "updateAxisPointer", update: ":updateAxisPointer" }, ntt) } function utt(n) { It(oae), It(Bb) } var dtt = function (n) { te(e, n); function e() { return n !== null && n.apply(this, arguments) || this } return e.prototype.makeElOption = function (t, r, i, a, o) { var s = i.axis; s.dim === "angle" && (this.animationThreshold = Math.PI / 18); var l = s.polar, c = l.getOtherAxis(s), u = c.getExtent(), d = s.dataToCoord(r), f = a.get("type"); if (f && f !== "none") { var h = dB(a), p = htt[f](s, l, d, u); p.style = h, t.graphicKey = p.type, t.pointer = p } var m = a.get(["label", "margin"]), g = ftt(r, i, a, l, m); Moe(t, i, a, o, g) }, e }(uB); function ftt(n, e, t, r, i) { var a = e.axis, o = a.dataToCoord(n), s = r.getAngleAxis().getExtent()[0]; s = s / 180 * Math.PI; var l = r.getRadiusAxis().getExtent(), c, u, d; if (a.dim === "radius") { var f = Va(); rp(f, f, s), Sl(f, f, [r.cx, r.cy]), c = bs([o, -i], f); var h = e.getModel("axisLabel").get("rotate") || 0, p = Rc.innerTextLayout(s, h * Math.PI / 180, -1); u = p.textAlign, d = p.textVerticalAlign } else { var m = l[1]; c = r.coordToPoint([m + i, o]); var g = r.cx, y = r.cy; u = Math.abs(c[0] - g) / m < .3 ? "center" : c[0] > g ? "left" : "right", d = Math.abs(c[1] - y) / m < .3 ? "middle" : c[1] > y ? "top" : "bottom" } return { position: c, align: u, verticalAlign: d } } var htt = { line: function (n, e, t, r) { return n.dim === "angle" ? { type: "Line", shape: hB(e.coordToPoint([r[0], t]), e.coordToPoint([r[1], t])) } : { type: "Circle", shape: { cx: e.cx, cy: e.cy, r: t } } }, shadow: function (n, e, t, r) { var i = Math.max(1, n.getBandWidth()), a = Math.PI / 180; return n.dim === "angle" ? { type: "Sector", shape: HU(e.cx, e.cy, r[0], r[1], (-t - i / 2) * a, (-t + i / 2) * a) } : { type: "Sector", shape: HU(e.cx, e.cy, t - i / 2, t + i / 2, 0, Math.PI * 2) } } }; const ptt = dtt; var mtt = function (n) { te(e, n); function e() { var t = n !== null && n.apply(this, arguments) || this; return t.type = e.type, t } return e.prototype.findAxisModel = function (t) { var r, i = this.ecModel; return i.eachComponent(t, function (a) { a.getCoordSysModel() === this && (r = a) }, this), r }, e.type = "polar", e.dependencies = ["radiusAxis", "angleAxis"], e.defaultOption = { z: 0, center: ["50%", "50%"], radius: "80%" }, e }(Jt); const gtt = mtt; var pB = function (n) { te(e, n); function e() { return n !== null && n.apply(this, arguments) || this } return e.prototype.getCoordSysModel = function () { return this.getReferringComponents("polar", xr).models[0] }, e.type = "polarAxis", e }(Jt); Cr(pB, Mb); var vtt = function (n) { te(e, n); function e() { var t = n !== null && n.apply(this, arguments) || this; return t.type = e.type, t } return e.type = "angleAxis", e }(pB), ytt = function (n) { te(e, n); function e() { var t = n !== null && n.apply(this, arguments) || this; return t.type = e.type, t } return e.type = "radiusAxis", e }(pB), mB = function (n) { te(e, n); function e(t, r) { return n.call(this, "radius", t, r) || this } return e.prototype.pointToData = function (t, r) { return this.polar.pointToData(t, r)[this.dim === "radius" ? 0 : 1] }, e }(Ps); mB.prototype.dataToRadius = Ps.prototype.dataToCoord; mB.prototype.radiusToData = Ps.prototype.coordToData; const _tt = mB; var btt = Kt(), gB = function (n) { te(e, n); function e(t, r) { return n.call(this, "angle", t, r || [0, 360]) || this } return e.prototype.pointToData = function (t, r) { return this.polar.pointToData(t, r)[this.dim === "radius" ? 0 : 1] }, e.prototype.calculateCategoryInterval = function () { var t = this, r = t.getLabelModel(), i = t.scale, a = i.getExtent(), o = i.count(); if (a[1] - a[0] < 1) return 0; var s = a[0], l = t.dataToCoord(s + 1) - t.dataToCoord(s), c = Math.abs(l), u = bb(s == null ? "" : s + "", r.getFont(), "center", "top"), d = Math.max(u.height, 7), f = d / c; isNaN(f) && (f = 1 / 0); var h = Math.max(0, Math.floor(f)), p = btt(t.model), m = p.lastAutoInterval, g = p.lastTickCount; return m != null && g != null && Math.abs(m - h) <= 1 && Math.abs(g - o) <= 1 && m > h ? h = m : (p.lastTickCount = o, p.lastAutoInterval = h), h }, e }(Ps); gB.prototype.dataToAngle = Ps.prototype.dataToCoord; gB.prototype.angleToData = Ps.prototype.coordToData; const wtt = gB; var Loe = ["radius", "angle"], xtt = function () { function n(e) { this.dimensions = Loe, this.type = "polar", this.cx = 0, this.cy = 0, this._radiusAxis = new _tt, this._angleAxis = new wtt, this.axisPointerEnabled = !0, this.name = e || "", this._radiusAxis.polar = this._angleAxis.polar = this } return n.prototype.containPoint = function (e) { var t = this.pointToCoord(e); return this._radiusAxis.contain(t[0]) && this._angleAxis.contain(t[1]) }, n.prototype.containData = function (e) { return this._radiusAxis.containData(e[0]) && this._angleAxis.containData(e[1]) }, n.prototype.getAxis = function (e) { var t = "_" + e + "Axis"; return this[t] }, n.prototype.getAxes = function () { return [this._radiusAxis, this._angleAxis] }, n.prototype.getAxesByScale = function (e) { var t = [], r = this._angleAxis, i = this._radiusAxis; return r.scale.type === e && t.push(r), i.scale.type === e && t.push(i), t }, n.prototype.getAngleAxis = function () { return this._angleAxis }, n.prototype.getRadiusAxis = function () { return this._radiusAxis }, n.prototype.getOtherAxis = function (e) { var t = this._angleAxis; return e === t ? this._radiusAxis : t }, n.prototype.getBaseAxis = function () { return this.getAxesByScale("ordinal")[0] || this.getAxesByScale("time")[0] || this.getAngleAxis() }, n.prototype.getTooltipAxes = function (e) { var t = e != null && e !== "auto" ? this.getAxis(e) : this.getBaseAxis(); return { baseAxes: [t], otherAxes: [this.getOtherAxis(t)] } }, n.prototype.dataToPoint = function (e, t) { return this.coordToPoint([this._radiusAxis.dataToRadius(e[0], t), this._angleAxis.dataToAngle(e[1], t)]) }, n.prototype.pointToData = function (e, t) { var r = this.pointToCoord(e); return [this._radiusAxis.radiusToData(r[0], t), this._angleAxis.angleToData(r[1], t)] }, n.prototype.pointToCoord = function (e) { var t = e[0] - this.cx, r = e[1] - this.cy, i = this.getAngleAxis(), a = i.getExtent(), o = Math.min(a[0], a[1]), s = Math.max(a[0], a[1]); i.inverse ? o = s - 360 : s = o + 360; var l = Math.sqrt(t * t + r * r); t /= l, r /= l; for (var c = Math.atan2(-r, t) / Math.PI * 180, u = c < o ? 1 : -1; c < o || c > s;)c += u * 360; return [l, c] }, n.prototype.coordToPoint = function (e) { var t = e[0], r = e[1] / 180 * Math.PI, i = Math.cos(r) * t + this.cx, a = -Math.sin(r) * t + this.cy; return [i, a] }, n.prototype.getArea = function () { var e = this.getAngleAxis(), t = this.getRadiusAxis(), r = t.getExtent().slice(); r[0] > r[1] && r.reverse(); var i = e.getExtent(), a = Math.PI / 180, o = 1e-4; return { cx: this.cx, cy: this.cy, r0: r[0], r: r[1], startAngle: -i[0] * a, endAngle: -i[1] * a, clockwise: e.inverse, contain: function (s, l) { var c = s - this.cx, u = l - this.cy, d = c * c + u * u, f = this.r, h = this.r0; return f !== h && d - o <= f * f && d + o >= h * h } } }, n.prototype.convertToPixel = function (e, t, r) { var i = ZU(t); return i === this ? this.dataToPoint(r) : null }, n.prototype.convertFromPixel = function (e, t, r) { var i = ZU(t); return i === this ? this.pointToData(r) : null }, n }(); function ZU(n) { var e = n.seriesModel, t = n.polarModel; return t && t.coordinateSystem || e && e.coordinateSystem } const Stt = xtt; function Ttt(n, e, t) { var r = e.get("center"), i = t.getWidth(), a = t.getHeight(); n.cx = Ne(r[0], i), n.cy = Ne(r[1], a); var o = n.getRadiusAxis(), s = Math.min(i, a) / 2, l = e.get("radius"); l == null ? l = [0, "100%"] : ke(l) || (l = [0, l]); var c = [Ne(l[0], s), Ne(l[1], s)]; o.inverse ? o.setExtent(c[1], c[0]) : o.setExtent(c[0], c[1]) } function ktt(n, e) { var t = this, r = t.getAngleAxis(), i = t.getRadiusAxis(); if (r.scale.setExtent(1 / 0, -1 / 0), i.scale.setExtent(1 / 0, -1 / 0), n.eachSeries(function (s) { if (s.coordinateSystem === t) { var l = s.getData(); $(fT(l, "radius"), function (c) { i.scale.unionExtentFromData(l, c) }), $(fT(l, "angle"), function (c) { r.scale.unionExtentFromData(l, c) }) } }), Eg(r.scale, r.model), Eg(i.scale, i.model), r.type === "category" && !r.onBand) { var a = r.getExtent(), o = 360 / r.scale.count(); r.inverse ? a[1] += o : a[1] -= o, r.setExtent(a[0], a[1]) } } function Ctt(n) { return n.mainType === "angleAxis" } function XU(n, e) { var t; if (n.type = e.get("type"), n.scale = xC(e), n.onBand = e.get("boundaryGap") && n.type === "category", n.inverse = e.get("inverse"), Ctt(e)) { n.inverse = n.inverse !== e.get("clockwise"); var r = e.get("startAngle"), i = (t = e.get("endAngle")) !== null && t !== void 0 ? t : r + (n.inverse ? -360 : 360); n.setExtent(r, i) } e.axis = n, n.model = e } var Att = { dimensions: Loe, create: function (n, e) { var t = []; return n.eachComponent("polar", function (r, i) { var a = new Stt(i + ""); a.update = ktt; var o = a.getRadiusAxis(), s = a.getAngleAxis(), l = r.findAxisModel("radiusAxis"), c = r.findAxisModel("angleAxis"); XU(o, l), XU(s, c), Ttt(a, r, e), t.push(a), r.coordinateSystem = a, a.model = r }), n.eachSeries(function (r) { if (r.get("coordinateSystem") === "polar") { var i = r.getReferringComponents("polar", xr).models[0]; r.coordinateSystem = i.coordinateSystem } }), t } }; const Ett = Att; var Mtt = ["axisLine", "axisLabel", "axisTick", "minorTick", "splitLine", "minorSplitLine", "splitArea"]; function gx(n, e, t) { e[1] > e[0] && (e = e.slice().reverse()); var r = n.coordToPoint([e[0], t]), i = n.coordToPoint([e[1], t]); return { x1: r[0], y1: r[1], x2: i[0], y2: i[1] } } function vx(n) { var e = n.getRadiusAxis(); return e.inverse ? 0 : 1 } function JU(n) { var e = n[0], t = n[n.length - 1]; e && t && Math.abs(Math.abs(e.coord - t.coord) - 360) < 1e-4 && n.pop() } var Ott = function (n) { te(e, n); function e() { var t = n !== null && n.apply(this, arguments) || this; return t.type = e.type, t.axisPointerClass = "PolarAxisPointer", t } return e.prototype.render = function (t, r) { if (this.group.removeAll(), !!t.get("show")) { var i = t.axis, a = i.polar, o = a.getRadiusAxis().getExtent(), s = i.getTicksCoords(), l = i.getMinorTicksCoords(), c = Ae(i.getViewLabels(), function (u) { u = lt(u); var d = i.scale, f = d.type === "ordinal" ? d.getRawOrdinalNumber(u.tickValue) : u.tickValue; return u.coord = i.dataToCoord(f), u }); JU(c), JU(s), $(Mtt, function (u) { t.get([u, "show"]) && (!i.scale.isBlank() || u === "axisLine") && Dtt[u](this.group, t, a, s, l, o, c) }, this) } }, e.type = "angleAxis", e }(up), Dtt = { axisLine: function (n, e, t, r, i, a) { var o = e.getModel(["axisLine", "lineStyle"]), s = t.getAngleAxis(), l = Math.PI / 180, c = s.getExtent(), u = vx(t), d = u ? 0 : 1, f, h = Math.abs(c[1] - c[0]) === 360 ? "Circle" : "Arc"; a[d] === 0 ? f = new ap[h]({ shape: { cx: t.cx, cy: t.cy, r: a[u], startAngle: -c[0] * l, endAngle: -c[1] * l, clockwise: s.inverse }, style: o.getLineStyle(), z2: 1, silent: !0 }) : f = new rC({ shape: { cx: t.cx, cy: t.cy, r: a[u], r0: a[d] }, style: o.getLineStyle(), z2: 1, silent: !0 }), f.style.fill = null, n.add(f) }, axisTick: function (n, e, t, r, i, a) { var o = e.getModel("axisTick"), s = (o.get("inside") ? -1 : 1) * o.get("length"), l = a[vx(t)], c = Ae(r, function (u) { return new Jr({ shape: gx(t, [l, l + s], u.coord) }) }); n.add(Co(c, { style: rt(o.getModel("lineStyle").getLineStyle(), { stroke: e.get(["axisLine", "lineStyle", "color"]) }) })) }, minorTick: function (n, e, t, r, i, a) { if (i.length) { for (var o = e.getModel("axisTick"), s = e.getModel("minorTick"), l = (o.get("inside") ? -1 : 1) * s.get("length"), c = a[vx(t)], u = [], d = 0; d < i.length; d++)for (var f = 0; f < i[d].length; f++)u.push(new Jr({ shape: gx(t, [c, c + l], i[d][f].coord) })); n.add(Co(u, { style: rt(s.getModel("lineStyle").getLineStyle(), rt(o.getLineStyle(), { stroke: e.get(["axisLine", "lineStyle", "color"]) })) })) } }, axisLabel: function (n, e, t, r, i, a, o) { var s = e.getCategories(!0), l = e.getModel("axisLabel"), c = l.get("margin"), u = e.get("triggerEvent"); $(o, function (d, f) { var h = l, p = d.tickValue, m = a[vx(t)], g = t.coordToPoint([m + c, d.coord]), y = t.cx, b = t.cy, w = Math.abs(g[0] - y) / m < .3 ? "center" : g[0] > y ? "left" : "right", v = Math.abs(g[1] - b) / m < .3 ? "middle" : g[1] > b ? "top" : "bottom"; if (s && s[p]) { var S = s[p]; ot(S) && S.textStyle && (h = new Rn(S.textStyle, l, l.ecModel)) } var x = new tn({ silent: Rc.isLabelSilent(e), style: Ln(h, { x: g[0], y: g[1], fill: h.getTextColor() || e.get(["axisLine", "lineStyle", "color"]), text: d.formattedLabel, align: w, verticalAlign: v }) }); if (n.add(x), u) { var k = Rc.makeAxisEventDataBase(e); k.targetType = "axisLabel", k.value = d.rawLabel, pt(x).eventData = k } }, this) }, splitLine: function (n, e, t, r, i, a) { var o = e.getModel("splitLine"), s = o.getModel("lineStyle"), l = s.get("color"), c = 0; l = l instanceof Array ? l : [l]; for (var u = [], d = 0; d < r.length; d++) { var f = c++ % l.length; u[f] = u[f] || [], u[f].push(new Jr({ shape: gx(t, a, r[d].coord) })) } for (var d = 0; d < u.length; d++)n.add(Co(u[d], { style: rt({ stroke: l[d % l.length] }, s.getLineStyle()), silent: !0, z: e.get("z") })) }, minorSplitLine: function (n, e, t, r, i, a) { if (i.length) { for (var o = e.getModel("minorSplitLine"), s = o.getModel("lineStyle"), l = [], c = 0; c < i.length; c++)for (var u = 0; u < i[c].length; u++)l.push(new Jr({ shape: gx(t, a, i[c][u].coord) })); n.add(Co(l, { style: s.getLineStyle(), silent: !0, z: e.get("z") })) } }, splitArea: function (n, e, t, r, i, a) { if (r.length) { var o = e.getModel("splitArea"), s = o.getModel("areaStyle"), l = s.get("color"), c = 0; l = l instanceof Array ? l : [l]; for (var u = [], d = Math.PI / 180, f = -r[0].coord * d, h = Math.min(a[0], a[1]), p = Math.max(a[0], a[1]), m = e.get("clockwise"), g = 1, y = r.length; g <= y; g++) { var b = g === y ? r[0].coord : r[g].coord, w = c++ % l.length; u[w] = u[w] || [], u[w].push(new Ca({ shape: { cx: t.cx, cy: t.cy, r0: h, r: p, startAngle: f, endAngle: -b * d, clockwise: m }, silent: !0 })), f = -b * d } for (var g = 0; g < u.length; g++)n.add(Co(u[g], { style: rt({ fill: l[g % l.length] }, s.getAreaStyle()), silent: !0 })) } } }; const jtt = Ott; var Ptt = ["axisLine", "axisTickLabel", "axisName"], Itt = ["splitLine", "splitArea", "minorSplitLine"], Ltt = function (n) { te(e, n); function e() { var t = n !== null && n.apply(this, arguments) || this; return t.type = e.type, t.axisPointerClass = "PolarAxisPointer", t } return e.prototype.render = function (t, r) { if (this.group.removeAll(), !!t.get("show")) { var i = this._axisGroup, a = this._axisGroup = new ft; this.group.add(a); var o = t.axis, s = o.polar, l = s.getAngleAxis(), c = o.getTicksCoords(), u = o.getMinorTicksCoords(), d = l.getExtent()[0], f = o.getExtent(), h = Ntt(s, t, d), p = new Rc(t, h); $(Ptt, p.add, p), a.add(p.getGroup()), Tb(i, a, t), $(Itt, function (m) { t.get([m, "show"]) && !o.scale.isBlank() && Rtt[m](this.group, t, s, d, f, c, u) }, this) } }, e.type = "radiusAxis", e }(up), Rtt = { splitLine: function (n, e, t, r, i, a) { var o = e.getModel("splitLine"), s = o.getModel("lineStyle"), l = s.get("color"), c = 0, u = t.getAngleAxis(), d = Math.PI / 180, f = u.getExtent(), h = Math.abs(f[1] - f[0]) === 360 ? "Circle" : "Arc"; l = l instanceof Array ? l : [l]; for (var p = [], m = 0; m < a.length; m++) { var g = c++ % l.length; p[g] = p[g] || [], p[g].push(new ap[h]({ shape: { cx: t.cx, cy: t.cy, r: Math.max(a[m].coord, 0), startAngle: -f[0] * d, endAngle: -f[1] * d, clockwise: u.inverse } })) } for (var m = 0; m < p.length; m++)n.add(Co(p[m], { style: rt({ stroke: l[m % l.length], fill: null }, s.getLineStyle()), silent: !0 })) }, minorSplitLine: function (n, e, t, r, i, a, o) { if (o.length) { for (var s = e.getModel("minorSplitLine"), l = s.getModel("lineStyle"), c = [], u = 0; u < o.length; u++)for (var d = 0; d < o[u].length; d++)c.push(new Ud({ shape: { cx: t.cx, cy: t.cy, r: o[u][d].coord } })); n.add(Co(c, { style: rt({ fill: null }, l.getLineStyle()), silent: !0 })) } }, splitArea: function (n, e, t, r, i, a) { if (a.length) { var o = e.getModel("splitArea"), s = o.getModel("areaStyle"), l = s.get("color"), c = 0; l = l instanceof Array ? l : [l]; for (var u = [], d = a[0].coord, f = 1; f < a.length; f++) { var h = c++ % l.length; u[h] = u[h] || [], u[h].push(new Ca({ shape: { cx: t.cx, cy: t.cy, r0: d, r: a[f].coord, startAngle: 0, endAngle: Math.PI * 2 }, silent: !0 })), d = a[f].coord } for (var f = 0; f < u.length; f++)n.add(Co(u[f], { style: rt({ fill: l[f % l.length] }, s.getAreaStyle()), silent: !0 })) } } }; function Ntt(n, e, t) { return { position: [n.cx, n.cy], rotation: t / 180 * Math.PI, labelDirection: -1, tickDirection: -1, nameDirection: 1, labelRotate: e.getModel("axisLabel").get("rotate"), z2: 1 } } const Btt = Ltt; function Roe(n) { return n.get("stack") || "__ec_stack_" + n.seriesIndex } function Noe(n, e) { return e.dim + n.model.componentIndex } function $tt(n, e, t) { var r = {}, i = Ftt(pn(e.getSeriesByType(n), function (a) { return !e.isSeriesFiltered(a) && a.coordinateSystem && a.coordinateSystem.type === "polar" })); e.eachSeriesByType(n, function (a) { if (a.coordinateSystem.type === "polar") { var o = a.getData(), s = a.coordinateSystem, l = s.getBaseAxis(), c = Noe(s, l), u = Roe(a), d = i[c][u], f = d.offset, h = d.width, p = s.getOtherAxis(l), m = a.coordinateSystem.cx, g = a.coordinateSystem.cy, y = a.get("barMinHeight") || 0, b = a.get("barMinAngle") || 0; r[u] = r[u] || []; for (var w = o.mapDimension(p.dim), v = o.mapDimension(l.dim), S = Md(o, w), x = l.dim !== "radius" || !a.get("roundCap", !0), k = p.model, A = k.get("startValue"), C = p.dataToCoord(A || 0), E = 0, O = o.count(); E < O; E++) { var j = o.get(w, E), I = o.get(v, E), L = j >= 0 ? "p" : "n", R = C; S && (r[u][I] || (r[u][I] = { p: C, n: C }), R = r[u][I][L]); var D = void 0, P = void 0, B = void 0, F = void 0; if (p.dim === "radius") { var K = p.dataToCoord(j) - C, V = l.dataToCoord(I); Math.abs(K) < y && (K = (K < 0 ? -1 : 1) * y), D = R, P = R + K, B = V - f, F = B - h, S && (r[u][I][L] = P) } else { var W = p.dataToCoord(j, x) - C, J = l.dataToCoord(I); Math.abs(W) < b && (W = (W < 0 ? -1 : 1) * b), D = J + f, P = D + h, B = R, F = R + W, S && (r[u][I][L] = F) } o.setItemLayout(E, { cx: m, cy: g, r0: D, r: P, startAngle: -B * Math.PI / 180, endAngle: -F * Math.PI / 180, clockwise: B >= F }) } } }) } function Ftt(n) { var e = {}; $(n, function (r, i) { var a = r.getData(), o = r.coordinateSystem, s = o.getBaseAxis(), l = Noe(o, s), c = s.getExtent(), u = s.type === "category" ? s.getBandWidth() : Math.abs(c[1] - c[0]) / a.count(), d = e[l] || { bandWidth: u, remainedWidth: u, autoWidthCount: 0, categoryGap: "20%", gap: "30%", stacks: {} }, f = d.stacks; e[l] = d; var h = Roe(r); f[h] || d.autoWidthCount++, f[h] = f[h] || { width: 0, maxWidth: 0 }; var p = Ne(r.get("barWidth"), u), m = Ne(r.get("barMaxWidth"), u), g = r.get("barGap"), y = r.get("barCategoryGap"); p && !f[h].width && (p = Math.min(d.remainedWidth, p), f[h].width = p, d.remainedWidth -= p), m && (f[h].maxWidth = m), g != null && (d.gap = g), y != null && (d.categoryGap = y) }); var t = {}; return $(e, function (r, i) { t[i] = {}; var a = r.stacks, o = r.bandWidth, s = Ne(r.categoryGap, o), l = Ne(r.gap, 1), c = r.remainedWidth, u = r.autoWidthCount, d = (c - s) / (u + (u - 1) * l); d = Math.max(d, 0), $(a, function (m, g) { var y = m.maxWidth; y && y < d && (y = Math.min(y, c), m.width && (y = Math.min(y, m.width)), c -= y, m.width = y, u--) }), d = (c - s) / (u + (u - 1) * l), d = Math.max(d, 0); var f = 0, h; $(a, function (m, g) { m.width || (m.width = d), h = m, f += m.width * (1 + l) }), h && (f -= h.width * l); var p = -f / 2; $(a, function (m, g) { t[i][g] = t[i][g] || { offset: p, width: m.width }, p += m.width * (1 + l) }) }), t } var ztt = { startAngle: 90, clockwise: !0, splitNumber: 12, axisLabel: { rotate: 0 } }, Vtt = { splitNumber: 5 }, Htt = function (n) { te(e, n); function e() { var t = n !== null && n.apply(this, arguments) || this; return t.type = e.type, t } return e.type = "polar", e }(nr); function Utt(n) { It(Bb), up.registerAxisPointerClass("PolarAxisPointer", ptt), n.registerCoordinateSystem("polar", Ett), n.registerComponentModel(gtt), n.registerComponentView(Htt), Og(n, "angle", vtt, ztt), Og(n, "radius", ytt, Vtt), n.registerComponentView(jtt), n.registerComponentView(Btt), n.registerLayout(wt($tt, "bar")) } function WI(n, e) { e = e || {}; var t = n.coordinateSystem, r = n.axis, i = {}, a = r.position, o = r.orient, s = t.getRect(), l = [s.x, s.x + s.width, s.y, s.y + s.height], c = { horizontal: { top: l[2], bottom: l[3] }, vertical: { left: l[0], right: l[1] } }; i.position = [o === "vertical" ? c.vertical[a] : l[0], o === "horizontal" ? c.horizontal[a] : l[3]]; var u = { horizontal: 0, vertical: 1 }; i.rotation = Math.PI / 2 * u[o]; var d = { top: -1, bottom: 1, right: 1, left: -1 }; i.labelDirection = i.tickDirection = i.nameDirection = d[a], n.get(["axisTick", "inside"]) && (i.tickDirection = -i.tickDirection), Xr(e.labelInside, n.get(["axisLabel", "inside"])) && (i.labelDirection = -i.labelDirection); var f = e.rotate; return f == null && (f = n.get(["axisLabel", "rotate"])), i.labelRotation = a === "top" ? -f : f, i.z2 = 1, i } var Gtt = ["axisLine", "axisTickLabel", "axisName"], Wtt = ["splitArea", "splitLine"], Ktt = function (n) { te(e, n); function e() { var t = n !== null && n.apply(this, arguments) || this; return t.type = e.type, t.axisPointerClass = "SingleAxisPointer", t } return e.prototype.render = function (t, r, i, a) { var o = this.group; o.removeAll(); var s = this._axisGroup; this._axisGroup = new ft; var l = WI(t), c = new Rc(t, l); $(Gtt, c.add, c), o.add(this._axisGroup), o.add(c.getGroup()), $(Wtt, function (u) { t.get([u, "show"]) && qtt[u](this, this.group, this._axisGroup, t) }, this), Tb(s, this._axisGroup, t), n.prototype.render.call(this, t, r, i, a) }, e.prototype.remove = function () { rae(this) }, e.type = "singleAxis", e }(up), qtt = { splitLine: function (n, e, t, r) { var i = r.axis; if (!i.scale.isBlank()) { var a = r.getModel("splitLine"), o = a.getModel("lineStyle"), s = o.get("color"); s = s instanceof Array ? s : [s]; for (var l = o.get("width"), c = r.coordinateSystem.getRect(), u = i.isHorizontal(), d = [], f = 0, h = i.getTicksCoords({ tickModel: a }), p = [], m = [], g = 0; g < h.length; ++g) { var y = i.toGlobalCoord(h[g].coord); u ? (p[0] = y, p[1] = c.y, m[0] = y, m[1] = c.y + c.height) : (p[0] = c.x, p[1] = y, m[0] = c.x + c.width, m[1] = y); var b = new Jr({ shape: { x1: p[0], y1: p[1], x2: m[0], y2: m[1] }, silent: !0 }); kg(b.shape, l); var w = f++ % s.length; d[w] = d[w] || [], d[w].push(b) } for (var v = o.getLineStyle(["color"]), g = 0; g < d.length; ++g)e.add(Co(d[g], { style: rt({ stroke: s[g % s.length] }, v), silent: !0 })) } }, splitArea: function (n, e, t, r) { nae(n, t, r, r) } }; const Ytt = Ktt; var Boe = function (n) { te(e, n); function e() { var t = n !== null && n.apply(this, arguments) || this; return t.type = e.type, t } return e.prototype.getCoordSysModel = function () { return this }, e.type = "singleAxis", e.layoutMode = "box", e.defaultOption = { left: "5%", top: "5%", right: "5%", bottom: "5%", type: "value", position: "bottom", orient: "horizontal", axisLine: { show: !0, lineStyle: { width: 1, type: "solid" } }, tooltip: { show: !0 }, axisTick: { show: !0, length: 6, lineStyle: { width: 1 } }, axisLabel: { show: !0, interval: "auto" }, splitLine: { show: !0, lineStyle: { type: "dashed", opacity: .2 } } }, e }(Jt); Cr(Boe, Mb.prototype); const sD = Boe; var Ztt = function (n) { te(e, n); function e(t, r, i, a, o) { var s = n.call(this, t, r, i) || this; return s.type = a || "value", s.position = o || "bottom", s } return e.prototype.isHorizontal = function () { var t = this.position; return t === "top" || t === "bottom" }, e.prototype.pointToData = function (t, r) { return this.coordinateSystem.pointToData(t)[0] }, e }(Ps); const Xtt = Ztt; var $oe = ["single"], Jtt = function () { function n(e, t, r) { this.type = "single", this.dimension = "single", this.dimensions = $oe, this.axisPointerEnabled = !0, this.model = e, this._init(e, t, r) } return n.prototype._init = function (e, t, r) { var i = this.dimension, a = new Xtt(i, xC(e), [0, 0], e.get("type"), e.get("position")), o = a.type === "category"; a.onBand = o && e.get("boundaryGap"), a.inverse = e.get("inverse"), a.orient = e.get("orient"), e.axis = a, a.model = e, a.coordinateSystem = this, this._axis = a }, n.prototype.update = function (e, t) { e.eachSeries(function (r) { if (r.coordinateSystem === this) { var i = r.getData(); $(i.mapDimensionsAll(this.dimension), function (a) { this._axis.scale.unionExtentFromData(i, a) }, this), Eg(this._axis.scale, this._axis.model) } }, this) }, n.prototype.resize = function (e, t) { this._rect = jr({ left: e.get("left"), top: e.get("top"), right: e.get("right"), bottom: e.get("bottom"), width: e.get("width"), height: e.get("height") }, { width: t.getWidth(), height: t.getHeight() }), this._adjustAxis() }, n.prototype.getRect = function () { return this._rect }, n.prototype._adjustAxis = function () { var e = this._rect, t = this._axis, r = t.isHorizontal(), i = r ? [0, e.width] : [0, e.height], a = t.inverse ? 1 : 0; t.setExtent(i[a], i[1 - a]), this._updateAxisTransform(t, r ? e.x : e.y) }, n.prototype._updateAxisTransform = function (e, t) { var r = e.getExtent(), i = r[0] + r[1], a = e.isHorizontal(); e.toGlobalCoord = a ? function (o) { return o + t } : function (o) { return i - o + t }, e.toLocalCoord = a ? function (o) { return o - t } : function (o) { return i - o + t } }, n.prototype.getAxis = function () { return this._axis }, n.prototype.getBaseAxis = function () { return this._axis }, n.prototype.getAxes = function () { return [this._axis] }, n.prototype.getTooltipAxes = function () { return { baseAxes: [this.getAxis()], otherAxes: [] } }, n.prototype.containPoint = function (e) { var t = this.getRect(), r = this.getAxis(), i = r.orient; return i === "horizontal" ? r.contain(r.toLocalCoord(e[0])) && e[1] >= t.y && e[1] <= t.y + t.height : r.contain(r.toLocalCoord(e[1])) && e[0] >= t.y && e[0] <= t.y + t.height }, n.prototype.pointToData = function (e) { var t = this.getAxis(); return [t.coordToData(t.toLocalCoord(e[t.orient === "horizontal" ? 0 : 1]))] }, n.prototype.dataToPoint = function (e) { var t = this.getAxis(), r = this.getRect(), i = [], a = t.orient === "horizontal" ? 0 : 1; return e instanceof Array && (e = e[0]), i[a] = t.toGlobalCoord(t.dataToCoord(+e)), i[1 - a] = a === 0 ? r.y + r.height / 2 : r.x + r.width / 2, i }, n.prototype.convertToPixel = function (e, t, r) { var i = QU(t); return i === this ? this.dataToPoint(r) : null }, n.prototype.convertFromPixel = function (e, t, r) { var i = QU(t); return i === this ? this.pointToData(r) : null }, n }(); function QU(n) { var e = n.seriesModel, t = n.singleAxisModel; return t && t.coordinateSystem || e && e.coordinateSystem } function Qtt(n, e) { var t = []; return n.eachComponent("singleAxis", function (r, i) { var a = new Jtt(r, n, e); a.name = "single_" + i, a.resize(r, e), r.coordinateSystem = a, t.push(a) }), n.eachSeries(function (r) { if (r.get("coordinateSystem") === "singleAxis") { var i = r.getReferringComponents("singleAxis", xr).models[0]; r.coordinateSystem = i && i.coordinateSystem } }), t } var ent = { create: Qtt, dimensions: $oe }; const tnt = ent; var eG = ["x", "y"], nnt = ["width", "height"], rnt = function (n) { te(e, n); function e() { return n !== null && n.apply(this, arguments) || this } return e.prototype.makeElOption = function (t, r, i, a, o) { var s = i.axis, l = s.coordinateSystem, c = lD(l, 1 - AT(s)), u = l.dataToPoint(r)[0], d = a.get("type"); if (d && d !== "none") { var f = dB(a), h = int[d](s, u, c); h.style = f, t.graphicKey = h.type, t.pointer = h } var p = WI(i); Doe(r, t, p, i, a, o) }, e.prototype.getHandleTransform = function (t, r, i) { var a = WI(r, { labelInside: !1 }); a.labelMargin = i.get(["handle", "margin"]); var o = fB(r.axis, t, a); return { x: o[0], y: o[1], rotation: a.rotation + (a.labelDirection < 0 ? Math.PI : 0) } }, e.prototype.updateHandleTransform = function (t, r, i, a) { var o = i.axis, s = o.coordinateSystem, l = AT(o), c = lD(s, l), u = [t.x, t.y]; u[l] += r[l], u[l] = Math.min(c[1], u[l]), u[l] = Math.max(c[0], u[l]); var d = lD(s, 1 - l), f = (d[1] + d[0]) / 2, h = [f, f]; return h[l] = u[l], { x: u[0], y: u[1], rotation: t.rotation, cursorPoint: h, tooltipOption: { verticalAlign: "middle" } } }, e }(uB), int = { line: function (n, e, t) { var r = hB([e, t[0]], [e, t[1]], AT(n)); return { type: "Line", subPixelOptimize: !0, shape: r } }, shadow: function (n, e, t) { var r = n.getBandWidth(), i = t[1] - t[0]; return { type: "Rect", shape: joe([e - r / 2, t[0]], [r, i], AT(n)) } } }; function AT(n) { return n.isHorizontal() ? 0 : 1 } function lD(n, e) { var t = n.getRect(); return [t[eG[e]], t[eG[e]] + t[nnt[e]]] } const ant = rnt; var ont = function (n) { te(e, n); function e() { var t = n !== null && n.apply(this, arguments) || this; return t.type = e.type, t } return e.type = "single", e }(nr); function snt(n) { It(Bb), up.registerAxisPointerClass("SingleAxisPointer", ant), n.registerComponentView(ont), n.registerComponentView(Ytt), n.registerComponentModel(sD), Og(n, "single", sD, sD.defaultOption), n.registerCoordinateSystem("single", tnt) } var lnt = function (n) { te(e, n); function e() { var t = n !== null && n.apply(this, arguments) || this; return t.type = e.type, t } return e.prototype.init = function (t, r, i) { var a = tv(t); n.prototype.init.apply(this, arguments), tG(t, a) }, e.prototype.mergeOption = function (t) { n.prototype.mergeOption.apply(this, arguments), tG(this.option, t) }, e.prototype.getCellSize = function () { return this.option.cellSize }, e.type = "calendar", e.defaultOption = { z: 2, left: 80, top: 60, cellSize: 20, orient: "horizontal", splitLine: { show: !0, lineStyle: { color: "#000", width: 1, type: "solid" } }, itemStyle: { color: "#fff", borderWidth: 1, borderColor: "#ccc" }, dayLabel: { show: !0, firstDay: 0, position: "start", margin: "50%", color: "#000" }, monthLabel: { show: !0, position: "start", margin: 5, align: "center", formatter: null, color: "#000" }, yearLabel: { show: !0, position: null, margin: 30, formatter: null, color: "#ccc", fontFamily: "sans-serif", fontWeight: "bolder", fontSize: 20 } }, e }(Jt); function tG(n, e) { var t = n.cellSize, r; ke(t) ? r = t : r = n.cellSize = [t, t], r.length === 1 && (r[1] = r[0]); var i = Ae([0, 1], function (a) { return dVe(e, a) && (r[a] = "auto"), r[a] != null && r[a] !== "auto" }); Ed(n, e, { type: "box", ignoreSize: i }) } const cnt = lnt; var unt = function (n) { te(e, n); function e() { var t = n !== null && n.apply(this, arguments) || this; return t.type = e.type, t } return e.prototype.render = function (t, r, i) { var a = this.group; a.removeAll(); var o = t.coordinateSystem, s = o.getRangeInfo(), l = o.getOrient(), c = r.getLocaleModel(); this._renderDayRect(t, s, a), this._renderLines(t, s, l, a), this._renderYearText(t, s, l, a), this._renderMonthText(t, c, l, a), this._renderWeekText(t, c, s, l, a) }, e.prototype._renderDayRect = function (t, r, i) { for (var a = t.coordinateSystem, o = t.getModel("itemStyle").getItemStyle(), s = a.getCellWidth(), l = a.getCellHeight(), c = r.start.time; c <= r.end.time; c = a.getNextNDay(c, 1).time) { var u = a.dataToRect([c], !1).tl, d = new Yt({ shape: { x: u[0], y: u[1], width: s, height: l }, cursor: "default", style: o }); i.add(d) } }, e.prototype._renderLines = function (t, r, i, a) { var o = this, s = t.coordinateSystem, l = t.getModel(["splitLine", "lineStyle"]).getLineStyle(), c = t.get(["splitLine", "show"]), u = l.lineWidth; this._tlpoints = [], this._blpoints = [], this._firstDayOfMonth = [], this._firstDayPoints = []; for (var d = r.start, f = 0; d.time <= r.end.time; f++) { p(d.formatedDate), f === 0 && (d = s.getDateInfo(r.start.y + "-" + r.start.m)); var h = d.date; h.setMonth(h.getMonth() + 1), d = s.getDateInfo(h) } p(s.getNextNDay(r.end.time, 1).formatedDate); function p(m) { o._firstDayOfMonth.push(s.getDateInfo(m)), o._firstDayPoints.push(s.dataToRect([m], !1).tl); var g = o._getLinePointsOfOneWeek(t, m, i); o._tlpoints.push(g[0]), o._blpoints.push(g[g.length - 1]), c && o._drawSplitline(g, l, a) } c && this._drawSplitline(o._getEdgesPoints(o._tlpoints, u, i), l, a), c && this._drawSplitline(o._getEdgesPoints(o._blpoints, u, i), l, a) }, e.prototype._getEdgesPoints = function (t, r, i) { var a = [t[0].slice(), t[t.length - 1].slice()], o = i === "horizontal" ? 0 : 1; return a[0][o] = a[0][o] - r / 2, a[1][o] = a[1][o] + r / 2, a }, e.prototype._drawSplitline = function (t, r, i) { var a = new Ea({ z2: 20, shape: { points: t }, style: r }); i.add(a) }, e.prototype._getLinePointsOfOneWeek = function (t, r, i) { for (var a = t.coordinateSystem, o = a.getDateInfo(r), s = [], l = 0; l < 7; l++) { var c = a.getNextNDay(o.time, l), u = a.dataToRect([c.time], !1); s[2 * c.day] = u.tl, s[2 * c.day + 1] = u[i === "horizontal" ? "bl" : "tr"] } return s }, e.prototype._formatterLabel = function (t, r) { return Fe(t) && t ? lVe(t, r) : tt(t) ? t(r) : r.nameMap }, e.prototype._yearTextPositionControl = function (t, r, i, a, o) { var s = r[0], l = r[1], c = ["center", "bottom"]; a === "bottom" ? (l += o, c = ["center", "top"]) : a === "left" ? s -= o : a === "right" ? (s += o, c = ["center", "top"]) : l -= o; var u = 0; return (a === "left" || a === "right") && (u = Math.PI / 2), { rotation: u, x: s, y: l, style: { align: c[0], verticalAlign: c[1] } } }, e.prototype._renderYearText = function (t, r, i, a) { var o = t.getModel("yearLabel"); if (o.get("show")) { var s = o.get("margin"), l = o.get("position"); l || (l = i !== "horizontal" ? "top" : "left"); var c = [this._tlpoints[this._tlpoints.length - 1], this._blpoints[0]], u = (c[0][0] + c[1][0]) / 2, d = (c[0][1] + c[1][1]) / 2, f = i === "horizontal" ? 0 : 1, h = { top: [u, c[f][1]], bottom: [u, c[1 - f][1]], left: [c[1 - f][0], d], right: [c[f][0], d] }, p = r.start.y; +r.end.y > +r.start.y && (p = p + "-" + r.end.y); var m = o.get("formatter"), g = { start: r.start.y, end: r.end.y, nameMap: p }, y = this._formatterLabel(m, g), b = new tn({ z2: 30, style: Ln(o, { text: y }), silent: o.get("silent") }); b.attr(this._yearTextPositionControl(b, h[l], i, l, s)), a.add(b) } }, e.prototype._monthTextPositionControl = function (t, r, i, a, o) { var s = "left", l = "top", c = t[0], u = t[1]; return i === "horizontal" ? (u = u + o, r && (s = "center"), a === "start" && (l = "bottom")) : (c = c + o, r && (l = "middle"), a === "start" && (s = "right")), { x: c, y: u, align: s, verticalAlign: l } }, e.prototype._renderMonthText = function (t, r, i, a) { var o = t.getModel("monthLabel"); if (o.get("show")) { var s = o.get("nameMap"), l = o.get("margin"), c = o.get("position"), u = o.get("align"), d = [this._tlpoints, this._blpoints]; (!s || Fe(s)) && (s && (r = nI(s) || r), s = r.get(["time", "monthAbbr"]) || []); var f = c === "start" ? 0 : 1, h = i === "horizontal" ? 0 : 1; l = c === "start" ? -l : l; for (var p = u === "center", m = o.get("silent"), g = 0; g < d[f].length - 1; g++) { var y = d[f][g].slice(), b = this._firstDayOfMonth[g]; if (p) { var w = this._firstDayPoints[g]; y[h] = (w[h] + d[0][g + 1][h]) / 2 } var v = o.get("formatter"), S = s[+b.m - 1], x = { yyyy: b.y, yy: (b.y + "").slice(2), MM: b.m, M: +b.m, nameMap: S }, k = this._formatterLabel(v, x), A = new tn({ z2: 30, style: be(Ln(o, { text: k }), this._monthTextPositionControl(y, p, i, c, l)), silent: m }); a.add(A) } } }, e.prototype._weekTextPositionControl = function (t, r, i, a, o) { var s = "center", l = "middle", c = t[0], u = t[1], d = i === "start"; return r === "horizontal" ? (c = c + a + (d ? 1 : -1) * o[0] / 2, s = d ? "right" : "left") : (u = u + a + (d ? 1 : -1) * o[1] / 2, l = d ? "bottom" : "top"), { x: c, y: u, align: s, verticalAlign: l } }, e.prototype._renderWeekText = function (t, r, i, a, o) { var s = t.getModel("dayLabel"); if (s.get("show")) { var l = t.coordinateSystem, c = s.get("position"), u = s.get("nameMap"), d = s.get("margin"), f = l.getFirstDayOfWeek(); if (!u || Fe(u)) { u && (r = nI(u) || r); var h = r.get(["time", "dayOfWeekShort"]); u = h || Ae(r.get(["time", "dayOfWeekAbbr"]), function (x) { return x[0] }) } var p = l.getNextNDay(i.end.time, 7 - i.lweek).time, m = [l.getCellWidth(), l.getCellHeight()]; d = Ne(d, Math.min(m[1], m[0])), c === "start" && (p = l.getNextNDay(i.start.time, -(7 + i.fweek)).time, d = -d); for (var g = s.get("silent"), y = 0; y < 7; y++) { var b = l.getNextNDay(p, y), w = l.dataToRect([b.time], !1).center, v = y; v = Math.abs((y + f) % 7); var S = new tn({ z2: 30, style: be(Ln(s, { text: u[v] }), this._weekTextPositionControl(w, a, c, d, m)), silent: g }); o.add(S) } } }, e.type = "calendar", e }(nr); const dnt = unt; var cD = 864e5, fnt = function () { function n(e, t, r) { this.type = "calendar", this.dimensions = n.dimensions, this.getDimensionsInfo = n.getDimensionsInfo, this._model = e } return n.getDimensionsInfo = function () { return [{ name: "time", type: "time" }, "value"] }, n.prototype.getRangeInfo = function () { return this._rangeInfo }, n.prototype.getModel = function () { return this._model }, n.prototype.getRect = function () { return this._rect }, n.prototype.getCellWidth = function () { return this._sw }, n.prototype.getCellHeight = function () { return this._sh }, n.prototype.getOrient = function () { return this._orient }, n.prototype.getFirstDayOfWeek = function () { return this._firstDayOfWeek }, n.prototype.getDateInfo = function (e) { e = kl(e); var t = e.getFullYear(), r = e.getMonth() + 1, i = r < 10 ? "0" + r : "" + r, a = e.getDate(), o = a < 10 ? "0" + a : "" + a, s = e.getDay(); return s = Math.abs((s + 7 - this.getFirstDayOfWeek()) % 7), { y: t + "", m: i, d: o, day: s, time: e.getTime(), formatedDate: t + "-" + i + "-" + o, date: e } }, n.prototype.getNextNDay = function (e, t) { return t = t || 0, t === 0 ? this.getDateInfo(e) : (e = new Date(this.getDateInfo(e).time), e.setDate(e.getDate() + t), this.getDateInfo(e)) }, n.prototype.update = function (e, t) { this._firstDayOfWeek = +this._model.getModel("dayLabel").get("firstDay"), this._orient = this._model.get("orient"), this._lineWidth = this._model.getModel("itemStyle").getItemStyle().lineWidth || 0, this._rangeInfo = this._getRangeInfo(this._initRangeOption()); var r = this._rangeInfo.weeks || 1, i = ["width", "height"], a = this._model.getCellSize().slice(), o = this._model.getBoxLayoutParams(), s = this._orient === "horizontal" ? [r, 7] : [7, r]; $([0, 1], function (d) { u(a, d) && (o[i[d]] = a[d] * s[d]) }); var l = { width: t.getWidth(), height: t.getHeight() }, c = this._rect = jr(o, l); $([0, 1], function (d) { u(a, d) || (a[d] = c[i[d]] / s[d]) }); function u(d, f) { return d[f] != null && d[f] !== "auto" } this._sw = a[0], this._sh = a[1] }, n.prototype.dataToPoint = function (e, t) { ke(e) && (e = e[0]), t == null && (t = !0); var r = this.getDateInfo(e), i = this._rangeInfo, a = r.formatedDate; if (t && !(r.time >= i.start.time && r.time < i.end.time + cD)) return [NaN, NaN]; var o = r.day, s = this._getRangeInfo([i.start.time, a]).nthWeek; return this._orient === "vertical" ? [this._rect.x + o * this._sw + this._sw / 2, this._rect.y + s * this._sh + this._sh / 2] : [this._rect.x + s * this._sw + this._sw / 2, this._rect.y + o * this._sh + this._sh / 2] }, n.prototype.pointToData = function (e) { var t = this.pointToDate(e); return t && t.time }, n.prototype.dataToRect = function (e, t) { var r = this.dataToPoint(e, t); return { contentShape: { x: r[0] - (this._sw - this._lineWidth) / 2, y: r[1] - (this._sh - this._lineWidth) / 2, width: this._sw - this._lineWidth, height: this._sh - this._lineWidth }, center: r, tl: [r[0] - this._sw / 2, r[1] - this._sh / 2], tr: [r[0] + this._sw / 2, r[1] - this._sh / 2], br: [r[0] + this._sw / 2, r[1] + this._sh / 2], bl: [r[0] - this._sw / 2, r[1] + this._sh / 2] } }, n.prototype.pointToDate = function (e) { var t = Math.floor((e[0] - this._rect.x) / this._sw) + 1, r = Math.floor((e[1] - this._rect.y) / this._sh) + 1, i = this._rangeInfo.range; return this._orient === "vertical" ? this._getDateByWeeksAndDay(r, t - 1, i) : this._getDateByWeeksAndDay(t, r - 1, i) }, n.prototype.convertToPixel = function (e, t, r) { var i = nG(t); return i === this ? i.dataToPoint(r) : null }, n.prototype.convertFromPixel = function (e, t, r) { var i = nG(t); return i === this ? i.pointToData(r) : null }, n.prototype.containPoint = function (e) { return console.warn("Not implemented."), !1 }, n.prototype._initRangeOption = function () { var e = this._model.get("range"), t; if (ke(e) && e.length === 1 && (e = e[0]), ke(e)) t = e; else { var r = e.toString(); if (/^\d{4}$/.test(r) && (t = [r + "-01-01", r + "-12-31"]), /^\d{4}[\/|-]\d{1,2}$/.test(r)) { var i = this.getDateInfo(r), a = i.date; a.setMonth(a.getMonth() + 1); var o = this.getNextNDay(a, -1); t = [i.formatedDate, o.formatedDate] } /^\d{4}[\/|-]\d{1,2}[\/|-]\d{1,2}$/.test(r) && (t = [r, r]) } if (!t) return e; var s = this._getRangeInfo(t); return s.start.time > s.end.time && t.reverse(), t }, n.prototype._getRangeInfo = function (e) { var t = [this.getDateInfo(e[0]), this.getDateInfo(e[1])], r; t[0].time > t[1].time && (r = !0, t.reverse()); var i = Math.floor(t[1].time / cD) - Math.floor(t[0].time / cD) + 1, a = new Date(t[0].time), o = a.getDate(), s = t[1].date.getDate(); a.setDate(o + i - 1); var l = a.getDate(); if (l !== s) for (var c = a.getTime() - t[1].time > 0 ? 1 : -1; (l = a.getDate()) !== s && (a.getTime() - t[1].time) * c > 0;)i -= c, a.setDate(l - c); var u = Math.floor((i + t[0].day + 6) / 7), d = r ? -u + 1 : u - 1; return r && t.reverse(), { range: [t[0].formatedDate, t[1].formatedDate], start: t[0], end: t[1], allDay: i, weeks: u, nthWeek: d, fweek: t[0].day, lweek: t[1].day } }, n.prototype._getDateByWeeksAndDay = function (e, t, r) { var i = this._getRangeInfo(r); if (e > i.weeks || e === 0 && t < i.fweek || e === i.weeks && t > i.lweek) return null; var a = (e - 1) * 7 - i.fweek + t, o = new Date(i.start.time); return o.setDate(+i.start.d + a), this.getDateInfo(o) }, n.create = function (e, t) { var r = []; return e.eachComponent("calendar", function (i) { var a = new n(i); r.push(a), i.coordinateSystem = a }), e.eachSeries(function (i) { i.get("coordinateSystem") === "calendar" && (i.coordinateSystem = r[i.get("calendarIndex") || 0]) }), r }, n.dimensions = ["time", "value"], n }(); function nG(n) { var e = n.calendarModel, t = n.seriesModel, r = e ? e.coordinateSystem : t ? t.coordinateSystem : null; return r } const hnt = fnt; function pnt(n) { n.registerComponentModel(cnt), n.registerComponentView(dnt), n.registerCoordinateSystem("calendar", hnt) } function mnt(n, e) { var t = n.existing; if (e.id = n.keyInfo.id, !e.type && t && (e.type = t.type), e.parentId == null) { var r = e.parentOption; r ? e.parentId = r.id : t && (e.parentId = t.parentId) } e.parentOption = null } function rG(n, e) { var t; return $(e, function (r) { n[r] != null && n[r] !== "auto" && (t = !0) }), t } function gnt(n, e, t) { var r = be({}, t), i = n[e], a = t.$action || "merge"; a === "merge" ? i ? (xt(i, r, !0), Ed(i, r, { ignoreSize: !0 }), wne(t, i), yx(t, i), yx(t, i, "shape"), yx(t, i, "style"), yx(t, i, "extra"), t.clipPath = i.clipPath) : n[e] = r : a === "replace" ? n[e] = r : a === "remove" && i && (n[e] = null) } var Foe = ["transition", "enterFrom", "leaveTo"], vnt = Foe.concat(["enterAnimation", "updateAnimation", "leaveAnimation"]); function yx(n, e, t) { if (t && (!n[t] && e[t] && (n[t] = {}), n = n[t], e = e[t]), !(!n || !e)) for (var r = t ? Foe : vnt, i = 0; i < r.length; i++) { var a = r[i]; n[a] == null && e[a] != null && (n[a] = e[a]) } } function ynt(n, e) { if (n && (n.hv = e.hv = [rG(e, ["left", "right"]), rG(e, ["top", "bottom"])], n.type === "group")) { var t = n, r = e; t.width == null && (t.width = r.width = 0), t.height == null && (t.height = r.height = 0) } } var _nt = function (n) { te(e, n); function e() { var t = n !== null && n.apply(this, arguments) || this; return t.type = e.type, t.preventAutoZ = !0, t } return e.prototype.mergeOption = function (t, r) { var i = this.option.elements; this.option.elements = null, n.prototype.mergeOption.call(this, t, r), this.option.elements = i }, e.prototype.optionUpdated = function (t, r) { var i = this.option, a = (r ? i : t).elements, o = i.elements = r ? [] : i.elements, s = []; this._flatten(a, s, null); var l = ite(o, s, "normalMerge"), c = this._elOptionsToUpdate = []; $(l, function (u, d) { var f = u.newOption; f && (c.push(f), mnt(u, f), gnt(o, d, f), ynt(o[d], f)) }, this), i.elements = pn(o, function (u) { return u && delete u.$action, u != null }) }, e.prototype._flatten = function (t, r, i) { $(t, function (a) { if (a) { i && (a.parentOption = i), r.push(a); var o = a.children; o && o.length && this._flatten(o, r, a), delete a.children } }, this) }, e.prototype.useElOptionsToUpdate = function () { var t = this._elOptionsToUpdate; return this._elOptionsToUpdate = null, t }, e.type = "graphic", e.defaultOption = { elements: [] }, e }(Jt), iG = { path: null, compoundPath: null, group: ft, image: gi, text: tn }, vo = Kt(), bnt = function (n) { te(e, n); function e() { var t = n !== null && n.apply(this, arguments) || this; return t.type = e.type, t } return e.prototype.init = function () { this._elMap = Ze() }, e.prototype.render = function (t, r, i) { t !== this._lastGraphicModel && this._clear(), this._lastGraphicModel = t, this._updateElements(t), this._relocate(t, i) }, e.prototype._updateElements = function (t) { var r = t.useElOptionsToUpdate(); if (r) { var i = this._elMap, a = this.group, o = t.get("z"), s = t.get("zlevel"); $(r, function (l) { var c = Er(l.id, null), u = c != null ? i.get(c) : null, d = Er(l.parentId, null), f = d != null ? i.get(d) : a, h = l.type, p = l.style; h === "text" && p && l.hv && l.hv[1] && (p.textVerticalAlign = p.textBaseline = p.verticalAlign = p.align = null); var m = l.textContent, g = l.textConfig; if (p && _oe(p, h, !!g, !!m)) { var y = boe(p, h, !0); !g && y.textConfig && (g = l.textConfig = y.textConfig), !m && y.textContent && (m = y.textContent) } var b = wnt(l), w = l.$action || "merge", v = w === "merge", S = w === "replace"; if (v) { var x = !u, k = u; x ? k = aG(c, f, l.type, i) : (k && (vo(k).isNew = !1), Toe(k)), k && (cS(k, b, t, { isInit: x }), oG(k, l, o, s)) } else if (S) { dS(u, l, i, t); var A = aG(c, f, l.type, i); A && (cS(A, b, t, { isInit: !0 }), oG(A, l, o, s)) } else w === "remove" && (xoe(u, l), dS(u, l, i, t)); var C = i.get(c); if (C && m) if (v) { var E = C.getTextContent(); E ? E.attr(m) : C.setTextContent(new tn(m)) } else S && C.setTextContent(new tn(m)); if (C) { var O = l.clipPath; if (O) { var j = O.type, I = void 0, x = !1; if (v) { var L = C.getClipPath(); x = !L || vo(L).type !== j, I = x ? KI(j) : L } else S && (x = !0, I = KI(j)); C.setClipPath(I), cS(I, O, t, { isInit: x }), kT(I, O.keyframeAnimation, t) } var R = vo(C); C.setTextConfig(g), R.option = l, xnt(C, t, l), ip({ el: C, componentModel: t, itemName: C.name, itemTooltipOption: l.tooltip }), kT(C, l.keyframeAnimation, t) } }) } }, e.prototype._relocate = function (t, r) { for (var i = t.option.elements, a = this.group, o = this._elMap, s = r.getWidth(), l = r.getHeight(), c = ["x", "y"], u = 0; u < i.length; u++) { var d = i[u], f = Er(d.id, null), h = f != null ? o.get(f) : null; if (!(!h || !h.isGroup)) { var p = h.parent, m = p === a, g = vo(h), y = vo(p); g.width = Ne(g.option.width, m ? s : y.width) || 0, g.height = Ne(g.option.height, m ? l : y.height) || 0 } } for (var u = i.length - 1; u >= 0; u--) { var d = i[u], f = Er(d.id, null), h = f != null ? o.get(f) : null; if (h) { var p = h.parent, y = vo(p), b = p === a ? { width: s, height: l } : { width: y.width, height: y.height }, w = {}, v = hC(h, d, b, null, { hv: d.hv, boundingMode: d.bounding }, w); if (!vo(h).isNew && v) { for (var S = d.transition, x = {}, k = 0; k < c.length; k++) { var A = c[k], C = w[A]; S && (Mh(S) || Et(S, A) >= 0) ? x[A] = C : h[A] = C } on(h, x, t, 0) } else h.attr(w) } } }, e.prototype._clear = function () { var t = this, r = this._elMap; r.each(function (i) { dS(i, vo(i).option, r, t._lastGraphicModel) }), this._elMap = Ze() }, e.prototype.dispose = function () { this._clear() }, e.type = "graphic", e }(nr); function KI(n) { var e = Ge(iG, n) ? iG[n] : WN(n), t = new e({}); return vo(t).type = n, t } function aG(n, e, t, r) { var i = KI(t); return e.add(i), r.set(n, i), vo(i).id = n, vo(i).isNew = !0, i } function dS(n, e, t, r) { var i = n && n.parent; i && (n.type === "group" && n.traverse(function (a) { dS(a, e, t, r) }), MC(n, e, r), t.removeKey(vo(n).id)) } function oG(n, e, t, r) { n.isGroup || $([["cursor", Ho.prototype.cursor], ["zlevel", r || 0], ["z", t || 0], ["z2", 0]], function (i) { var a = i[0]; Ge(e, a) ? n[a] = yt(e[a], i[1]) : n[a] == null && (n[a] = i[1]) }), $(Bt(e), function (i) { if (i.indexOf("on") === 0) { var a = e[i]; n[i] = tt(a) ? a : null } }), Ge(e, "draggable") && (n.draggable = e.draggable), e.name != null && (n.name = e.name), e.id != null && (n.id = e.id) } function wnt(n) { return n = be({}, n), $(["id", "parentId", "$action", "hv", "bounding", "textContent", "clipPath"].concat(bne), function (e) { delete n[e] }), n } function xnt(n, e, t) { var r = pt(n).eventData; !n.silent && !n.ignore && !r && (r = pt(n).eventData = { componentType: "graphic", componentIndex: e.componentIndex, name: n.name }), r && (r.info = t.info) } function Snt(n) { n.registerComponentModel(_nt), n.registerComponentView(bnt), n.registerPreprocessor(function (e) { var t = e.graphic; ke(t) ? !t[0] || !t[0].elements ? e.graphic = [{ elements: t }] : e.graphic = [e.graphic[0]] : t && !t.elements && (e.graphic = [{ elements: [t] }]) }) } var sG = ["x", "y", "radius", "angle", "single"], Tnt = ["cartesian2d", "polar", "singleAxis"]; function knt(n) { var e = n.get("coordinateSystem"); return Et(Tnt, e) >= 0 } function Xu(n) { return n + "Axis" } function Cnt(n, e) { var t = Ze(), r = [], i = Ze(); n.eachComponent({ mainType: "dataZoom", query: e }, function (u) { i.get(u.uid) || s(u) }); var a; do a = !1, n.eachComponent("dataZoom", o); while (a); function o(u) { !i.get(u.uid) && l(u) && (s(u), a = !0) } function s(u) { i.set(u.uid, !0), r.push(u), c(u) } function l(u) { var d = !1; return u.eachTargetAxis(function (f, h) { var p = t.get(f); p && p[h] && (d = !0) }), d } function c(u) { u.eachTargetAxis(function (d, f) { (t.get(d) || t.set(d, []))[f] = !0 }) } return r } function zoe(n) { var e = n.ecModel, t = { infoList: [], infoMap: Ze() }; return n.eachTargetAxis(function (r, i) { var a = e.getComponent(Xu(r), i); if (a) { var o = a.getCoordSysModel(); if (o) { var s = o.uid, l = t.infoMap.get(s); l || (l = { model: o, axisModels: [] }, t.infoList.push(l), t.infoMap.set(s, l)), l.axisModels.push(a) } } }), t } var uD = function () { function n() { this.indexList = [], this.indexMap = [] } return n.prototype.add = function (e) { this.indexMap[e] || (this.indexList.push(e), this.indexMap[e] = !0) }, n }(), Ant = function (n) { te(e, n); function e() { var t = n !== null && n.apply(this, arguments) || this; return t.type = e.type, t._autoThrottle = !0, t._noTarget = !0, t._rangePropMode = ["percent", "percent"], t } return e.prototype.init = function (t, r, i) { var a = lG(t); this.settledOption = a, this.mergeDefaultAndTheme(t, i), this._doInit(a) }, e.prototype.mergeOption = function (t) { var r = lG(t); xt(this.option, t, !0), xt(this.settledOption, r, !0), this._doInit(r) }, e.prototype._doInit = function (t) { var r = this.option; this._setDefaultThrottle(t), this._updateRangeUse(t); var i = this.settledOption; $([["start", "startValue"], ["end", "endValue"]], function (a, o) { this._rangePropMode[o] === "value" && (r[a[0]] = i[a[0]] = null) }, this), this._resetTarget() }, e.prototype._resetTarget = function () { var t = this.get("orient", !0), r = this._targetAxisInfoMap = Ze(), i = this._fillSpecifiedTargetAxis(r); i ? this._orient = t || this._makeAutoOrientByTargetAxis() : (this._orient = t || "horizontal", this._fillAutoTargetAxisByOrient(r, this._orient)), this._noTarget = !0, r.each(function (a) { a.indexList.length && (this._noTarget = !1) }, this) }, e.prototype._fillSpecifiedTargetAxis = function (t) { var r = !1; return $(sG, function (i) { var a = this.getReferringComponents(Xu(i), VFe); if (a.specified) { r = !0; var o = new uD; $(a.models, function (s) { o.add(s.componentIndex) }), t.set(i, o) } }, this), r }, e.prototype._fillAutoTargetAxisByOrient = function (t, r) { var i = this.ecModel, a = !0; if (a) { var o = r === "vertical" ? "y" : "x", s = i.findComponents({ mainType: o + "Axis" }); l(s, o) } if (a) { var s = i.findComponents({ mainType: "singleAxis", filter: function (u) { return u.get("orient", !0) === r } }); l(s, "single") } function l(c, u) { var d = c[0]; if (d) { var f = new uD; if (f.add(d.componentIndex), t.set(u, f), a = !1, u === "x" || u === "y") { var h = d.getReferringComponents("grid", xr).models[0]; h && $(c, function (p) { d.componentIndex !== p.componentIndex && h === p.getReferringComponents("grid", xr).models[0] && f.add(p.componentIndex) }) } } } a && $(sG, function (c) { if (a) { var u = i.findComponents({ mainType: Xu(c), filter: function (f) { return f.get("type", !0) === "category" } }); if (u[0]) { var d = new uD; d.add(u[0].componentIndex), t.set(c, d), a = !1 } } }, this) }, e.prototype._makeAutoOrientByTargetAxis = function () { var t; return this.eachTargetAxis(function (r) { !t && (t = r) }, this), t === "y" ? "vertical" : "horizontal" }, e.prototype._setDefaultThrottle = function (t) { if (t.hasOwnProperty("throttle") && (this._autoThrottle = !1), this._autoThrottle) { var r = this.ecModel.option; this.option.throttle = r.animation && r.animationDurationUpdate > 0 ? 100 : 20 } }, e.prototype._updateRangeUse = function (t) { var r = this._rangePropMode, i = this.get("rangeMode"); $([["start", "startValue"], ["end", "endValue"]], function (a, o) { var s = t[a[0]] != null, l = t[a[1]] != null; s && !l ? r[o] = "percent" : !s && l ? r[o] = "value" : i ? r[o] = i[o] : s && (r[o] = "percent") }) }, e.prototype.noTarget = function () { return this._noTarget }, e.prototype.getFirstTargetAxisModel = function () { var t; return this.eachTargetAxis(function (r, i) { t == null && (t = this.ecModel.getComponent(Xu(r), i)) }, this), t }, e.prototype.eachTargetAxis = function (t, r) { this._targetAxisInfoMap.each(function (i, a) { $(i.indexList, function (o) { t.call(r, a, o) }) }) }, e.prototype.getAxisProxy = function (t, r) { var i = this.getAxisModel(t, r); if (i) return i.__dzAxisProxy }, e.prototype.getAxisModel = function (t, r) { var i = this._targetAxisInfoMap.get(t); if (i && i.indexMap[r]) return this.ecModel.getComponent(Xu(t), r) }, e.prototype.setRawRange = function (t) { var r = this.option, i = this.settledOption; $([["start", "startValue"], ["end", "endValue"]], function (a) { (t[a[0]] != null || t[a[1]] != null) && (r[a[0]] = i[a[0]] = t[a[0]], r[a[1]] = i[a[1]] = t[a[1]]) }, this), this._updateRangeUse(t) }, e.prototype.setCalculatedRange = function (t) { var r = this.option; $(["start", "startValue", "end", "endValue"], function (i) { r[i] = t[i] }) }, e.prototype.getPercentRange = function () { var t = this.findRepresentativeAxisProxy(); if (t) return t.getDataPercentWindow() }, e.prototype.getValueRange = function (t, r) { if (t == null && r == null) { var i = this.findRepresentativeAxisProxy(); if (i) return i.getDataValueWindow() } else return this.getAxisProxy(t, r).getDataValueWindow() }, e.prototype.findRepresentativeAxisProxy = function (t) { if (t) return t.__dzAxisProxy; for (var r, i = this._targetAxisInfoMap.keys(), a = 0; a < i.length; a++)for (var o = i[a], s = this._targetAxisInfoMap.get(o), l = 0; l < s.indexList.length; l++) { var c = this.getAxisProxy(o, s.indexList[l]); if (c.hostedBy(this)) return c; r || (r = c) } return r }, e.prototype.getRangePropMode = function () { return this._rangePropMode.slice() }, e.prototype.getOrient = function () { return this._orient }, e.type = "dataZoom", e.dependencies = ["xAxis", "yAxis", "radiusAxis", "angleAxis", "singleAxis", "series", "toolbox"], e.defaultOption = { z: 4, filterMode: "filter", start: 0, end: 100 }, e }(Jt); function lG(n) { var e = {}; return $(["start", "end", "startValue", "endValue", "throttle"], function (t) { n.hasOwnProperty(t) && (e[t] = n[t]) }), e } const L_ = Ant; var Ent = function (n) { te(e, n); function e() { var t = n !== null && n.apply(this, arguments) || this; return t.type = e.type, t } return e.type = "dataZoom.select", e }(L_); const Mnt = Ent; var Ont = function (n) { te(e, n); function e() { var t = n !== null && n.apply(this, arguments) || this; return t.type = e.type, t } return e.prototype.render = function (t, r, i, a) { this.dataZoomModel = t, this.ecModel = r, this.api = i }, e.type = "dataZoom", e }(nr); const vB = Ont; var Dnt = function (n) { te(e, n); function e() { var t = n !== null && n.apply(this, arguments) || this; return t.type = e.type, t } return e.type = "dataZoom.select", e }(vB); const jnt = Dnt; var Tm = $, cG = Oo, Pnt = function () { function n(e, t, r, i) { this._dimName = e, this._axisIndex = t, this.ecModel = i, this._dataZoomModel = r } return n.prototype.hostedBy = function (e) { return this._dataZoomModel === e }, n.prototype.getDataValueWindow = function () { return this._valueWindow.slice() }, n.prototype.getDataPercentWindow = function () { return this._percentWindow.slice() }, n.prototype.getTargetSeriesModels = function () { var e = []; return this.ecModel.eachSeries(function (t) { if (knt(t)) { var r = Xu(this._dimName), i = t.getReferringComponents(r, xr).models[0]; i && this._axisIndex === i.componentIndex && e.push(t) } }, this), e }, n.prototype.getAxisModel = function () { return this.ecModel.getComponent(this._dimName + "Axis", this._axisIndex) }, n.prototype.getMinMaxSpan = function () { return lt(this._minMaxSpan) }, n.prototype.calculateDataWindow = function (e) { var t = this._dataExtent, r = this.getAxisModel(), i = r.axis.scale, a = this._dataZoomModel.getRangePropMode(), o = [0, 100], s = [], l = [], c; Tm(["start", "end"], function (f, h) { var p = e[f], m = e[f + "Value"]; a[h] === "percent" ? (p == null && (p = o[h]), m = i.parse(vn(p, o, t))) : (c = !0, m = m == null ? t[h] : i.parse(m), p = vn(m, t, o)), l[h] = m == null || isNaN(m) ? t[h] : m, s[h] = p == null || isNaN(p) ? o[h] : p }), cG(l), cG(s); var u = this._minMaxSpan; c ? d(l, s, t, o, !1) : d(s, l, o, t, !0); function d(f, h, p, m, g) { var y = g ? "Span" : "ValueSpan"; dp(0, f, p, "all", u["min" + y], u["max" + y]); for (var b = 0; b < 2; b++)h[b] = vn(f[b], p, m, !0), g && (h[b] = i.parse(h[b])) } return { valueWindow: l, percentWindow: s } }, n.prototype.reset = function (e) { if (e === this._dataZoomModel) { var t = this.getTargetSeriesModels(); this._dataExtent = Int(this, this._dimName, t), this._updateMinMaxSpan(); var r = this.calculateDataWindow(e.settledOption); this._valueWindow = r.valueWindow, this._percentWindow = r.percentWindow, this._setAxisModel() } }, n.prototype.filterData = function (e, t) { if (e !== this._dataZoomModel) return; var r = this._dimName, i = this.getTargetSeriesModels(), a = e.get("filterMode"), o = this._valueWindow; if (a === "none") return; Tm(i, function (l) { var c = l.getData(), u = c.mapDimensionsAll(r); if (u.length) { if (a === "weakFilter") { var d = c.getStore(), f = Ae(u, function (h) { return c.getDimensionIndex(h) }, c); c.filterSelf(function (h) { for (var p, m, g, y = 0; y < u.length; y++) { var b = d.get(f[y], h), w = !isNaN(b), v = b < o[0], S = b > o[1]; if (w && !v && !S) return !0; w && (g = !0), v && (p = !0), S && (m = !0) } return g && p && m }) } else Tm(u, function (h) { if (a === "empty") l.setData(c = c.map(h, function (m) { return s(m) ? m : NaN })); else { var p = {}; p[h] = o, c.selectRange(p) } }); Tm(u, function (h) { c.setApproximateExtent(o, h) }) } }); function s(l) { return l >= o[0] && l <= o[1] } }, n.prototype._updateMinMaxSpan = function () { var e = this._minMaxSpan = {}, t = this._dataZoomModel, r = this._dataExtent; Tm(["min", "max"], function (i) { var a = t.get(i + "Span"), o = t.get(i + "ValueSpan"); o != null && (o = this.getAxisModel().axis.scale.parse(o)), o != null ? a = vn(r[0] + o, r, [0, 100], !0) : a != null && (o = vn(a, [0, 100], r, !0) - r[0]), e[i + "Span"] = a, e[i + "ValueSpan"] = o }, this) }, n.prototype._setAxisModel = function () { var e = this.getAxisModel(), t = this._percentWindow, r = this._valueWindow; if (t) { var i = Zee(r, [0, 500]); i = Math.min(i, 20); var a = e.axis.scale.rawExtentInfo; t[0] !== 0 && a.setDeterminedMinMax("min", +r[0].toFixed(i)), t[1] !== 100 && a.setDeterminedMinMax("max", +r[1].toFixed(i)), a.freeze() } }, n }(); function Int(n, e, t) { var r = [1 / 0, -1 / 0]; Tm(t, function (o) { eUe(r, o.getData(), e) }); var i = n.getAxisModel(), a = tie(i.axis.scale, i, r).calculate(); return [a.min, a.max] } const Lnt = Pnt; var Rnt = { getTargetSeries: function (n) { function e(i) { n.eachComponent("dataZoom", function (a) { a.eachTargetAxis(function (o, s) { var l = n.getComponent(Xu(o), s); i(o, s, l, a) }) }) } e(function (i, a, o, s) { o.__dzAxisProxy = null }); var t = []; e(function (i, a, o, s) { o.__dzAxisProxy || (o.__dzAxisProxy = new Lnt(i, a, s, n), t.push(o.__dzAxisProxy)) }); var r = Ze(); return $(t, function (i) { $(i.getTargetSeriesModels(), function (a) { r.set(a.uid, a) }) }), r }, overallReset: function (n, e) { n.eachComponent("dataZoom", function (t) { t.eachTargetAxis(function (r, i) { t.getAxisProxy(r, i).reset(t) }), t.eachTargetAxis(function (r, i) { t.getAxisProxy(r, i).filterData(t, e) }) }), n.eachComponent("dataZoom", function (t) { var r = t.findRepresentativeAxisProxy(); if (r) { var i = r.getDataPercentWindow(), a = r.getDataValueWindow(); t.setCalculatedRange({ start: i[0], end: i[1], startValue: a[0], endValue: a[1] }) } }) } }; const Nnt = Rnt; function Bnt(n) { n.registerAction("dataZoom", function (e, t) { var r = Cnt(t, e); $(r, function (i) { i.setRawRange({ start: e.start, end: e.end, startValue: e.startValue, endValue: e.endValue }) }) }) } var uG = !1; function yB(n) { uG || (uG = !0, n.registerProcessor(n.PRIORITY.PROCESSOR.FILTER, Nnt), Bnt(n), n.registerSubTypeDefaulter("dataZoom", function () { return "slider" })) } function $nt(n) { n.registerComponentModel(Mnt), n.registerComponentView(jnt), yB(n) } var wo = function () { function n() { } return n }(), Voe = {}; function km(n, e) { Voe[n] = e } function Hoe(n) { return Voe[n] } var Fnt = function (n) { te(e, n); function e() { var t = n !== null && n.apply(this, arguments) || this; return t.type = e.type, t } return e.prototype.optionUpdated = function () { n.prototype.optionUpdated.apply(this, arguments); var t = this.ecModel; $(this.option.feature, function (r, i) { var a = Hoe(i); a && (a.getDefaultOption && (a.defaultOption = a.getDefaultOption(t)), xt(r, a.defaultOption)) }) }, e.type = "toolbox", e.layoutMode = { type: "box", ignoreSize: !0 }, e.defaultOption = { show: !0, z: 6, orient: "horizontal", left: "right", top: "top", backgroundColor: "transparent", borderColor: "#ccc", borderRadius: 0, borderWidth: 0, padding: 5, itemSize: 15, itemGap: 8, showTitle: !0, iconStyle: { borderColor: "#666", color: "none" }, emphasis: { iconStyle: { borderColor: "#3E98C5" } }, tooltip: { show: !1, position: "bottom" } }, e }(Jt); const znt = Fnt; function Vnt(n, e, t) { var r = e.getBoxLayoutParams(), i = e.get("padding"), a = { width: t.getWidth(), height: t.getHeight() }, o = jr(r, a, i); Ch(e.get("orient"), n, e.get("itemGap"), o.width, o.height), hC(n, r, a, i) } function Uoe(n, e) { var t = ev(e.get("padding")), r = e.getItemStyle(["color", "opacity"]); return r.fill = e.get("backgroundColor"), n = new Yt({ shape: { x: n.x - t[3], y: n.y - t[0], width: n.width + t[1] + t[3], height: n.height + t[0] + t[2], r: e.get("borderRadius") }, style: r, silent: !0, z2: -1 }), n } var Hnt = function (n) { te(e, n); function e() { return n !== null && n.apply(this, arguments) || this } return e.prototype.render = function (t, r, i, a) { var o = this.group; if (o.removeAll(), !t.get("show")) return; var s = +t.get("itemSize"), l = t.get("orient") === "vertical", c = t.get("feature") || {}, u = this._features || (this._features = {}), d = []; $(c, function (p, m) { d.push(m) }), new Lc(this._featureNames || [], d).add(f).update(f).remove(wt(f, null)).execute(), this._featureNames = d; function f(p, m) { var g = d[p], y = d[m], b = c[g], w = new Rn(b, t, t.ecModel), v; if (a && a.newTitle != null && a.featureName === g && (b.title = a.newTitle), g && !y) { if (Unt(g)) v = { onclick: w.option.onclick, featureName: g }; else { var S = Hoe(g); if (!S) return; v = new S } u[g] = v } else if (v = u[y], !v) return; v.uid = Qg("toolbox-feature"), v.model = w, v.ecModel = r, v.api = i; var x = v instanceof wo; if (!g && y) { x && v.dispose && v.dispose(r, i); return } if (!w.get("show") || x && v.unusable) { x && v.remove && v.remove(r, i); return } h(w, v, g), w.setIconStatus = function (k, A) { var C = this.option, E = this.iconPaths; C.iconStatus = C.iconStatus || {}, C.iconStatus[k] = A, E[k] && (A === "emphasis" ? Pc : Ic)(E[k]) }, v instanceof wo && v.render && v.render(w, r, i, a) } function h(p, m, g) { var y = p.getModel("iconStyle"), b = p.getModel(["emphasis", "iconStyle"]), w = m instanceof wo && m.getIcons ? m.getIcons() : p.get("icon"), v = p.get("title") || {}, S, x; Fe(w) ? (S = {}, S[g] = w) : S = w, Fe(v) ? (x = {}, x[g] = v) : x = v; var k = p.iconPaths = {}; $(S, function (A, C) { var E = kb(A, {}, { x: -s / 2, y: -s / 2, width: s, height: s }); E.setStyle(y.getItemStyle()); var O = E.ensureState("emphasis"); O.style = b.getItemStyle(); var j = new tn({ style: { text: x[C], align: b.get("textAlign"), borderRadius: b.get("textBorderRadius"), padding: b.get("textPadding"), fill: null, font: KN({ fontStyle: b.get("textFontStyle"), fontFamily: b.get("textFontFamily"), fontSize: b.get("textFontSize"), fontWeight: b.get("textFontWeight") }, r) }, ignore: !0 }); E.setTextContent(j), ip({ el: E, componentModel: t, itemName: C, formatterParamsExtra: { title: x[C] } }), E.__title = x[C], E.on("mouseover", function () { var I = b.getItemStyle(), L = l ? t.get("right") == null && t.get("left") !== "right" ? "right" : "left" : t.get("bottom") == null && t.get("top") !== "bottom" ? "bottom" : "top"; j.setStyle({ fill: b.get("textFill") || I.fill || I.stroke || "#000", backgroundColor: b.get("textBackgroundColor") }), E.setTextConfig({ position: b.get("textPosition") || L }), j.ignore = !t.get("showTitle"), i.enterEmphasis(this) }).on("mouseout", function () { p.get(["iconStatus", C]) !== "emphasis" && i.leaveEmphasis(this), j.hide() }), (p.get(["iconStatus", C]) === "emphasis" ? Pc : Ic)(E), o.add(E), E.on("click", He(m.onclick, m, r, i, C)), k[C] = E }) } Vnt(o, t, i), o.add(Uoe(o.getBoundingRect(), t)), l || o.eachChild(function (p) { var m = p.__title, g = p.ensureState("emphasis"), y = g.textConfig || (g.textConfig = {}), b = p.getTextContent(), w = b && b.ensureState("emphasis"); if (w && !tt(w) && m) { var v = w.style || (w.style = {}), S = bb(m, tn.makeFont(v)), x = p.x + o.x, k = p.y + o.y + s, A = !1; k + S.height > i.getHeight() && (y.position = "top", A = !0); var C = A ? -5 - S.height : s + 10; x + S.width / 2 > i.getWidth() ? (y.position = ["100%", C], v.align = "right") : x - S.width / 2 < 0 && (y.position = [0, C], v.align = "left") } }) }, e.prototype.updateView = function (t, r, i, a) { $(this._features, function (o) { o instanceof wo && o.updateView && o.updateView(o.model, r, i, a) }) }, e.prototype.remove = function (t, r) { $(this._features, function (i) { i instanceof wo && i.remove && i.remove(t, r) }), this.group.removeAll() }, e.prototype.dispose = function (t, r) { $(this._features, function (i) { i instanceof wo && i.dispose && i.dispose(t, r) }) }, e.type = "toolbox", e }(nr); function Unt(n) { return n.indexOf("my") === 0 } const Gnt = Hnt; var Wnt = function (n) { te(e, n); function e() { return n !== null && n.apply(this, arguments) || this } return e.prototype.onclick = function (t, r) { var i = this.model, a = i.get("name") || t.get("title.0.text") || "echarts", o = r.getZr().painter.getType() === "svg", s = o ? "svg" : i.get("type", !0) || "png", l = r.getConnectedDataURL({ type: s, backgroundColor: i.get("backgroundColor", !0) || t.get("backgroundColor") || "#fff", connectedBackgroundColor: i.get("connectedBackgroundColor"), excludeComponents: i.get("excludeComponents"), pixelRatio: i.get("pixelRatio") }), c = en.browser; if (typeof MouseEvent == "function" && (c.newEdge || !c.ie && !c.edge)) { var u = document.createElement("a"); u.download = a + "." + s, u.target = "_blank", u.href = l; var d = new MouseEvent("click", { view: document.defaultView, bubbles: !0, cancelable: !1 }); u.dispatchEvent(d) } else if (window.navigator.msSaveOrOpenBlob || o) { var f = l.split(","), h = f[0].indexOf("base64") > -1, p = o ? decodeURIComponent(f[1]) : f[1]; h && (p = window.atob(p)); var m = a + "." + s; if (window.navigator.msSaveOrOpenBlob) { for (var g = p.length, y = new Uint8Array(g); g--;)y[g] = p.charCodeAt(g); var b = new Blob([y]); window.navigator.msSaveOrOpenBlob(b, m) } else { var w = document.createElement("iframe"); document.body.appendChild(w); var v = w.contentWindow, S = v.document; S.open("image/svg+xml", "replace"), S.write(p), S.close(), v.focus(), S.execCommand("SaveAs", !0, m), document.body.removeChild(w) } } else { var x = i.get("lang"), k = '<body style="margin:0;"><img src="' + l + '" style="max-width:100%;" title="' + (x && x[0] || "") + '" /></body>', A = window.open(); A.document.write(k), A.document.title = a } }, e.getDefaultOption = function (t) { var r = { show: !0, icon: "M4.7,22.9L29.3,45.5L54.7,23.4M4.6,43.6L4.6,58L53.8,58L53.8,43.6M29.2,45.1L29.2,0", title: t.getLocaleModel().get(["toolbox", "saveAsImage", "title"]), type: "png", connectedBackgroundColor: "#fff", name: "", excludeComponents: ["toolbox"], lang: t.getLocaleModel().get(["toolbox", "saveAsImage", "lang"]) }; return r }, e }(wo); const Knt = Wnt; var dG = "__ec_magicType_stack__", qnt = [["line", "bar"], ["stack"]], Ynt = function (n) { te(e, n); function e() { return n !== null && n.apply(this, arguments) || this } return e.prototype.getIcons = function () { var t = this.model, r = t.get("icon"), i = {}; return $(t.get("type"), function (a) { r[a] && (i[a] = r[a]) }), i }, e.getDefaultOption = function (t) { var r = { show: !0, type: [], icon: { line: "M4.1,28.9h7.1l9.3-22l7.4,38l9.7-19.7l3,12.8h14.9M4.1,58h51.4", bar: "M6.7,22.9h10V48h-10V22.9zM24.9,13h10v35h-10V13zM43.2,2h10v46h-10V2zM3.1,58h53.7", stack: "M8.2,38.4l-8.4,4.1l30.6,15.3L60,42.5l-8.1-4.1l-21.5,11L8.2,38.4z M51.9,30l-8.1,4.2l-13.4,6.9l-13.9-6.9L8.2,30l-8.4,4.2l8.4,4.2l22.2,11l21.5-11l8.1-4.2L51.9,30z M51.9,21.7l-8.1,4.2L35.7,30l-5.3,2.8L24.9,30l-8.4-4.1l-8.3-4.2l-8.4,4.2L8.2,30l8.3,4.2l13.9,6.9l13.4-6.9l8.1-4.2l8.1-4.1L51.9,21.7zM30.4,2.2L-0.2,17.5l8.4,4.1l8.3,4.2l8.4,4.2l5.5,2.7l5.3-2.7l8.1-4.2l8.1-4.2l8.1-4.1L30.4,2.2z" }, title: t.getLocaleModel().get(["toolbox", "magicType", "title"]), option: {}, seriesIndex: {} }; return r }, e.prototype.onclick = function (t, r, i) { var a = this.model, o = a.get(["seriesIndex", i]); if (fG[i]) { var s = { series: [] }, l = function (d) { var f = d.subType, h = d.id, p = fG[i](f, h, d, a); p && (rt(p, d.option), s.series.push(p)); var m = d.coordinateSystem; if (m && m.type === "cartesian2d" && (i === "line" || i === "bar")) { var g = m.getAxesByScale("ordinal")[0]; if (g) { var y = g.dim, b = y + "Axis", w = d.getReferringComponents(b, xr).models[0], v = w.componentIndex; s[b] = s[b] || []; for (var S = 0; S <= v; S++)s[b][v] = s[b][v] || {}; s[b][v].boundaryGap = i === "bar" } } }; $(qnt, function (d) { Et(d, i) >= 0 && $(d, function (f) { a.setIconStatus(f, "normal") }) }), a.setIconStatus(i, "emphasis"), t.eachComponent({ mainType: "series", query: o == null ? null : { seriesIndex: o } }, l); var c, u = i; i === "stack" && (c = xt({ stack: a.option.title.tiled, tiled: a.option.title.stack }, a.option.title), a.get(["iconStatus", i]) !== "emphasis" && (u = "tiled")), r.dispatchAction({ type: "changeMagicType", currentType: u, newOption: s, newTitle: c, featureName: "magicType" }) } }, e }(wo), fG = { line: function (n, e, t, r) { if (n === "bar") return xt({ id: e, type: "line", data: t.get("data"), stack: t.get("stack"), markPoint: t.get("markPoint"), markLine: t.get("markLine") }, r.get(["option", "line"]) || {}, !0) }, bar: function (n, e, t, r) { if (n === "line") return xt({ id: e, type: "bar", data: t.get("data"), stack: t.get("stack"), markPoint: t.get("markPoint"), markLine: t.get("markLine") }, r.get(["option", "bar"]) || {}, !0) }, stack: function (n, e, t, r) { var i = t.get("stack") === dG; if (n === "line" || n === "bar") return r.setIconStatus("stack", i ? "normal" : "emphasis"), xt({ id: e, stack: i ? "" : dG }, r.get(["option", "stack"]) || {}, !0) } }; Ll({ type: "changeMagicType", event: "magicTypeChanged", update: "prepareAndUpdate" }, function (n, e) { e.mergeOption(n.newOption) }); const Znt = Ynt; var OC = new Array(60).join("-"), Pg = "	"; function Xnt(n) { var e = {}, t = [], r = []; return n.eachRawSeries(function (i) { var a = i.coordinateSystem; if (a && (a.type === "cartesian2d" || a.type === "polar")) { var o = a.getBaseAxis(); if (o.type === "category") { var s = o.dim + "_" + o.index; e[s] || (e[s] = { categoryAxis: o, valueAxis: a.getOtherAxis(o), series: [] }, r.push({ axisDim: o.dim, axisIndex: o.index })), e[s].series.push(i) } else t.push(i) } else t.push(i) }), { seriesGroupByCategoryAxis: e, other: t, meta: r } } function Jnt(n) {
  var e = []; return $(n, function (t, r) {
    var i = t.categoryAxis, a = t.valueAxis, o = a.dim, s = [" "].concat(Ae(t.series, function (h) { return h.name })), l = [i.model.getCategories()]; $(t.series, function (h) { var p = h.getRawData(); l.push(h.getRawData().mapArray(p.mapDimension(o), function (m) { return m })) }); for (var c = [s.join(Pg)], u = 0; u < l[0].length; u++) { for (var d = [], f = 0; f < l.length; f++)d.push(l[f][u]); c.push(d.join(Pg)) } e.push(c.join(`
`))
  }), e.join(`

`+ OC + `

`)
} function Qnt(n) {
  return Ae(n, function (e) {
    var t = e.getRawData(), r = [e.name], i = []; return t.each(t.dimensions, function () { for (var a = arguments.length, o = arguments[a - 1], s = t.getName(o), l = 0; l < a - 1; l++)i[l] = arguments[l]; r.push((s ? s + Pg : "") + i.join(Pg)) }), r.join(`
`)
  }).join(`

`+ OC + `

`)
} function ert(n) {
  var e = Xnt(n); return {
    value: pn([Jnt(e.seriesGroupByCategoryAxis), Qnt(e.other)], function (t) { return !!t.replace(/[\n\t\s]/g, "") }).join(`

`+ OC + `

`), meta: e.meta
  }
} function ET(n) { return n.replace(/^\s\s*/, "").replace(/\s\s*$/, "") } function trt(n) {
  var e = n.slice(0, n.indexOf(`
`)); if (e.indexOf(Pg) >= 0) return !0
} var qI = new RegExp("[" + Pg + "]+", "g"); function nrt(n) { for (var e = n.split(/\n+/g), t = ET(e.shift()).split(qI), r = [], i = Ae(t, function (l) { return { name: l, data: [] } }), a = 0; a < e.length; a++) { var o = ET(e[a]).split(qI); r.push(o.shift()); for (var s = 0; s < o.length; s++)i[s] && (i[s].data[a] = o[s]) } return { series: i, categories: r } } function rrt(n) { for (var e = n.split(/\n+/g), t = ET(e.shift()), r = [], i = 0; i < e.length; i++) { var a = ET(e[i]); if (a) { var o = a.split(qI), s = "", l = void 0, c = !1; isNaN(o[0]) ? (c = !0, s = o[0], o = o.slice(1), r[i] = { name: s, value: [] }, l = r[i].value) : l = r[i] = []; for (var u = 0; u < o.length; u++)l.push(+o[u]); l.length === 1 && (c ? r[i].value = l[0] : r[i] = l[0]) } } return { name: t, data: r } } function irt(n, e) {
  var t = n.split(new RegExp(`
*`+ OC + `
*`, "g")), r = { series: [] }; return $(t, function (i, a) { if (trt(i)) { var o = nrt(i), s = e[a], l = s.axisDim + "Axis"; s && (r[l] = r[l] || [], r[l][s.axisIndex] = { data: o.categories }, r.series = r.series.concat(o.series)) } else { var o = rrt(i); r.series.push(o) } }), r
} var art = function (n) { te(e, n); function e() { return n !== null && n.apply(this, arguments) || this } return e.prototype.onclick = function (t, r) { setTimeout(function () { r.dispatchAction({ type: "hideTip" }) }); var i = r.getDom(), a = this.model; this._dom && i.removeChild(this._dom); var o = document.createElement("div"); o.style.cssText = "position:absolute;top:0;bottom:0;left:0;right:0;padding:5px", o.style.backgroundColor = a.get("backgroundColor") || "#fff"; var s = document.createElement("h4"), l = a.get("lang") || []; s.innerHTML = l[0] || a.get("title"), s.style.cssText = "margin:10px 20px", s.style.color = a.get("textColor"); var c = document.createElement("div"), u = document.createElement("textarea"); c.style.cssText = "overflow:auto"; var d = a.get("optionToContent"), f = a.get("contentToOption"), h = ert(t); if (tt(d)) { var p = d(r.getOption()); Fe(p) ? c.innerHTML = p : Tg(p) && c.appendChild(p) } else { u.readOnly = a.get("readOnly"); var m = u.style; m.cssText = "display:block;width:100%;height:100%;font-family:monospace;font-size:14px;line-height:1.6rem;resize:none;box-sizing:border-box;outline:none", m.color = a.get("textColor"), m.borderColor = a.get("textareaBorderColor"), m.backgroundColor = a.get("textareaColor"), u.value = h.value, c.appendChild(u) } var g = h.meta, y = document.createElement("div"); y.style.cssText = "position:absolute;bottom:5px;left:0;right:0"; var b = "float:right;margin-right:20px;border:none;cursor:pointer;padding:2px 5px;font-size:12px;border-radius:3px", w = document.createElement("div"), v = document.createElement("div"); b += ";background-color:" + a.get("buttonColor"), b += ";color:" + a.get("buttonTextColor"); var S = this; function x() { i.removeChild(o), S._dom = null } AP(w, "click", x), AP(v, "click", function () { if (f == null && d != null || f != null && d == null) { x(); return } var k; try { tt(f) ? k = f(c, r.getOption()) : k = irt(u.value, g) } catch (A) { throw x(), new Error("Data view format error " + A) } k && r.dispatchAction({ type: "changeDataView", newOption: k }), x() }), w.innerHTML = l[1], v.innerHTML = l[2], v.style.cssText = w.style.cssText = b, !a.get("readOnly") && y.appendChild(v), y.appendChild(w), o.appendChild(s), o.appendChild(c), o.appendChild(y), c.style.height = i.clientHeight - 80 + "px", i.appendChild(o), this._dom = o }, e.prototype.remove = function (t, r) { this._dom && r.getDom().removeChild(this._dom) }, e.prototype.dispose = function (t, r) { this.remove(t, r) }, e.getDefaultOption = function (t) { var r = { show: !0, readOnly: !1, optionToContent: null, contentToOption: null, icon: "M17.5,17.3H33 M17.5,17.3H33 M45.4,29.5h-28 M11.5,2v56H51V14.8L38.4,2H11.5z M38.4,2.2v12.7H51 M45.4,41.7h-28", title: t.getLocaleModel().get(["toolbox", "dataView", "title"]), lang: t.getLocaleModel().get(["toolbox", "dataView", "lang"]), backgroundColor: "#fff", textColor: "#000", textareaColor: "#fff", textareaBorderColor: "#333", buttonColor: "#c23531", buttonTextColor: "#fff" }; return r }, e }(wo); function ort(n, e) { return Ae(n, function (t, r) { var i = e && e[r]; if (ot(i) && !ke(i)) { var a = ot(t) && !ke(t); a || (t = { value: t }); var o = i.name != null && t.name == null; return t = rt(t, i), o && delete t.name, t } else return t }) } Ll({ type: "changeDataView", event: "dataViewChanged", update: "prepareAndUpdate" }, function (n, e) { var t = []; $(n.newOption.series, function (r) { var i = e.getSeriesByName(r.name)[0]; if (!i) t.push(be({ type: "scatter" }, r)); else { var a = i.get("data"); t.push({ name: r.name, data: ort(r.data, a) }) } }), e.mergeOption(rt({ series: t }, n.newOption)) }); const srt = art; var Goe = $, Woe = Kt(); function lrt(n, e) { var t = _B(n); Goe(e, function (r, i) { for (var a = t.length - 1; a >= 0; a--) { var o = t[a]; if (o[i]) break } if (a < 0) { var s = n.queryComponents({ mainType: "dataZoom", subType: "select", id: i })[0]; if (s) { var l = s.getPercentRange(); t[0][i] = { dataZoomId: i, start: l[0], end: l[1] } } } }), t.push(e) } function crt(n) { var e = _B(n), t = e[e.length - 1]; e.length > 1 && e.pop(); var r = {}; return Goe(t, function (i, a) { for (var o = e.length - 1; o >= 0; o--)if (i = e[o][a], i) { r[a] = i; break } }), r } function urt(n) { Woe(n).snapshots = null } function drt(n) { return _B(n).length } function _B(n) { var e = Woe(n); return e.snapshots || (e.snapshots = [{}]), e.snapshots } var frt = function (n) { te(e, n); function e() { return n !== null && n.apply(this, arguments) || this } return e.prototype.onclick = function (t, r) { urt(t), r.dispatchAction({ type: "restore", from: this.uid }) }, e.getDefaultOption = function (t) { var r = { show: !0, icon: "M3.8,33.4 M47,18.9h9.8V8.7 M56.3,20.1 C52.1,9,40.5,0.6,26.8,2.1C12.6,3.7,1.6,16.2,2.1,30.6 M13,41.1H3.1v10.2 M3.7,39.9c4.2,11.1,15.8,19.5,29.5,18 c14.2-1.6,25.2-14.1,24.7-28.5", title: t.getLocaleModel().get(["toolbox", "restore", "title"]) }; return r }, e }(wo); Ll({ type: "restore", event: "restore", update: "prepareAndUpdate" }, function (n, e) { e.resetOption("recreate") }); const hrt = frt; var prt = ["grid", "xAxis", "yAxis", "geo", "graph", "polar", "radiusAxis", "angleAxis", "bmap"], mrt = function () { function n(e, t, r) { var i = this; this._targetInfoList = []; var a = hG(t, e); $(grt, function (o, s) { (!r || !r.include || Et(r.include, s) >= 0) && o(a, i._targetInfoList) }) } return n.prototype.setOutputRanges = function (e, t) { return this.matchOutputRanges(e, t, function (r, i, a) { if ((r.coordRanges || (r.coordRanges = [])).push(i), !r.coordRange) { r.coordRange = i; var o = dD[r.brushType](0, a, i); r.__rangeOffset = { offset: vG[r.brushType](o.values, r.range, [1, 1]), xyMinMax: o.xyMinMax } } }), e }, n.prototype.matchOutputRanges = function (e, t, r) { $(e, function (i) { var a = this.findTargetInfo(i, t); a && a !== !0 && $(a.coordSyses, function (o) { var s = dD[i.brushType](1, o, i.range, !0); r(i, s.values, o, t) }) }, this) }, n.prototype.setInputRanges = function (e, t) { $(e, function (r) { var i = this.findTargetInfo(r, t); if (r.range = r.range || [], i && i !== !0) { r.panelId = i.panelId; var a = dD[r.brushType](0, i.coordSys, r.coordRange), o = r.__rangeOffset; r.range = o ? vG[r.brushType](a.values, o.offset, vrt(a.xyMinMax, o.xyMinMax)) : a.values } }, this) }, n.prototype.makePanelOpts = function (e, t) { return Ae(this._targetInfoList, function (r) { var i = r.getPanelRect(); return { panelId: r.panelId, defaultBrushType: t ? t(r) : null, clipPath: Qae(i), isTargetByCursor: toe(i, e, r.coordSysModel), getLinearBrushOtherExtent: eoe(i) } }) }, n.prototype.controlSeries = function (e, t, r) { var i = this.findTargetInfo(e, r); return i === !0 || i && Et(i.coordSyses, t.coordinateSystem) >= 0 }, n.prototype.findTargetInfo = function (e, t) { for (var r = this._targetInfoList, i = hG(t, e), a = 0; a < r.length; a++) { var o = r[a], s = e.panelId; if (s) { if (o.panelId === s) return o } else for (var l = 0; l < pG.length; l++)if (pG[l](i, o)) return o } return !0 }, n }(); function YI(n) { return n[0] > n[1] && n.reverse(), n } function hG(n, e) { return h0(n, e, { includeMainTypes: prt }) } var grt = { grid: function (n, e) { var t = n.xAxisModels, r = n.yAxisModels, i = n.gridModels, a = Ze(), o = {}, s = {}; !t && !r && !i || ($(t, function (l) { var c = l.axis.grid.model; a.set(c.id, c), o[c.id] = !0 }), $(r, function (l) { var c = l.axis.grid.model; a.set(c.id, c), s[c.id] = !0 }), $(i, function (l) { a.set(l.id, l), o[l.id] = !0, s[l.id] = !0 }), a.each(function (l) { var c = l.coordinateSystem, u = []; $(c.getCartesians(), function (d, f) { (Et(t, d.getAxis("x").model) >= 0 || Et(r, d.getAxis("y").model) >= 0) && u.push(d) }), e.push({ panelId: "grid--" + l.id, gridModel: l, coordSysModel: l, coordSys: u[0], coordSyses: u, getPanelRect: mG.grid, xAxisDeclared: o[l.id], yAxisDeclared: s[l.id] }) })) }, geo: function (n, e) { $(n.geoModels, function (t) { var r = t.coordinateSystem; e.push({ panelId: "geo--" + t.id, geoModel: t, coordSysModel: t, coordSys: r, coordSyses: [r], getPanelRect: mG.geo }) }) } }, pG = [function (n, e) { var t = n.xAxisModel, r = n.yAxisModel, i = n.gridModel; return !i && t && (i = t.axis.grid.model), !i && r && (i = r.axis.grid.model), i && i === e.gridModel }, function (n, e) { var t = n.geoModel; return t && t === e.geoModel }], mG = { grid: function () { return this.coordSys.master.getRect().clone() }, geo: function () { var n = this.coordSys, e = n.getBoundingRect().clone(); return e.applyTransform(kh(n)), e } }, dD = { lineX: wt(gG, 0), lineY: wt(gG, 1), rect: function (n, e, t, r) { var i = n ? e.pointToData([t[0][0], t[1][0]], r) : e.dataToPoint([t[0][0], t[1][0]], r), a = n ? e.pointToData([t[0][1], t[1][1]], r) : e.dataToPoint([t[0][1], t[1][1]], r), o = [YI([i[0], a[0]]), YI([i[1], a[1]])]; return { values: o, xyMinMax: o } }, polygon: function (n, e, t, r) { var i = [[1 / 0, -1 / 0], [1 / 0, -1 / 0]], a = Ae(t, function (o) { var s = n ? e.pointToData(o, r) : e.dataToPoint(o, r); return i[0][0] = Math.min(i[0][0], s[0]), i[1][0] = Math.min(i[1][0], s[1]), i[0][1] = Math.max(i[0][1], s[0]), i[1][1] = Math.max(i[1][1], s[1]), s }); return { values: a, xyMinMax: i } } }; function gG(n, e, t, r) { var i = t.getAxis(["x", "y"][n]), a = YI(Ae([0, 1], function (s) { return e ? i.coordToData(i.toLocalCoord(r[s]), !0) : i.toGlobalCoord(i.dataToCoord(r[s])) })), o = []; return o[n] = a, o[1 - n] = [NaN, NaN], { values: a, xyMinMax: o } } var vG = { lineX: wt(yG, 0), lineY: wt(yG, 1), rect: function (n, e, t) { return [[n[0][0] - t[0] * e[0][0], n[0][1] - t[0] * e[0][1]], [n[1][0] - t[1] * e[1][0], n[1][1] - t[1] * e[1][1]]] }, polygon: function (n, e, t) { return Ae(n, function (r, i) { return [r[0] - t[0] * e[i][0], r[1] - t[1] * e[i][1]] }) } }; function yG(n, e, t, r) { return [e[0] - r[n] * t[0], e[1] - r[n] * t[1]] } function vrt(n, e) { var t = _G(n), r = _G(e), i = [t[0] / r[0], t[1] / r[1]]; return isNaN(i[0]) && (i[0] = 1), isNaN(i[1]) && (i[1] = 1), i } function _G(n) { return n ? [n[0][1] - n[0][0], n[1][1] - n[1][0]] : [NaN, NaN] } const bB = mrt; var ZI = $, yrt = NFe("toolbox-dataZoom_"), _rt = function (n) { te(e, n); function e() { return n !== null && n.apply(this, arguments) || this } return e.prototype.render = function (t, r, i, a) { this._brushController || (this._brushController = new J3(i.getZr()), this._brushController.on("brush", He(this._onBrush, this)).mount()), xrt(t, r, this, a, i), wrt(t, r) }, e.prototype.onclick = function (t, r, i) { brt[i].call(this) }, e.prototype.remove = function (t, r) { this._brushController && this._brushController.unmount() }, e.prototype.dispose = function (t, r) { this._brushController && this._brushController.dispose() }, e.prototype._onBrush = function (t) { var r = t.areas; if (!t.isEnd || !r.length) return; var i = {}, a = this.ecModel; this._brushController.updateCovers([]); var o = new bB(wB(this.model), a, { include: ["grid"] }); o.matchOutputRanges(r, a, function (c, u, d) { if (d.type === "cartesian2d") { var f = c.brushType; f === "rect" ? (s("x", d, u[0]), s("y", d, u[1])) : s({ lineX: "x", lineY: "y" }[f], d, u) } }), lrt(a, i), this._dispatchZoomAction(i); function s(c, u, d) { var f = u.getAxis(c), h = f.model, p = l(c, h, a), m = p.findRepresentativeAxisProxy(h).getMinMaxSpan(); (m.minValueSpan != null || m.maxValueSpan != null) && (d = dp(0, d.slice(), f.scale.getExtent(), 0, m.minValueSpan, m.maxValueSpan)), p && (i[p.id] = { dataZoomId: p.id, startValue: d[0], endValue: d[1] }) } function l(c, u, d) { var f; return d.eachComponent({ mainType: "dataZoom", subType: "select" }, function (h) { var p = h.getAxisModel(c, u.componentIndex); p && (f = h) }), f } }, e.prototype._dispatchZoomAction = function (t) { var r = []; ZI(t, function (i, a) { r.push(lt(i)) }), r.length && this.api.dispatchAction({ type: "dataZoom", from: this.uid, batch: r }) }, e.getDefaultOption = function (t) { var r = { show: !0, filterMode: "filter", icon: { zoom: "M0,13.5h26.9 M13.5,26.9V0 M32.1,13.5H58V58H13.5 V32.1", back: "M22,1.4L9.9,13.5l12.3,12.3 M10.3,13.5H54.9v44.6 H10.3v-26" }, title: t.getLocaleModel().get(["toolbox", "dataZoom", "title"]), brushStyle: { borderWidth: 0, color: "rgba(210,219,238,0.2)" } }; return r }, e }(wo), brt = { zoom: function () { var n = !this._isZoomActive; this.api.dispatchAction({ type: "takeGlobalCursor", key: "dataZoomSelect", dataZoomSelectActive: n }) }, back: function () { this._dispatchZoomAction(crt(this.ecModel)) } }; function wB(n) { var e = { xAxisIndex: n.get("xAxisIndex", !0), yAxisIndex: n.get("yAxisIndex", !0), xAxisId: n.get("xAxisId", !0), yAxisId: n.get("yAxisId", !0) }; return e.xAxisIndex == null && e.xAxisId == null && (e.xAxisIndex = "all"), e.yAxisIndex == null && e.yAxisId == null && (e.yAxisIndex = "all"), e } function wrt(n, e) { n.setIconStatus("back", drt(e) > 1 ? "emphasis" : "normal") } function xrt(n, e, t, r, i) { var a = t._isZoomActive; r && r.type === "takeGlobalCursor" && (a = r.key === "dataZoomSelect" ? r.dataZoomSelectActive : !1), t._isZoomActive = a, n.setIconStatus("zoom", a ? "emphasis" : "normal"); var o = new bB(wB(n), e, { include: ["grid"] }), s = o.makePanelOpts(i, function (l) { return l.xAxisDeclared && !l.yAxisDeclared ? "lineX" : !l.xAxisDeclared && l.yAxisDeclared ? "lineY" : "rect" }); t._brushController.setPanels(s).enableBrush(a && s.length ? { brushType: "auto", brushStyle: n.getModel("brushStyle").getItemStyle() } : !1) } vVe("dataZoom", function (n) { var e = n.getComponent("toolbox", 0), t = ["feature", "dataZoom"]; if (!e || e.get(t) == null) return; var r = e.getModel(t), i = [], a = wB(r), o = h0(n, a); ZI(o.xAxisModels, function (l) { return s(l, "xAxis", "xAxisIndex") }), ZI(o.yAxisModels, function (l) { return s(l, "yAxis", "yAxisIndex") }); function s(l, c, u) { var d = l.componentIndex, f = { type: "select", $fromToolbox: !0, filterMode: r.get("filterMode", !0) || "filter", id: yrt + c + d }; f[u] = d, i.push(f) } return i }); const Srt = _rt; function Trt(n) { n.registerComponentModel(znt), n.registerComponentView(Gnt), km("saveAsImage", Knt), km("magicType", Znt), km("dataView", srt), km("dataZoom", Srt), km("restore", hrt), It($nt) } var krt = function (n) { te(e, n); function e() { var t = n !== null && n.apply(this, arguments) || this; return t.type = e.type, t } return e.type = "tooltip", e.dependencies = ["axisPointer"], e.defaultOption = { z: 60, show: !0, showContent: !0, trigger: "item", triggerOn: "mousemove|click", alwaysShowContent: !1, displayMode: "single", renderMode: "auto", confine: null, showDelay: 0, hideDelay: 100, transitionDuration: .4, enterable: !1, backgroundColor: "#fff", shadowBlur: 10, shadowColor: "rgba(0, 0, 0, .2)", shadowOffsetX: 1, shadowOffsetY: 2, borderRadius: 4, borderWidth: 1, padding: null, extraCssText: "", axisPointer: { type: "line", axis: "auto", animation: "auto", animationDurationUpdate: 200, animationEasingUpdate: "exponentialOut", crossStyle: { color: "#999", width: 1, type: "dashed", textStyle: {} } }, textStyle: { color: "#666", fontSize: 14 } }, e }(Jt); const Crt = krt; function Koe(n) { var e = n.get("confine"); return e != null ? !!e : n.get("renderMode") === "richText" } function qoe(n) { if (en.domSupported) { for (var e = document.documentElement.style, t = 0, r = n.length; t < r; t++)if (n[t] in e) return n[t] } } var Yoe = qoe(["transform", "webkitTransform", "OTransform", "MozTransform", "msTransform"]), Art = qoe(["webkitTransition", "transition", "OTransition", "MozTransition", "msTransition"]); function Zoe(n, e) { if (!n) return e; e = yne(e, !0); var t = n.indexOf(e); return n = t === -1 ? e : "-" + n.slice(0, t) + "-" + e, n.toLowerCase() } function Ert(n, e) { var t = n.currentStyle || document.defaultView && document.defaultView.getComputedStyle(n); return t ? e ? t[e] : t : null } var Mrt = Zoe(Art, "transition"), xB = Zoe(Yoe, "transform"), Ort = "position:absolute;display:block;border-style:solid;white-space:nowrap;z-index:9999999;" + (en.transform3dSupported ? "will-change:transform;" : ""); function Drt(n) { return n = n === "left" ? "right" : n === "right" ? "left" : n === "top" ? "bottom" : "top", n } function jrt(n, e, t) { if (!Fe(t) || t === "inside") return ""; var r = n.get("backgroundColor"), i = n.get("borderWidth"); e = Wh(e); var a = Drt(t), o = Math.max(Math.round(i) * 1.5, 6), s = "", l = xB + ":", c; Et(["left", "right"], a) > -1 ? (s += "top:50%", l += "translateY(-50%) rotate(" + (c = a === "left" ? -225 : -45) + "deg)") : (s += "left:50%", l += "translateX(-50%) rotate(" + (c = a === "top" ? 225 : 45) + "deg)"); var u = c * Math.PI / 180, d = o + i, f = d * Math.abs(Math.cos(u)) + d * Math.abs(Math.sin(u)), h = Math.round(((f - Math.SQRT2 * i) / 2 + Math.SQRT2 * i - (f - d) / 2) * 100) / 100; s += ";" + a + ":-" + h + "px"; var p = e + " solid " + i + "px;", m = ["position:absolute;width:" + o + "px;height:" + o + "px;z-index:-1;", s + ";" + l + ";", "border-bottom:" + p, "border-right:" + p, "background-color:" + r + ";"]; return '<div style="' + m.join("") + '"></div>' } function Prt(n, e) { var t = "cubic-bezier(0.23,1,0.32,1)", r = " " + n / 2 + "s " + t, i = "opacity" + r + ",visibility" + r; return e || (r = " " + n + "s " + t, i += en.transformSupported ? "," + xB + r : ",left" + r + ",top" + r), Mrt + ":" + i } function bG(n, e, t) { var r = n.toFixed(0) + "px", i = e.toFixed(0) + "px"; if (!en.transformSupported) return t ? "top:" + i + ";left:" + r + ";" : [["top", i], ["left", r]]; var a = en.transform3dSupported, o = "translate" + (a ? "3d" : "") + "(" + r + "," + i + (a ? ",0" : "") + ")"; return t ? "top:0;left:0;" + xB + ":" + o + ";" : [["top", 0], ["left", 0], [Yoe, o]] } function Irt(n) { var e = [], t = n.get("fontSize"), r = n.getTextColor(); r && e.push("color:" + r), e.push("font:" + n.getFont()); var i = yt(n.get("lineHeight"), Math.round(t * 3 / 2)); t && e.push("line-height:" + i + "px"); var a = n.get("textShadowColor"), o = n.get("textShadowBlur") || 0, s = n.get("textShadowOffsetX") || 0, l = n.get("textShadowOffsetY") || 0; return a && o && e.push("text-shadow:" + s + "px " + l + "px " + o + "px " + a), $(["decoration", "align"], function (c) { var u = n.get(c); u && e.push("text-" + c + ":" + u) }), e.join(";") } function Lrt(n, e, t) { var r = [], i = n.get("transitionDuration"), a = n.get("backgroundColor"), o = n.get("shadowBlur"), s = n.get("shadowColor"), l = n.get("shadowOffsetX"), c = n.get("shadowOffsetY"), u = n.getModel("textStyle"), d = ere(n, "html"), f = l + "px " + c + "px " + o + "px " + s; return r.push("box-shadow:" + f), e && i && r.push(Prt(i, t)), a && r.push("background-color:" + a), $(["width", "color", "radius"], function (h) { var p = "border-" + h, m = yne(p), g = n.get(m); g != null && r.push(p + ":" + g + (h === "color" ? "" : "px")) }), r.push(Irt(u)), d != null && r.push("padding:" + ev(d).join("px ") + "px"), r.join(";") + ";" } function wG(n, e, t, r, i) { var a = e && e.painter; if (t) { var o = a && a.getViewportRoot(); o && o$e(n, o, t, r, i) } else { n[0] = r, n[1] = i; var s = a && a.getViewportRootOffset(); s && (n[0] += s.offsetLeft, n[1] += s.offsetTop) } n[2] = n[0] / e.getWidth(), n[3] = n[1] / e.getHeight() } var Rrt = function () { function n(e, t) { if (this._show = !1, this._styleCoord = [0, 0, 0, 0], this._enterable = !0, this._alwaysShowContent = !1, this._firstShow = !0, this._longHide = !0, en.wxa) return null; var r = document.createElement("div"); r.domBelongToZr = !0, this.el = r; var i = this._zr = e.getZr(), a = t.appendTo, o = a && (Fe(a) ? document.querySelector(a) : Tg(a) ? a : tt(a) && a(e.getDom())); wG(this._styleCoord, i, o, e.getWidth() / 2, e.getHeight() / 2), (o || e.getDom()).appendChild(r), this._api = e, this._container = o; var s = this; r.onmouseenter = function () { s._enterable && (clearTimeout(s._hideTimeout), s._show = !0), s._inContent = !0 }, r.onmousemove = function (l) { if (l = l || window.event, !s._enterable) { var c = i.handler, u = i.painter.getViewportRoot(); po(u, l, !0), c.dispatch("mousemove", l) } }, r.onmouseleave = function () { s._inContent = !1, s._enterable && s._show && s.hideLater(s._hideDelay) } } return n.prototype.update = function (e) { if (!this._container) { var t = this._api.getDom(), r = Ert(t, "position"), i = t.style; i.position !== "absolute" && r !== "absolute" && (i.position = "relative") } var a = e.get("alwaysShowContent"); a && this._moveIfResized(), this._alwaysShowContent = a, this.el.className = e.get("className") || "" }, n.prototype.show = function (e, t) { clearTimeout(this._hideTimeout), clearTimeout(this._longHideTimeout); var r = this.el, i = r.style, a = this._styleCoord; r.innerHTML ? i.cssText = Ort + Lrt(e, !this._firstShow, this._longHide) + bG(a[0], a[1], !0) + ("border-color:" + Wh(t) + ";") + (e.get("extraCssText") || "") + (";pointer-events:" + (this._enterable ? "auto" : "none")) : i.display = "none", this._show = !0, this._firstShow = !1, this._longHide = !1 }, n.prototype.setContent = function (e, t, r, i, a) { var o = this.el; if (e == null) { o.innerHTML = ""; return } var s = ""; if (Fe(a) && r.get("trigger") === "item" && !Koe(r) && (s = jrt(r, i, a)), Fe(e)) o.innerHTML = e + s; else if (e) { o.innerHTML = "", ke(e) || (e = [e]); for (var l = 0; l < e.length; l++)Tg(e[l]) && e[l].parentNode !== o && o.appendChild(e[l]); if (s && o.childNodes.length) { var c = document.createElement("div"); c.innerHTML = s, o.appendChild(c) } } }, n.prototype.setEnterable = function (e) { this._enterable = e }, n.prototype.getSize = function () { var e = this.el; return e ? [e.offsetWidth, e.offsetHeight] : [0, 0] }, n.prototype.moveTo = function (e, t) { if (this.el) { var r = this._styleCoord; if (wG(r, this._zr, this._container, e, t), r[0] != null && r[1] != null) { var i = this.el.style, a = bG(r[0], r[1]); $(a, function (o) { i[o[0]] = o[1] }) } } }, n.prototype._moveIfResized = function () { var e = this._styleCoord[2], t = this._styleCoord[3]; this.moveTo(e * this._zr.getWidth(), t * this._zr.getHeight()) }, n.prototype.hide = function () { var e = this, t = this.el.style; t.visibility = "hidden", t.opacity = "0", en.transform3dSupported && (t.willChange = ""), this._show = !1, this._longHideTimeout = setTimeout(function () { return e._longHide = !0 }, 500) }, n.prototype.hideLater = function (e) { this._show && !(this._inContent && this._enterable) && !this._alwaysShowContent && (e ? (this._hideDelay = e, this._show = !1, this._hideTimeout = setTimeout(He(this.hide, this), e)) : this.hide()) }, n.prototype.isShow = function () { return this._show }, n.prototype.dispose = function () { clearTimeout(this._hideTimeout), clearTimeout(this._longHideTimeout); var e = this.el.parentNode; e && e.removeChild(this.el), this.el = this._container = null }, n }(); const Nrt = Rrt; var Brt = function () { function n(e) { this._show = !1, this._styleCoord = [0, 0, 0, 0], this._alwaysShowContent = !1, this._enterable = !0, this._zr = e.getZr(), SG(this._styleCoord, this._zr, e.getWidth() / 2, e.getHeight() / 2) } return n.prototype.update = function (e) { var t = e.get("alwaysShowContent"); t && this._moveIfResized(), this._alwaysShowContent = t }, n.prototype.show = function () { this._hideTimeout && clearTimeout(this._hideTimeout), this.el.show(), this._show = !0 }, n.prototype.setContent = function (e, t, r, i, a) { var o = this; ot(e) && hn(""), this.el && this._zr.remove(this.el); var s = r.getModel("textStyle"); this.el = new tn({ style: { rich: t.richTextStyles, text: e, lineHeight: 22, borderWidth: 1, borderColor: i, textShadowColor: s.get("textShadowColor"), fill: r.get(["textStyle", "color"]), padding: ere(r, "richText"), verticalAlign: "top", align: "left" }, z: r.get("z") }), $(["backgroundColor", "borderRadius", "shadowColor", "shadowBlur", "shadowOffsetX", "shadowOffsetY"], function (c) { o.el.style[c] = r.get(c) }), $(["textShadowBlur", "textShadowOffsetX", "textShadowOffsetY"], function (c) { o.el.style[c] = s.get(c) || 0 }), this._zr.add(this.el); var l = this; this.el.on("mouseover", function () { l._enterable && (clearTimeout(l._hideTimeout), l._show = !0), l._inContent = !0 }), this.el.on("mouseout", function () { l._enterable && l._show && l.hideLater(l._hideDelay), l._inContent = !1 }) }, n.prototype.setEnterable = function (e) { this._enterable = e }, n.prototype.getSize = function () { var e = this.el, t = this.el.getBoundingRect(), r = xG(e.style); return [t.width + r.left + r.right, t.height + r.top + r.bottom] }, n.prototype.moveTo = function (e, t) { var r = this.el; if (r) { var i = this._styleCoord; SG(i, this._zr, e, t), e = i[0], t = i[1]; var a = r.style, o = vu(a.borderWidth || 0), s = xG(a); r.x = e + o + s.left, r.y = t + o + s.top, r.markRedraw() } }, n.prototype._moveIfResized = function () { var e = this._styleCoord[2], t = this._styleCoord[3]; this.moveTo(e * this._zr.getWidth(), t * this._zr.getHeight()) }, n.prototype.hide = function () { this.el && this.el.hide(), this._show = !1 }, n.prototype.hideLater = function (e) { this._show && !(this._inContent && this._enterable) && !this._alwaysShowContent && (e ? (this._hideDelay = e, this._show = !1, this._hideTimeout = setTimeout(He(this.hide, this), e)) : this.hide()) }, n.prototype.isShow = function () { return this._show }, n.prototype.dispose = function () { this._zr.remove(this.el) }, n }(); function vu(n) { return Math.max(0, n) } function xG(n) { var e = vu(n.shadowBlur || 0), t = vu(n.shadowOffsetX || 0), r = vu(n.shadowOffsetY || 0); return { left: vu(e - t), right: vu(e + t), top: vu(e - r), bottom: vu(e + r) } } function SG(n, e, t, r) { n[0] = t, n[1] = r, n[2] = n[0] / e.getWidth(), n[3] = n[1] / e.getHeight() } const $rt = Brt; var Frt = new Yt({ shape: { x: -1, y: -1, width: 2, height: 2 } }), zrt = function (n) {
  te(e, n); function e() { var t = n !== null && n.apply(this, arguments) || this; return t.type = e.type, t } return e.prototype.init = function (t, r) { if (!(en.node || !r.getDom())) { var i = t.getComponent("tooltip"), a = this._renderMode = UFe(i.get("renderMode")); this._tooltipContent = a === "richText" ? new $rt(r) : new Nrt(r, { appendTo: i.get("appendToBody", !0) ? "body" : i.get("appendTo", !0) }) } }, e.prototype.render = function (t, r, i) { if (!(en.node || !i.getDom())) { this.group.removeAll(), this._tooltipModel = t, this._ecModel = r, this._api = i; var a = this._tooltipContent; a.update(t), a.setEnterable(t.get("enterable")), this._initGlobalListener(), this._keepShow(), this._renderMode !== "richText" && t.get("transitionDuration") ? av(this, "_updatePosition", 50, "fixRate") : S_(this, "_updatePosition") } }, e.prototype._initGlobalListener = function () { var t = this._tooltipModel, r = t.get("triggerOn"); Poe("itemTooltip", this._api, He(function (i, a, o) { r !== "none" && (r.indexOf(i) >= 0 ? this._tryShow(a, o) : i === "leave" && this._hide(o)) }, this)) }, e.prototype._keepShow = function () { var t = this._tooltipModel, r = this._ecModel, i = this._api, a = t.get("triggerOn"); if (this._lastX != null && this._lastY != null && a !== "none" && a !== "click") { var o = this; clearTimeout(this._refreshUpdateTimeout), this._refreshUpdateTimeout = setTimeout(function () { !i.isDisposed() && o.manuallyShowTip(t, r, i, { x: o._lastX, y: o._lastY, dataByCoordSys: o._lastDataByCoordSys }) }) } }, e.prototype.manuallyShowTip = function (t, r, i, a) { if (!(a.from === this.uid || en.node || !i.getDom())) { var o = TG(a, i); this._ticket = ""; var s = a.dataByCoordSys, l = Grt(a, r, i); if (l) { var c = l.el.getBoundingRect().clone(); c.applyTransform(l.el.transform), this._tryShow({ offsetX: c.x + c.width / 2, offsetY: c.y + c.height / 2, target: l.el, position: a.position, positionDefault: "bottom" }, o) } else if (a.tooltip && a.x != null && a.y != null) { var u = Frt; u.x = a.x, u.y = a.y, u.update(), pt(u).tooltipConfig = { name: null, option: a.tooltip }, this._tryShow({ offsetX: a.x, offsetY: a.y, target: u }, o) } else if (s) this._tryShow({ offsetX: a.x, offsetY: a.y, position: a.position, dataByCoordSys: s, tooltipOption: a.tooltipOption }, o); else if (a.seriesIndex != null) { if (this._manuallyAxisShowTip(t, r, i, a)) return; var d = Ioe(a, r), f = d.point[0], h = d.point[1]; f != null && h != null && this._tryShow({ offsetX: f, offsetY: h, target: d.el, position: a.position, positionDefault: "bottom" }, o) } else a.x != null && a.y != null && (i.dispatchAction({ type: "updateAxisPointer", x: a.x, y: a.y }), this._tryShow({ offsetX: a.x, offsetY: a.y, position: a.position, target: i.getZr().findHover(a.x, a.y).target }, o)) } }, e.prototype.manuallyHideTip = function (t, r, i, a) { var o = this._tooltipContent; this._tooltipModel && o.hideLater(this._tooltipModel.get("hideDelay")), this._lastX = this._lastY = this._lastDataByCoordSys = null, a.from !== this.uid && this._hide(TG(a, i)) }, e.prototype._manuallyAxisShowTip = function (t, r, i, a) { var o = a.seriesIndex, s = a.dataIndex, l = r.getComponent("axisPointer").coordSysAxesInfo; if (!(o == null || s == null || l == null)) { var c = r.getSeriesByIndex(o); if (c) { var u = c.getData(), d = uy([u.getItemModel(s), c, (c.coordinateSystem || {}).model], this._tooltipModel); if (d.get("trigger") === "axis") return i.dispatchAction({ type: "updateAxisPointer", seriesIndex: o, dataIndex: s, position: a.position }), !0 } } }, e.prototype._tryShow = function (t, r) { var i = t.target, a = this._tooltipModel; if (a) { this._lastX = t.offsetX, this._lastY = t.offsetY; var o = t.dataByCoordSys; if (o && o.length) this._showAxisTooltip(o, t); else if (i) { var s = pt(i); if (s.ssrType === "legend") return; this._lastDataByCoordSys = null; var l, c; rh(i, function (u) { if (pt(u).dataIndex != null) return l = u, !0; if (pt(u).tooltipConfig != null) return c = u, !0 }, !0), l ? this._showSeriesItemTooltip(t, l, r) : c ? this._showComponentItemTooltip(t, c, r) : this._hide(r) } else this._lastDataByCoordSys = null, this._hide(r) } }, e.prototype._showOrMove = function (t, r) { var i = t.get("showDelay"); r = He(r, this), clearTimeout(this._showTimout), i > 0 ? this._showTimout = setTimeout(r, i) : r() }, e.prototype._showAxisTooltip = function (t, r) {
    var i = this._ecModel, a = this._tooltipModel, o = [r.offsetX, r.offsetY], s = uy([r.tooltipOption], a), l = this._renderMode, c = [], u = Gr("section", { blocks: [], noHeader: !0 }), d = [], f = new YM; $(t, function (b) { $(b.dataByAxis, function (w) { var v = i.getComponent(w.axisDim + "Axis", w.axisIndex), S = w.value; if (!(!v || S == null)) { var x = Ooe(S, v.axis, i, w.seriesDataIndices, w.valueLabelOpt), k = Gr("section", { header: x, noHeader: !ps(x), sortBlocks: !0, blocks: [] }); u.blocks.push(k), $(w.seriesDataIndices, function (A) { var C = i.getSeriesByIndex(A.seriesIndex), E = A.dataIndexInside, O = C.getDataParams(E); if (!(O.dataIndex < 0)) { O.axisDim = w.axisDim, O.axisIndex = w.axisIndex, O.axisType = w.axisType, O.axisId = w.axisId, O.axisValue = w3(v.axis, { value: S }), O.axisValueLabel = x, O.marker = f.makeTooltipMarker("item", Wh(O.color), l); var j = lH(C.formatTooltip(E, !0, null)), I = j.frag; if (I) { var L = uy([C], a).get("valueFormatter"); k.blocks.push(L ? be({ valueFormatter: L }, I) : I) } j.text && d.push(j.text), c.push(O) } }) } }) }), u.blocks.reverse(), d.reverse(); var h = r.position, p = s.get("order"), m = pH(u, f, l, p, i.get("useUTC"), s.get("textStyle")); m && d.unshift(m); var g = l === "richText" ? `

`: "<br/>", y = d.join(g); this._showOrMove(s, function () { this._updateContentNotChangedOnAxis(t, c) ? this._updatePosition(s, h, o[0], o[1], this._tooltipContent, c) : this._showTooltipContent(s, y, c, Math.random() + "", o[0], o[1], h, null, f) })
  }, e.prototype._showSeriesItemTooltip = function (t, r, i) { var a = this._ecModel, o = pt(r), s = o.seriesIndex, l = a.getSeriesByIndex(s), c = o.dataModel || l, u = o.dataIndex, d = o.dataType, f = c.getData(d), h = this._renderMode, p = t.positionDefault, m = uy([f.getItemModel(u), c, l && (l.coordinateSystem || {}).model], this._tooltipModel, p ? { position: p } : null), g = m.get("trigger"); if (!(g != null && g !== "item")) { var y = c.getDataParams(u, d), b = new YM; y.marker = b.makeTooltipMarker("item", Wh(y.color), h); var w = lH(c.formatTooltip(u, !1, d)), v = m.get("order"), S = m.get("valueFormatter"), x = w.frag, k = x ? pH(S ? be({ valueFormatter: S }, x) : x, b, h, v, a.get("useUTC"), m.get("textStyle")) : w.text, A = "item_" + c.name + "_" + u; this._showOrMove(m, function () { this._showTooltipContent(m, k, y, A, t.offsetX, t.offsetY, t.position, t.target, b) }), i({ type: "showTip", dataIndexInside: u, dataIndex: f.getRawIndex(u), seriesIndex: s, from: this.uid }) } }, e.prototype._showComponentItemTooltip = function (t, r, i) { var a = this._renderMode === "html", o = pt(r), s = o.tooltipConfig, l = s.option || {}, c = l.encodeHTMLContent; if (Fe(l)) { var u = l; l = { content: u, formatter: u }, c = !0 } c && a && l.content && (l = lt(l), l.content = Ai(l.content)); var d = [l], f = this._ecModel.getComponent(o.componentMainType, o.componentIndex); f && d.push(f), d.push({ formatter: l.content }); var h = t.positionDefault, p = uy(d, this._tooltipModel, h ? { position: h } : null), m = p.get("content"), g = Math.random() + "", y = new YM; this._showOrMove(p, function () { var b = lt(p.get("formatterParams") || {}); this._showTooltipContent(p, m, b, g, t.offsetX, t.offsetY, t.position, r, y) }), i({ type: "showTip", from: this.uid }) }, e.prototype._showTooltipContent = function (t, r, i, a, o, s, l, c, u) { if (this._ticket = "", !(!t.get("showContent") || !t.get("show"))) { var d = this._tooltipContent; d.setEnterable(t.get("enterable")); var f = t.get("formatter"); l = l || t.get("position"); var h = r, p = this._getNearestPoint([o, s], i, t.get("trigger"), t.get("borderColor")), m = p.color; if (f) if (Fe(f)) { var g = t.ecModel.get("useUTC"), y = ke(i) ? i[0] : i, b = y && y.axisType && y.axisType.indexOf("time") >= 0; h = f, b && (h = lC(y.axisValue, h, g)), h = _ne(h, i, !0) } else if (tt(f)) { var w = He(function (v, S) { v === this._ticket && (d.setContent(S, u, t, m, l), this._updatePosition(t, l, o, s, d, i, c)) }, this); this._ticket = a, h = f(i, a, w) } else h = f; d.setContent(h, u, t, m, l), d.show(t, m), this._updatePosition(t, l, o, s, d, i, c) } }, e.prototype._getNearestPoint = function (t, r, i, a) { if (i === "axis" || ke(r)) return { color: a || (this._renderMode === "html" ? "#fff" : "none") }; if (!ke(r)) return { color: a || r.color || r.borderColor } }, e.prototype._updatePosition = function (t, r, i, a, o, s, l) { var c = this._api.getWidth(), u = this._api.getHeight(); r = r || t.get("position"); var d = o.getSize(), f = t.get("align"), h = t.get("verticalAlign"), p = l && l.getBoundingRect().clone(); if (l && p.applyTransform(l.transform), tt(r) && (r = r([i, a], s, o.el, p, { viewSize: [c, u], contentSize: d.slice() })), ke(r)) i = Ne(r[0], c), a = Ne(r[1], u); else if (ot(r)) { var m = r; m.width = d[0], m.height = d[1]; var g = jr(m, { width: c, height: u }); i = g.x, a = g.y, f = null, h = null } else if (Fe(r) && l) { var y = Urt(r, p, d, t.get("borderWidth")); i = y[0], a = y[1] } else { var y = Vrt(i, a, o, c, u, f ? null : 20, h ? null : 20); i = y[0], a = y[1] } if (f && (i -= kG(f) ? d[0] / 2 : f === "right" ? d[0] : 0), h && (a -= kG(h) ? d[1] / 2 : h === "bottom" ? d[1] : 0), Koe(t)) { var y = Hrt(i, a, o, c, u); i = y[0], a = y[1] } o.moveTo(i, a) }, e.prototype._updateContentNotChangedOnAxis = function (t, r) { var i = this._lastDataByCoordSys, a = this._cbParamsList, o = !!i && i.length === t.length; return o && $(i, function (s, l) { var c = s.dataByAxis || [], u = t[l] || {}, d = u.dataByAxis || []; o = o && c.length === d.length, o && $(c, function (f, h) { var p = d[h] || {}, m = f.seriesDataIndices || [], g = p.seriesDataIndices || []; o = o && f.value === p.value && f.axisType === p.axisType && f.axisId === p.axisId && m.length === g.length, o && $(m, function (y, b) { var w = g[b]; o = o && y.seriesIndex === w.seriesIndex && y.dataIndex === w.dataIndex }), a && $(f.seriesDataIndices, function (y) { var b = y.seriesIndex, w = r[b], v = a[b]; w && v && v.data !== w.data && (o = !1) }) }) }), this._lastDataByCoordSys = t, this._cbParamsList = r, !!o }, e.prototype._hide = function (t) { this._lastDataByCoordSys = null, t({ type: "hideTip", from: this.uid }) }, e.prototype.dispose = function (t, r) { en.node || !r.getDom() || (S_(this, "_updatePosition"), this._tooltipContent.dispose(), GI("itemTooltip", r)) }, e.type = "tooltip", e
}(nr); function uy(n, e, t) { var r = e.ecModel, i; t ? (i = new Rn(t, r, r), i = new Rn(e.option, i, r)) : i = e; for (var a = n.length - 1; a >= 0; a--) { var o = n[a]; o && (o instanceof Rn && (o = o.get("tooltip", !0)), Fe(o) && (o = { formatter: o }), o && (i = new Rn(o, i, r))) } return i } function TG(n, e) { return n.dispatchAction || He(e.dispatchAction, e) } function Vrt(n, e, t, r, i, a, o) { var s = t.getSize(), l = s[0], c = s[1]; return a != null && (n + l + a + 2 > r ? n -= l + a : n += a), o != null && (e + c + o > i ? e -= c + o : e += o), [n, e] } function Hrt(n, e, t, r, i) { var a = t.getSize(), o = a[0], s = a[1]; return n = Math.min(n + o, r) - o, e = Math.min(e + s, i) - s, n = Math.max(n, 0), e = Math.max(e, 0), [n, e] } function Urt(n, e, t, r) { var i = t[0], a = t[1], o = Math.ceil(Math.SQRT2 * r) + 8, s = 0, l = 0, c = e.width, u = e.height; switch (n) { case "inside": s = e.x + c / 2 - i / 2, l = e.y + u / 2 - a / 2; break; case "top": s = e.x + c / 2 - i / 2, l = e.y - a - o; break; case "bottom": s = e.x + c / 2 - i / 2, l = e.y + u + o; break; case "left": s = e.x - i - o, l = e.y + u / 2 - a / 2; break; case "right": s = e.x + c + o, l = e.y + u / 2 - a / 2 }return [s, l] } function kG(n) { return n === "center" || n === "middle" } function Grt(n, e, t) { var r = jN(n).queryOptionMap, i = r.keys()[0]; if (!(!i || i === "series")) { var a = wb(e, i, r.get(i), { useDefault: !1, enableAll: !1, enableNone: !1 }), o = a.models[0]; if (o) { var s = t.getViewOfComponentModel(o), l; if (s.group.traverse(function (c) { var u = pt(c).tooltipConfig; if (u && u.name === n.name) return l = c, !0 }), l) return { componentMainType: i, componentIndex: o.componentIndex, el: l } } } } const Wrt = zrt; function Krt(n) { It(Bb), n.registerComponentModel(Crt), n.registerComponentView(Wrt), n.registerAction({ type: "showTip", event: "showTip", update: "tooltip:manuallyShowTip" }, gr), n.registerAction({ type: "hideTip", event: "hideTip", update: "tooltip:manuallyHideTip" }, gr) } var qrt = ["rect", "polygon", "keep", "clear"]; function Yrt(n, e) { var t = Cn(n ? n.brush : []); if (t.length) { var r = []; $(t, function (l) { var c = l.hasOwnProperty("toolbox") ? l.toolbox : []; c instanceof Array && (r = r.concat(c)) }); var i = n && n.toolbox; ke(i) && (i = i[0]), i || (i = { feature: {} }, n.toolbox = [i]); var a = i.feature || (i.feature = {}), o = a.brush || (a.brush = {}), s = o.type || (o.type = []); s.push.apply(s, r), Zrt(s), e && !s.length && s.push.apply(s, qrt) } } function Zrt(n) { var e = {}; $(n, function (t) { e[t] = 1 }), n.length = 0, $(e, function (t, r) { n.push(r) }) } var CG = $; function AG(n) { if (n) { for (var e in n) if (n.hasOwnProperty(e)) return !0 } } function XI(n, e, t) { var r = {}; return CG(e, function (a) { var o = r[a] = i(); CG(n[a], function (s, l) { if (hi.isValidType(l)) { var c = { type: l, visual: s }; t && t(c, a), o[l] = new hi(c), l === "opacity" && (c = lt(c), c.type = "colorAlpha", o.__hidden.__alphaForOpacity = new hi(c)) } }) }), r; function i() { var a = function () { }; a.prototype.__hidden = a.prototype; var o = new a; return o } } function Xoe(n, e, t) { var r; $(t, function (i) { e.hasOwnProperty(i) && AG(e[i]) && (r = !0) }), r && $(t, function (i) { e.hasOwnProperty(i) && AG(e[i]) ? n[i] = lt(e[i]) : delete n[i] }) } function Xrt(n, e, t, r, i, a) { var o = {}; $(n, function (d) { var f = hi.prepareVisualTypes(e[d]); o[d] = f }); var s; function l(d) { return u3(t, s, d) } function c(d, f) { ure(t, s, d, f) } a == null ? t.each(u) : t.each([a], u); function u(d, f) { s = a == null ? d : f; var h = t.getRawDataItem(s); if (!(h && h.visualMap === !1)) for (var p = r.call(i, d), m = e[p], g = o[p], y = 0, b = g.length; y < b; y++) { var w = g[y]; m[w] && m[w].applyVisual(d, l, c) } } } function Jrt(n, e, t, r) { var i = {}; return $(n, function (a) { var o = hi.prepareVisualTypes(e[a]); i[a] = o }), { progress: function (o, s) { var l; r != null && (l = s.getDimensionIndex(r)); function c(S) { return u3(s, d, S) } function u(S, x) { ure(s, d, S, x) } for (var d, f = s.getStore(); (d = o.next()) != null;) { var h = s.getRawDataItem(d); if (!(h && h.visualMap === !1)) for (var p = r != null ? f.get(l, d) : d, m = t(p), g = e[m], y = i[m], b = 0, w = y.length; b < w; b++) { var v = y[b]; g[v] && g[v].applyVisual(p, c, u) } } } } } function Qrt(n) { var e = n.brushType, t = { point: function (r) { return EG[e].point(r, t, n) }, rect: function (r) { return EG[e].rect(r, t, n) } }; return t } var EG = { lineX: MG(0), lineY: MG(1), rect: { point: function (n, e, t) { return n && t.boundingRect.contain(n[0], n[1]) }, rect: function (n, e, t) { return n && t.boundingRect.intersect(n) } }, polygon: { point: function (n, e, t) { return n && t.boundingRect.contain(n[0], n[1]) && Vf(t.range, n[0], n[1]) }, rect: function (n, e, t) { var r = t.range; if (!n || r.length <= 1) return !1; var i = n.x, a = n.y, o = n.width, s = n.height, l = r[0]; if (Vf(r, i, a) || Vf(r, i + o, a) || Vf(r, i, a + s) || Vf(r, i + o, a + s) || kt.create(n).contain(l[0], l[1]) || Ay(i, a, i + o, a, r) || Ay(i, a, i, a + s, r) || Ay(i + o, a, i + o, a + s, r) || Ay(i, a + s, i + o, a + s, r)) return !0 } } }; function MG(n) { var e = ["x", "y"], t = ["width", "height"]; return { point: function (r, i, a) { if (r) { var o = a.range, s = r[n]; return dy(s, o) } }, rect: function (r, i, a) { if (r) { var o = a.range, s = [r[e[n]], r[e[n]] + r[t[n]]]; return s[1] < s[0] && s.reverse(), dy(s[0], o) || dy(s[1], o) || dy(o[0], s) || dy(o[1], s) } } } } function dy(n, e) { return e[0] <= n && n <= e[1] } var OG = ["inBrush", "outOfBrush"], fD = "__ecBrushSelect", JI = "__ecInBrushSelectEvent"; function Joe(n) { n.eachComponent({ mainType: "brush" }, function (e) { var t = e.brushTargetManager = new bB(e.option, n); t.setInputRanges(e.areas, n) }) } function eit(n, e, t) { var r = [], i, a; n.eachComponent({ mainType: "brush" }, function (o) { t && t.type === "takeGlobalCursor" && o.setBrushOption(t.key === "brush" ? t.brushOption : { brushType: !1 }) }), Joe(n), n.eachComponent({ mainType: "brush" }, function (o, s) { var l = { brushId: o.id, brushIndex: s, brushName: o.name, areas: lt(o.areas), selected: [] }; r.push(l); var c = o.option, u = c.brushLink, d = [], f = [], h = [], p = !1; s || (i = c.throttleType, a = c.throttleDelay); var m = Ae(o.areas, function (S) { var x = iit[S.brushType], k = rt({ boundingRect: x ? x(S) : void 0 }, S); return k.selectors = Qrt(k), k }), g = XI(o.option, OG, function (S) { S.mappingMethod = "fixed" }); ke(u) && $(u, function (S) { d[S] = 1 }); function y(S) { return u === "all" || !!d[S] } function b(S) { return !!S.length } n.eachSeries(function (S, x) { var k = h[x] = []; S.subType === "parallel" ? w(S, x) : v(S, x, k) }); function w(S, x) { var k = S.coordinateSystem; p = p || k.hasAxisBrushed(), y(x) && k.eachActiveState(S.getData(), function (A, C) { A === "active" && (f[C] = 1) }) } function v(S, x, k) { if (!(!S.brushSelector || rit(o, x)) && ($(m, function (C) { o.brushTargetManager.controlSeries(C, S, n) && k.push(C), p = p || b(k) }), y(x) && b(k))) { var A = S.getData(); A.each(function (C) { DG(S, k, A, C) && (f[C] = 1) }) } } n.eachSeries(function (S, x) { var k = { seriesId: S.id, seriesIndex: x, seriesName: S.name, dataIndex: [] }; l.selected.push(k); var A = h[x], C = S.getData(), E = y(x) ? function (O) { return f[O] ? (k.dataIndex.push(C.getRawIndex(O)), "inBrush") : "outOfBrush" } : function (O) { return DG(S, A, C, O) ? (k.dataIndex.push(C.getRawIndex(O)), "inBrush") : "outOfBrush" }; (y(x) ? p : b(A)) && Xrt(OG, g, C, E) }) }), tit(e, i, a, r, t) } function tit(n, e, t, r, i) { if (i) { var a = n.getZr(); if (!a[JI]) { a[fD] || (a[fD] = nit); var o = av(a, fD, t, e); o(n, r) } } } function nit(n, e) { if (!n.isDisposed()) { var t = n.getZr(); t[JI] = !0, n.dispatchAction({ type: "brushSelect", batch: e }), t[JI] = !1 } } function DG(n, e, t, r) { for (var i = 0, a = e.length; i < a; i++) { var o = e[i]; if (n.brushSelector(r, t, o.selectors, o)) return !0 } } function rit(n, e) { var t = n.option.seriesIndex; return t != null && t !== "all" && (ke(t) ? Et(t, e) < 0 : e !== t) } var iit = { rect: function (n) { return jG(n.range) }, polygon: function (n) { for (var e, t = n.range, r = 0, i = t.length; r < i; r++) { e = e || [[1 / 0, -1 / 0], [1 / 0, -1 / 0]]; var a = t[r]; a[0] < e[0][0] && (e[0][0] = a[0]), a[0] > e[0][1] && (e[0][1] = a[0]), a[1] < e[1][0] && (e[1][0] = a[1]), a[1] > e[1][1] && (e[1][1] = a[1]) } return e && jG(e) } }; function jG(n) { return new kt(n[0][0], n[1][0], n[0][1] - n[0][0], n[1][1] - n[1][0]) } var ait = function (n) { te(e, n); function e() { var t = n !== null && n.apply(this, arguments) || this; return t.type = e.type, t } return e.prototype.init = function (t, r) { this.ecModel = t, this.api = r, this.model, (this._brushController = new J3(r.getZr())).on("brush", He(this._onBrush, this)).mount() }, e.prototype.render = function (t, r, i, a) { this.model = t, this._updateController(t, r, i, a) }, e.prototype.updateTransform = function (t, r, i, a) { Joe(r), this._updateController(t, r, i, a) }, e.prototype.updateVisual = function (t, r, i, a) { this.updateTransform(t, r, i, a) }, e.prototype.updateView = function (t, r, i, a) { this._updateController(t, r, i, a) }, e.prototype._updateController = function (t, r, i, a) { (!a || a.$from !== t.id) && this._brushController.setPanels(t.brushTargetManager.makePanelOpts(i)).enableBrush(t.brushOption).updateCovers(t.areas.slice()) }, e.prototype.dispose = function () { this._brushController.dispose() }, e.prototype._onBrush = function (t) { var r = this.model.id, i = this.model.brushTargetManager.setOutputRanges(t.areas, this.ecModel); (!t.isEnd || t.removeOnClick) && this.api.dispatchAction({ type: "brush", brushId: r, areas: lt(i), $from: r }), t.isEnd && this.api.dispatchAction({ type: "brushEnd", brushId: r, areas: lt(i), $from: r }) }, e.type = "brush", e }(nr); const oit = ait; var sit = "#ddd", lit = function (n) { te(e, n); function e() { var t = n !== null && n.apply(this, arguments) || this; return t.type = e.type, t.areas = [], t.brushOption = {}, t } return e.prototype.optionUpdated = function (t, r) { var i = this.option; !r && Xoe(i, t, ["inBrush", "outOfBrush"]); var a = i.inBrush = i.inBrush || {}; i.outOfBrush = i.outOfBrush || { color: sit }, a.hasOwnProperty("liftZ") || (a.liftZ = 5) }, e.prototype.setAreas = function (t) { t && (this.areas = Ae(t, function (r) { return PG(this.option, r) }, this)) }, e.prototype.setBrushOption = function (t) { this.brushOption = PG(this.option, t), this.brushType = this.brushOption.brushType }, e.type = "brush", e.dependencies = ["geo", "grid", "xAxis", "yAxis", "parallel", "series"], e.defaultOption = { seriesIndex: "all", brushType: "rect", brushMode: "single", transformable: !0, brushStyle: { borderWidth: 1, color: "rgba(210,219,238,0.3)", borderColor: "#D2DBEE" }, throttleType: "fixRate", throttleDelay: 0, removeOnClick: !0, z: 1e4 }, e }(Jt); function PG(n, e) { return xt({ brushType: n.brushType, brushMode: n.brushMode, transformable: n.transformable, brushStyle: new Rn(n.brushStyle).getItemStyle(), removeOnClick: n.removeOnClick, z: n.z }, e, !0) } const cit = lit; var uit = ["rect", "polygon", "lineX", "lineY", "keep", "clear"], dit = function (n) { te(e, n); function e() { return n !== null && n.apply(this, arguments) || this } return e.prototype.render = function (t, r, i) { var a, o, s; r.eachComponent({ mainType: "brush" }, function (l) { a = l.brushType, o = l.brushOption.brushMode || "single", s = s || !!l.areas.length }), this._brushType = a, this._brushMode = o, $(t.get("type", !0), function (l) { t.setIconStatus(l, (l === "keep" ? o === "multiple" : l === "clear" ? s : l === a) ? "emphasis" : "normal") }) }, e.prototype.updateView = function (t, r, i) { this.render(t, r, i) }, e.prototype.getIcons = function () { var t = this.model, r = t.get("icon", !0), i = {}; return $(t.get("type", !0), function (a) { r[a] && (i[a] = r[a]) }), i }, e.prototype.onclick = function (t, r, i) { var a = this._brushType, o = this._brushMode; i === "clear" ? (r.dispatchAction({ type: "axisAreaSelect", intervals: [] }), r.dispatchAction({ type: "brush", command: "clear", areas: [] })) : r.dispatchAction({ type: "takeGlobalCursor", key: "brush", brushOption: { brushType: i === "keep" ? a : a === i ? !1 : i, brushMode: i === "keep" ? o === "multiple" ? "single" : "multiple" : o } }) }, e.getDefaultOption = function (t) { var r = { show: !0, type: uit.slice(), icon: { rect: "M7.3,34.7 M0.4,10V-0.2h9.8 M89.6,10V-0.2h-9.8 M0.4,60v10.2h9.8 M89.6,60v10.2h-9.8 M12.3,22.4V10.5h13.1 M33.6,10.5h7.8 M49.1,10.5h7.8 M77.5,22.4V10.5h-13 M12.3,31.1v8.2 M77.7,31.1v8.2 M12.3,47.6v11.9h13.1 M33.6,59.5h7.6 M49.1,59.5 h7.7 M77.5,47.6v11.9h-13", polygon: "M55.2,34.9c1.7,0,3.1,1.4,3.1,3.1s-1.4,3.1-3.1,3.1 s-3.1-1.4-3.1-3.1S53.5,34.9,55.2,34.9z M50.4,51c1.7,0,3.1,1.4,3.1,3.1c0,1.7-1.4,3.1-3.1,3.1c-1.7,0-3.1-1.4-3.1-3.1 C47.3,52.4,48.7,51,50.4,51z M55.6,37.1l1.5-7.8 M60.1,13.5l1.6-8.7l-7.8,4 M59,19l-1,5.3 M24,16.1l6.4,4.9l6.4-3.3 M48.5,11.6 l-5.9,3.1 M19.1,12.8L9.7,5.1l1.1,7.7 M13.4,29.8l1,7.3l6.6,1.6 M11.6,18.4l1,6.1 M32.8,41.9 M26.6,40.4 M27.3,40.2l6.1,1.6 M49.9,52.1l-5.6-7.6l-4.9-1.2", lineX: "M15.2,30 M19.7,15.6V1.9H29 M34.8,1.9H40.4 M55.3,15.6V1.9H45.9 M19.7,44.4V58.1H29 M34.8,58.1H40.4 M55.3,44.4 V58.1H45.9 M12.5,20.3l-9.4,9.6l9.6,9.8 M3.1,29.9h16.5 M62.5,20.3l9.4,9.6L62.3,39.7 M71.9,29.9H55.4", lineY: "M38.8,7.7 M52.7,12h13.2v9 M65.9,26.6V32 M52.7,46.3h13.2v-9 M24.9,12H11.8v9 M11.8,26.6V32 M24.9,46.3H11.8v-9 M48.2,5.1l-9.3-9l-9.4,9.2 M38.9-3.9V12 M48.2,53.3l-9.3,9l-9.4-9.2 M38.9,62.3V46.4", keep: "M4,10.5V1h10.3 M20.7,1h6.1 M33,1h6.1 M55.4,10.5V1H45.2 M4,17.3v6.6 M55.6,17.3v6.6 M4,30.5V40h10.3 M20.7,40 h6.1 M33,40h6.1 M55.4,30.5V40H45.2 M21,18.9h62.9v48.6H21V18.9z", clear: "M22,14.7l30.9,31 M52.9,14.7L22,45.7 M4.7,16.8V4.2h13.1 M26,4.2h7.8 M41.6,4.2h7.8 M70.3,16.8V4.2H57.2 M4.7,25.9v8.6 M70.3,25.9v8.6 M4.7,43.2v12.6h13.1 M26,55.8h7.8 M41.6,55.8h7.8 M70.3,43.2v12.6H57.2" }, title: t.getLocaleModel().get(["toolbox", "brush", "title"]) }; return r }, e }(wo); const fit = dit; function hit(n) { n.registerComponentView(oit), n.registerComponentModel(cit), n.registerPreprocessor(Yrt), n.registerVisual(n.PRIORITY.VISUAL.BRUSH, eit), n.registerAction({ type: "brush", event: "brush", update: "updateVisual" }, function (e, t) { t.eachComponent({ mainType: "brush", query: e }, function (r) { r.setAreas(e.areas) }) }), n.registerAction({ type: "brushSelect", event: "brushSelected", update: "none" }, gr), n.registerAction({ type: "brushEnd", event: "brushEnd", update: "none" }, gr), km("brush", fit) } var pit = function (n) { te(e, n); function e() { var t = n !== null && n.apply(this, arguments) || this; return t.type = e.type, t.layoutMode = { type: "box", ignoreSize: !0 }, t } return e.type = "title", e.defaultOption = { z: 6, show: !0, text: "", target: "blank", subtext: "", subtarget: "blank", left: 0, top: 0, backgroundColor: "rgba(0,0,0,0)", borderColor: "#ccc", borderWidth: 0, padding: 5, itemGap: 10, textStyle: { fontSize: 18, fontWeight: "bold", color: "#464646" }, subtextStyle: { fontSize: 12, color: "#6E7079" } }, e }(Jt), mit = function (n) { te(e, n); function e() { var t = n !== null && n.apply(this, arguments) || this; return t.type = e.type, t } return e.prototype.render = function (t, r, i) { if (this.group.removeAll(), !!t.get("show")) { var a = this.group, o = t.getModel("textStyle"), s = t.getModel("subtextStyle"), l = t.get("textAlign"), c = yt(t.get("textBaseline"), t.get("textVerticalAlign")), u = new tn({ style: Ln(o, { text: t.get("text"), fill: o.getTextColor() }, { disableBox: !0 }), z2: 10 }), d = u.getBoundingRect(), f = t.get("subtext"), h = new tn({ style: Ln(s, { text: f, fill: s.getTextColor(), y: d.height + t.get("itemGap"), verticalAlign: "top" }, { disableBox: !0 }), z2: 10 }), p = t.get("link"), m = t.get("sublink"), g = t.get("triggerEvent", !0); u.silent = !p && !g, h.silent = !m && !g, p && u.on("click", function () { rT(p, "_" + t.get("target")) }), m && h.on("click", function () { rT(m, "_" + t.get("subtarget")) }), pt(u).eventData = pt(h).eventData = g ? { componentType: "title", componentIndex: t.componentIndex } : null, a.add(u), f && a.add(h); var y = a.getBoundingRect(), b = t.getBoxLayoutParams(); b.width = y.width, b.height = y.height; var w = jr(b, { width: i.getWidth(), height: i.getHeight() }, t.get("padding")); l || (l = t.get("left") || t.get("right"), l === "middle" && (l = "center"), l === "right" ? w.x += w.width : l === "center" && (w.x += w.width / 2)), c || (c = t.get("top") || t.get("bottom"), c === "center" && (c = "middle"), c === "bottom" ? w.y += w.height : c === "middle" && (w.y += w.height / 2), c = c || "top"), a.x = w.x, a.y = w.y, a.markRedraw(); var v = { align: l, verticalAlign: c }; u.setStyle(v), h.setStyle(v), y = a.getBoundingRect(); var S = w.margin, x = t.getItemStyle(["color", "opacity"]); x.fill = t.get("backgroundColor"); var k = new Yt({ shape: { x: y.x - S[3], y: y.y - S[0], width: y.width + S[1] + S[3], height: y.height + S[0] + S[2], r: t.get("borderRadius") }, style: x, subPixelOptimize: !0, silent: !0 }); a.add(k) } }, e.type = "title", e }(nr); function git(n) { n.registerComponentModel(pit), n.registerComponentView(mit) } var vit = function (n) { te(e, n); function e() { var t = n !== null && n.apply(this, arguments) || this; return t.type = e.type, t.layoutMode = "box", t } return e.prototype.init = function (t, r, i) { this.mergeDefaultAndTheme(t, i), this._initData() }, e.prototype.mergeOption = function (t) { n.prototype.mergeOption.apply(this, arguments), this._initData() }, e.prototype.setCurrentIndex = function (t) { t == null && (t = this.option.currentIndex); var r = this._data.count(); this.option.loop ? t = (t % r + r) % r : (t >= r && (t = r - 1), t < 0 && (t = 0)), this.option.currentIndex = t }, e.prototype.getCurrentIndex = function () { return this.option.currentIndex }, e.prototype.isIndexMax = function () { return this.getCurrentIndex() >= this._data.count() - 1 }, e.prototype.setPlayState = function (t) { this.option.autoPlay = !!t }, e.prototype.getPlayState = function () { return !!this.option.autoPlay }, e.prototype._initData = function () { var t = this.option, r = t.data || [], i = t.axisType, a = this._names = [], o; i === "category" ? (o = [], $(r, function (c, u) { var d = Er(Yg(c), ""), f; ot(c) ? (f = lt(c), f.value = u) : f = u, o.push(f), a.push(d) })) : o = r; var s = { category: "ordinal", time: "time", value: "number" }[i] || "number", l = this._data = new Ji([{ name: "value", type: s }], this); l.initData(o, a) }, e.prototype.getData = function () { return this._data }, e.prototype.getCategories = function () { if (this.get("axisType") === "category") return this._names.slice() }, e.type = "timeline", e.defaultOption = { z: 4, show: !0, axisType: "time", realtime: !0, left: "20%", top: null, right: "20%", bottom: 0, width: null, height: 40, padding: 5, controlPosition: "left", autoPlay: !1, rewind: !1, loop: !0, playInterval: 2e3, currentIndex: 0, itemStyle: {}, label: { color: "#000" }, data: [] }, e }(Jt); const IG = vit; var Qoe = function (n) { te(e, n); function e() { var t = n !== null && n.apply(this, arguments) || this; return t.type = e.type, t } return e.type = "timeline.slider", e.defaultOption = Wd(IG.defaultOption, { backgroundColor: "rgba(0,0,0,0)", borderColor: "#ccc", borderWidth: 0, orient: "horizontal", inverse: !1, tooltip: { trigger: "item" }, symbol: "circle", symbolSize: 12, lineStyle: { show: !0, width: 2, color: "#DAE1F5" }, label: { position: "auto", show: !0, interval: "auto", rotate: 0, color: "#A4B1D7" }, itemStyle: { color: "#A4B1D7", borderWidth: 1 }, checkpointStyle: { symbol: "circle", symbolSize: 15, color: "#316bf3", borderColor: "#fff", borderWidth: 2, shadowBlur: 2, shadowOffsetX: 1, shadowOffsetY: 1, shadowColor: "rgba(0, 0, 0, 0.3)", animation: !0, animationDuration: 300, animationEasing: "quinticInOut" }, controlStyle: { show: !0, showPlayBtn: !0, showPrevBtn: !0, showNextBtn: !0, itemSize: 24, itemGap: 12, position: "left", playIcon: "path://M31.6,53C17.5,53,6,41.5,6,27.4S17.5,1.8,31.6,1.8C45.7,1.8,57.2,13.3,57.2,27.4S45.7,53,31.6,53z M31.6,3.3 C18.4,3.3,7.5,14.1,7.5,27.4c0,13.3,10.8,24.1,24.1,24.1C44.9,51.5,55.7,40.7,55.7,27.4C55.7,14.1,44.9,3.3,31.6,3.3z M24.9,21.3 c0-2.2,1.6-3.1,3.5-2l10.5,6.1c1.899,1.1,1.899,2.9,0,4l-10.5,6.1c-1.9,1.1-3.5,0.2-3.5-2V21.3z", stopIcon: "path://M30.9,53.2C16.8,53.2,5.3,41.7,5.3,27.6S16.8,2,30.9,2C45,2,56.4,13.5,56.4,27.6S45,53.2,30.9,53.2z M30.9,3.5C17.6,3.5,6.8,14.4,6.8,27.6c0,13.3,10.8,24.1,24.101,24.1C44.2,51.7,55,40.9,55,27.6C54.9,14.4,44.1,3.5,30.9,3.5z M36.9,35.8c0,0.601-0.4,1-0.9,1h-1.3c-0.5,0-0.9-0.399-0.9-1V19.5c0-0.6,0.4-1,0.9-1H36c0.5,0,0.9,0.4,0.9,1V35.8z M27.8,35.8 c0,0.601-0.4,1-0.9,1h-1.3c-0.5,0-0.9-0.399-0.9-1V19.5c0-0.6,0.4-1,0.9-1H27c0.5,0,0.9,0.4,0.9,1L27.8,35.8L27.8,35.8z", nextIcon: "M2,18.5A1.52,1.52,0,0,1,.92,18a1.49,1.49,0,0,1,0-2.12L7.81,9.36,1,3.11A1.5,1.5,0,1,1,3,.89l8,7.34a1.48,1.48,0,0,1,.49,1.09,1.51,1.51,0,0,1-.46,1.1L3,18.08A1.5,1.5,0,0,1,2,18.5Z", prevIcon: "M10,.5A1.52,1.52,0,0,1,11.08,1a1.49,1.49,0,0,1,0,2.12L4.19,9.64,11,15.89a1.5,1.5,0,1,1-2,2.22L1,10.77A1.48,1.48,0,0,1,.5,9.68,1.51,1.51,0,0,1,1,8.58L9,.92A1.5,1.5,0,0,1,10,.5Z", prevBtnSize: 18, nextBtnSize: 18, color: "#A4B1D7", borderColor: "#A4B1D7", borderWidth: 1 }, emphasis: { label: { show: !0, color: "#6f778d" }, itemStyle: { color: "#316BF3" }, controlStyle: { color: "#316BF3", borderColor: "#316BF3", borderWidth: 2 } }, progress: { lineStyle: { color: "#316BF3" }, itemStyle: { color: "#316BF3" }, label: { color: "#6f778d" } }, data: [] }), e }(IG); Cr(Qoe, mC.prototype); const yit = Qoe; var _it = function (n) { te(e, n); function e() { var t = n !== null && n.apply(this, arguments) || this; return t.type = e.type, t } return e.type = "timeline", e }(nr); const bit = _it; var wit = function (n) { te(e, n); function e(t, r, i, a) { var o = n.call(this, t, r, i) || this; return o.type = a || "value", o } return e.prototype.getLabelModel = function () { return this.model.getModel("label") }, e.prototype.isHorizontal = function () { return this.model.get("orient") === "horizontal" }, e }(Ps); const xit = wit; var hD = Math.PI, LG = Kt(), Sit = function (n) { te(e, n); function e() { var t = n !== null && n.apply(this, arguments) || this; return t.type = e.type, t } return e.prototype.init = function (t, r) { this.api = r }, e.prototype.render = function (t, r, i) { if (this.model = t, this.api = i, this.ecModel = r, this.group.removeAll(), t.get("show", !0)) { var a = this._layout(t, i), o = this._createGroup("_mainGroup"), s = this._createGroup("_labelGroup"), l = this._axis = this._createAxis(a, t); t.formatTooltip = function (c) { var u = l.scale.getLabel({ value: c }); return Gr("nameValue", { noName: !0, value: u }) }, $(["AxisLine", "AxisTick", "Control", "CurrentPointer"], function (c) { this["_render" + c](a, o, l, t) }, this), this._renderAxisLabel(a, s, l, t), this._position(a, t) } this._doPlayStop(), this._updateTicksStatus() }, e.prototype.remove = function () { this._clearTimer(), this.group.removeAll() }, e.prototype.dispose = function () { this._clearTimer() }, e.prototype._layout = function (t, r) { var i = t.get(["label", "position"]), a = t.get("orient"), o = kit(t, r), s; i == null || i === "auto" ? s = a === "horizontal" ? o.y + o.height / 2 < r.getHeight() / 2 ? "-" : "+" : o.x + o.width / 2 < r.getWidth() / 2 ? "+" : "-" : Fe(i) ? s = { horizontal: { top: "-", bottom: "+" }, vertical: { left: "-", right: "+" } }[a][i] : s = i; var l = { horizontal: "center", vertical: s >= 0 || s === "+" ? "left" : "right" }, c = { horizontal: s >= 0 || s === "+" ? "top" : "bottom", vertical: "middle" }, u = { horizontal: 0, vertical: hD / 2 }, d = a === "vertical" ? o.height : o.width, f = t.getModel("controlStyle"), h = f.get("show", !0), p = h ? f.get("itemSize") : 0, m = h ? f.get("itemGap") : 0, g = p + m, y = t.get(["label", "rotate"]) || 0; y = y * hD / 180; var b, w, v, S = f.get("position", !0), x = h && f.get("showPlayBtn", !0), k = h && f.get("showPrevBtn", !0), A = h && f.get("showNextBtn", !0), C = 0, E = d; S === "left" || S === "bottom" ? (x && (b = [0, 0], C += g), k && (w = [C, 0], C += g), A && (v = [E - p, 0], E -= g)) : (x && (b = [E - p, 0], E -= g), k && (w = [0, 0], C += g), A && (v = [E - p, 0], E -= g)); var O = [C, E]; return t.get("inverse") && O.reverse(), { viewRect: o, mainLength: d, orient: a, rotation: u[a], labelRotation: y, labelPosOpt: s, labelAlign: t.get(["label", "align"]) || l[a], labelBaseline: t.get(["label", "verticalAlign"]) || t.get(["label", "baseline"]) || c[a], playPosition: b, prevBtnPosition: w, nextBtnPosition: v, axisExtent: O, controlSize: p, controlGap: m } }, e.prototype._position = function (t, r) { var i = this._mainGroup, a = this._labelGroup, o = t.viewRect; if (t.orient === "vertical") { var s = Va(), l = o.x, c = o.y + o.height; Sl(s, s, [-l, -c]), rp(s, s, -hD / 2), Sl(s, s, [l, c]), o = o.clone(), o.applyTransform(s) } var u = b(o), d = b(i.getBoundingRect()), f = b(a.getBoundingRect()), h = [i.x, i.y], p = [a.x, a.y]; p[0] = h[0] = u[0][0]; var m = t.labelPosOpt; if (m == null || Fe(m)) { var g = m === "+" ? 0 : 1; w(h, d, u, 1, g), w(p, f, u, 1, 1 - g) } else { var g = m >= 0 ? 0 : 1; w(h, d, u, 1, g), p[1] = h[1] + m } i.setPosition(h), a.setPosition(p), i.rotation = a.rotation = t.rotation, y(i), y(a); function y(v) { v.originX = u[0][0] - v.x, v.originY = u[1][0] - v.y } function b(v) { return [[v.x, v.x + v.width], [v.y, v.y + v.height]] } function w(v, S, x, k, A) { v[k] += x[k][A] - S[k][A] } }, e.prototype._createAxis = function (t, r) { var i = r.getData(), a = r.get("axisType"), o = Tit(r, a); o.getTicks = function () { return i.mapArray(["value"], function (c) { return { value: c } }) }; var s = i.getDataExtent("value"); o.setExtent(s[0], s[1]), o.calcNiceTicks(); var l = new xit("value", o, t.axisExtent, a); return l.model = r, l }, e.prototype._createGroup = function (t) { var r = this[t] = new ft; return this.group.add(r), r }, e.prototype._renderAxisLine = function (t, r, i, a) { var o = i.getExtent(); if (a.get(["lineStyle", "show"])) { var s = new Jr({ shape: { x1: o[0], y1: 0, x2: o[1], y2: 0 }, style: be({ lineCap: "round" }, a.getModel("lineStyle").getLineStyle()), silent: !0, z2: 1 }); r.add(s); var l = this._progressLine = new Jr({ shape: { x1: o[0], x2: this._currentPointer ? this._currentPointer.x : o[0], y1: 0, y2: 0 }, style: rt({ lineCap: "round", lineWidth: s.style.lineWidth }, a.getModel(["progress", "lineStyle"]).getLineStyle()), silent: !0, z2: 1 }); r.add(l) } }, e.prototype._renderAxisTick = function (t, r, i, a) { var o = this, s = a.getData(), l = i.scale.getTicks(); this._tickSymbols = [], $(l, function (c) { var u = i.dataToCoord(c.value), d = s.getItemModel(c.value), f = d.getModel("itemStyle"), h = d.getModel(["emphasis", "itemStyle"]), p = d.getModel(["progress", "itemStyle"]), m = { x: u, y: 0, onclick: He(o._changeTimeline, o, c.value) }, g = RG(d, f, r, m); g.ensureState("emphasis").style = h.getItemStyle(), g.ensureState("progress").style = p.getItemStyle(), Th(g); var y = pt(g); d.get("tooltip") ? (y.dataIndex = c.value, y.dataModel = a) : y.dataIndex = y.dataModel = null, o._tickSymbols.push(g) }) }, e.prototype._renderAxisLabel = function (t, r, i, a) { var o = this, s = i.getLabelModel(); if (s.get("show")) { var l = a.getData(), c = i.getViewLabels(); this._tickLabels = [], $(c, function (u) { var d = u.tickValue, f = l.getItemModel(d), h = f.getModel("label"), p = f.getModel(["emphasis", "label"]), m = f.getModel(["progress", "label"]), g = i.dataToCoord(u.tickValue), y = new tn({ x: g, y: 0, rotation: t.labelRotation - t.rotation, onclick: He(o._changeTimeline, o, d), silent: !1, style: Ln(h, { text: u.formattedLabel, align: t.labelAlign, verticalAlign: t.labelBaseline }) }); y.ensureState("emphasis").style = Ln(p), y.ensureState("progress").style = Ln(m), r.add(y), Th(y), LG(y).dataIndex = d, o._tickLabels.push(y) }) } }, e.prototype._renderControl = function (t, r, i, a) { var o = t.controlSize, s = t.rotation, l = a.getModel("controlStyle").getItemStyle(), c = a.getModel(["emphasis", "controlStyle"]).getItemStyle(), u = a.getPlayState(), d = a.get("inverse", !0); f(t.nextBtnPosition, "next", He(this._changeTimeline, this, d ? "-" : "+")), f(t.prevBtnPosition, "prev", He(this._changeTimeline, this, d ? "+" : "-")), f(t.playPosition, u ? "stop" : "play", He(this._handlePlayClick, this, !u), !0); function f(h, p, m, g) { if (h) { var y = Es(yt(a.get(["controlStyle", p + "BtnSize"]), o), o), b = [0, -y / 2, y, y], w = Cit(a, p + "Icon", b, { x: h[0], y: h[1], originX: o / 2, originY: 0, rotation: g ? -s : 0, rectHover: !0, style: l, onclick: m }); w.ensureState("emphasis").style = c, r.add(w), Th(w) } } }, e.prototype._renderCurrentPointer = function (t, r, i, a) { var o = a.getData(), s = a.getCurrentIndex(), l = o.getItemModel(s).getModel("checkpointStyle"), c = this, u = { onCreate: function (d) { d.draggable = !0, d.drift = He(c._handlePointerDrag, c), d.ondragend = He(c._handlePointerDragend, c), NG(d, c._progressLine, s, i, a, !0) }, onUpdate: function (d) { NG(d, c._progressLine, s, i, a) } }; this._currentPointer = RG(l, l, this._mainGroup, {}, this._currentPointer, u) }, e.prototype._handlePlayClick = function (t) { this._clearTimer(), this.api.dispatchAction({ type: "timelinePlayChange", playState: t, from: this.uid }) }, e.prototype._handlePointerDrag = function (t, r, i) { this._clearTimer(), this._pointerChangeTimeline([i.offsetX, i.offsetY]) }, e.prototype._handlePointerDragend = function (t) { this._pointerChangeTimeline([t.offsetX, t.offsetY], !0) }, e.prototype._pointerChangeTimeline = function (t, r) { var i = this._toAxisCoord(t)[0], a = this._axis, o = Oo(a.getExtent().slice()); i > o[1] && (i = o[1]), i < o[0] && (i = o[0]), this._currentPointer.x = i, this._currentPointer.markRedraw(); var s = this._progressLine; s && (s.shape.x2 = i, s.dirty()); var l = this._findNearestTick(i), c = this.model; (r || l !== c.getCurrentIndex() && c.get("realtime")) && this._changeTimeline(l) }, e.prototype._doPlayStop = function () { var t = this; this._clearTimer(), this.model.getPlayState() && (this._timer = setTimeout(function () { var r = t.model; t._changeTimeline(r.getCurrentIndex() + (r.get("rewind", !0) ? -1 : 1)) }, this.model.get("playInterval"))) }, e.prototype._toAxisCoord = function (t) { var r = this._mainGroup.getLocalTransform(); return bs(t, r, !0) }, e.prototype._findNearestTick = function (t) { var r = this.model.getData(), i = 1 / 0, a, o = this._axis; return r.each(["value"], function (s, l) { var c = o.dataToCoord(s), u = Math.abs(c - t); u < i && (i = u, a = l) }), a }, e.prototype._clearTimer = function () { this._timer && (clearTimeout(this._timer), this._timer = null) }, e.prototype._changeTimeline = function (t) { var r = this.model.getCurrentIndex(); t === "+" ? t = r + 1 : t === "-" && (t = r - 1), this.api.dispatchAction({ type: "timelineChange", currentIndex: t, from: this.uid }) }, e.prototype._updateTicksStatus = function () { var t = this.model.getCurrentIndex(), r = this._tickSymbols, i = this._tickLabels; if (r) for (var a = 0; a < r.length; a++)r && r[a] && r[a].toggleState("progress", a < t); if (i) for (var a = 0; a < i.length; a++)i && i[a] && i[a].toggleState("progress", LG(i[a]).dataIndex <= t) }, e.type = "timeline.slider", e }(bit); function Tit(n, e) { if (e = e || n.get("type"), e) switch (e) { case "category": return new v3({ ordinalMeta: n.getCategories(), extent: [1 / 0, -1 / 0] }); case "time": return new Qre({ locale: n.ecModel.getLocaleModel(), useUTC: n.ecModel.get("useUTC") }); default: return new Od } } function kit(n, e) { return jr(n.getBoxLayoutParams(), { width: e.getWidth(), height: e.getHeight() }, n.get("padding")) } function Cit(n, e, t, r) { var i = r.style, a = kb(n.get(["controlStyle", e]), r || {}, new kt(t[0], t[1], t[2], t[3])); return i && a.setStyle(i), a } function RG(n, e, t, r, i, a) { var o = e.get("color"); if (i) i.setColor(o), t.add(i), a && a.onUpdate(i); else { var s = n.get("symbol"); i = Tr(s, -1, -1, 2, 2, o), i.setStyle("strokeNoScale", !0), t.add(i), a && a.onCreate(i) } var l = e.getItemStyle(["color"]); i.setStyle(l), r = xt({ rectHover: !0, z2: 100 }, r, !0); var c = ov(n.get("symbolSize")); r.scaleX = c[0] / 2, r.scaleY = c[1] / 2; var u = sp(n.get("symbolOffset"), c); u && (r.x = (r.x || 0) + u[0], r.y = (r.y || 0) + u[1]); var d = n.get("symbolRotate"); return r.rotation = (d || 0) * Math.PI / 180 || 0, i.attr(r), i.updateTransform(), i } function NG(n, e, t, r, i, a) { if (!n.dragging) { var o = i.getModel("checkpointStyle"), s = r.dataToCoord(i.getData().get("value", t)); if (a || !o.get("animation", !0)) n.attr({ x: s, y: 0 }), e && e.attr({ shape: { x2: s } }); else { var l = { duration: o.get("animationDuration", !0), easing: o.get("animationEasing", !0) }; n.stopAnimation(null, !0), n.animateTo({ x: s, y: 0 }, l), e && e.animateTo({ shape: { x2: s } }, l) } } } const Ait = Sit; function Eit(n) { n.registerAction({ type: "timelineChange", event: "timelineChanged", update: "prepareAndUpdate" }, function (e, t, r) { var i = t.getComponent("timeline"); return i && e.currentIndex != null && (i.setCurrentIndex(e.currentIndex), !i.get("loop", !0) && i.isIndexMax() && i.getPlayState() && (i.setPlayState(!1), r.dispatchAction({ type: "timelinePlayChange", playState: !1, from: e.from }))), t.resetOption("timeline", { replaceMerge: i.get("replaceMerge", !0) }), rt({ currentIndex: i.option.currentIndex }, e) }), n.registerAction({ type: "timelinePlayChange", event: "timelinePlayChanged", update: "update" }, function (e, t) { var r = t.getComponent("timeline"); r && e.playState != null && r.setPlayState(e.playState) }) } function Mit(n) { var e = n && n.timeline; ke(e) || (e = e ? [e] : []), $(e, function (t) { t && Oit(t) }) } function Oit(n) { var e = n.type, t = { number: "value", time: "time" }; if (t[e] && (n.axisType = t[e], delete n.type), BG(n), Gf(n, "controlPosition")) { var r = n.controlStyle || (n.controlStyle = {}); Gf(r, "position") || (r.position = n.controlPosition), r.position === "none" && !Gf(r, "show") && (r.show = !1, delete r.position), delete n.controlPosition } $(n.data || [], function (i) { ot(i) && !ke(i) && (!Gf(i, "value") && Gf(i, "name") && (i.value = i.name), BG(i)) }) } function BG(n) { var e = n.itemStyle || (n.itemStyle = {}), t = e.emphasis || (e.emphasis = {}), r = n.label || n.label || {}, i = r.normal || (r.normal = {}), a = { normal: 1, emphasis: 1 }; $(r, function (o, s) { !a[s] && !Gf(i, s) && (i[s] = o) }), t.label && !Gf(r, "emphasis") && (r.emphasis = t.label, delete t.label) } function Gf(n, e) { return n.hasOwnProperty(e) } function Dit(n) { n.registerComponentModel(yit), n.registerComponentView(Ait), n.registerSubTypeDefaulter("timeline", function () { return "slider" }), Eit(n), n.registerPreprocessor(Mit) } function SB(n, e) { if (!n) return !1; for (var t = ke(n) ? n : [n], r = 0; r < t.length; r++)if (t[r] && t[r][e]) return !0; return !1 } function _x(n) { Vh(n, "label", ["show"]) } var bx = Kt(), ese = function (n) { te(e, n); function e() { var t = n !== null && n.apply(this, arguments) || this; return t.type = e.type, t.createdBySelf = !1, t } return e.prototype.init = function (t, r, i) { this.mergeDefaultAndTheme(t, i), this._mergeOption(t, i, !1, !0) }, e.prototype.isAnimationEnabled = function () { if (en.node) return !1; var t = this.__hostSeries; return this.getShallow("animation") && t && t.isAnimationEnabled() }, e.prototype.mergeOption = function (t, r) { this._mergeOption(t, r, !1, !1) }, e.prototype._mergeOption = function (t, r, i, a) { var o = this.mainType; i || r.eachSeries(function (s) { var l = s.get(this.mainType, !0), c = bx(s)[o]; if (!l || !l.data) { bx(s)[o] = null; return } c ? c._mergeOption(l, r, !0) : (a && _x(l), $(l.data, function (u) { u instanceof Array ? (_x(u[0]), _x(u[1])) : _x(u) }), c = this.createMarkerModelFromSeries(l, this, r), be(c, { mainType: this.mainType, seriesIndex: s.seriesIndex, name: s.name, createdBySelf: !0 }), c.__hostSeries = s), bx(s)[o] = c }, this) }, e.prototype.formatTooltip = function (t, r, i) { var a = this.getData(), o = this.getRawValue(t), s = a.getName(t); return Gr("section", { header: this.name, blocks: [Gr("nameValue", { name: s, value: o, noName: !s, noValue: o == null })] }) }, e.prototype.getData = function () { return this._data }, e.prototype.setData = function (t) { this._data = t }, e.prototype.getDataParams = function (t, r) { var i = mC.prototype.getDataParams.call(this, t, r), a = this.__hostSeries; return a && (i.seriesId = a.id, i.seriesName = a.name, i.seriesType = a.subType), i }, e.getMarkerModelFromSeries = function (t, r) { return bx(t)[r] }, e.type = "marker", e.dependencies = ["series", "grid", "polar", "geo"], e }(Jt); Cr(ese, mC.prototype); const Pd = ese; var jit = function (n) { te(e, n); function e() { var t = n !== null && n.apply(this, arguments) || this; return t.type = e.type, t } return e.prototype.createMarkerModelFromSeries = function (t, r, i) { return new e(t, r, i) }, e.type = "markPoint", e.defaultOption = { z: 5, symbol: "pin", symbolSize: 50, tooltip: { trigger: "item" }, label: { show: !0, position: "inside" }, itemStyle: { borderWidth: 2 }, emphasis: { label: { show: !0 } } }, e }(Pd); const Pit = jit; function QI(n) { return !(isNaN(parseFloat(n.x)) && isNaN(parseFloat(n.y))) } function Iit(n) { return !isNaN(parseFloat(n.x)) && !isNaN(parseFloat(n.y)) } function xx(n, e, t, r, i, a) { var o = [], s = Md(e, r), l = s ? e.getCalculationInfo("stackResultDimension") : r, c = TB(e, l, n), u = e.indicesOfNearest(l, c)[0]; o[i] = e.get(t, u), o[a] = e.get(l, u); var d = e.get(r, u), f = ol(e.get(r, u)); return f = Math.min(f, 20), f >= 0 && (o[a] = +o[a].toFixed(f)), [o, d] } var pD = { min: wt(xx, "min"), max: wt(xx, "max"), average: wt(xx, "average"), median: wt(xx, "median") }; function R_(n, e) { if (e) { var t = n.getData(), r = n.coordinateSystem, i = r && r.dimensions; if (!Iit(e) && !ke(e.coord) && ke(i)) { var a = tse(e, t, r, n); if (e = lt(e), e.type && pD[e.type] && a.baseAxis && a.valueAxis) { var o = Et(i, a.baseAxis.dim), s = Et(i, a.valueAxis.dim), l = pD[e.type](t, a.baseDataDim, a.valueDataDim, o, s); e.coord = l[0], e.value = l[1] } else e.coord = [e.xAxis != null ? e.xAxis : e.radiusAxis, e.yAxis != null ? e.yAxis : e.angleAxis] } if (e.coord == null || !ke(i)) e.coord = []; else for (var c = e.coord, u = 0; u < 2; u++)pD[c[u]] && (c[u] = TB(t, t.mapDimension(i[u]), c[u])); return e } } function tse(n, e, t, r) { var i = {}; return n.valueIndex != null || n.valueDim != null ? (i.valueDataDim = n.valueIndex != null ? e.getDimension(n.valueIndex) : n.valueDim, i.valueAxis = t.getAxis(Lit(r, i.valueDataDim)), i.baseAxis = t.getOtherAxis(i.valueAxis), i.baseDataDim = e.mapDimension(i.baseAxis.dim)) : (i.baseAxis = r.getBaseAxis(), i.valueAxis = t.getOtherAxis(i.baseAxis), i.baseDataDim = e.mapDimension(i.baseAxis.dim), i.valueDataDim = e.mapDimension(i.valueAxis.dim)), i } function Lit(n, e) { var t = n.getData().getDimensionInfo(e); return t && t.coordDim } function N_(n, e) { return n && n.containData && e.coord && !QI(e) ? n.containData(e.coord) : !0 } function Rit(n, e, t) { return n && n.containZone && e.coord && t.coord && !QI(e) && !QI(t) ? n.containZone(e.coord, t.coord) : !0 } function nse(n, e) { return n ? function (t, r, i, a) { var o = a < 2 ? t.coord && t.coord[a] : t.value; return ld(o, e[a]) } : function (t, r, i, a) { return ld(t.value, e[a]) } } function TB(n, e, t) { if (t === "average") { var r = 0, i = 0; return n.each(e, function (a, o) { isNaN(a) || (r += a, i++) }), r / i } else return t === "median" ? n.getMedian(e) : n.getDataExtent(e)[t === "max" ? 1 : 0] } var mD = Kt(), Nit = function (n) { te(e, n); function e() { var t = n !== null && n.apply(this, arguments) || this; return t.type = e.type, t } return e.prototype.init = function () { this.markerGroupMap = Ze() }, e.prototype.render = function (t, r, i) { var a = this, o = this.markerGroupMap; o.each(function (s) { mD(s).keep = !1 }), r.eachSeries(function (s) { var l = Pd.getMarkerModelFromSeries(s, a.type); l && a.renderSeries(s, l, r, i) }), o.each(function (s) { !mD(s).keep && a.group.remove(s.group) }) }, e.prototype.markKeep = function (t) { mD(t).keep = !0 }, e.prototype.toggleBlurSeries = function (t, r) { var i = this; $(t, function (a) { var o = Pd.getMarkerModelFromSeries(a, i.type); if (o) { var s = o.getData(); s.eachItemGraphicEl(function (l) { l && (r ? Ate(l) : $N(l)) }) } }) }, e.type = "marker", e }(nr); const kB = Nit; function $G(n, e, t) { var r = e.coordinateSystem; n.each(function (i) { var a = n.getItemModel(i), o, s = Ne(a.get("x"), t.getWidth()), l = Ne(a.get("y"), t.getHeight()); if (!isNaN(s) && !isNaN(l)) o = [s, l]; else if (e.getMarkerPosition) o = e.getMarkerPosition(n.getValues(n.dimensions, i)); else if (r) { var c = n.get(r.dimensions[0], i), u = n.get(r.dimensions[1], i); o = r.dataToPoint([c, u]) } isNaN(s) || (o[0] = s), isNaN(l) || (o[1] = l), n.setItemLayout(i, o) }) } var Bit = function (n) { te(e, n); function e() { var t = n !== null && n.apply(this, arguments) || this; return t.type = e.type, t } return e.prototype.updateTransform = function (t, r, i) { r.eachSeries(function (a) { var o = Pd.getMarkerModelFromSeries(a, "markPoint"); o && ($G(o.getData(), a, i), this.markerGroupMap.get(a.id).updateLayout()) }, this) }, e.prototype.renderSeries = function (t, r, i, a) { var o = t.coordinateSystem, s = t.id, l = t.getData(), c = this.markerGroupMap, u = c.get(s) || c.set(s, new Db), d = $it(o, t, r); r.setData(d), $G(r.getData(), t, a), d.each(function (f) { var h = d.getItemModel(f), p = h.getShallow("symbol"), m = h.getShallow("symbolSize"), g = h.getShallow("symbolRotate"), y = h.getShallow("symbolOffset"), b = h.getShallow("symbolKeepAspect"); if (tt(p) || tt(m) || tt(g) || tt(y)) { var w = r.getRawValue(f), v = r.getDataParams(f); tt(p) && (p = p(w, v)), tt(m) && (m = m(w, v)), tt(g) && (g = g(w, v)), tt(y) && (y = y(w, v)) } var S = h.getModel("itemStyle").getItemStyle(), x = Ab(l, "color"); S.fill || (S.fill = x), d.setItemVisual(f, { symbol: p, symbolSize: m, symbolRotate: g, symbolOffset: y, symbolKeepAspect: b, style: S }) }), u.updateData(d), this.group.add(u.group), d.eachItemGraphicEl(function (f) { f.traverse(function (h) { pt(h).dataModel = r }) }), this.markKeep(u), u.group.silent = r.get("silent") || t.get("silent") }, e.type = "markPoint", e }(kB); function $it(n, e, t) { var r; n ? r = Ae(n && n.dimensions, function (s) { var l = e.getData().getDimensionInfo(e.getData().mapDimension(s)) || {}; return be(be({}, l), { name: s, ordinalMeta: null }) }) : r = [{ name: "value", type: "float" }]; var i = new Ji(r, t), a = Ae(t.get("data"), wt(R_, e)); n && (a = pn(a, wt(N_, n))); var o = nse(!!n, r); return i.initData(a, null, o), i } const Fit = Bit; function zit(n) { n.registerComponentModel(Pit), n.registerComponentView(Fit), n.registerPreprocessor(function (e) { SB(e.series, "markPoint") && (e.markPoint = e.markPoint || {}) }) } var Vit = function (n) { te(e, n); function e() { var t = n !== null && n.apply(this, arguments) || this; return t.type = e.type, t } return e.prototype.createMarkerModelFromSeries = function (t, r, i) { return new e(t, r, i) }, e.type = "markLine", e.defaultOption = { z: 5, symbol: ["circle", "arrow"], symbolSize: [8, 16], symbolOffset: 0, precision: 2, tooltip: { trigger: "item" }, label: { show: !0, position: "end", distance: 5 }, lineStyle: { type: "dashed" }, emphasis: { label: { show: !0 }, lineStyle: { width: 3 } }, animationEasing: "linear" }, e }(Pd); const Hit = Vit; var Sx = Kt(), Uit = function (n, e, t, r) { var i = n.getData(), a; if (ke(r)) a = r; else { var o = r.type; if (o === "min" || o === "max" || o === "average" || o === "median" || r.xAxis != null || r.yAxis != null) { var s = void 0, l = void 0; if (r.yAxis != null || r.xAxis != null) s = e.getAxis(r.yAxis != null ? "y" : "x"), l = Xr(r.yAxis, r.xAxis); else { var c = tse(r, i, e, n); s = c.valueAxis; var u = $re(i, c.valueDataDim); l = TB(i, u, o) } var d = s.dim === "x" ? 0 : 1, f = 1 - d, h = lt(r), p = { coord: [] }; h.type = null, h.coord = [], h.coord[f] = -1 / 0, p.coord[f] = 1 / 0; var m = t.get("precision"); m >= 0 && nn(l) && (l = +l.toFixed(Math.min(m, 20))), h.coord[d] = p.coord[d] = l, a = [h, p, { type: o, valueIndex: r.valueIndex, value: l }] } else a = [] } var g = [R_(n, a[0]), R_(n, a[1]), be({}, a[2])]; return g[2].type = g[2].type || null, xt(g[2], g[0]), xt(g[2], g[1]), g }; function MT(n) { return !isNaN(n) && !isFinite(n) } function FG(n, e, t, r) { var i = 1 - n, a = r.dimensions[n]; return MT(e[i]) && MT(t[i]) && e[n] === t[n] && r.getAxis(a).containData(e[n]) } function Git(n, e) { if (n.type === "cartesian2d") { var t = e[0].coord, r = e[1].coord; if (t && r && (FG(1, t, r, n) || FG(0, t, r, n))) return !0 } return N_(n, e[0]) && N_(n, e[1]) } function gD(n, e, t, r, i) { var a = r.coordinateSystem, o = n.getItemModel(e), s, l = Ne(o.get("x"), i.getWidth()), c = Ne(o.get("y"), i.getHeight()); if (!isNaN(l) && !isNaN(c)) s = [l, c]; else { if (r.getMarkerPosition) s = r.getMarkerPosition(n.getValues(n.dimensions, e)); else { var u = a.dimensions, d = n.get(u[0], e), f = n.get(u[1], e); s = a.dataToPoint([d, f]) } if (cp(a, "cartesian2d")) { var h = a.getAxis("x"), p = a.getAxis("y"), u = a.dimensions; MT(n.get(u[0], e)) ? s[0] = h.toGlobalCoord(h.getExtent()[t ? 0 : 1]) : MT(n.get(u[1], e)) && (s[1] = p.toGlobalCoord(p.getExtent()[t ? 0 : 1])) } isNaN(l) || (s[0] = l), isNaN(c) || (s[1] = c) } n.setItemLayout(e, s) } var Wit = function (n) { te(e, n); function e() { var t = n !== null && n.apply(this, arguments) || this; return t.type = e.type, t } return e.prototype.updateTransform = function (t, r, i) { r.eachSeries(function (a) { var o = Pd.getMarkerModelFromSeries(a, "markLine"); if (o) { var s = o.getData(), l = Sx(o).from, c = Sx(o).to; l.each(function (u) { gD(l, u, !0, a, i), gD(c, u, !1, a, i) }), s.each(function (u) { s.setItemLayout(u, [l.getItemLayout(u), c.getItemLayout(u)]) }), this.markerGroupMap.get(a.id).updateLayout() } }, this) }, e.prototype.renderSeries = function (t, r, i, a) { var o = t.coordinateSystem, s = t.id, l = t.getData(), c = this.markerGroupMap, u = c.get(s) || c.set(s, new W3); this.group.add(u.group); var d = Kit(o, t, r), f = d.from, h = d.to, p = d.line; Sx(r).from = f, Sx(r).to = h, r.setData(p); var m = r.get("symbol"), g = r.get("symbolSize"), y = r.get("symbolRotate"), b = r.get("symbolOffset"); ke(m) || (m = [m, m]), ke(g) || (g = [g, g]), ke(y) || (y = [y, y]), ke(b) || (b = [b, b]), d.from.each(function (v) { w(f, v, !0), w(h, v, !1) }), p.each(function (v) { var S = p.getItemModel(v).getModel("lineStyle").getLineStyle(); p.setItemLayout(v, [f.getItemLayout(v), h.getItemLayout(v)]), S.stroke == null && (S.stroke = f.getItemVisual(v, "style").fill), p.setItemVisual(v, { fromSymbolKeepAspect: f.getItemVisual(v, "symbolKeepAspect"), fromSymbolOffset: f.getItemVisual(v, "symbolOffset"), fromSymbolRotate: f.getItemVisual(v, "symbolRotate"), fromSymbolSize: f.getItemVisual(v, "symbolSize"), fromSymbol: f.getItemVisual(v, "symbol"), toSymbolKeepAspect: h.getItemVisual(v, "symbolKeepAspect"), toSymbolOffset: h.getItemVisual(v, "symbolOffset"), toSymbolRotate: h.getItemVisual(v, "symbolRotate"), toSymbolSize: h.getItemVisual(v, "symbolSize"), toSymbol: h.getItemVisual(v, "symbol"), style: S }) }), u.updateData(p), d.line.eachItemGraphicEl(function (v) { pt(v).dataModel = r, v.traverse(function (S) { pt(S).dataModel = r }) }); function w(v, S, x) { var k = v.getItemModel(S); gD(v, S, x, t, a); var A = k.getModel("itemStyle").getItemStyle(); A.fill == null && (A.fill = Ab(l, "color")), v.setItemVisual(S, { symbolKeepAspect: k.get("symbolKeepAspect"), symbolOffset: yt(k.get("symbolOffset", !0), b[x ? 0 : 1]), symbolRotate: yt(k.get("symbolRotate", !0), y[x ? 0 : 1]), symbolSize: yt(k.get("symbolSize"), g[x ? 0 : 1]), symbol: yt(k.get("symbol", !0), m[x ? 0 : 1]), style: A }) } this.markKeep(u), u.group.silent = r.get("silent") || t.get("silent") }, e.type = "markLine", e }(kB); function Kit(n, e, t) { var r; n ? r = Ae(n && n.dimensions, function (c) { var u = e.getData().getDimensionInfo(e.getData().mapDimension(c)) || {}; return be(be({}, u), { name: c, ordinalMeta: null }) }) : r = [{ name: "value", type: "float" }]; var i = new Ji(r, t), a = new Ji(r, t), o = new Ji([], t), s = Ae(t.get("data"), wt(Uit, e, n, t)); n && (s = pn(s, wt(Git, n))); var l = nse(!!n, r); return i.initData(Ae(s, function (c) { return c[0] }), null, l), a.initData(Ae(s, function (c) { return c[1] }), null, l), o.initData(Ae(s, function (c) { return c[2] })), o.hasItemOption = !0, { from: i, to: a, line: o } } const qit = Wit; function Yit(n) { n.registerComponentModel(Hit), n.registerComponentView(qit), n.registerPreprocessor(function (e) { SB(e.series, "markLine") && (e.markLine = e.markLine || {}) }) } var Zit = function (n) { te(e, n); function e() { var t = n !== null && n.apply(this, arguments) || this; return t.type = e.type, t } return e.prototype.createMarkerModelFromSeries = function (t, r, i) { return new e(t, r, i) }, e.type = "markArea", e.defaultOption = { z: 1, tooltip: { trigger: "item" }, animation: !1, label: { show: !0, position: "top" }, itemStyle: { borderWidth: 0 }, emphasis: { label: { show: !0, position: "top" } } }, e }(Pd); const Xit = Zit; var Tx = Kt(), Jit = function (n, e, t, r) { var i = r[0], a = r[1]; if (!(!i || !a)) { var o = R_(n, i), s = R_(n, a), l = o.coord, c = s.coord; l[0] = Xr(l[0], -1 / 0), l[1] = Xr(l[1], -1 / 0), c[0] = Xr(c[0], 1 / 0), c[1] = Xr(c[1], 1 / 0); var u = bN([{}, o, s]); return u.coord = [o.coord, s.coord], u.x0 = o.x, u.y0 = o.y, u.x1 = s.x, u.y1 = s.y, u } }; function OT(n) { return !isNaN(n) && !isFinite(n) } function zG(n, e, t, r) { var i = 1 - n; return OT(e[i]) && OT(t[i]) } function Qit(n, e) { var t = e.coord[0], r = e.coord[1], i = { coord: t, x: e.x0, y: e.y0 }, a = { coord: r, x: e.x1, y: e.y1 }; return cp(n, "cartesian2d") ? t && r && (zG(1, t, r) || zG(0, t, r)) ? !0 : Rit(n, i, a) : N_(n, i) || N_(n, a) } function VG(n, e, t, r, i) { var a = r.coordinateSystem, o = n.getItemModel(e), s, l = Ne(o.get(t[0]), i.getWidth()), c = Ne(o.get(t[1]), i.getHeight()); if (!isNaN(l) && !isNaN(c)) s = [l, c]; else { if (r.getMarkerPosition) { var u = n.getValues(["x0", "y0"], e), d = n.getValues(["x1", "y1"], e), f = a.clampData(u), h = a.clampData(d), p = []; t[0] === "x0" ? p[0] = f[0] > h[0] ? d[0] : u[0] : p[0] = f[0] > h[0] ? u[0] : d[0], t[1] === "y0" ? p[1] = f[1] > h[1] ? d[1] : u[1] : p[1] = f[1] > h[1] ? u[1] : d[1], s = r.getMarkerPosition(p, t, !0) } else { var m = n.get(t[0], e), g = n.get(t[1], e), y = [m, g]; a.clampData && a.clampData(y, y), s = a.dataToPoint(y, !0) } if (cp(a, "cartesian2d")) { var b = a.getAxis("x"), w = a.getAxis("y"), m = n.get(t[0], e), g = n.get(t[1], e); OT(m) ? s[0] = b.toGlobalCoord(b.getExtent()[t[0] === "x0" ? 0 : 1]) : OT(g) && (s[1] = w.toGlobalCoord(w.getExtent()[t[1] === "y0" ? 0 : 1])) } isNaN(l) || (s[0] = l), isNaN(c) || (s[1] = c) } return s } var HG = [["x0", "y0"], ["x1", "y0"], ["x1", "y1"], ["x0", "y1"]], eat = function (n) { te(e, n); function e() { var t = n !== null && n.apply(this, arguments) || this; return t.type = e.type, t } return e.prototype.updateTransform = function (t, r, i) { r.eachSeries(function (a) { var o = Pd.getMarkerModelFromSeries(a, "markArea"); if (o) { var s = o.getData(); s.each(function (l) { var c = Ae(HG, function (d) { return VG(s, l, d, a, i) }); s.setItemLayout(l, c); var u = s.getItemGraphicEl(l); u.setShape("points", c) }) } }, this) }, e.prototype.renderSeries = function (t, r, i, a) { var o = t.coordinateSystem, s = t.id, l = t.getData(), c = this.markerGroupMap, u = c.get(s) || c.set(s, { group: new ft }); this.group.add(u.group), this.markKeep(u); var d = tat(o, t, r); r.setData(d), d.each(function (f) { var h = Ae(HG, function (A) { return VG(d, f, A, t, a) }), p = o.getAxis("x").scale, m = o.getAxis("y").scale, g = p.getExtent(), y = m.getExtent(), b = [p.parse(d.get("x0", f)), p.parse(d.get("x1", f))], w = [m.parse(d.get("y0", f)), m.parse(d.get("y1", f))]; Oo(b), Oo(w); var v = !(g[0] > b[1] || g[1] < b[0] || y[0] > w[1] || y[1] < w[0]), S = !v; d.setItemLayout(f, { points: h, allClipped: S }); var x = d.getItemModel(f).getModel("itemStyle").getItemStyle(), k = Ab(l, "color"); x.fill || (x.fill = k, Fe(x.fill) && (x.fill = G2(x.fill, .4))), x.stroke || (x.stroke = k), d.setItemVisual(f, "style", x) }), d.diff(Tx(u).data).add(function (f) { var h = d.getItemLayout(f); if (!h.allClipped) { var p = new Aa({ shape: { points: h.points } }); d.setItemGraphicEl(f, p), u.group.add(p) } }).update(function (f, h) { var p = Tx(u).data.getItemGraphicEl(h), m = d.getItemLayout(f); m.allClipped ? p && u.group.remove(p) : (p ? on(p, { shape: { points: m.points } }, r, f) : p = new Aa({ shape: { points: m.points } }), d.setItemGraphicEl(f, p), u.group.add(p)) }).remove(function (f) { var h = Tx(u).data.getItemGraphicEl(f); u.group.remove(h) }).execute(), d.eachItemGraphicEl(function (f, h) { var p = d.getItemModel(h), m = d.getItemVisual(h, "style"); f.useStyle(d.getItemVisual(h, "style")), mi(f, Ur(p), { labelFetcher: r, labelDataIndex: h, defaultText: d.getName(h) || "", inheritColor: Fe(m.fill) ? G2(m.fill, 1) : "#000" }), pi(f, p), Qn(f, null, null, p.get(["emphasis", "disabled"])), pt(f).dataModel = r }), Tx(u).data = d, u.group.silent = r.get("silent") || t.get("silent") }, e.type = "markArea", e }(kB); function tat(n, e, t) { var r, i, a = ["x0", "y0", "x1", "y1"]; if (n) { var o = Ae(n && n.dimensions, function (c) { var u = e.getData(), d = u.getDimensionInfo(u.mapDimension(c)) || {}; return be(be({}, d), { name: c, ordinalMeta: null }) }); i = Ae(a, function (c, u) { return { name: c, type: o[u % 2].type } }), r = new Ji(i, t) } else i = [{ name: "value", type: "float" }], r = new Ji(i, t); var s = Ae(t.get("data"), wt(Jit, e, n, t)); n && (s = pn(s, wt(Qit, n))); var l = n ? function (c, u, d, f) { var h = c.coord[Math.floor(f / 2)][f % 2]; return ld(h, i[f]) } : function (c, u, d, f) { return ld(c.value, i[f]) }; return r.initData(s, null, l), r.hasItemOption = !0, r } const nat = eat; function rat(n) { n.registerComponentModel(Xit), n.registerComponentView(nat), n.registerPreprocessor(function (e) { SB(e.series, "markArea") && (e.markArea = e.markArea || {}) }) } var iat = function (n, e) { if (e === "all") return { type: "all", title: n.getLocaleModel().get(["legend", "selector", "all"]) }; if (e === "inverse") return { type: "inverse", title: n.getLocaleModel().get(["legend", "selector", "inverse"]) } }, aat = function (n) { te(e, n); function e() { var t = n !== null && n.apply(this, arguments) || this; return t.type = e.type, t.layoutMode = { type: "box", ignoreSize: !0 }, t } return e.prototype.init = function (t, r, i) { this.mergeDefaultAndTheme(t, i), t.selected = t.selected || {}, this._updateSelector(t) }, e.prototype.mergeOption = function (t, r) { n.prototype.mergeOption.call(this, t, r), this._updateSelector(t) }, e.prototype._updateSelector = function (t) { var r = t.selector, i = this.ecModel; r === !0 && (r = t.selector = ["all", "inverse"]), ke(r) && $(r, function (a, o) { Fe(a) && (a = { type: a }), r[o] = xt(a, iat(i, a.type)) }) }, e.prototype.optionUpdated = function () { this._updateData(this.ecModel); var t = this._data; if (t[0] && this.get("selectedMode") === "single") { for (var r = !1, i = 0; i < t.length; i++) { var a = t[i].get("name"); if (this.isSelected(a)) { this.select(a), r = !0; break } } !r && this.select(t[0].get("name")) } }, e.prototype._updateData = function (t) { var r = [], i = []; t.eachRawSeries(function (l) { var c = l.name; i.push(c); var u; if (l.legendVisualProvider) { var d = l.legendVisualProvider, f = d.getAllNames(); t.isSeriesFiltered(l) || (i = i.concat(f)), f.length ? r = r.concat(f) : u = !0 } else u = !0; u && DN(l) && r.push(l.name) }), this._availableNames = i; var a = this.get("data") || r, o = Ze(), s = Ae(a, function (l) { return (Fe(l) || nn(l)) && (l = { name: l }), o.get(l.name) ? null : (o.set(l.name, !0), new Rn(l, this, this.ecModel)) }, this); this._data = pn(s, function (l) { return !!l }) }, e.prototype.getData = function () { return this._data }, e.prototype.select = function (t) { var r = this.option.selected, i = this.get("selectedMode"); if (i === "single") { var a = this._data; $(a, function (o) { r[o.get("name")] = !1 }) } r[t] = !0 }, e.prototype.unSelect = function (t) { this.get("selectedMode") !== "single" && (this.option.selected[t] = !1) }, e.prototype.toggleSelected = function (t) { var r = this.option.selected; r.hasOwnProperty(t) || (r[t] = !0), this[r[t] ? "unSelect" : "select"](t) }, e.prototype.allSelect = function () { var t = this._data, r = this.option.selected; $(t, function (i) { r[i.get("name", !0)] = !0 }) }, e.prototype.inverseSelect = function () { var t = this._data, r = this.option.selected; $(t, function (i) { var a = i.get("name", !0); r.hasOwnProperty(a) || (r[a] = !0), r[a] = !r[a] }) }, e.prototype.isSelected = function (t) { var r = this.option.selected; return !(r.hasOwnProperty(t) && !r[t]) && Et(this._availableNames, t) >= 0 }, e.prototype.getOrient = function () { return this.get("orient") === "vertical" ? { index: 1, name: "vertical" } : { index: 0, name: "horizontal" } }, e.type = "legend.plain", e.dependencies = ["series"], e.defaultOption = { z: 4, show: !0, orient: "horizontal", left: "center", top: 0, align: "auto", backgroundColor: "rgba(0,0,0,0)", borderColor: "#ccc", borderRadius: 0, borderWidth: 0, padding: 5, itemGap: 10, itemWidth: 25, itemHeight: 14, symbolRotate: "inherit", symbolKeepAspect: !0, inactiveColor: "#ccc", inactiveBorderColor: "#ccc", inactiveBorderWidth: "auto", itemStyle: { color: "inherit", opacity: "inherit", borderColor: "inherit", borderWidth: "auto", borderCap: "inherit", borderJoin: "inherit", borderDashOffset: "inherit", borderMiterLimit: "inherit" }, lineStyle: { width: "auto", color: "inherit", inactiveColor: "#ccc", inactiveWidth: 2, opacity: "inherit", type: "inherit", cap: "inherit", join: "inherit", dashOffset: "inherit", miterLimit: "inherit" }, textStyle: { color: "#333" }, selectedMode: !0, selector: !1, selectorLabel: { show: !0, borderRadius: 10, padding: [3, 5, 3, 5], fontSize: 12, fontFamily: "sans-serif", color: "#666", borderWidth: 1, borderColor: "#666" }, emphasis: { selectorLabel: { show: !0, color: "#eee", backgroundColor: "#666" } }, selectorPosition: "auto", selectorItemGap: 7, selectorButtonGap: 10, tooltip: { show: !1 } }, e }(Jt); const eL = aat; var im = wt, tL = $, kx = ft, oat = function (n) {
  te(e, n); function e() { var t = n !== null && n.apply(this, arguments) || this; return t.type = e.type, t.newlineDisabled = !1, t } return e.prototype.init = function () { this.group.add(this._contentGroup = new kx), this.group.add(this._selectorGroup = new kx), this._isFirstRender = !0 }, e.prototype.getContentGroup = function () { return this._contentGroup }, e.prototype.getSelectorGroup = function () { return this._selectorGroup }, e.prototype.render = function (t, r, i) { var a = this._isFirstRender; if (this._isFirstRender = !1, this.resetInner(), !!t.get("show", !0)) { var o = t.get("align"), s = t.get("orient"); (!o || o === "auto") && (o = t.get("left") === "right" && s === "vertical" ? "right" : "left"); var l = t.get("selector", !0), c = t.get("selectorPosition", !0); l && (!c || c === "auto") && (c = s === "horizontal" ? "end" : "start"), this.renderInner(o, t, r, i, l, s, c); var u = t.getBoxLayoutParams(), d = { width: i.getWidth(), height: i.getHeight() }, f = t.get("padding"), h = jr(u, d, f), p = this.layoutInner(t, o, h, a, l, c), m = jr(rt({ width: p.width, height: p.height }, u), d, f); this.group.x = m.x - p.x, this.group.y = m.y - p.y, this.group.markRedraw(), this.group.add(this._backgroundEl = Uoe(p, t)) } }, e.prototype.resetInner = function () { this.getContentGroup().removeAll(), this._backgroundEl && this.group.remove(this._backgroundEl), this.getSelectorGroup().removeAll() }, e.prototype.renderInner = function (t, r, i, a, o, s, l) {
    var c = this.getContentGroup(), u = Ze(), d = r.get("selectedMode"), f = []; i.eachRawSeries(function (h) { !h.get("legendHoverLink") && f.push(h.id) }), tL(r.getData(), function (h, p) {
      var m = h.get("name"); if (!this.newlineDisabled && (m === "" || m === `
`)) { var g = new kx; g.newline = !0, c.add(g); return } var y = i.getSeriesByName(m)[0]; if (!u.get(m)) if (y) { var b = y.getData(), w = b.getVisual("legendLineStyle") || {}, v = b.getVisual("legendIcon"), S = b.getVisual("style"), x = this._createItem(y, m, p, h, r, t, w, S, v, d, a); x.on("click", im(UG, m, null, a, f)).on("mouseover", im(nL, y.name, null, a, f)).on("mouseout", im(rL, y.name, null, a, f)), i.ssr && x.eachChild(function (k) { var A = pt(k); A.seriesIndex = y.seriesIndex, A.dataIndex = p, A.ssrType = "legend" }), u.set(m, !0) } else i.eachRawSeries(function (k) { if (!u.get(m) && k.legendVisualProvider) { var A = k.legendVisualProvider; if (!A.containName(m)) return; var C = A.indexOfName(m), E = A.getItemVisual(C, "style"), O = A.getItemVisual(C, "legendIcon"), j = Ha(E.fill); j && j[3] === 0 && (j[3] = .2, E = be(be({}, E), { fill: wc(j, "rgba") })); var I = this._createItem(k, m, p, h, r, t, {}, E, O, d, a); I.on("click", im(UG, null, m, a, f)).on("mouseover", im(nL, null, m, a, f)).on("mouseout", im(rL, null, m, a, f)), i.ssr && I.eachChild(function (L) { var R = pt(L); R.seriesIndex = k.seriesIndex, R.dataIndex = p, R.ssrType = "legend" }), u.set(m, !0) } }, this)
    }, this), o && this._createSelector(o, r, a, s, l)
  }, e.prototype._createSelector = function (t, r, i, a, o) { var s = this.getSelectorGroup(); tL(t, function (c) { var u = c.type, d = new tn({ style: { x: 0, y: 0, align: "center", verticalAlign: "middle" }, onclick: function () { i.dispatchAction({ type: u === "all" ? "legendAllSelect" : "legendInverseSelect", legendId: r.id }) } }); s.add(d); var f = r.getModel("selectorLabel"), h = r.getModel(["emphasis", "selectorLabel"]); mi(d, { normal: f, emphasis: h }, { defaultText: c.title }), Th(d) }) }, e.prototype._createItem = function (t, r, i, a, o, s, l, c, u, d, f) { var h = t.visualDrawType, p = o.get("itemWidth"), m = o.get("itemHeight"), g = o.isSelected(r), y = a.get("symbolRotate"), b = a.get("symbolKeepAspect"), w = a.get("icon"); u = w || u || "roundRect"; var v = sat(u, a, l, c, h, g, f), S = new kx, x = a.getModel("textStyle"); if (tt(t.getLegendIcon) && (!w || w === "inherit")) S.add(t.getLegendIcon({ itemWidth: p, itemHeight: m, icon: u, iconRotate: y, itemStyle: v.itemStyle, lineStyle: v.lineStyle, symbolKeepAspect: b })); else { var k = w === "inherit" && t.getData().getVisual("symbol") ? y === "inherit" ? t.getData().getVisual("symbolRotate") : y : 0; S.add(lat({ itemWidth: p, itemHeight: m, icon: u, iconRotate: k, itemStyle: v.itemStyle, lineStyle: v.lineStyle, symbolKeepAspect: b })) } var A = s === "left" ? p + 5 : -5, C = s, E = o.get("formatter"), O = r; Fe(E) && E ? O = E.replace("{name}", r ?? "") : tt(E) && (O = E(r)); var j = g ? x.getTextColor() : a.get("inactiveColor"); S.add(new tn({ style: Ln(x, { text: O, x: A, y: m / 2, fill: j, align: C, verticalAlign: "middle" }, { inheritColor: j }) })); var I = new Yt({ shape: S.getBoundingRect(), style: { fill: "transparent" } }), L = a.getModel("tooltip"); return L.get("show") && ip({ el: I, componentModel: o, itemName: r, itemTooltipOption: L.option }), S.add(I), S.eachChild(function (R) { R.silent = !0 }), I.silent = !d, this.getContentGroup().add(S), Th(S), S.__legendDataIndex = i, S }, e.prototype.layoutInner = function (t, r, i, a, o, s) { var l = this.getContentGroup(), c = this.getSelectorGroup(); Ch(t.get("orient"), l, t.get("itemGap"), i.width, i.height); var u = l.getBoundingRect(), d = [-u.x, -u.y]; if (c.markRedraw(), l.markRedraw(), o) { Ch("horizontal", c, t.get("selectorItemGap", !0)); var f = c.getBoundingRect(), h = [-f.x, -f.y], p = t.get("selectorButtonGap", !0), m = t.getOrient().index, g = m === 0 ? "width" : "height", y = m === 0 ? "height" : "width", b = m === 0 ? "y" : "x"; s === "end" ? h[m] += u[g] + p : d[m] += f[g] + p, h[1 - m] += u[y] / 2 - f[y] / 2, c.x = h[0], c.y = h[1], l.x = d[0], l.y = d[1]; var w = { x: 0, y: 0 }; return w[g] = u[g] + p + f[g], w[y] = Math.max(u[y], f[y]), w[b] = Math.min(0, f[b] + h[1 - m]), w } else return l.x = d[0], l.y = d[1], this.group.getBoundingRect() }, e.prototype.remove = function () { this.getContentGroup().removeAll(), this._isFirstRender = !0 }, e.type = "legend.plain", e
}(nr); function sat(n, e, t, r, i, a, o) { function s(g, y) { g.lineWidth === "auto" && (g.lineWidth = y.lineWidth > 0 ? 2 : 0), tL(g, function (b, w) { g[w] === "inherit" && (g[w] = y[w]) }) } var l = e.getModel("itemStyle"), c = l.getItemStyle(), u = n.lastIndexOf("empty", 0) === 0 ? "fill" : "stroke", d = l.getShallow("decal"); c.decal = !d || d === "inherit" ? r.decal : Ag(d, o), c.fill === "inherit" && (c.fill = r[i]), c.stroke === "inherit" && (c.stroke = r[u]), c.opacity === "inherit" && (c.opacity = (i === "fill" ? r : t).opacity), s(c, r); var f = e.getModel("lineStyle"), h = f.getLineStyle(); if (s(h, t), c.fill === "auto" && (c.fill = r.fill), c.stroke === "auto" && (c.stroke = r.fill), h.stroke === "auto" && (h.stroke = r.fill), !a) { var p = e.get("inactiveBorderWidth"), m = c[u]; c.lineWidth = p === "auto" ? r.lineWidth > 0 && m ? 2 : 0 : c.lineWidth, c.fill = e.get("inactiveColor"), c.stroke = e.get("inactiveBorderColor"), h.stroke = f.get("inactiveColor"), h.lineWidth = f.get("inactiveWidth") } return { itemStyle: c, lineStyle: h } } function lat(n) { var e = n.icon || "roundRect", t = Tr(e, 0, 0, n.itemWidth, n.itemHeight, n.itemStyle.fill, n.symbolKeepAspect); return t.setStyle(n.itemStyle), t.rotation = (n.iconRotate || 0) * Math.PI / 180, t.setOrigin([n.itemWidth / 2, n.itemHeight / 2]), e.indexOf("empty") > -1 && (t.style.stroke = t.style.fill, t.style.fill = "#fff", t.style.lineWidth = 2), t } function UG(n, e, t, r) { rL(n, e, t, r), t.dispatchAction({ type: "legendToggleSelect", name: n ?? e }), nL(n, e, t, r) } function rse(n) { for (var e = n.getZr().storage.getDisplayList(), t, r = 0, i = e.length; r < i && !(t = e[r].states.emphasis);)r++; return t && t.hoverLayer } function nL(n, e, t, r) { rse(t) || t.dispatchAction({ type: "highlight", seriesName: n, name: e, excludeSeriesId: r }) } function rL(n, e, t, r) { rse(t) || t.dispatchAction({ type: "downplay", seriesName: n, name: e, excludeSeriesId: r }) } const ise = oat; function cat(n) { var e = n.findComponents({ mainType: "legend" }); e && e.length && n.filterSeries(function (t) { for (var r = 0; r < e.length; r++)if (!e[r].isSelected(t.name)) return !1; return !0 }) } function fy(n, e, t) { var r = n === "allSelect" || n === "inverseSelect", i = {}, a = []; t.eachComponent({ mainType: "legend", query: e }, function (s) { r ? s[n]() : s[n](e.name), GG(s, i), a.push(s.componentIndex) }); var o = {}; return t.eachComponent("legend", function (s) { $(i, function (l, c) { s[l ? "select" : "unSelect"](c) }), GG(s, o) }), r ? { selected: o, legendIndex: a } : { name: e.name, selected: o } } function GG(n, e) {
  var t = e || {}; return $(n.getData(), function (r) {
    var i = r.get("name"); if (!(i === `
`|| i === "")) { var a = n.isSelected(i); Ge(t, i) ? t[i] = t[i] && a : t[i] = a }
  }), t
} function uat(n) { n.registerAction("legendToggleSelect", "legendselectchanged", wt(fy, "toggleSelected")), n.registerAction("legendAllSelect", "legendselectall", wt(fy, "allSelect")), n.registerAction("legendInverseSelect", "legendinverseselect", wt(fy, "inverseSelect")), n.registerAction("legendSelect", "legendselected", wt(fy, "select")), n.registerAction("legendUnSelect", "legendunselected", wt(fy, "unSelect")) } function ase(n) { n.registerComponentModel(eL), n.registerComponentView(ise), n.registerProcessor(n.PRIORITY.PROCESSOR.SERIES_FILTER, cat), n.registerSubTypeDefaulter("legend", function () { return "plain" }), uat(n) } var dat = function (n) { te(e, n); function e() { var t = n !== null && n.apply(this, arguments) || this; return t.type = e.type, t } return e.prototype.setScrollDataIndex = function (t) { this.option.scrollDataIndex = t }, e.prototype.init = function (t, r, i) { var a = tv(t); n.prototype.init.call(this, t, r, i), WG(this, t, a) }, e.prototype.mergeOption = function (t, r) { n.prototype.mergeOption.call(this, t, r), WG(this, this.option, t) }, e.type = "legend.scroll", e.defaultOption = Wd(eL.defaultOption, { scrollDataIndex: 0, pageButtonItemGap: 5, pageButtonGap: null, pageButtonPosition: "end", pageFormatter: "{current}/{total}", pageIcons: { horizontal: ["M0,0L12,-10L12,10z", "M0,0L-12,-10L-12,10z"], vertical: ["M0,0L20,0L10,-20z", "M0,0L20,0L10,20z"] }, pageIconColor: "#2f4554", pageIconInactiveColor: "#aaa", pageIconSize: 15, pageTextStyle: { color: "#333" }, animationDurationUpdate: 800 }), e }(eL); function WG(n, e, t) { var r = n.getOrient(), i = [1, 1]; i[r.index] = 0, Ed(e, t, { type: "box", ignoreSize: !!i }) } const fat = dat; var KG = ft, vD = ["width", "height"], yD = ["x", "y"], hat = function (n) { te(e, n); function e() { var t = n !== null && n.apply(this, arguments) || this; return t.type = e.type, t.newlineDisabled = !0, t._currentIndex = 0, t } return e.prototype.init = function () { n.prototype.init.call(this), this.group.add(this._containerGroup = new KG), this._containerGroup.add(this.getContentGroup()), this.group.add(this._controllerGroup = new KG) }, e.prototype.resetInner = function () { n.prototype.resetInner.call(this), this._controllerGroup.removeAll(), this._containerGroup.removeClipPath(), this._containerGroup.__rectSize = null }, e.prototype.renderInner = function (t, r, i, a, o, s, l) { var c = this; n.prototype.renderInner.call(this, t, r, i, a, o, s, l); var u = this._controllerGroup, d = r.get("pageIconSize", !0), f = ke(d) ? d : [d, d]; p("pagePrev", 0); var h = r.getModel("pageTextStyle"); u.add(new tn({ name: "pageText", style: { text: "xx/xx", fill: h.getTextColor(), font: h.getFont(), verticalAlign: "middle", align: "center" }, silent: !0 })), p("pageNext", 1); function p(m, g) { var y = m + "DataIndex", b = kb(r.get("pageIcons", !0)[r.getOrient().name][g], { onclick: He(c._pageGo, c, y, r, a) }, { x: -f[0] / 2, y: -f[1] / 2, width: f[0], height: f[1] }); b.name = m, u.add(b) } }, e.prototype.layoutInner = function (t, r, i, a, o, s) { var l = this.getSelectorGroup(), c = t.getOrient().index, u = vD[c], d = yD[c], f = vD[1 - c], h = yD[1 - c]; o && Ch("horizontal", l, t.get("selectorItemGap", !0)); var p = t.get("selectorButtonGap", !0), m = l.getBoundingRect(), g = [-m.x, -m.y], y = lt(i); o && (y[u] = i[u] - m[u] - p); var b = this._layoutContentAndController(t, a, y, c, u, f, h, d); if (o) { if (s === "end") g[c] += b[u] + p; else { var w = m[u] + p; g[c] -= w, b[d] -= w } b[u] += m[u] + p, g[1 - c] += b[h] + b[f] / 2 - m[f] / 2, b[f] = Math.max(b[f], m[f]), b[h] = Math.min(b[h], m[h] + g[1 - c]), l.x = g[0], l.y = g[1], l.markRedraw() } return b }, e.prototype._layoutContentAndController = function (t, r, i, a, o, s, l, c) { var u = this.getContentGroup(), d = this._containerGroup, f = this._controllerGroup; Ch(t.get("orient"), u, t.get("itemGap"), a ? i.width : null, a ? null : i.height), Ch("horizontal", f, t.get("pageButtonItemGap", !0)); var h = u.getBoundingRect(), p = f.getBoundingRect(), m = this._showController = h[o] > i[o], g = [-h.x, -h.y]; r || (g[a] = u[c]); var y = [0, 0], b = [-p.x, -p.y], w = yt(t.get("pageButtonGap", !0), t.get("itemGap", !0)); if (m) { var v = t.get("pageButtonPosition", !0); v === "end" ? b[a] += i[o] - p[o] : y[a] += p[o] + w } b[1 - a] += h[s] / 2 - p[s] / 2, u.setPosition(g), d.setPosition(y), f.setPosition(b); var S = { x: 0, y: 0 }; if (S[o] = m ? i[o] : h[o], S[s] = Math.max(h[s], p[s]), S[l] = Math.min(0, p[l] + b[1 - a]), d.__rectSize = i[o], m) { var x = { x: 0, y: 0 }; x[o] = Math.max(i[o] - p[o] - w, 0), x[s] = S[s], d.setClipPath(new Yt({ shape: x })), d.__rectSize = x[o] } else f.eachChild(function (A) { A.attr({ invisible: !0, silent: !0 }) }); var k = this._getPageInfo(t); return k.pageIndex != null && on(u, { x: k.contentPosition[0], y: k.contentPosition[1] }, m ? t : null), this._updatePageInfoView(t, k), S }, e.prototype._pageGo = function (t, r, i) { var a = this._getPageInfo(r)[t]; a != null && i.dispatchAction({ type: "legendScroll", scrollDataIndex: a, legendId: r.id }) }, e.prototype._updatePageInfoView = function (t, r) { var i = this._controllerGroup; $(["pagePrev", "pageNext"], function (u) { var d = u + "DataIndex", f = r[d] != null, h = i.childOfName(u); h && (h.setStyle("fill", f ? t.get("pageIconColor", !0) : t.get("pageIconInactiveColor", !0)), h.cursor = f ? "pointer" : "default") }); var a = i.childOfName("pageText"), o = t.get("pageFormatter"), s = r.pageIndex, l = s != null ? s + 1 : 0, c = r.pageCount; a && o && a.setStyle("text", Fe(o) ? o.replace("{current}", l == null ? "" : l + "").replace("{total}", c == null ? "" : c + "") : o({ current: l, total: c })) }, e.prototype._getPageInfo = function (t) { var r = t.get("scrollDataIndex", !0), i = this.getContentGroup(), a = this._containerGroup.__rectSize, o = t.getOrient().index, s = vD[o], l = yD[o], c = this._findTargetItemIndex(r), u = i.children(), d = u[c], f = u.length, h = f ? 1 : 0, p = { contentPosition: [i.x, i.y], pageCount: h, pageIndex: h - 1, pagePrevDataIndex: null, pageNextDataIndex: null }; if (!d) return p; var m = v(d); p.contentPosition[o] = -m.s; for (var g = c + 1, y = m, b = m, w = null; g <= f; ++g)w = v(u[g]), (!w && b.e > y.s + a || w && !S(w, y.s)) && (b.i > y.i ? y = b : y = w, y && (p.pageNextDataIndex == null && (p.pageNextDataIndex = y.i), ++p.pageCount)), b = w; for (var g = c - 1, y = m, b = m, w = null; g >= -1; --g)w = v(u[g]), (!w || !S(b, w.s)) && y.i < b.i && (b = y, p.pagePrevDataIndex == null && (p.pagePrevDataIndex = y.i), ++p.pageCount, ++p.pageIndex), y = w; return p; function v(x) { if (x) { var k = x.getBoundingRect(), A = k[l] + x[l]; return { s: A, e: A + k[s], i: x.__legendDataIndex } } } function S(x, k) { return x.e >= k && x.s <= k + a } }, e.prototype._findTargetItemIndex = function (t) { if (!this._showController) return 0; var r, i = this.getContentGroup(), a; return i.eachChild(function (o, s) { var l = o.__legendDataIndex; a == null && l != null && (a = s), l === t && (r = s) }), r ?? a }, e.type = "legend.scroll", e }(ise); const pat = hat; function mat(n) { n.registerAction("legendScroll", "legendscroll", function (e, t) { var r = e.scrollDataIndex; r != null && t.eachComponent({ mainType: "legend", subType: "scroll", query: e }, function (i) { i.setScrollDataIndex(r) }) }) } function gat(n) { It(ase), n.registerComponentModel(fat), n.registerComponentView(pat), mat(n) } function vat(n) { It(ase), It(gat) } var yat = function (n) { te(e, n); function e() { var t = n !== null && n.apply(this, arguments) || this; return t.type = e.type, t } return e.type = "dataZoom.inside", e.defaultOption = Wd(L_.defaultOption, { disabled: !1, zoomLock: !1, zoomOnMouseWheel: !0, moveOnMouseMove: !0, moveOnMouseWheel: !1, preventDefaultMouseMove: !0 }), e }(L_); const _at = yat; var CB = Kt(); function bat(n, e, t) { CB(n).coordSysRecordMap.each(function (r) { var i = r.dataZoomInfoMap.get(e.uid); i && (i.getRange = t) }) } function wat(n, e) { for (var t = CB(n).coordSysRecordMap, r = t.keys(), i = 0; i < r.length; i++) { var a = r[i], o = t.get(a), s = o.dataZoomInfoMap; if (s) { var l = e.uid, c = s.get(l); c && (s.removeKey(l), s.keys().length || ose(t, o)) } } } function ose(n, e) { if (e) { n.removeKey(e.model.uid); var t = e.controller; t && t.dispose() } } function xat(n, e) { var t = { model: e, containsPoint: wt(Tat, e), dispatchAction: wt(Sat, n), dataZoomInfoMap: null, controller: null }, r = t.controller = new Rb(n.getZr()); return $(["pan", "zoom", "scrollMove"], function (i) { r.on(i, function (a) { var o = []; t.dataZoomInfoMap.each(function (s) { if (a.isAvailableBehavior(s.model.option)) { var l = (s.getRange || {})[i], c = l && l(s.dzReferCoordSysInfo, t.model.mainType, t.controller, a); !s.model.get("disabled", !0) && c && o.push({ dataZoomId: s.model.id, start: c[0], end: c[1] }) } }), o.length && t.dispatchAction(o) }) }), t } function Sat(n, e) { n.isDisposed() || n.dispatchAction({ type: "dataZoom", animation: { easing: "cubicOut", duration: 100 }, batch: e }) } function Tat(n, e, t, r) { return n.coordinateSystem.containPoint([t, r]) } function kat(n) { var e, t = "type_", r = { type_true: 2, type_move: 1, type_false: 0, type_undefined: -1 }, i = !0; return n.each(function (a) { var o = a.model, s = o.get("disabled", !0) ? !1 : o.get("zoomLock", !0) ? "move" : !0; r[t + s] > r[t + e] && (e = s), i = i && o.get("preventDefaultMouseMove", !0) }), { controlType: e, opt: { zoomOnMouseWheel: !0, moveOnMouseMove: !0, moveOnMouseWheel: !0, preventDefaultMouseMove: !!i } } } function Cat(n) { n.registerProcessor(n.PRIORITY.PROCESSOR.FILTER, function (e, t) { var r = CB(t), i = r.coordSysRecordMap || (r.coordSysRecordMap = Ze()); i.each(function (a) { a.dataZoomInfoMap = null }), e.eachComponent({ mainType: "dataZoom", subType: "inside" }, function (a) { var o = zoe(a); $(o.infoList, function (s) { var l = s.model.uid, c = i.get(l) || i.set(l, xat(t, s.model)), u = c.dataZoomInfoMap || (c.dataZoomInfoMap = Ze()); u.set(a.uid, { dzReferCoordSysInfo: s, model: a, getRange: null }) }) }), i.each(function (a) { var o = a.controller, s, l = a.dataZoomInfoMap; if (l) { var c = l.keys()[0]; c != null && (s = l.get(c)) } if (!s) { ose(i, a); return } var u = kat(l); o.enable(u.controlType, u.opt), o.setPointerChecker(a.containsPoint), av(a, "dispatchAction", s.model.get("throttle", !0), "fixRate") }) }) } var Aat = function (n) { te(e, n); function e() { var t = n !== null && n.apply(this, arguments) || this; return t.type = "dataZoom.inside", t } return e.prototype.render = function (t, r, i) { if (n.prototype.render.apply(this, arguments), t.noTarget()) { this._clear(); return } this.range = t.getPercentRange(), bat(i, t, { pan: He(_D.pan, this), zoom: He(_D.zoom, this), scrollMove: He(_D.scrollMove, this) }) }, e.prototype.dispose = function () { this._clear(), n.prototype.dispose.apply(this, arguments) }, e.prototype._clear = function () { wat(this.api, this.dataZoomModel), this.range = null }, e.type = "dataZoom.inside", e }(vB), _D = { zoom: function (n, e, t, r) { var i = this.range, a = i.slice(), o = n.axisModels[0]; if (o) { var s = bD[e](null, [r.originX, r.originY], o, t, n), l = (s.signal > 0 ? s.pixelStart + s.pixelLength - s.pixel : s.pixel - s.pixelStart) / s.pixelLength * (a[1] - a[0]) + a[0], c = Math.max(1 / r.scale, 0); a[0] = (a[0] - l) * c + l, a[1] = (a[1] - l) * c + l; var u = this.dataZoomModel.findRepresentativeAxisProxy().getMinMaxSpan(); if (dp(0, a, [0, 100], 0, u.minSpan, u.maxSpan), this.range = a, i[0] !== a[0] || i[1] !== a[1]) return a } }, pan: qG(function (n, e, t, r, i, a) { var o = bD[r]([a.oldX, a.oldY], [a.newX, a.newY], e, i, t); return o.signal * (n[1] - n[0]) * o.pixel / o.pixelLength }), scrollMove: qG(function (n, e, t, r, i, a) { var o = bD[r]([0, 0], [a.scrollDelta, a.scrollDelta], e, i, t); return o.signal * (n[1] - n[0]) * a.scrollDelta }) }; function qG(n) { return function (e, t, r, i) { var a = this.range, o = a.slice(), s = e.axisModels[0]; if (s) { var l = n(o, s, e, t, r, i); if (dp(l, o, [0, 100], "all"), this.range = o, a[0] !== o[0] || a[1] !== o[1]) return o } } } var bD = { grid: function (n, e, t, r, i) { var a = t.axis, o = {}, s = i.model.coordinateSystem.getRect(); return n = n || [0, 0], a.dim === "x" ? (o.pixel = e[0] - n[0], o.pixelLength = s.width, o.pixelStart = s.x, o.signal = a.inverse ? 1 : -1) : (o.pixel = e[1] - n[1], o.pixelLength = s.height, o.pixelStart = s.y, o.signal = a.inverse ? -1 : 1), o }, polar: function (n, e, t, r, i) { var a = t.axis, o = {}, s = i.model.coordinateSystem, l = s.getRadiusAxis().getExtent(), c = s.getAngleAxis().getExtent(); return n = n ? s.pointToCoord(n) : [0, 0], e = s.pointToCoord(e), t.mainType === "radiusAxis" ? (o.pixel = e[0] - n[0], o.pixelLength = l[1] - l[0], o.pixelStart = l[0], o.signal = a.inverse ? 1 : -1) : (o.pixel = e[1] - n[1], o.pixelLength = c[1] - c[0], o.pixelStart = c[0], o.signal = a.inverse ? -1 : 1), o }, singleAxis: function (n, e, t, r, i) { var a = t.axis, o = i.model.coordinateSystem.getRect(), s = {}; return n = n || [0, 0], a.orient === "horizontal" ? (s.pixel = e[0] - n[0], s.pixelLength = o.width, s.pixelStart = o.x, s.signal = a.inverse ? 1 : -1) : (s.pixel = e[1] - n[1], s.pixelLength = o.height, s.pixelStart = o.y, s.signal = a.inverse ? -1 : 1), s } }; const Eat = Aat; function sse(n) { yB(n), n.registerComponentModel(_at), n.registerComponentView(Eat), Cat(n) } var Mat = function (n) { te(e, n); function e() { var t = n !== null && n.apply(this, arguments) || this; return t.type = e.type, t } return e.type = "dataZoom.slider", e.layoutMode = "box", e.defaultOption = Wd(L_.defaultOption, { show: !0, right: "ph", top: "ph", width: "ph", height: "ph", left: null, bottom: null, borderColor: "#d2dbee", borderRadius: 3, backgroundColor: "rgba(47,69,84,0)", dataBackground: { lineStyle: { color: "#d2dbee", width: .5 }, areaStyle: { color: "#d2dbee", opacity: .2 } }, selectedDataBackground: { lineStyle: { color: "#8fb0f7", width: .5 }, areaStyle: { color: "#8fb0f7", opacity: .2 } }, fillerColor: "rgba(135,175,274,0.2)", handleIcon: "path://M-9.35,34.56V42m0-40V9.5m-2,0h4a2,2,0,0,1,2,2v21a2,2,0,0,1-2,2h-4a2,2,0,0,1-2-2v-21A2,2,0,0,1-11.35,9.5Z", handleSize: "100%", handleStyle: { color: "#fff", borderColor: "#ACB8D1" }, moveHandleSize: 7, moveHandleIcon: "path://M-320.9-50L-320.9-50c18.1,0,27.1,9,27.1,27.1V85.7c0,18.1-9,27.1-27.1,27.1l0,0c-18.1,0-27.1-9-27.1-27.1V-22.9C-348-41-339-50-320.9-50z M-212.3-50L-212.3-50c18.1,0,27.1,9,27.1,27.1V85.7c0,18.1-9,27.1-27.1,27.1l0,0c-18.1,0-27.1-9-27.1-27.1V-22.9C-239.4-41-230.4-50-212.3-50z M-103.7-50L-103.7-50c18.1,0,27.1,9,27.1,27.1V85.7c0,18.1-9,27.1-27.1,27.1l0,0c-18.1,0-27.1-9-27.1-27.1V-22.9C-130.9-41-121.8-50-103.7-50z", moveHandleStyle: { color: "#D2DBEE", opacity: .7 }, showDetail: !0, showDataShadow: "auto", realtime: !0, zoomLock: !1, textStyle: { color: "#6E7079" }, brushSelect: !0, brushStyle: { color: "rgba(135,175,274,0.15)" }, emphasis: { handleLabel: { show: !0 }, handleStyle: { borderColor: "#8FB0F7" }, moveHandleStyle: { color: "#8FB0F7" } } }), e }(L_); const Oat = Mat; var hy = Yt, YG = 7, Dat = 1, wD = 30, jat = 7, py = "horizontal", ZG = "vertical", Pat = 5, Iat = ["line", "bar", "candlestick", "scatter"], Lat = { easing: "cubicOut", duration: 100, delay: 0 }, Rat = function (n) { te(e, n); function e() { var t = n !== null && n.apply(this, arguments) || this; return t.type = e.type, t._displayables = {}, t } return e.prototype.init = function (t, r) { this.api = r, this._onBrush = He(this._onBrush, this), this._onBrushEnd = He(this._onBrushEnd, this) }, e.prototype.render = function (t, r, i, a) { if (n.prototype.render.apply(this, arguments), av(this, "_dispatchZoomAction", t.get("throttle"), "fixRate"), this._orient = t.getOrient(), t.get("show") === !1) { this.group.removeAll(); return } if (t.noTarget()) { this._clear(), this.group.removeAll(); return } (!a || a.type !== "dataZoom" || a.from !== this.uid) && this._buildView(), this._updateView() }, e.prototype.dispose = function () { this._clear(), n.prototype.dispose.apply(this, arguments) }, e.prototype._clear = function () { S_(this, "_dispatchZoomAction"); var t = this.api.getZr(); t.off("mousemove", this._onBrush), t.off("mouseup", this._onBrushEnd) }, e.prototype._buildView = function () { var t = this.group; t.removeAll(), this._brushing = !1, this._displayables.brushRect = null, this._resetLocation(), this._resetInterval(); var r = this._displayables.sliderGroup = new ft; this._renderBackground(), this._renderHandle(), this._renderDataShadow(), t.add(r), this._positionGroup() }, e.prototype._resetLocation = function () { var t = this.dataZoomModel, r = this.api, i = t.get("brushSelect"), a = i ? jat : 0, o = this._findCoordRect(), s = { width: r.getWidth(), height: r.getHeight() }, l = this._orient === py ? { right: s.width - o.x - o.width, top: s.height - wD - YG - a, width: o.width, height: wD } : { right: YG, top: o.y, width: wD, height: o.height }, c = tv(t.option); $(["right", "top", "width", "height"], function (d) { c[d] === "ph" && (c[d] = l[d]) }); var u = jr(c, s); this._location = { x: u.x, y: u.y }, this._size = [u.width, u.height], this._orient === ZG && this._size.reverse() }, e.prototype._positionGroup = function () { var t = this.group, r = this._location, i = this._orient, a = this.dataZoomModel.getFirstTargetAxisModel(), o = a && a.get("inverse"), s = this._displayables.sliderGroup, l = (this._dataShadowInfo || {}).otherAxisInverse; s.attr(i === py && !o ? { scaleY: l ? 1 : -1, scaleX: 1 } : i === py && o ? { scaleY: l ? 1 : -1, scaleX: -1 } : i === ZG && !o ? { scaleY: l ? -1 : 1, scaleX: 1, rotation: Math.PI / 2 } : { scaleY: l ? -1 : 1, scaleX: -1, rotation: Math.PI / 2 }); var c = t.getBoundingRect([s]); t.x = r.x - c.x, t.y = r.y - c.y, t.markRedraw() }, e.prototype._getViewExtent = function () { return [0, this._size[0]] }, e.prototype._renderBackground = function () { var t = this.dataZoomModel, r = this._size, i = this._displayables.sliderGroup, a = t.get("brushSelect"); i.add(new hy({ silent: !0, shape: { x: 0, y: 0, width: r[0], height: r[1] }, style: { fill: t.get("backgroundColor") }, z2: -40 })); var o = new hy({ shape: { x: 0, y: 0, width: r[0], height: r[1] }, style: { fill: "transparent" }, z2: 0, onclick: He(this._onClickPanel, this) }), s = this.api.getZr(); a ? (o.on("mousedown", this._onBrushStart, this), o.cursor = "crosshair", s.on("mousemove", this._onBrush), s.on("mouseup", this._onBrushEnd)) : (s.off("mousemove", this._onBrush), s.off("mouseup", this._onBrushEnd)), i.add(o) }, e.prototype._renderDataShadow = function () { var t = this._dataShadowInfo = this._prepareDataShadowInfo(); if (this._displayables.dataShadowSegs = [], !t) return; var r = this._size, i = this._shadowSize || [], a = t.series, o = a.getRawData(), s = a.getShadowDim && a.getShadowDim(), l = s && o.getDimensionInfo(s) ? a.getShadowDim() : t.otherDim; if (l == null) return; var c = this._shadowPolygonPts, u = this._shadowPolylinePts; if (o !== this._shadowData || l !== this._shadowDim || r[0] !== i[0] || r[1] !== i[1]) { var d = o.getDataExtent(l), f = (d[1] - d[0]) * .3; d = [d[0] - f, d[1] + f]; var h = [0, r[1]], p = [0, r[0]], m = [[r[0], 0], [0, 0]], g = [], y = p[1] / (o.count() - 1), b = 0, w = Math.round(o.count() / r[0]), v; o.each([l], function (C, E) { if (w > 0 && E % w) { b += y; return } var O = C == null || isNaN(C) || C === "", j = O ? 0 : vn(C, d, h, !0); O && !v && E ? (m.push([m[m.length - 1][0], 0]), g.push([g[g.length - 1][0], 0])) : !O && v && (m.push([b, 0]), g.push([b, 0])), m.push([b, j]), g.push([b, j]), b += y, v = O }), c = this._shadowPolygonPts = m, u = this._shadowPolylinePts = g } this._shadowData = o, this._shadowDim = l, this._shadowSize = [r[0], r[1]]; var S = this.dataZoomModel; function x(C) { var E = S.getModel(C ? "selectedDataBackground" : "dataBackground"), O = new ft, j = new Aa({ shape: { points: c }, segmentIgnoreThreshold: 1, style: E.getModel("areaStyle").getAreaStyle(), silent: !0, z2: -20 }), I = new Ea({ shape: { points: u }, segmentIgnoreThreshold: 1, style: E.getModel("lineStyle").getLineStyle(), silent: !0, z2: -19 }); return O.add(j), O.add(I), O } for (var k = 0; k < 3; k++) { var A = x(k === 1); this._displayables.sliderGroup.add(A), this._displayables.dataShadowSegs.push(A) } }, e.prototype._prepareDataShadowInfo = function () { var t = this.dataZoomModel, r = t.get("showDataShadow"); if (r !== !1) { var i, a = this.ecModel; return t.eachTargetAxis(function (o, s) { var l = t.getAxisProxy(o, s).getTargetSeriesModels(); $(l, function (c) { if (!i && !(r !== !0 && Et(Iat, c.get("type")) < 0)) { var u = a.getComponent(Xu(o), s).axis, d = Nat(o), f, h = c.coordinateSystem; d != null && h.getOtherAxis && (f = h.getOtherAxis(u).inverse), d = c.getData().mapDimension(d), i = { thisAxis: u, series: c, thisDim: o, otherDim: d, otherAxisInverse: f } } }, this) }, this), i } }, e.prototype._renderHandle = function () { var t = this.group, r = this._displayables, i = r.handles = [null, null], a = r.handleLabels = [null, null], o = this._displayables.sliderGroup, s = this._size, l = this.dataZoomModel, c = this.api, u = l.get("borderRadius") || 0, d = l.get("brushSelect"), f = r.filler = new hy({ silent: d, style: { fill: l.get("fillerColor") }, textConfig: { position: "inside" } }); o.add(f), o.add(new hy({ silent: !0, subPixelOptimize: !0, shape: { x: 0, y: 0, width: s[0], height: s[1], r: u }, style: { stroke: l.get("dataBackgroundColor") || l.get("borderColor"), lineWidth: Dat, fill: "rgba(0,0,0,0)" } })), $([0, 1], function (w) { var v = l.get("handleIcon"); !oT[v] && v.indexOf("path://") < 0 && v.indexOf("image://") < 0 && (v = "path://" + v); var S = Tr(v, -1, 0, 2, 2, null, !0); S.attr({ cursor: XG(this._orient), draggable: !0, drift: He(this._onDragMove, this, w), ondragend: He(this._onDragEnd, this), onmouseover: He(this._showDataInfo, this, !0), onmouseout: He(this._showDataInfo, this, !1), z2: 5 }); var x = S.getBoundingRect(), k = l.get("handleSize"); this._handleHeight = Ne(k, this._size[1]), this._handleWidth = x.width / x.height * this._handleHeight, S.setStyle(l.getModel("handleStyle").getItemStyle()), S.style.strokeNoScale = !0, S.rectHover = !0, S.ensureState("emphasis").style = l.getModel(["emphasis", "handleStyle"]).getItemStyle(), Th(S); var A = l.get("handleColor"); A != null && (S.style.fill = A), o.add(i[w] = S); var C = l.getModel("textStyle"), E = l.get("handleLabel") || {}, O = E.show || !1; t.add(a[w] = new tn({ silent: !0, invisible: !O, style: Ln(C, { x: 0, y: 0, text: "", verticalAlign: "middle", align: "center", fill: C.getTextColor(), font: C.getFont() }), z2: 10 })) }, this); var h = f; if (d) { var p = Ne(l.get("moveHandleSize"), s[1]), m = r.moveHandle = new Yt({ style: l.getModel("moveHandleStyle").getItemStyle(), silent: !0, shape: { r: [0, 0, 2, 2], y: s[1] - .5, height: p } }), g = p * .8, y = r.moveHandleIcon = Tr(l.get("moveHandleIcon"), -g / 2, -g / 2, g, g, "#fff", !0); y.silent = !0, y.y = s[1] + p / 2 - .5, m.ensureState("emphasis").style = l.getModel(["emphasis", "moveHandleStyle"]).getItemStyle(); var b = Math.min(s[1] / 2, Math.max(p, 10)); h = r.moveZone = new Yt({ invisible: !0, shape: { y: s[1] - b, height: p + b } }), h.on("mouseover", function () { c.enterEmphasis(m) }).on("mouseout", function () { c.leaveEmphasis(m) }), o.add(m), o.add(y), o.add(h) } h.attr({ draggable: !0, cursor: XG(this._orient), drift: He(this._onDragMove, this, "all"), ondragstart: He(this._showDataInfo, this, !0), ondragend: He(this._onDragEnd, this), onmouseover: He(this._showDataInfo, this, !0), onmouseout: He(this._showDataInfo, this, !1) }) }, e.prototype._resetInterval = function () { var t = this._range = this.dataZoomModel.getPercentRange(), r = this._getViewExtent(); this._handleEnds = [vn(t[0], [0, 100], r, !0), vn(t[1], [0, 100], r, !0)] }, e.prototype._updateInterval = function (t, r) { var i = this.dataZoomModel, a = this._handleEnds, o = this._getViewExtent(), s = i.findRepresentativeAxisProxy().getMinMaxSpan(), l = [0, 100]; dp(r, a, o, i.get("zoomLock") ? "all" : t, s.minSpan != null ? vn(s.minSpan, l, o, !0) : null, s.maxSpan != null ? vn(s.maxSpan, l, o, !0) : null); var c = this._range, u = this._range = Oo([vn(a[0], o, l, !0), vn(a[1], o, l, !0)]); return !c || c[0] !== u[0] || c[1] !== u[1] }, e.prototype._updateView = function (t) { var r = this._displayables, i = this._handleEnds, a = Oo(i.slice()), o = this._size; $([0, 1], function (h) { var p = r.handles[h], m = this._handleHeight; p.attr({ scaleX: m / 2, scaleY: m / 2, x: i[h] + (h ? -1 : 1), y: o[1] / 2 - m / 2 }) }, this), r.filler.setShape({ x: a[0], y: 0, width: a[1] - a[0], height: o[1] }); var s = { x: a[0], width: a[1] - a[0] }; r.moveHandle && (r.moveHandle.setShape(s), r.moveZone.setShape(s), r.moveZone.getBoundingRect(), r.moveHandleIcon && r.moveHandleIcon.attr("x", s.x + s.width / 2)); for (var l = r.dataShadowSegs, c = [0, a[0], a[1], o[0]], u = 0; u < l.length; u++) { var d = l[u], f = d.getClipPath(); f || (f = new Yt, d.setClipPath(f)), f.setShape({ x: c[u], y: 0, width: c[u + 1] - c[u], height: o[1] }) } this._updateDataInfo(t) }, e.prototype._updateDataInfo = function (t) { var r = this.dataZoomModel, i = this._displayables, a = i.handleLabels, o = this._orient, s = ["", ""]; if (r.get("showDetail")) { var l = r.findRepresentativeAxisProxy(); if (l) { var c = l.getAxisModel().axis, u = this._range, d = t ? l.calculateDataWindow({ start: u[0], end: u[1] }).valueWindow : l.getDataValueWindow(); s = [this._formatLabel(d[0], c), this._formatLabel(d[1], c)] } } var f = Oo(this._handleEnds.slice()); h.call(this, 0), h.call(this, 1); function h(p) { var m = kh(i.handles[p].parent, this.group), g = oC(p === 0 ? "right" : "left", m), y = this._handleWidth / 2 + Pat, b = bs([f[p] + (p === 0 ? -y : y), this._size[1] / 2], m); a[p].setStyle({ x: b[0], y: b[1], verticalAlign: o === py ? "middle" : g, align: o === py ? g : "center", text: s[p] }) } }, e.prototype._formatLabel = function (t, r) { var i = this.dataZoomModel, a = i.get("labelFormatter"), o = i.get("labelPrecision"); (o == null || o === "auto") && (o = r.getPixelPrecision()); var s = t == null || isNaN(t) ? "" : r.type === "category" || r.type === "time" ? r.scale.getLabel({ value: Math.round(t) }) : t.toFixed(Math.min(o, 20)); return tt(a) ? a(t, s) : Fe(a) ? a.replace("{value}", s) : s }, e.prototype._showDataInfo = function (t) { var r = this.dataZoomModel.get("handleLabel") || {}, i = r.show || !1, a = this.dataZoomModel.getModel(["emphasis", "handleLabel"]), o = a.get("show") || !1, s = t || this._dragging ? o : i, l = this._displayables, c = l.handleLabels; c[0].attr("invisible", !s), c[1].attr("invisible", !s), l.moveHandle && this.api[s ? "enterEmphasis" : "leaveEmphasis"](l.moveHandle, 1) }, e.prototype._onDragMove = function (t, r, i, a) { this._dragging = !0, Dc(a.event); var o = this._displayables.sliderGroup.getLocalTransform(), s = bs([r, i], o, !0), l = this._updateInterval(t, s[0]), c = this.dataZoomModel.get("realtime"); this._updateView(!c), l && c && this._dispatchZoomAction(!0) }, e.prototype._onDragEnd = function () { this._dragging = !1, this._showDataInfo(!1); var t = this.dataZoomModel.get("realtime"); !t && this._dispatchZoomAction(!1) }, e.prototype._onClickPanel = function (t) { var r = this._size, i = this._displayables.sliderGroup.transformCoordToLocal(t.offsetX, t.offsetY); if (!(i[0] < 0 || i[0] > r[0] || i[1] < 0 || i[1] > r[1])) { var a = this._handleEnds, o = (a[0] + a[1]) / 2, s = this._updateInterval("all", i[0] - o); this._updateView(), s && this._dispatchZoomAction(!1) } }, e.prototype._onBrushStart = function (t) { var r = t.offsetX, i = t.offsetY; this._brushStart = new St(r, i), this._brushing = !0, this._brushStartTime = +new Date }, e.prototype._onBrushEnd = function (t) { if (this._brushing) { var r = this._displayables.brushRect; if (this._brushing = !1, !!r) { r.attr("ignore", !0); var i = r.shape, a = +new Date; if (!(a - this._brushStartTime < 200 && Math.abs(i.width) < 5)) { var o = this._getViewExtent(), s = [0, 100]; this._range = Oo([vn(i.x, o, s, !0), vn(i.x + i.width, o, s, !0)]), this._handleEnds = [i.x, i.x + i.width], this._updateView(), this._dispatchZoomAction(!1) } } } }, e.prototype._onBrush = function (t) { this._brushing && (Dc(t.event), this._updateBrushRect(t.offsetX, t.offsetY)) }, e.prototype._updateBrushRect = function (t, r) { var i = this._displayables, a = this.dataZoomModel, o = i.brushRect; o || (o = i.brushRect = new hy({ silent: !0, style: a.getModel("brushStyle").getItemStyle() }), i.sliderGroup.add(o)), o.attr("ignore", !1); var s = this._brushStart, l = this._displayables.sliderGroup, c = l.transformCoordToLocal(t, r), u = l.transformCoordToLocal(s.x, s.y), d = this._size; c[0] = Math.max(Math.min(d[0], c[0]), 0), o.setShape({ x: u[0], y: 0, width: c[0] - u[0], height: d[1] }) }, e.prototype._dispatchZoomAction = function (t) { var r = this._range; this.api.dispatchAction({ type: "dataZoom", from: this.uid, dataZoomId: this.dataZoomModel.id, animation: t ? Lat : null, start: r[0], end: r[1] }) }, e.prototype._findCoordRect = function () { var t, r = zoe(this.dataZoomModel).infoList; if (!t && r.length) { var i = r[0].model.coordinateSystem; t = i.getRect && i.getRect() } if (!t) { var a = this.api.getWidth(), o = this.api.getHeight(); t = { x: a * .2, y: o * .2, width: a * .6, height: o * .6 } } return t }, e.type = "dataZoom.slider", e }(vB); function Nat(n) { var e = { x: "y", y: "x", radius: "angle", angle: "radius" }; return e[n] } function XG(n) { return n === "vertical" ? "ns-resize" : "ew-resize" } const Bat = Rat; function lse(n) { n.registerComponentModel(Oat), n.registerComponentView(Bat), yB(n) } function $at(n) { It(sse), It(lse) } var Fat = { get: function (n, e, t) { var r = lt((zat[n] || {})[e]); return t && ke(r) ? r[r.length - 1] : r } }, zat = { color: { active: ["#006edd", "#e0ffff"], inactive: ["rgba(0,0,0,0)"] }, colorHue: { active: [0, 360], inactive: [0, 0] }, colorSaturation: { active: [.3, 1], inactive: [0, 0] }, colorLightness: { active: [.9, .5], inactive: [0, 0] }, colorAlpha: { active: [.3, 1], inactive: [0, 0] }, opacity: { active: [.3, 1], inactive: [0, 0] }, symbol: { active: ["circle", "roundRect", "diamond"], inactive: ["none"] }, symbolSize: { active: [10, 50], inactive: [0, 0] } }; const cse = Fat; var JG = hi.mapVisual, Vat = hi.eachVisual, Hat = ke, QG = $, Uat = Oo, Gat = vn, Wat = function (n) { te(e, n); function e() { var t = n !== null && n.apply(this, arguments) || this; return t.type = e.type, t.stateList = ["inRange", "outOfRange"], t.replacableOptionKeys = ["inRange", "outOfRange", "target", "controller", "color"], t.layoutMode = { type: "box", ignoreSize: !0 }, t.dataBound = [-1 / 0, 1 / 0], t.targetVisuals = {}, t.controllerVisuals = {}, t } return e.prototype.init = function (t, r, i) { this.mergeDefaultAndTheme(t, i) }, e.prototype.optionUpdated = function (t, r) { var i = this.option; !r && Xoe(i, t, this.replacableOptionKeys), this.textStyleModel = this.getModel("textStyle"), this.resetItemSize(), this.completeVisualOption() }, e.prototype.resetVisual = function (t) { var r = this.stateList; t = He(t, this), this.controllerVisuals = XI(this.option.controller, r, t), this.targetVisuals = XI(this.option.target, r, t) }, e.prototype.getItemSymbol = function () { return null }, e.prototype.getTargetSeriesIndices = function () { var t = this.option.seriesIndex, r = []; return t == null || t === "all" ? this.ecModel.eachSeries(function (i, a) { r.push(a) }) : r = Cn(t), r }, e.prototype.eachTargetSeries = function (t, r) { $(this.getTargetSeriesIndices(), function (i) { var a = this.ecModel.getSeriesByIndex(i); a && t.call(r, a) }, this) }, e.prototype.isTargetSeries = function (t) { var r = !1; return this.eachTargetSeries(function (i) { i === t && (r = !0) }), r }, e.prototype.formatValueText = function (t, r, i) { var a = this.option, o = a.precision, s = this.dataBound, l = a.formatter, c; i = i || ["<", ">"], ke(t) && (t = t.slice(), c = !0); var u = r ? t : c ? [d(t[0]), d(t[1])] : d(t); if (Fe(l)) return l.replace("{value}", c ? u[0] : u).replace("{value2}", c ? u[1] : u); if (tt(l)) return c ? l(t[0], t[1]) : l(t); if (c) return t[0] === s[0] ? i[0] + " " + u[1] : t[1] === s[1] ? i[1] + " " + u[0] : u[0] + " - " + u[1]; return u; function d(f) { return f === s[0] ? "min" : f === s[1] ? "max" : (+f).toFixed(Math.min(o, 20)) } }, e.prototype.resetExtent = function () { var t = this.option, r = Uat([t.min, t.max]); this._dataExtent = r }, e.prototype.getDataDimensionIndex = function (t) { var r = this.option.dimension; if (r != null) return t.getDimensionIndex(r); for (var i = t.dimensions, a = i.length - 1; a >= 0; a--) { var o = i[a], s = t.getDimensionInfo(o); if (!s.isCalculationCoord) return s.storeDimIndex } }, e.prototype.getExtent = function () { return this._dataExtent.slice() }, e.prototype.completeVisualOption = function () { var t = this.ecModel, r = this.option, i = { inRange: r.inRange, outOfRange: r.outOfRange }, a = r.target || (r.target = {}), o = r.controller || (r.controller = {}); xt(a, i), xt(o, i); var s = this.isCategory(); l.call(this, a), l.call(this, o), c.call(this, a, "inRange", "outOfRange"), u.call(this, o); function l(d) { Hat(r.color) && !d.inRange && (d.inRange = { color: r.color.slice().reverse() }), d.inRange = d.inRange || { color: t.get("gradientColor") } } function c(d, f, h) { var p = d[f], m = d[h]; p && !m && (m = d[h] = {}, QG(p, function (g, y) { if (hi.isValidType(y)) { var b = cse.get(y, "inactive", s); b != null && (m[y] = b, y === "color" && !m.hasOwnProperty("opacity") && !m.hasOwnProperty("colorAlpha") && (m.opacity = [0, 0])) } })) } function u(d) { var f = (d.inRange || {}).symbol || (d.outOfRange || {}).symbol, h = (d.inRange || {}).symbolSize || (d.outOfRange || {}).symbolSize, p = this.get("inactiveColor"), m = this.getItemSymbol(), g = m || "roundRect"; QG(this.stateList, function (y) { var b = this.itemSize, w = d[y]; w || (w = d[y] = { color: s ? p : [p] }), w.symbol == null && (w.symbol = f && lt(f) || (s ? g : [g])), w.symbolSize == null && (w.symbolSize = h && lt(h) || (s ? b[0] : [b[0], b[0]])), w.symbol = JG(w.symbol, function (x) { return x === "none" ? g : x }); var v = w.symbolSize; if (v != null) { var S = -1 / 0; Vat(v, function (x) { x > S && (S = x) }), w.symbolSize = JG(v, function (x) { return Gat(x, [0, S], [0, b[0]], !0) }) } }, this) } }, e.prototype.resetItemSize = function () { this.itemSize = [parseFloat(this.get("itemWidth")), parseFloat(this.get("itemHeight"))] }, e.prototype.isCategory = function () { return !!this.option.categories }, e.prototype.setSelected = function (t) { }, e.prototype.getSelected = function () { return null }, e.prototype.getValueState = function (t) { return null }, e.prototype.getVisualMeta = function (t) { return null }, e.type = "visualMap", e.dependencies = ["series"], e.defaultOption = { show: !0, z: 4, seriesIndex: "all", min: 0, max: 200, left: 0, right: null, top: null, bottom: 0, itemWidth: null, itemHeight: null, inverse: !1, orient: "vertical", backgroundColor: "rgba(0,0,0,0)", borderColor: "#ccc", contentColor: "#5793f3", inactiveColor: "#aaa", borderWidth: 0, padding: 5, textGap: 10, precision: 0, textStyle: { color: "#333" } }, e }(Jt); const DT = Wat; var eW = [20, 140], Kat = function (n) { te(e, n); function e() { var t = n !== null && n.apply(this, arguments) || this; return t.type = e.type, t } return e.prototype.optionUpdated = function (t, r) { n.prototype.optionUpdated.apply(this, arguments), this.resetExtent(), this.resetVisual(function (i) { i.mappingMethod = "linear", i.dataExtent = this.getExtent() }), this._resetRange() }, e.prototype.resetItemSize = function () { n.prototype.resetItemSize.apply(this, arguments); var t = this.itemSize; (t[0] == null || isNaN(t[0])) && (t[0] = eW[0]), (t[1] == null || isNaN(t[1])) && (t[1] = eW[1]) }, e.prototype._resetRange = function () { var t = this.getExtent(), r = this.option.range; !r || r.auto ? (t.auto = 1, this.option.range = t) : ke(r) && (r[0] > r[1] && r.reverse(), r[0] = Math.max(r[0], t[0]), r[1] = Math.min(r[1], t[1])) }, e.prototype.completeVisualOption = function () { n.prototype.completeVisualOption.apply(this, arguments), $(this.stateList, function (t) { var r = this.option.controller[t].symbolSize; r && r[0] !== r[1] && (r[0] = r[1] / 3) }, this) }, e.prototype.setSelected = function (t) { this.option.range = t.slice(), this._resetRange() }, e.prototype.getSelected = function () { var t = this.getExtent(), r = Oo((this.get("range") || []).slice()); return r[0] > t[1] && (r[0] = t[1]), r[1] > t[1] && (r[1] = t[1]), r[0] < t[0] && (r[0] = t[0]), r[1] < t[0] && (r[1] = t[0]), r }, e.prototype.getValueState = function (t) { var r = this.option.range, i = this.getExtent(); return (r[0] <= i[0] || r[0] <= t) && (r[1] >= i[1] || t <= r[1]) ? "inRange" : "outOfRange" }, e.prototype.findTargetDataIndices = function (t) { var r = []; return this.eachTargetSeries(function (i) { var a = [], o = i.getData(); o.each(this.getDataDimensionIndex(o), function (s, l) { t[0] <= s && s <= t[1] && a.push(l) }, this), r.push({ seriesId: i.id, dataIndex: a }) }, this), r }, e.prototype.getVisualMeta = function (t) { var r = tW(this, "outOfRange", this.getExtent()), i = tW(this, "inRange", this.option.range.slice()), a = []; function o(h, p) { a.push({ value: h, color: t(h, p) }) } for (var s = 0, l = 0, c = i.length, u = r.length; l < u && (!i.length || r[l] <= i[0]); l++)r[l] < i[s] && o(r[l], "outOfRange"); for (var d = 1; s < c; s++, d = 0)d && a.length && o(i[s], "outOfRange"), o(i[s], "inRange"); for (var d = 1; l < u; l++)(!i.length || i[i.length - 1] < r[l]) && (d && (a.length && o(a[a.length - 1].value, "outOfRange"), d = 0), o(r[l], "outOfRange")); var f = a.length; return { stops: a, outerColors: [f ? a[0].color : "transparent", f ? a[f - 1].color : "transparent"] } }, e.type = "visualMap.continuous", e.defaultOption = Wd(DT.defaultOption, { align: "auto", calculable: !1, hoverLink: !0, realtime: !0, handleIcon: "path://M-11.39,9.77h0a3.5,3.5,0,0,1-3.5,3.5h-22a3.5,3.5,0,0,1-3.5-3.5h0a3.5,3.5,0,0,1,3.5-3.5h22A3.5,3.5,0,0,1-11.39,9.77Z", handleSize: "120%", handleStyle: { borderColor: "#fff", borderWidth: 1 }, indicatorIcon: "circle", indicatorSize: "50%", indicatorStyle: { borderColor: "#fff", borderWidth: 2, shadowBlur: 2, shadowOffsetX: 1, shadowOffsetY: 1, shadowColor: "rgba(0,0,0,0.2)" } }), e }(DT); function tW(n, e, t) { if (t[0] === t[1]) return t.slice(); for (var r = 200, i = (t[1] - t[0]) / r, a = t[0], o = [], s = 0; s <= r && a < t[1]; s++)o.push(a), a += i; return o.push(t[1]), o } const qat = Kat; var Yat = function (n) { te(e, n); function e() { var t = n !== null && n.apply(this, arguments) || this; return t.type = e.type, t.autoPositionValues = { left: 1, right: 1, top: 1, bottom: 1 }, t } return e.prototype.init = function (t, r) { this.ecModel = t, this.api = r }, e.prototype.render = function (t, r, i, a) { if (this.visualMapModel = t, t.get("show") === !1) { this.group.removeAll(); return } this.doRender(t, r, i, a) }, e.prototype.renderBackground = function (t) { var r = this.visualMapModel, i = ev(r.get("padding") || 0), a = t.getBoundingRect(); t.add(new Yt({ z2: -1, silent: !0, shape: { x: a.x - i[3], y: a.y - i[0], width: a.width + i[3] + i[1], height: a.height + i[0] + i[2] }, style: { fill: r.get("backgroundColor"), stroke: r.get("borderColor"), lineWidth: r.get("borderWidth") } })) }, e.prototype.getControllerVisual = function (t, r, i) { i = i || {}; var a = i.forceState, o = this.visualMapModel, s = {}; if (r === "color") { var l = o.get("contentColor"); s.color = l } function c(h) { return s[h] } function u(h, p) { s[h] = p } var d = o.controllerVisuals[a || o.getValueState(t)], f = hi.prepareVisualTypes(d); return $(f, function (h) { var p = d[h]; i.convertOpacityToAlpha && h === "opacity" && (h = "colorAlpha", p = d.__alphaForOpacity), hi.dependsOn(h, r) && p && p.applyVisual(t, c, u) }), s[r] }, e.prototype.positionGroup = function (t) { var r = this.visualMapModel, i = this.api; hC(t, r.getBoxLayoutParams(), { width: i.getWidth(), height: i.getHeight() }) }, e.prototype.doRender = function (t, r, i, a) { }, e.type = "visualMap", e }(nr); const use = Yat; var nW = [["left", "right", "width"], ["top", "bottom", "height"]]; function dse(n, e, t) { var r = n.option, i = r.align; if (i != null && i !== "auto") return i; for (var a = { width: e.getWidth(), height: e.getHeight() }, o = r.orient === "horizontal" ? 1 : 0, s = nW[o], l = [0, null, 10], c = {}, u = 0; u < 3; u++)c[nW[1 - o][u]] = l[u], c[s[u]] = u === 2 ? t[0] : r[s[u]]; var d = [["x", "width", 3], ["y", "height", 0]][o], f = jr(c, a, r.padding); return s[(f.margin[d[2]] || 0) + f[d[0]] + f[d[1]] * .5 < a[d[1]] * .5 ? 0 : 1] } function fS(n, e) { return $(n || [], function (t) { t.dataIndex != null && (t.dataIndexInside = t.dataIndex, t.dataIndex = null), t.highlightKey = "visualMap" + (e ? e.componentIndex : "") }), n } var Gs = vn, Zat = $, rW = Math.min, xD = Math.max, Xat = 12, Jat = 6, Qat = function (n) { te(e, n); function e() { var t = n !== null && n.apply(this, arguments) || this; return t.type = e.type, t._shapes = {}, t._dataInterval = [], t._handleEnds = [], t._hoverLinkDataIndices = [], t } return e.prototype.init = function (t, r) { n.prototype.init.call(this, t, r), this._hoverLinkFromSeriesMouseOver = He(this._hoverLinkFromSeriesMouseOver, this), this._hideIndicator = He(this._hideIndicator, this) }, e.prototype.doRender = function (t, r, i, a) { (!a || a.type !== "selectDataRange" || a.from !== this.uid) && this._buildView() }, e.prototype._buildView = function () { this.group.removeAll(); var t = this.visualMapModel, r = this.group; this._orient = t.get("orient"), this._useHandle = t.get("calculable"), this._resetInterval(), this._renderBar(r); var i = t.get("text"); this._renderEndsText(r, i, 0), this._renderEndsText(r, i, 1), this._updateView(!0), this.renderBackground(r), this._updateView(), this._enableHoverLinkToSeries(), this._enableHoverLinkFromSeries(), this.positionGroup(r) }, e.prototype._renderEndsText = function (t, r, i) { if (r) { var a = r[1 - i]; a = a != null ? a + "" : ""; var o = this.visualMapModel, s = o.get("textGap"), l = o.itemSize, c = this._shapes.mainGroup, u = this._applyTransform([l[0] / 2, i === 0 ? -s : l[1] + s], c), d = this._applyTransform(i === 0 ? "bottom" : "top", c), f = this._orient, h = this.visualMapModel.textStyleModel; this.group.add(new tn({ style: Ln(h, { x: u[0], y: u[1], verticalAlign: f === "horizontal" ? "middle" : d, align: f === "horizontal" ? d : "center", text: a }) })) } }, e.prototype._renderBar = function (t) { var r = this.visualMapModel, i = this._shapes, a = r.itemSize, o = this._orient, s = this._useHandle, l = dse(r, this.api, a), c = i.mainGroup = this._createBarGroup(l), u = new ft; c.add(u), u.add(i.outOfRange = iW()), u.add(i.inRange = iW(null, s ? oW(this._orient) : null, He(this._dragHandle, this, "all", !1), He(this._dragHandle, this, "all", !0))), u.setClipPath(new Yt({ shape: { x: 0, y: 0, width: a[0], height: a[1], r: 3 } })); var d = r.textStyleModel.getTextRect(""), f = xD(d.width, d.height); s && (i.handleThumbs = [], i.handleLabels = [], i.handleLabelPoints = [], this._createHandle(r, c, 0, a, f, o), this._createHandle(r, c, 1, a, f, o)), this._createIndicator(r, c, a, f, o), t.add(c) }, e.prototype._createHandle = function (t, r, i, a, o, s) { var l = He(this._dragHandle, this, i, !1), c = He(this._dragHandle, this, i, !0), u = Es(t.get("handleSize"), a[0]), d = Tr(t.get("handleIcon"), -u / 2, -u / 2, u, u, null, !0), f = oW(this._orient); d.attr({ cursor: f, draggable: !0, drift: l, ondragend: c, onmousemove: function (y) { Dc(y.event) } }), d.x = a[0] / 2, d.useStyle(t.getModel("handleStyle").getItemStyle()), d.setStyle({ strokeNoScale: !0, strokeFirst: !0 }), d.style.lineWidth *= 2, d.ensureState("emphasis").style = t.getModel(["emphasis", "handleStyle"]).getItemStyle(), th(d, !0), r.add(d); var h = this.visualMapModel.textStyleModel, p = new tn({ cursor: f, draggable: !0, drift: l, onmousemove: function (y) { Dc(y.event) }, ondragend: c, style: Ln(h, { x: 0, y: 0, text: "" }) }); p.ensureState("blur").style = { opacity: .1 }, p.stateTransition = { duration: 200 }, this.group.add(p); var m = [u, 0], g = this._shapes; g.handleThumbs[i] = d, g.handleLabelPoints[i] = m, g.handleLabels[i] = p }, e.prototype._createIndicator = function (t, r, i, a, o) { var s = Es(t.get("indicatorSize"), i[0]), l = Tr(t.get("indicatorIcon"), -s / 2, -s / 2, s, s, null, !0); l.attr({ cursor: "move", invisible: !0, silent: !0, x: i[0] / 2 }); var c = t.getModel("indicatorStyle").getItemStyle(); if (l instanceof gi) { var u = l.style; l.useStyle(be({ image: u.image, x: u.x, y: u.y, width: u.width, height: u.height }, c)) } else l.useStyle(c); r.add(l); var d = this.visualMapModel.textStyleModel, f = new tn({ silent: !0, invisible: !0, style: Ln(d, { x: 0, y: 0, text: "" }) }); this.group.add(f); var h = [(o === "horizontal" ? a / 2 : Jat) + i[0] / 2, 0], p = this._shapes; p.indicator = l, p.indicatorLabel = f, p.indicatorLabelPoint = h, this._firstShowIndicator = !0 }, e.prototype._dragHandle = function (t, r, i, a) { if (this._useHandle) { if (this._dragging = !r, !r) { var o = this._applyTransform([i, a], this._shapes.mainGroup, !0); this._updateInterval(t, o[1]), this._hideIndicator(), this._updateView() } r === !this.visualMapModel.get("realtime") && this.api.dispatchAction({ type: "selectDataRange", from: this.uid, visualMapId: this.visualMapModel.id, selected: this._dataInterval.slice() }), r ? !this._hovering && this._clearHoverLinkToSeries() : aW(this.visualMapModel) && this._doHoverLinkToSeries(this._handleEnds[t], !1) } }, e.prototype._resetInterval = function () { var t = this.visualMapModel, r = this._dataInterval = t.getSelected(), i = t.getExtent(), a = [0, t.itemSize[1]]; this._handleEnds = [Gs(r[0], i, a, !0), Gs(r[1], i, a, !0)] }, e.prototype._updateInterval = function (t, r) { r = r || 0; var i = this.visualMapModel, a = this._handleEnds, o = [0, i.itemSize[1]]; dp(r, a, o, t, 0); var s = i.getExtent(); this._dataInterval = [Gs(a[0], o, s, !0), Gs(a[1], o, s, !0)] }, e.prototype._updateView = function (t) { var r = this.visualMapModel, i = r.getExtent(), a = this._shapes, o = [0, r.itemSize[1]], s = t ? o : this._handleEnds, l = this._createBarVisual(this._dataInterval, i, s, "inRange"), c = this._createBarVisual(i, i, o, "outOfRange"); a.inRange.setStyle({ fill: l.barColor }).setShape("points", l.barPoints), a.outOfRange.setStyle({ fill: c.barColor }).setShape("points", c.barPoints), this._updateHandle(s, l) }, e.prototype._createBarVisual = function (t, r, i, a) { var o = { forceState: a, convertOpacityToAlpha: !0 }, s = this._makeColorGradient(t, o), l = [this.getControllerVisual(t[0], "symbolSize", o), this.getControllerVisual(t[1], "symbolSize", o)], c = this._createBarPoints(i, l); return { barColor: new Sb(0, 0, 0, 1, s), barPoints: c, handlesColor: [s[0].color, s[s.length - 1].color] } }, e.prototype._makeColorGradient = function (t, r) { var i = 100, a = [], o = (t[1] - t[0]) / i; a.push({ color: this.getControllerVisual(t[0], "color", r), offset: 0 }); for (var s = 1; s < i; s++) { var l = t[0] + o * s; if (l > t[1]) break; a.push({ color: this.getControllerVisual(l, "color", r), offset: s / i }) } return a.push({ color: this.getControllerVisual(t[1], "color", r), offset: 1 }), a }, e.prototype._createBarPoints = function (t, r) { var i = this.visualMapModel.itemSize; return [[i[0] - r[0], t[0]], [i[0], t[0]], [i[0], t[1]], [i[0] - r[1], t[1]]] }, e.prototype._createBarGroup = function (t) { var r = this._orient, i = this.visualMapModel.get("inverse"); return new ft(r === "horizontal" && !i ? { scaleX: t === "bottom" ? 1 : -1, rotation: Math.PI / 2 } : r === "horizontal" && i ? { scaleX: t === "bottom" ? -1 : 1, rotation: -Math.PI / 2 } : r === "vertical" && !i ? { scaleX: t === "left" ? 1 : -1, scaleY: -1 } : { scaleX: t === "left" ? 1 : -1 }) }, e.prototype._updateHandle = function (t, r) { if (this._useHandle) { var i = this._shapes, a = this.visualMapModel, o = i.handleThumbs, s = i.handleLabels, l = a.itemSize, c = a.getExtent(), u = this._applyTransform("left", i.mainGroup); Zat([0, 1], function (d) { var f = o[d]; f.setStyle("fill", r.handlesColor[d]), f.y = t[d]; var h = Gs(t[d], [0, l[1]], c, !0), p = this.getControllerVisual(h, "symbolSize"); f.scaleX = f.scaleY = p / l[0], f.x = l[0] - p / 2; var m = bs(i.handleLabelPoints[d], kh(f, this.group)); if (this._orient === "horizontal") { var g = u === "left" || u === "top" ? (l[0] - p) / 2 : (l[0] - p) / -2; m[1] += g } s[d].setStyle({ x: m[0], y: m[1], text: a.formatValueText(this._dataInterval[d]), verticalAlign: "middle", align: this._orient === "vertical" ? this._applyTransform("left", i.mainGroup) : "center" }) }, this) } }, e.prototype._showIndicator = function (t, r, i, a) { var o = this.visualMapModel, s = o.getExtent(), l = o.itemSize, c = [0, l[1]], u = this._shapes, d = u.indicator; if (d) { d.attr("invisible", !1); var f = { convertOpacityToAlpha: !0 }, h = this.getControllerVisual(t, "color", f), p = this.getControllerVisual(t, "symbolSize"), m = Gs(t, s, c, !0), g = l[0] - p / 2, y = { x: d.x, y: d.y }; d.y = m, d.x = g; var b = bs(u.indicatorLabelPoint, kh(d, this.group)), w = u.indicatorLabel; w.attr("invisible", !1); var v = this._applyTransform("left", u.mainGroup), S = this._orient, x = S === "horizontal"; w.setStyle({ text: (i || "") + o.formatValueText(r), verticalAlign: x ? v : "middle", align: x ? "center" : v }); var k = { x: g, y: m, style: { fill: h } }, A = { style: { x: b[0], y: b[1] } }; if (o.ecModel.isAnimationEnabled() && !this._firstShowIndicator) { var C = { duration: 100, easing: "cubicInOut", additive: !0 }; d.x = y.x, d.y = y.y, d.animateTo(k, C), w.animateTo(A, C) } else d.attr(k), w.attr(A); this._firstShowIndicator = !1; var E = this._shapes.handleLabels; if (E) for (var O = 0; O < E.length; O++)this.api.enterBlur(E[O]) } }, e.prototype._enableHoverLinkToSeries = function () { var t = this; this._shapes.mainGroup.on("mousemove", function (r) { if (t._hovering = !0, !t._dragging) { var i = t.visualMapModel.itemSize, a = t._applyTransform([r.offsetX, r.offsetY], t._shapes.mainGroup, !0, !0); a[1] = rW(xD(0, a[1]), i[1]), t._doHoverLinkToSeries(a[1], 0 <= a[0] && a[0] <= i[0]) } }).on("mouseout", function () { t._hovering = !1, !t._dragging && t._clearHoverLinkToSeries() }) }, e.prototype._enableHoverLinkFromSeries = function () { var t = this.api.getZr(); this.visualMapModel.option.hoverLink ? (t.on("mouseover", this._hoverLinkFromSeriesMouseOver, this), t.on("mouseout", this._hideIndicator, this)) : this._clearHoverLinkFromSeries() }, e.prototype._doHoverLinkToSeries = function (t, r) { var i = this.visualMapModel, a = i.itemSize; if (i.option.hoverLink) { var o = [0, a[1]], s = i.getExtent(); t = rW(xD(o[0], t), o[1]); var l = eot(i, s, o), c = [t - l, t + l], u = Gs(t, o, s, !0), d = [Gs(c[0], o, s, !0), Gs(c[1], o, s, !0)]; c[0] < o[0] && (d[0] = -1 / 0), c[1] > o[1] && (d[1] = 1 / 0), r && (d[0] === -1 / 0 ? this._showIndicator(u, d[1], "< ", l) : d[1] === 1 / 0 ? this._showIndicator(u, d[0], "> ", l) : this._showIndicator(u, u, " ", l)); var f = this._hoverLinkDataIndices, h = []; (r || aW(i)) && (h = this._hoverLinkDataIndices = i.findTargetDataIndices(d)); var p = FFe(f, h); this._dispatchHighDown("downplay", fS(p[0], i)), this._dispatchHighDown("highlight", fS(p[1], i)) } }, e.prototype._hoverLinkFromSeriesMouseOver = function (t) { var r; if (rh(t.target, function (l) { var c = pt(l); if (c.dataIndex != null) return r = c, !0 }, !0), !!r) { var i = this.ecModel.getSeriesByIndex(r.seriesIndex), a = this.visualMapModel; if (a.isTargetSeries(i)) { var o = i.getData(r.dataType), s = o.getStore().get(a.getDataDimensionIndex(o), r.dataIndex); isNaN(s) || this._showIndicator(s, s) } } }, e.prototype._hideIndicator = function () { var t = this._shapes; t.indicator && t.indicator.attr("invisible", !0), t.indicatorLabel && t.indicatorLabel.attr("invisible", !0); var r = this._shapes.handleLabels; if (r) for (var i = 0; i < r.length; i++)this.api.leaveBlur(r[i]) }, e.prototype._clearHoverLinkToSeries = function () { this._hideIndicator(); var t = this._hoverLinkDataIndices; this._dispatchHighDown("downplay", fS(t, this.visualMapModel)), t.length = 0 }, e.prototype._clearHoverLinkFromSeries = function () { this._hideIndicator(); var t = this.api.getZr(); t.off("mouseover", this._hoverLinkFromSeriesMouseOver), t.off("mouseout", this._hideIndicator) }, e.prototype._applyTransform = function (t, r, i, a) { var o = kh(r, a ? null : this.group); return ke(t) ? bs(t, o, i) : oC(t, o, i) }, e.prototype._dispatchHighDown = function (t, r) { r && r.length && this.api.dispatchAction({ type: t, batch: r }) }, e.prototype.dispose = function () { this._clearHoverLinkFromSeries(), this._clearHoverLinkToSeries() }, e.type = "visualMap.continuous", e }(use); function iW(n, e, t, r) { return new Aa({ shape: { points: n }, draggable: !!t, cursor: e, drift: t, onmousemove: function (i) { Dc(i.event) }, ondragend: r }) } function eot(n, e, t) { var r = Xat / 2, i = n.get("hoverLinkDataSize"); return i && (r = Gs(i, e, t, !0) / 2), r } function aW(n) { var e = n.get("hoverLinkOnHandle"); return !!(e ?? n.get("realtime")) } function oW(n) { return n === "vertical" ? "ns-resize" : "ew-resize" } const tot = Qat; var not = { type: "selectDataRange", event: "dataRangeSelected", update: "update" }, rot = function (n, e) { e.eachComponent({ mainType: "visualMap", query: n }, function (t) { t.setSelected(n.selected) }) }, iot = [{ createOnAllSeries: !0, reset: function (n, e) { var t = []; return e.eachComponent("visualMap", function (r) { var i = n.pipelineContext; !r.isTargetSeries(n) || i && i.large || t.push(Jrt(r.stateList, r.targetVisuals, He(r.getValueState, r), r.getDataDimensionIndex(n.getData()))) }), t } }, { createOnAllSeries: !0, reset: function (n, e) { var t = n.getData(), r = []; e.eachComponent("visualMap", function (i) { if (i.isTargetSeries(n)) { var a = i.getVisualMeta(He(aot, null, n, i)) || { stops: [], outerColors: [] }, o = i.getDataDimensionIndex(t); o >= 0 && (a.dimension = o, r.push(a)) } }), n.getData().setVisual("visualMeta", r) } }]; function aot(n, e, t, r) { for (var i = e.targetVisuals[r], a = hi.prepareVisualTypes(i), o = { color: Ab(n.getData(), "color") }, s = 0, l = a.length; s < l; s++) { var c = a[s], u = i[c === "opacity" ? "__alphaForOpacity" : c]; u && u.applyVisual(t, d, f) } return o.color; function d(h) { return o[h] } function f(h, p) { o[h] = p } } var sW = $; function oot(n) { var e = n && n.visualMap; ke(e) || (e = e ? [e] : []), sW(e, function (t) { if (t) { am(t, "splitList") && !am(t, "pieces") && (t.pieces = t.splitList, delete t.splitList); var r = t.pieces; r && ke(r) && sW(r, function (i) { ot(i) && (am(i, "start") && !am(i, "min") && (i.min = i.start), am(i, "end") && !am(i, "max") && (i.max = i.end)) }) } }) } function am(n, e) { return n && n.hasOwnProperty && n.hasOwnProperty(e) } var lW = !1; function fse(n) { lW || (lW = !0, n.registerSubTypeDefaulter("visualMap", function (e) { return !e.categories && (!(e.pieces ? e.pieces.length > 0 : e.splitNumber > 0) || e.calculable) ? "continuous" : "piecewise" }), n.registerAction(not, rot), $(iot, function (e) { n.registerVisual(n.PRIORITY.VISUAL.COMPONENT, e) }), n.registerPreprocessor(oot)) } function hse(n) { n.registerComponentModel(qat), n.registerComponentView(tot), fse(n) } var sot = function (n) { te(e, n); function e() { var t = n !== null && n.apply(this, arguments) || this; return t.type = e.type, t._pieceList = [], t } return e.prototype.optionUpdated = function (t, r) { n.prototype.optionUpdated.apply(this, arguments), this.resetExtent(); var i = this._mode = this._determineMode(); this._pieceList = [], lot[this._mode].call(this, this._pieceList), this._resetSelected(t, r); var a = this.option.categories; this.resetVisual(function (o, s) { i === "categories" ? (o.mappingMethod = "category", o.categories = lt(a)) : (o.dataExtent = this.getExtent(), o.mappingMethod = "piecewise", o.pieceList = Ae(this._pieceList, function (l) { return l = lt(l), s !== "inRange" && (l.visual = null), l })) }) }, e.prototype.completeVisualOption = function () { var t = this.option, r = {}, i = hi.listVisualTypes(), a = this.isCategory(); $(t.pieces, function (s) { $(i, function (l) { s.hasOwnProperty(l) && (r[l] = 1) }) }), $(r, function (s, l) { var c = !1; $(this.stateList, function (u) { c = c || o(t, u, l) || o(t.target, u, l) }, this), !c && $(this.stateList, function (u) { (t[u] || (t[u] = {}))[l] = cse.get(l, u === "inRange" ? "active" : "inactive", a) }) }, this); function o(s, l, c) { return s && s[l] && s[l].hasOwnProperty(c) } n.prototype.completeVisualOption.apply(this, arguments) }, e.prototype._resetSelected = function (t, r) { var i = this.option, a = this._pieceList, o = (r ? i : t).selected || {}; if (i.selected = o, $(a, function (l, c) { var u = this.getSelectedMapKey(l); o.hasOwnProperty(u) || (o[u] = !0) }, this), i.selectedMode === "single") { var s = !1; $(a, function (l, c) { var u = this.getSelectedMapKey(l); o[u] && (s ? o[u] = !1 : s = !0) }, this) } }, e.prototype.getItemSymbol = function () { return this.get("itemSymbol") }, e.prototype.getSelectedMapKey = function (t) { return this._mode === "categories" ? t.value + "" : t.index + "" }, e.prototype.getPieceList = function () { return this._pieceList }, e.prototype._determineMode = function () { var t = this.option; return t.pieces && t.pieces.length > 0 ? "pieces" : this.option.categories ? "categories" : "splitNumber" }, e.prototype.setSelected = function (t) { this.option.selected = lt(t) }, e.prototype.getValueState = function (t) { var r = hi.findPieceIndex(t, this._pieceList); return r != null && this.option.selected[this.getSelectedMapKey(this._pieceList[r])] ? "inRange" : "outOfRange" }, e.prototype.findTargetDataIndices = function (t) { var r = [], i = this._pieceList; return this.eachTargetSeries(function (a) { var o = [], s = a.getData(); s.each(this.getDataDimensionIndex(s), function (l, c) { var u = hi.findPieceIndex(l, i); u === t && o.push(c) }, this), r.push({ seriesId: a.id, dataIndex: o }) }, this), r }, e.prototype.getRepresentValue = function (t) { var r; if (this.isCategory()) r = t.value; else if (t.value != null) r = t.value; else { var i = t.interval || []; r = i[0] === -1 / 0 && i[1] === 1 / 0 ? 0 : (i[0] + i[1]) / 2 } return r }, e.prototype.getVisualMeta = function (t) { if (this.isCategory()) return; var r = [], i = ["", ""], a = this; function o(u, d) { var f = a.getRepresentValue({ interval: u }); d || (d = a.getValueState(f)); var h = t(f, d); u[0] === -1 / 0 ? i[0] = h : u[1] === 1 / 0 ? i[1] = h : r.push({ value: u[0], color: h }, { value: u[1], color: h }) } var s = this._pieceList.slice(); if (!s.length) s.push({ interval: [-1 / 0, 1 / 0] }); else { var l = s[0].interval[0]; l !== -1 / 0 && s.unshift({ interval: [-1 / 0, l] }), l = s[s.length - 1].interval[1], l !== 1 / 0 && s.push({ interval: [l, 1 / 0] }) } var c = -1 / 0; return $(s, function (u) { var d = u.interval; d && (d[0] > c && o([c, d[0]], "outOfRange"), o(d.slice()), c = d[1]) }, this), { stops: r, outerColors: i } }, e.type = "visualMap.piecewise", e.defaultOption = Wd(DT.defaultOption, { selected: null, minOpen: !1, maxOpen: !1, align: "auto", itemWidth: 20, itemHeight: 14, itemSymbol: "roundRect", pieces: null, categories: null, splitNumber: 5, selectedMode: "multiple", itemGap: 10, hoverLink: !0 }), e }(DT), lot = { splitNumber: function (n) { var e = this.option, t = Math.min(e.precision, 20), r = this.getExtent(), i = e.splitNumber; i = Math.max(parseInt(i, 10), 1), e.splitNumber = i; for (var a = (r[1] - r[0]) / i; +a.toFixed(t) !== a && t < 5;)t++; e.precision = t, a = +a.toFixed(t), e.minOpen && n.push({ interval: [-1 / 0, r[0]], close: [0, 0] }); for (var o = 0, s = r[0]; o < i; s += a, o++) { var l = o === i - 1 ? r[1] : s + a; n.push({ interval: [s, l], close: [1, 1] }) } e.maxOpen && n.push({ interval: [r[1], 1 / 0], close: [0, 0] }), eV(n), $(n, function (c, u) { c.index = u, c.text = this.formatValueText(c.interval) }, this) }, categories: function (n) { var e = this.option; $(e.categories, function (t) { n.push({ text: this.formatValueText(t, !0), value: t }) }, this), cW(e, n) }, pieces: function (n) { var e = this.option; $(e.pieces, function (t, r) { ot(t) || (t = { value: t }); var i = { text: "", index: r }; if (t.label != null && (i.text = t.label), t.hasOwnProperty("value")) { var a = i.value = t.value; i.interval = [a, a], i.close = [1, 1] } else { for (var o = i.interval = [], s = i.close = [0, 0], l = [1, 0, 1], c = [-1 / 0, 1 / 0], u = [], d = 0; d < 2; d++) { for (var f = [["gte", "gt", "min"], ["lte", "lt", "max"]][d], h = 0; h < 3 && o[d] == null; h++)o[d] = t[f[h]], s[d] = l[h], u[d] = h === 2; o[d] == null && (o[d] = c[d]) } u[0] && o[1] === 1 / 0 && (s[0] = 0), u[1] && o[0] === -1 / 0 && (s[1] = 0), o[0] === o[1] && s[0] && s[1] && (i.value = o[0]) } i.visual = hi.retrieveVisuals(t), n.push(i) }, this), cW(e, n), eV(n), $(n, function (t) { var r = t.close, i = [["<", ""][r[1]], [">", ""][r[0]]]; t.text = t.text || this.formatValueText(t.value != null ? t.value : t.interval, !1, i) }, this) } }; function cW(n, e) { var t = n.inverse; (n.orient === "vertical" ? !t : t) && e.reverse() } const cot = sot; var uot = function (n) { te(e, n); function e() { var t = n !== null && n.apply(this, arguments) || this; return t.type = e.type, t } return e.prototype.doRender = function () { var t = this.group; t.removeAll(); var r = this.visualMapModel, i = r.get("textGap"), a = r.textStyleModel, o = a.getFont(), s = a.getTextColor(), l = this._getItemAlign(), c = r.itemSize, u = this._getViewData(), d = u.endsText, f = Xr(r.get("showLabel", !0), !d), h = !r.get("selectedMode"); d && this._renderEndsText(t, d[0], c, f, l), $(u.viewPieceList, function (p) { var m = p.piece, g = new ft; g.onclick = He(this._onItemClick, this, m), this._enableHoverLink(g, p.indexInModelPieceList); var y = r.getRepresentValue(m); if (this._createItemSymbol(g, y, [0, 0, c[0], c[1]], h), f) { var b = this.visualMapModel.getValueState(y); g.add(new tn({ style: { x: l === "right" ? -i : c[0] + i, y: c[1] / 2, text: m.text, verticalAlign: "middle", align: l, font: o, fill: s, opacity: b === "outOfRange" ? .5 : 1 }, silent: h })) } t.add(g) }, this), d && this._renderEndsText(t, d[1], c, f, l), Ch(r.get("orient"), t, r.get("itemGap")), this.renderBackground(t), this.positionGroup(t) }, e.prototype._enableHoverLink = function (t, r) { var i = this; t.on("mouseover", function () { return a("highlight") }).on("mouseout", function () { return a("downplay") }); var a = function (o) { var s = i.visualMapModel; s.option.hoverLink && i.api.dispatchAction({ type: o, batch: fS(s.findTargetDataIndices(r), s) }) } }, e.prototype._getItemAlign = function () { var t = this.visualMapModel, r = t.option; if (r.orient === "vertical") return dse(t, this.api, t.itemSize); var i = r.align; return (!i || i === "auto") && (i = "left"), i }, e.prototype._renderEndsText = function (t, r, i, a, o) { if (r) { var s = new ft, l = this.visualMapModel.textStyleModel; s.add(new tn({ style: Ln(l, { x: a ? o === "right" ? i[0] : 0 : i[0] / 2, y: i[1] / 2, verticalAlign: "middle", align: a ? o : "center", text: r }) })), t.add(s) } }, e.prototype._getViewData = function () { var t = this.visualMapModel, r = Ae(t.getPieceList(), function (s, l) { return { piece: s, indexInModelPieceList: l } }), i = t.get("text"), a = t.get("orient"), o = t.get("inverse"); return (a === "horizontal" ? o : !o) ? r.reverse() : i && (i = i.slice().reverse()), { viewPieceList: r, endsText: i } }, e.prototype._createItemSymbol = function (t, r, i, a) { var o = Tr(this.getControllerVisual(r, "symbol"), i[0], i[1], i[2], i[3], this.getControllerVisual(r, "color")); o.silent = a, t.add(o) }, e.prototype._onItemClick = function (t) { var r = this.visualMapModel, i = r.option, a = i.selectedMode; if (a) { var o = lt(i.selected), s = r.getSelectedMapKey(t); a === "single" || a === !0 ? (o[s] = !0, $(o, function (l, c) { o[c] = c === s })) : o[s] = !o[s], this.api.dispatchAction({ type: "selectDataRange", from: this.uid, visualMapId: this.visualMapModel.id, selected: o }) } }, e.type = "visualMap.piecewise", e }(use); const dot = uot; function pse(n) { n.registerComponentModel(cot), n.registerComponentView(dot), fse(n) } function fot(n) { It(hse), It(pse) } var hot = { label: { enabled: !0 }, decal: { show: !1 } }, uW = Kt(), pot = {}; function mot(n, e) { var t = n.getModel("aria"); if (!t.get("enabled")) return; var r = lt(hot); xt(r.label, n.getLocaleModel().get("aria"), !1), xt(t.option, r, !1), i(), a(); function i() { var c = t.getModel("decal"), u = c.get("show"); if (u) { var d = Ze(); n.eachSeries(function (f) { if (!f.isColorBySeries()) { var h = d.get(f.type); h || (h = {}, d.set(f.type, h)), uW(f).scope = h } }), n.eachRawSeries(function (f) { if (n.isSeriesFiltered(f)) return; if (tt(f.enableAriaDecal)) { f.enableAriaDecal(); return } var h = f.getData(); if (f.isColorBySeries()) { var b = aI(f.ecModel, f.name, pot, n.getSeriesCount()), w = h.getVisual("decal"); h.setVisual("decal", v(w, b)) } else { var p = f.getRawData(), m = {}, g = uW(f).scope; h.each(function (S) { var x = h.getRawIndex(S); m[x] = S }); var y = p.count(); p.each(function (S) { var x = m[S], k = p.getName(S) || S + "", A = aI(f.ecModel, k, g, y), C = h.getItemVisual(x, "decal"); h.setItemVisual(x, "decal", v(C, A)) }) } function v(S, x) { var k = S ? be(be({}, x), S) : x; return k.dirty = !0, k } }) } } function a() { var c = e.getZr().dom; if (c) { var u = n.getLocaleModel().get("aria"), d = t.getModel("label"); if (d.option = rt(d.option, u), !!d.get("enabled")) { if (c.setAttribute("role", "img"), d.get("description")) { c.setAttribute("aria-label", d.get("description")); return } var f = n.getSeriesCount(), h = d.get(["data", "maxCount"]) || 10, p = d.get(["series", "maxCount"]) || 10, m = Math.min(f, p), g; if (!(f < 1)) { var y = s(); if (y) { var b = d.get(["general", "withTitle"]); g = o(b, { title: y }) } else g = d.get(["general", "withoutTitle"]); var w = [], v = f > 1 ? d.get(["series", "multiple", "prefix"]) : d.get(["series", "single", "prefix"]); g += o(v, { seriesCount: f }), n.eachSeries(function (A, C) { if (C < m) { var E = void 0, O = A.get("name"), j = O ? "withName" : "withoutName"; E = f > 1 ? d.get(["series", "multiple", j]) : d.get(["series", "single", j]), E = o(E, { seriesId: A.seriesIndex, seriesName: A.get("name"), seriesType: l(A.subType) }); var I = A.getData(); if (I.count() > h) { var L = d.get(["data", "partialData"]); E += o(L, { displayCnt: h }) } else E += d.get(["data", "allData"]); for (var R = d.get(["data", "separator", "middle"]), D = d.get(["data", "separator", "end"]), P = d.get(["data", "excludeDimensionId"]), B = [], F = 0; F < I.count(); F++)if (F < h) { var K = I.getName(F), V = P ? pn(I.getValues(F), function (J, ie) { return Et(P, ie) === -1 }) : I.getValues(F), W = d.get(["data", K ? "withName" : "withoutName"]); B.push(o(W, { name: K, value: V.join(R) })) } E += B.join(R) + D, w.push(E) } }); var S = d.getModel(["series", "multiple", "separator"]), x = S.get("middle"), k = S.get("end"); g += w.join(x) + k, c.setAttribute("aria-label", g) } } } } function o(c, u) { if (!Fe(c)) return c; var d = c; return $(u, function (f, h) { d = d.replace(new RegExp("\\{\\s*" + h + "\\s*\\}", "g"), f) }), d } function s() { var c = n.get("title"); return c && c.length && (c = c[0]), c && c.text } function l(c) { var u = n.getLocaleModel().get(["series", "typeNames"]); return u[c] || u.chart } } function got(n) { if (!(!n || !n.aria)) { var e = n.aria; e.show != null && (e.enabled = e.show), e.label = e.label || {}, $(["description", "general", "series", "data"], function (t) { e[t] != null && (e.label[t] = e[t]) }) } } function vot(n) { n.registerPreprocessor(got), n.registerVisual(n.PRIORITY.VISUAL.ARIA, mot) } var dW = { value: "eq", "<": "lt", "<=": "lte", ">": "gt", ">=": "gte", "=": "eq", "!=": "ne", "<>": "ne" }, yot = function () { function n(e) { var t = this._condVal = Fe(e) ? new RegExp(e) : Y4e(e) ? e : null; if (t == null) { var r = ""; hn(r) } } return n.prototype.evaluate = function (e) { var t = typeof e; return Fe(t) ? this._condVal.test(e) : nn(t) ? this._condVal.test(e + "") : !1 }, n }(), _ot = function () { function n() { } return n.prototype.evaluate = function () { return this.value }, n }(), bot = function () { function n() { } return n.prototype.evaluate = function () { for (var e = this.children, t = 0; t < e.length; t++)if (!e[t].evaluate()) return !1; return !0 }, n }(), wot = function () { function n() { } return n.prototype.evaluate = function () { for (var e = this.children, t = 0; t < e.length; t++)if (e[t].evaluate()) return !0; return !1 }, n }(), xot = function () { function n() { } return n.prototype.evaluate = function () { return !this.child.evaluate() }, n }(), Sot = function () { function n() { } return n.prototype.evaluate = function () { for (var e = !!this.valueParser, t = this.getValue, r = t(this.valueGetterParam), i = e ? this.valueParser(r) : null, a = 0; a < this.subCondList.length; a++)if (!this.subCondList[a].evaluate(e ? i : r)) return !1; return !0 }, n }(); function AB(n, e) { if (n === !0 || n === !1) { var t = new _ot; return t.value = n, t } var r = ""; return mse(n) || hn(r), n.and ? fW("and", n, e) : n.or ? fW("or", n, e) : n.not ? Tot(n, e) : kot(n, e) } function fW(n, e, t) { var r = e[n], i = ""; ke(r) || hn(i), r.length || hn(i); var a = n === "and" ? new bot : new wot; return a.children = Ae(r, function (o) { return AB(o, t) }), a.children.length || hn(i), a } function Tot(n, e) { var t = n.not, r = ""; mse(t) || hn(r); var i = new xot; return i.child = AB(t, e), i.child || hn(r), i } function kot(n, e) { for (var t = "", r = e.prepareGetValue(n), i = [], a = Bt(n), o = n.parser, s = o ? zne(o) : null, l = 0; l < a.length; l++) { var c = a[l]; if (!(c === "parser" || e.valueGetterAttrMap.get(c))) { var u = Ge(dW, c) ? dW[c] : c, d = n[c], f = s ? s(d) : d, h = tHe(u, f) || u === "reg" && new yot(f); h || hn(t), i.push(h) } } i.length || hn(t); var p = new Sot; return p.valueGetterParam = r, p.valueParser = s, p.getValue = e.getValue, p.subCondList = i, p } function mse(n) { return ot(n) && !Ii(n) } var Cot = function () { function n(e, t) { this._cond = AB(e, t) } return n.prototype.evaluate = function () { return this._cond.evaluate() }, n }(); function Aot(n, e) { return new Cot(n, e) } var Eot = { type: "echarts:filter", transform: function (n) { for (var e = n.upstream, t, r = Aot(n.config, { valueGetterAttrMap: Ze({ dimension: !0 }), prepareGetValue: function (s) { var l = "", c = s.dimension; Ge(s, "dimension") || hn(l); var u = e.getDimensionInfo(c); return u || hn(l), { dimIdx: u.index } }, getValue: function (s) { return e.retrieveValueFromItem(t, s.dimIdx) } }), i = [], a = 0, o = e.count(); a < o; a++)t = e.getRawDataItem(a), r.evaluate() && i.push(t); return { data: i } } }, Mot = { type: "echarts:sort", transform: function (n) { var e = n.upstream, t = n.config, r = "", i = Cn(t); i.length || hn(r); var a = []; $(i, function (u) { var d = u.dimension, f = u.order, h = u.parser, p = u.incomparable; if (d == null && hn(r), f !== "asc" && f !== "desc" && hn(r), p && p !== "min" && p !== "max") { var m = ""; hn(m) } if (f !== "asc" && f !== "desc") { var g = ""; hn(g) } var y = e.getDimensionInfo(d); y || hn(r); var b = h ? zne(h) : null; h && !b && hn(r), a.push({ dimIdx: y.index, parser: b, comparator: new Hne(f, p) }) }); var o = e.sourceFormat; o !== Li && o !== Ko && hn(r); for (var s = [], l = 0, c = e.count(); l < c; l++)s.push(e.getRawDataItem(l)); return s.sort(function (u, d) { for (var f = 0; f < a.length; f++) { var h = a[f], p = e.retrieveValueFromItem(u, h.dimIdx), m = e.retrieveValueFromItem(d, h.dimIdx); h.parser && (p = h.parser(p), m = h.parser(m)); var g = h.comparator.evaluate(p, m); if (g !== 0) return g } return 0 }), { data: s } } }; function Oot(n) { n.registerTransform(Eot), n.registerTransform(Mot) } var Dot = function (n) { te(e, n); function e() { var t = n !== null && n.apply(this, arguments) || this; return t.type = "dataset", t } return e.prototype.init = function (t, r, i) { n.prototype.init.call(this, t, r, i), this._sourceManager = new Kne(this), fH(this) }, e.prototype.mergeOption = function (t, r) { n.prototype.mergeOption.call(this, t, r), fH(this) }, e.prototype.optionUpdated = function () { this._sourceManager.dirty() }, e.prototype.getSourceManager = function () { return this._sourceManager }, e.type = "dataset", e.defaultOption = { seriesLayoutBy: ml }, e }(Jt), jot = function (n) { te(e, n); function e() { var t = n !== null && n.apply(this, arguments) || this; return t.type = "dataset", t } return e.type = "dataset", e }(nr); function Pot(n) { n.registerComponentModel(Dot), n.registerComponentView(jot) } var zs = Cl.CMD; function Lm(n, e) { return Math.abs(n - e) < 1e-5 } function iL(n) { var e = n.data, t = n.len(), r = [], i, a = 0, o = 0, s = 0, l = 0; function c(I, L) { i && i.length > 2 && r.push(i), i = [I, L] } function u(I, L, R, D) { Lm(I, R) && Lm(L, D) || i.push(I, L, R, D, R, D) } function d(I, L, R, D, P, B) { var F = Math.abs(L - I), K = Math.tan(F / 4) * 4 / 3, V = L < I ? -1 : 1, W = Math.cos(I), J = Math.sin(I), ie = Math.cos(L), le = Math.sin(L), De = W * P + R, ae = J * B + D, pe = ie * P + R, se = le * B + D, ge = P * K * V, _e = B * K * V; i.push(De - ge * J, ae + _e * W, pe + ge * le, se - _e * ie, pe, se) } for (var f, h, p, m, g = 0; g < t;) { var y = e[g++], b = g === 1; switch (b && (a = e[g], o = e[g + 1], s = a, l = o, (y === zs.L || y === zs.C || y === zs.Q) && (i = [s, l])), y) { case zs.M: a = s = e[g++], o = l = e[g++], c(s, l); break; case zs.L: f = e[g++], h = e[g++], u(a, o, f, h), a = f, o = h; break; case zs.C: i.push(e[g++], e[g++], e[g++], e[g++], a = e[g++], o = e[g++]); break; case zs.Q: f = e[g++], h = e[g++], p = e[g++], m = e[g++], i.push(a + 2 / 3 * (f - a), o + 2 / 3 * (h - o), p + 2 / 3 * (f - p), m + 2 / 3 * (h - m), p, m), a = p, o = m; break; case zs.A: var w = e[g++], v = e[g++], S = e[g++], x = e[g++], k = e[g++], A = e[g++] + k; g += 1; var C = !e[g++]; f = Math.cos(k) * S + w, h = Math.sin(k) * x + v, b ? (s = f, l = h, c(s, l)) : u(a, o, f, h), a = Math.cos(A) * S + w, o = Math.sin(A) * x + v; for (var E = (C ? -1 : 1) * Math.PI / 2, O = k; C ? O > A : O < A; O += E) { var j = C ? Math.max(O + E, A) : Math.min(O + E, A); d(O, j, w, v, S, x) } break; case zs.R: s = a = e[g++], l = o = e[g++], f = s + e[g++], h = l + e[g++], c(f, l), u(f, l, f, h), u(f, h, s, h), u(s, h, s, l), u(s, l, f, l); break; case zs.Z: i && u(a, o, s, l), a = s, o = l; break } } return i && i.length > 2 && r.push(i), r } function aL(n, e, t, r, i, a, o, s, l, c) { if (Lm(n, t) && Lm(e, r) && Lm(i, o) && Lm(a, s)) { l.push(o, s); return } var u = 2 / c, d = u * u, f = o - n, h = s - e, p = Math.sqrt(f * f + h * h); f /= p, h /= p; var m = t - n, g = r - e, y = i - o, b = a - s, w = m * m + g * g, v = y * y + b * b; if (w < d && v < d) { l.push(o, s); return } var S = f * m + h * g, x = -f * y - h * b, k = w - S * S, A = v - x * x; if (k < d && S >= 0 && A < d && x >= 0) { l.push(o, s); return } var C = [], E = []; Cd(n, t, i, o, .5, C), Cd(e, r, a, s, .5, E), aL(C[0], E[0], C[1], E[1], C[2], E[2], C[3], E[3], l, c), aL(C[4], E[4], C[5], E[5], C[6], E[6], C[7], E[7], l, c) } function Iot(n, e) { var t = iL(n), r = []; e = e || 1; for (var i = 0; i < t.length; i++) { var a = t[i], o = [], s = a[0], l = a[1]; o.push(s, l); for (var c = 2; c < a.length;) { var u = a[c++], d = a[c++], f = a[c++], h = a[c++], p = a[c++], m = a[c++]; aL(s, l, u, d, f, h, p, m, o, e), s = p, l = m } r.push(o) } return r } function gse(n, e, t) { var r = n[e], i = n[1 - e], a = Math.abs(r / i), o = Math.ceil(Math.sqrt(a * t)), s = Math.floor(t / o); s === 0 && (s = 1, o = t); for (var l = [], c = 0; c < o; c++)l.push(s); var u = o * s, d = t - u; if (d > 0) for (var c = 0; c < d; c++)l[c % o] += 1; return l } function hW(n, e, t) { for (var r = n.r0, i = n.r, a = n.startAngle, o = n.endAngle, s = Math.abs(o - a), l = s * i, c = i - r, u = l > Math.abs(c), d = gse([l, c], u ? 0 : 1, e), f = (u ? s : c) / d.length, h = 0; h < d.length; h++)for (var p = (u ? c : s) / d[h], m = 0; m < d[h]; m++) { var g = {}; u ? (g.startAngle = a + f * h, g.endAngle = a + f * (h + 1), g.r0 = r + p * m, g.r = r + p * (m + 1)) : (g.startAngle = a + p * m, g.endAngle = a + p * (m + 1), g.r0 = r + f * h, g.r = r + f * (h + 1)), g.clockwise = n.clockwise, g.cx = n.cx, g.cy = n.cy, t.push(g) } } function Lot(n, e, t) { for (var r = n.width, i = n.height, a = r > i, o = gse([r, i], a ? 0 : 1, e), s = a ? "width" : "height", l = a ? "height" : "width", c = a ? "x" : "y", u = a ? "y" : "x", d = n[s] / o.length, f = 0; f < o.length; f++)for (var h = n[l] / o[f], p = 0; p < o[f]; p++) { var m = {}; m[c] = f * d, m[u] = p * h, m[s] = d, m[l] = h, m.x += n.x, m.y += n.y, t.push(m) } } function pW(n, e, t, r) { return n * r - t * e } function Rot(n, e, t, r, i, a, o, s) { var l = t - n, c = r - e, u = o - i, d = s - a, f = pW(u, d, l, c); if (Math.abs(f) < 1e-6) return null; var h = n - i, p = e - a, m = pW(h, p, u, d) / f; return m < 0 || m > 1 ? null : new St(m * l + n, m * c + e) } function Not(n, e, t) { var r = new St; St.sub(r, t, e), r.normalize(); var i = new St; St.sub(i, n, e); var a = i.dot(r); return a } function om(n, e) { var t = n[n.length - 1]; t && t[0] === e[0] && t[1] === e[1] || n.push(e) } function Bot(n, e, t) { for (var r = n.length, i = [], a = 0; a < r; a++) { var o = n[a], s = n[(a + 1) % r], l = Rot(o[0], o[1], s[0], s[1], e.x, e.y, t.x, t.y); l && i.push({ projPt: Not(l, e, t), pt: l, idx: a }) } if (i.length < 2) return [{ points: n }, { points: n }]; i.sort(function (g, y) { return g.projPt - y.projPt }); var c = i[0], u = i[i.length - 1]; if (u.idx < c.idx) { var d = c; c = u, u = d } for (var f = [c.pt.x, c.pt.y], h = [u.pt.x, u.pt.y], p = [f], m = [h], a = c.idx + 1; a <= u.idx; a++)om(p, n[a].slice()); om(p, h), om(p, f); for (var a = u.idx + 1; a <= c.idx + r; a++)om(m, n[a % r].slice()); return om(m, f), om(m, h), [{ points: p }, { points: m }] } function mW(n) { var e = n.points, t = [], r = []; eC(e, t, r); var i = new kt(t[0], t[1], r[0] - t[0], r[1] - t[1]), a = i.width, o = i.height, s = i.x, l = i.y, c = new St, u = new St; return a > o ? (c.x = u.x = s + a / 2, c.y = l, u.y = l + o) : (c.y = u.y = l + o / 2, c.x = s, u.x = s + a), Bot(e, c, u) } function jT(n, e, t, r) { if (t === 1) r.push(e); else { var i = Math.floor(t / 2), a = n(e); jT(n, a[0], i, r), jT(n, a[1], t - i, r) } return r } function $ot(n, e) { for (var t = [], r = 0; r < e; r++)t.push(zN(n)); return t } function Fot(n, e) { e.setStyle(n.style), e.z = n.z, e.z2 = n.z2, e.zlevel = n.zlevel } function zot(n) { for (var e = [], t = 0; t < n.length;)e.push([n[t++], n[t++]]); return e } function Vot(n, e) { var t = [], r = n.shape, i; switch (n.type) { case "rect": Lot(r, e, t), i = Yt; break; case "sector": hW(r, e, t), i = Ca; break; case "circle": hW({ r0: 0, r: r.r, startAngle: 0, endAngle: Math.PI * 2, cx: r.cx, cy: r.cy }, e, t), i = Ca; break; default: var a = n.getComputedTransform(), o = a ? Math.sqrt(Math.max(a[0] * a[0] + a[1] * a[1], a[2] * a[2] + a[3] * a[3])) : 1, s = Ae(Iot(n.getUpdatedPathProxy(), o), function (y) { return zot(y) }), l = s.length; if (l === 0) jT(mW, { points: s[0] }, e, t); else if (l === e) for (var c = 0; c < l; c++)t.push({ points: s[c] }); else { var u = 0, d = Ae(s, function (y) { var b = [], w = []; eC(y, b, w); var v = (w[1] - b[1]) * (w[0] - b[0]); return u += v, { poly: y, area: v } }); d.sort(function (y, b) { return b.area - y.area }); for (var f = e, c = 0; c < l; c++) { var h = d[c]; if (f <= 0) break; var p = c === l - 1 ? f : Math.ceil(h.area / u * e); p < 0 || (jT(mW, { points: h.poly }, p, t), f -= p) } } i = Aa; break }if (!i) return $ot(n, e); for (var m = [], c = 0; c < t.length; c++) { var g = new i; g.setShape(t[c]), Fot(n, g), m.push(g) } return m } function Hot(n, e) { var t = n.length, r = e.length; if (t === r) return [n, e]; for (var i = [], a = [], o = t < r ? n : e, s = Math.min(t, r), l = Math.abs(r - t) / 6, c = (s - 2) / 6, u = Math.ceil(l / c) + 1, d = [o[0], o[1]], f = l, h = 2; h < s;) { var p = o[h - 2], m = o[h - 1], g = o[h++], y = o[h++], b = o[h++], w = o[h++], v = o[h++], S = o[h++]; if (f <= 0) { d.push(g, y, b, w, v, S); continue } for (var x = Math.min(f, u - 1) + 1, k = 1; k <= x; k++) { var A = k / x; Cd(p, g, b, v, A, i), Cd(m, y, w, S, A, a), p = i[3], m = a[3], d.push(i[1], a[1], i[2], a[2], p, m), g = i[5], y = a[5], b = i[6], w = a[6] } f -= x - 1 } return o === n ? [d, e] : [n, d] } function gW(n, e) { for (var t = n.length, r = n[t - 2], i = n[t - 1], a = [], o = 0; o < e.length;)a[o++] = r, a[o++] = i; return a } function Uot(n, e) { for (var t, r, i, a = [], o = [], s = 0; s < Math.max(n.length, e.length); s++) { var l = n[s], c = e[s], u = void 0, d = void 0; l ? c ? (t = Hot(l, c), u = t[0], d = t[1], r = u, i = d) : (d = gW(i || l, l), u = l) : (u = gW(r || c, c), d = c), a.push(u), o.push(d) } return [a, o] } function vW(n) { for (var e = 0, t = 0, r = 0, i = n.length, a = 0, o = i - 2; a < i; o = a, a += 2) { var s = n[o], l = n[o + 1], c = n[a], u = n[a + 1], d = s * u - c * l; e += d, t += (s + c) * d, r += (l + u) * d } return e === 0 ? [n[0] || 0, n[1] || 0] : [t / e / 3, r / e / 3, e] } function Got(n, e, t, r) { for (var i = (n.length - 2) / 6, a = 1 / 0, o = 0, s = n.length, l = s - 2, c = 0; c < i; c++) { for (var u = c * 6, d = 0, f = 0; f < s; f += 2) { var h = f === 0 ? u : (u + f - 2) % l + 2, p = n[h] - t[0], m = n[h + 1] - t[1], g = e[f] - r[0], y = e[f + 1] - r[1], b = g - p, w = y - m; d += b * b + w * w } d < a && (a = d, o = c) } return o } function Wot(n) { for (var e = [], t = n.length, r = 0; r < t; r += 2)e[r] = n[t - r - 2], e[r + 1] = n[t - r - 1]; return e } function Kot(n, e, t, r) { for (var i = [], a, o = 0; o < n.length; o++) { var s = n[o], l = e[o], c = vW(s), u = vW(l); a == null && (a = c[2] < 0 != u[2] < 0); var d = [], f = [], h = 0, p = 1 / 0, m = [], g = s.length; a && (s = Wot(s)); for (var y = Got(s, l, c, u) * 6, b = g - 2, w = 0; w < b; w += 2) { var v = (y + w) % b + 2; d[w + 2] = s[v] - c[0], d[w + 3] = s[v + 1] - c[1] } if (d[0] = s[y] - c[0], d[1] = s[y + 1] - c[1], t > 0) for (var S = r / t, x = -r / 2; x <= r / 2; x += S) { for (var k = Math.sin(x), A = Math.cos(x), C = 0, w = 0; w < s.length; w += 2) { var E = d[w], O = d[w + 1], j = l[w] - u[0], I = l[w + 1] - u[1], L = j * A - I * k, R = j * k + I * A; m[w] = L, m[w + 1] = R; var D = L - E, P = R - O; C += D * D + P * P } if (C < p) { p = C, h = x; for (var B = 0; B < m.length; B++)f[B] = m[B] } } else for (var F = 0; F < g; F += 2)f[F] = l[F] - u[0], f[F + 1] = l[F + 1] - u[1]; i.push({ from: d, to: f, fromCp: c, toCp: u, rotation: -h }) } return i } function PT(n) { return n.__isCombineMorphing } var vse = "__mOriginal_"; function IT(n, e, t) { var r = vse + e, i = n[r] || n[e]; n[r] || (n[r] = n[e]); var a = t.replace, o = t.after, s = t.before; n[e] = function () { var l = arguments, c; return s && s.apply(this, l), a ? c = a.apply(this, l) : c = i.apply(this, l), o && o.apply(this, l), c } } function T0(n, e) { var t = vse + e; n[t] && (n[e] = n[t], n[t] = null) } function yW(n, e) { for (var t = 0; t < n.length; t++)for (var r = n[t], i = 0; i < r.length;) { var a = r[i], o = r[i + 1]; r[i++] = e[0] * a + e[2] * o + e[4], r[i++] = e[1] * a + e[3] * o + e[5] } } function yse(n, e) { var t = n.getUpdatedPathProxy(), r = e.getUpdatedPathProxy(), i = Uot(iL(t), iL(r)), a = i[0], o = i[1], s = n.getComputedTransform(), l = e.getComputedTransform(); function c() { this.transform = null } s && yW(a, s), l && yW(o, l), IT(e, "updateTransform", { replace: c }), e.transform = null; var u = Kot(a, o, 10, Math.PI), d = []; IT(e, "buildPath", { replace: function (f) { for (var h = e.__morphT, p = 1 - h, m = [], g = 0; g < u.length; g++) { var y = u[g], b = y.from, w = y.to, v = y.rotation * h, S = y.fromCp, x = y.toCp, k = Math.sin(v), A = Math.cos(v); qx(m, S, x, h); for (var C = 0; C < b.length; C += 2) { var E = b[C], O = b[C + 1], j = w[C], I = w[C + 1], L = E * p + j * h, R = O * p + I * h; d[C] = L * A - R * k + m[0], d[C + 1] = L * k + R * A + m[1] } var D = d[0], P = d[1]; f.moveTo(D, P); for (var C = 2; C < b.length;) { var j = d[C++], I = d[C++], B = d[C++], F = d[C++], K = d[C++], V = d[C++]; D === j && P === I && B === K && F === V ? f.lineTo(K, V) : f.bezierCurveTo(j, I, B, F, K, V), D = K, P = V } } } }) } function EB(n, e, t) { if (!n || !e) return e; var r = t.done, i = t.during; yse(n, e), e.__morphT = 0; function a() { T0(e, "buildPath"), T0(e, "updateTransform"), e.__morphT = -1, e.createPathProxy(), e.dirtyShape() } return e.animateTo({ __morphT: 1 }, rt({ during: function (o) { e.dirtyShape(), i && i(o) }, done: function () { a(), r && r() } }, t)), e } function qot(n, e, t, r, i, a) { var o = 16; n = i === t ? 0 : Math.round(32767 * (n - t) / (i - t)), e = a === r ? 0 : Math.round(32767 * (e - r) / (a - r)); for (var s = 0, l, c = (1 << o) / 2; c > 0; c /= 2) { var u = 0, d = 0; (n & c) > 0 && (u = 1), (e & c) > 0 && (d = 1), s += c * c * (3 * u ^ d), d === 0 && (u === 1 && (n = c - 1 - n, e = c - 1 - e), l = n, n = e, e = l) } return s } function LT(n) { var e = 1 / 0, t = 1 / 0, r = -1 / 0, i = -1 / 0, a = Ae(n, function (s) { var l = s.getBoundingRect(), c = s.getComputedTransform(), u = l.x + l.width / 2 + (c ? c[4] : 0), d = l.y + l.height / 2 + (c ? c[5] : 0); return e = Math.min(u, e), t = Math.min(d, t), r = Math.max(u, r), i = Math.max(d, i), [u, d] }), o = Ae(a, function (s, l) { return { cp: s, z: qot(s[0], s[1], e, t, r, i), path: n[l] } }); return o.sort(function (s, l) { return s.z - l.z }).map(function (s) { return s.path }) } function _se(n) { return Vot(n.path, n.count) } function oL() { return { fromIndividuals: [], toIndividuals: [], count: 0 } } function Yot(n, e, t) { var r = []; function i(S) { for (var x = 0; x < S.length; x++) { var k = S[x]; PT(k) ? i(k.childrenRef()) : k instanceof Nt && r.push(k) } } i(n); var a = r.length; if (!a) return oL(); var o = t.dividePath || _se, s = o({ path: e, count: a }); if (s.length !== a) return console.error("Invalid morphing: unmatched splitted path"), oL(); r = LT(r), s = LT(s); for (var l = t.done, c = t.during, u = t.individualDelay, d = new mc, f = 0; f < a; f++) { var h = r[f], p = s[f]; p.parent = e, p.copyTransform(d), u || yse(h, p) } e.__isCombineMorphing = !0, e.childrenRef = function () { return s }; function m(S) { for (var x = 0; x < s.length; x++)s[x].addSelfToZr(S) } IT(e, "addSelfToZr", { after: function (S) { m(S) } }), IT(e, "removeSelfFromZr", { after: function (S) { for (var x = 0; x < s.length; x++)s[x].removeSelfFromZr(S) } }); function g() { e.__isCombineMorphing = !1, e.__morphT = -1, e.childrenRef = null, T0(e, "addSelfToZr"), T0(e, "removeSelfFromZr") } var y = s.length; if (u) for (var b = y, w = function () { b--, b === 0 && (g(), l && l()) }, f = 0; f < y; f++) { var v = u ? rt({ delay: (t.delay || 0) + u(f, y, r[f], s[f]), done: w }, t) : t; EB(r[f], s[f], v) } else e.__morphT = 0, e.animateTo({ __morphT: 1 }, rt({ during: function (S) { for (var x = 0; x < y; x++) { var k = s[x]; k.__morphT = e.__morphT, k.dirtyShape() } c && c(S) }, done: function () { g(); for (var S = 0; S < n.length; S++)T0(n[S], "updateTransform"); l && l() } }, t)); return e.__zr && m(e.__zr), { fromIndividuals: r, toIndividuals: s, count: y } } function Zot(n, e, t) { var r = e.length, i = [], a = t.dividePath || _se; function o(h) { for (var p = 0; p < h.length; p++) { var m = h[p]; PT(m) ? o(m.childrenRef()) : m instanceof Nt && i.push(m) } } if (PT(n)) { o(n.childrenRef()); var s = i.length; if (s < r) for (var l = 0, c = s; c < r; c++)i.push(zN(i[l++ % s])); i.length = r } else { i = a({ path: n, count: r }); for (var u = n.getComputedTransform(), c = 0; c < i.length; c++)i[c].setLocalTransform(u); if (i.length !== r) return console.error("Invalid morphing: unmatched splitted path"), oL() } i = LT(i), e = LT(e); for (var d = t.individualDelay, c = 0; c < r; c++) { var f = d ? rt({ delay: (t.delay || 0) + d(c, r, i[c], e[c]) }, t) : t; EB(i[c], e[c], f) } return { fromIndividuals: i, toIndividuals: e, count: e.length } } function _W(n) { return ke(n[0]) } function bW(n, e) { for (var t = [], r = n.length, i = 0; i < r; i++)t.push({ one: n[i], many: [] }); for (var i = 0; i < e.length; i++) { var a = e[i].length, o = void 0; for (o = 0; o < a; o++)t[o % r].many.push(e[i][o]) } for (var s = 0, i = r - 1; i >= 0; i--)if (!t[i].many.length) { var l = t[s].many; if (l.length <= 1) if (s) s = 0; else return t; var a = l.length, c = Math.ceil(a / 2); t[i].many = l.slice(c, a), t[s].many = l.slice(0, c), s++ } return t } var Xot = { clone: function (n) { for (var e = [], t = 1 - Math.pow(1 - n.path.style.opacity, 1 / n.count), r = 0; r < n.count; r++) { var i = zN(n.path); i.setStyle("opacity", t), e.push(i) } return e }, split: null }; function SD(n, e, t, r, i, a) { if (!n.length || !e.length) return; var o = Xg("update", r, i); if (!(o && o.duration > 0)) return; var s = r.getModel("universalTransition").get("delay"), l = Object.assign({ setToFinal: !0 }, o), c, u; _W(n) && (c = n, u = e), _W(e) && (c = e, u = n); function d(y, b, w, v, S) { var x = y.many, k = y.one; if (x.length === 1 && !S) { var A = b ? x[0] : k, C = b ? k : x[0]; if (PT(A)) d({ many: [A], one: C }, !0, w, v, !0); else { var E = s ? rt({ delay: s(w, v) }, l) : l; EB(A, C, E), a(A, C, A, C, E) } } else for (var O = rt({ dividePath: Xot[t], individualDelay: s && function (P, B, F, K) { return s(P + w, v) } }, l), j = b ? Yot(x, k, O) : Zot(k, x, O), I = j.fromIndividuals, L = j.toIndividuals, R = I.length, D = 0; D < R; D++) { var E = s ? rt({ delay: s(D, R) }, l) : l; a(I[D], L[D], b ? x[D] : y.one, b ? y.one : x[D], E) } } for (var f = c ? c === n : n.length > e.length, h = c ? bW(u, c) : bW(f ? e : n, [f ? n : e]), p = 0, m = 0; m < h.length; m++)p += h[m].many.length; for (var g = 0, m = 0; m < h.length; m++)d(h[m], f, g, p), g += h[m].many.length } function $f(n) { if (!n) return []; if (ke(n)) { for (var e = [], t = 0; t < n.length; t++)e.push($f(n[t])); return e } var r = []; return n.traverse(function (i) { i instanceof Nt && !i.disableMorphing && !i.invisible && !i.ignore && r.push(i) }), r } var bse = 1e4, Jot = 0, wW = 1, xW = 2, Qot = Kt(); function est(n, e) { for (var t = n.dimensions, r = 0; r < t.length; r++) { var i = n.getDimensionInfo(t[r]); if (i && i.otherDims[e] === 0) return t[r] } } function tst(n, e, t) { var r = n.getDimensionInfo(t), i = r && r.ordinalMeta; if (r) { var a = n.get(r.name, e); return i && i.categories[a] || a + "" } } function SW(n, e, t, r) { var i = r ? "itemChildGroupId" : "itemGroupId", a = est(n, i); if (a) { var o = tst(n, e, a); return o } var s = n.getRawDataItem(e), l = r ? "childGroupId" : "groupId"; if (s && s[l]) return s[l] + ""; if (!r) return t || n.getId(e) } function TW(n) { var e = []; return $(n, function (t) { var r = t.data, i = t.dataGroupId; if (!(r.count() > bse)) for (var a = r.getIndices(), o = 0; o < a.length; o++)e.push({ data: r, groupId: SW(r, o, i, !1), childGroupId: SW(r, o, i, !0), divide: t.divide, dataIndex: o }) }), e } function TD(n, e, t) { n.traverse(function (r) { r instanceof Nt && Un(r, { style: { opacity: 0 } }, e, { dataIndex: t, isFrom: !0 }) }) } function kD(n) { if (n.parent) { var e = n.getComputedTransform(); n.setLocalTransform(e), n.parent.remove(n) } } function sm(n) { n.stopAnimation(), n.isGroup && n.traverse(function (e) { e.stopAnimation() }) } function nst(n, e, t) { var r = Xg("update", t, e); r && n.traverse(function (i) { if (i instanceof Ho) { var a = I6e(i); a && i.animateFrom({ style: a }, r) } }) } function rst(n, e) { var t = n.length; if (t !== e.length) return !1; for (var r = 0; r < t; r++) { var i = n[r], a = e[r]; if (i.data.getId(i.dataIndex) !== a.data.getId(a.dataIndex)) return !1 } return !0 } function wse(n, e, t) { var r = TW(n), i = TW(e); function a(w, v, S, x, k) { (S || w) && v.animateFrom({ style: S && S !== w ? be(be({}, S.style), w.style) : w.style }, k) } var o = !1, s = Jot, l = Ze(), c = Ze(); r.forEach(function (w) { w.groupId && l.set(w.groupId, !0), w.childGroupId && c.set(w.childGroupId, !0) }); for (var u = 0; u < i.length; u++) { var d = i[u].groupId; if (c.get(d)) { s = wW; break } var f = i[u].childGroupId; if (f && l.get(f)) { s = xW; break } } function h(w, v) { return function (S) { var x = S.data, k = S.dataIndex; return v ? x.getId(k) : w ? s === wW ? S.childGroupId : S.groupId : s === xW ? S.childGroupId : S.groupId } } var p = rst(r, i), m = {}; if (!p) for (var u = 0; u < i.length; u++) { var g = i[u], y = g.data.getItemGraphicEl(g.dataIndex); y && (m[y.id] = !0) } function b(w, v) { var S = r[v], x = i[w], k = x.data.hostModel, A = S.data.getItemGraphicEl(S.dataIndex), C = x.data.getItemGraphicEl(x.dataIndex); if (A === C) { C && nst(C, x.dataIndex, k); return } A && m[A.id] || C && (sm(C), A ? (sm(A), kD(A), o = !0, SD($f(A), $f(C), x.divide, k, w, a)) : TD(C, k, w)) } new Lc(r, i, h(!0, p), h(!1, p), null, "multiple").update(b).updateManyToOne(function (w, v) { var S = i[w], x = S.data, k = x.hostModel, A = x.getItemGraphicEl(S.dataIndex), C = pn(Ae(v, function (E) { return r[E].data.getItemGraphicEl(r[E].dataIndex) }), function (E) { return E && E !== A && !m[E.id] }); A && (sm(A), C.length ? ($(C, function (E) { sm(E), kD(E) }), o = !0, SD($f(C), $f(A), S.divide, k, w, a)) : TD(A, k, S.dataIndex)) }).updateOneToMany(function (w, v) { var S = r[v], x = S.data.getItemGraphicEl(S.dataIndex); if (!(x && m[x.id])) { var k = pn(Ae(w, function (C) { return i[C].data.getItemGraphicEl(i[C].dataIndex) }), function (C) { return C && C !== x }), A = i[w[0]].data.hostModel; k.length && ($(k, function (C) { return sm(C) }), x ? (sm(x), kD(x), o = !0, SD($f(x), $f(k), S.divide, A, w[0], a)) : $(k, function (C) { return TD(C, A, w[0]) })) } }).updateManyToMany(function (w, v) { new Lc(v, w, function (S) { return r[S].data.getId(r[S].dataIndex) }, function (S) { return i[S].data.getId(i[S].dataIndex) }).update(function (S, x) { b(w[S], v[x]) }).execute() }).execute(), o && $(e, function (w) { var v = w.data, S = v.hostModel, x = S && t.getViewOfSeriesModel(S), k = Xg("update", S, 0); x && S.isAnimationEnabled() && k && k.duration > 0 && x.group.traverse(function (A) { A instanceof Nt && !A.animators.length && A.animateFrom({ style: { opacity: 0 } }, k) }) }) } function kW(n) { var e = n.getModel("universalTransition").get("seriesKey"); return e || n.id } function CW(n) { return ke(n) ? n.sort().join(",") : n } function Eu(n) { if (n.hostModel) return n.hostModel.getModel("universalTransition").get("divideShape") } function ist(n, e) { var t = Ze(), r = Ze(), i = Ze(); return $(n.oldSeries, function (a, o) { var s = n.oldDataGroupIds[o], l = n.oldData[o], c = kW(a), u = CW(c); r.set(u, { dataGroupId: s, data: l }), ke(c) && $(c, function (d) { i.set(d, { key: u, dataGroupId: s, data: l }) }) }), $(e.updatedSeries, function (a) { if (a.isUniversalTransitionEnabled() && a.isAnimationEnabled()) { var o = a.get("dataGroupId"), s = a.getData(), l = kW(a), c = CW(l), u = r.get(c); if (u) t.set(c, { oldSeries: [{ dataGroupId: u.dataGroupId, divide: Eu(u.data), data: u.data }], newSeries: [{ dataGroupId: o, divide: Eu(s), data: s }] }); else if (ke(l)) { var d = []; $(l, function (p) { var m = r.get(p); m.data && d.push({ dataGroupId: m.dataGroupId, divide: Eu(m.data), data: m.data }) }), d.length && t.set(c, { oldSeries: d, newSeries: [{ dataGroupId: o, data: s, divide: Eu(s) }] }) } else { var f = i.get(l); if (f) { var h = t.get(f.key); h || (h = { oldSeries: [{ dataGroupId: f.dataGroupId, data: f.data, divide: Eu(f.data) }], newSeries: [] }, t.set(f.key, h)), h.newSeries.push({ dataGroupId: o, data: s, divide: Eu(s) }) } } } }), t } function AW(n, e) { for (var t = 0; t < n.length; t++) { var r = e.seriesIndex != null && e.seriesIndex === n[t].seriesIndex || e.seriesId != null && e.seriesId === n[t].id; if (r) return t } } function ast(n, e, t, r) { var i = [], a = []; $(Cn(n.from), function (o) { var s = AW(e.oldSeries, o); s >= 0 && i.push({ dataGroupId: e.oldDataGroupIds[s], data: e.oldData[s], divide: Eu(e.oldData[s]), groupIdDim: o.dimension }) }), $(Cn(n.to), function (o) { var s = AW(t.updatedSeries, o); if (s >= 0) { var l = t.updatedSeries[s].getData(); a.push({ dataGroupId: e.oldDataGroupIds[s], data: l, divide: Eu(l), groupIdDim: o.dimension }) } }), i.length > 0 && a.length > 0 && wse(i, a, r) } function ost(n) { n.registerUpdateLifecycle("series:beforeupdate", function (e, t, r) { $(Cn(r.seriesTransition), function (i) { $(Cn(i.to), function (a) { for (var o = r.updatedSeries, s = 0; s < o.length; s++)(a.seriesIndex != null && a.seriesIndex === o[s].seriesIndex || a.seriesId != null && a.seriesId === o[s].id) && (o[s][oS] = !0) }) }) }), n.registerUpdateLifecycle("series:transition", function (e, t, r) { var i = Qot(t); if (i.oldSeries && r.updatedSeries && r.optionChanged) { var a = r.seriesTransition; if (a) $(Cn(a), function (h) { ast(h, i, r, t) }); else { var o = ist(i, r); $(o.keys(), function (h) { var p = o.get(h); wse(p.oldSeries, p.newSeries, t) }) } $(r.updatedSeries, function (h) { h[oS] && (h[oS] = !1) }) } for (var s = e.getSeries(), l = i.oldSeries = [], c = i.oldDataGroupIds = [], u = i.oldData = [], d = 0; d < s.length; d++) { var f = s[d].getData(); f.count() < bse && (l.push(s[d]), c.push(s[d].get("dataGroupId")), u.push(f)) } }) } It([_Ge]); It([fGe]); It([HGe, sWe, bWe, sKe, TKe, yqe, Yqe, LYe, cZe, yZe, MZe, PXe, oJe, _Je, $Je, WJe, uQe, bQe, PQe, zQe, eet, zet]); It(utt); It(Utt); It(gae); It(snt); It(noe); It(pnt); It(Snt); It(Trt); It(Krt); It(Bb); It(hit); It(git); It(Dit); It(zit); It(Yit); It(rat); It(vat); It($at); It(sse); It(lse); It(fot); It(hse); It(pse); It(vot); It(Oot); It(Pot); It(ost); It(OUe); async function sst(n, e, t = {}) {
  e || (e = {}); let r = Object.assign({ Accept: "application/json", "Content-Type": "application/json; charset=utf-8", "X-Frappe-Site-Name": window.location.hostname }, t.headers || {}); window.csrf_token && window.csrf_token !== "{{ csrf_token }}" && (r["X-Frappe-CSRF-Token"] = window.csrf_token); let i = n.startsWith("/") ? n : `/api/method/${n}`; const a = await fetch(i, { method: "POST", headers: r, body: JSON.stringify(e) }); if (a.ok) { const o = await a.json(); if (o.docs || n === "login") return o; if (o.exc) try { console.groupCollapsed(n), console.log(`method: ${n}`), console.log("params:", e); let s = JSON.parse(o.exc); for (let l of s) console.log(l); console.groupEnd() } catch (s) { console.warn("Error printing debug messages", s) } return o.message } else {
    let o = await a.text(), s, l; try { s = JSON.parse(o) } catch { } let c = [[n, s.exc_type, s._error_message].filter(Boolean).join(" ")]; if (s.exc) { l = s.exc; try { l = JSON.parse(l)[0], console.log(l) } catch { } } let u = new Error(c.join(`
`)); throw u.exc_type = s.exc_type, u.exc = l, u.status = a.status, u.messages = s._server_messages ? JSON.parse(s._server_messages) : [], u.messages = u.messages.concat(s.message), u.messages = u.messages.map(d => { try { return JSON.parse(d).message } catch { return d } }), u.messages = u.messages.filter(Boolean), u.messages.length || (u.messages = s._error_message ? [s._error_message] : ["Internal Server Error"]), t.onError && t.onError({ response: a, status: a.status, error: u }), u
  }
} const lst = n => new Promise((e, t) => { const r = new FileReader; r.onloadend = () => { r.result == null ? t(new Error("FileReader result is null")) : typeof r.result == "string" && e(r.result) }, r.readAsDataURL(n) }); let Qm = document.querySelector('link[rel="icon"]'), cst = Qm == null ? void 0 : Qm.href; function oft(n) { Ct(() => { try { return n() } catch { return null } }, e => { if (e) if (e.title && (document.title = e.title), e.emoji) { let t = `data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>${e.emoji}</text></svg>`; Qm.href = t } else e.icon ? Qm.href = e.icon : Qm.href = cst }, { immediate: !0, deep: !0 }) } function xse(n) { let e = Object.assign({}, n); if (!e.url) throw new Error("[request] options.url is required"); e.transformRequest && (e = e.transformRequest(n)), e.responseType || (e.responseType = "json"), e.method || (e.method = "GET"); let t = e.url, r; if (e.params) if (e.method === "GET") { let i = new URLSearchParams; for (let a in e.params) i.append(a, e.params[a]); t = e.url + "?" + i.toString() } else r = JSON.stringify(e.params); return fetch(t, { method: e.method || "GET", headers: e.headers, body: r }).then(i => { if (e.transformResponse) return e.transformResponse(i, e); if (i.status >= 200 && i.status < 300) return e.responseType === "json" ? i.json() : i; { let a = new Error(i.statusText); throw a.response = i, a } }).catch(i => { if (e.transformError) return e.transformError(i); throw i }) } function fp(n) { return new Promise((e, t) => { n.oncomplete = n.onsuccess = () => e(n.result), n.onabort = n.onerror = () => t(n.error) }) } function ust(n, e) { const t = indexedDB.open(n); t.onupgradeneeded = () => t.result.createObjectStore(e); const r = fp(t); return (i, a) => r.then(o => a(o.transaction(e, i).objectStore(e))) } let CD; function $b() { return CD || (CD = ust("keyval-store", "keyval")), CD } function Sse(n, e = $b()) { return e("readonly", t => fp(t.get(n))) } function Tse(n, e, t = $b()) { return t("readwrite", r => (r.put(e, n), fp(r.transaction))) } function dst(n, e = $b()) { return e("readwrite", t => (n.forEach(r => t.put(r[1], r[0])), fp(t.transaction))) } function kse(n, e = $b()) { return e("readwrite", t => (t.delete(n), fp(t.transaction))) } function fst(n, e) { return n.openCursor().onsuccess = function () { this.result && (e(this.result), this.result.continue()) }, fp(n.transaction) } function hst(n = $b()) { return n("readonly", e => { if (e.getAllKeys) return fp(e.getAllKeys()); const t = []; return fst(e, r => t.push(r.key)).then(() => t) }) } function MB(n, e) { return typeof indexedDB > "u" ? Promise.resolve(null) : n ? Tse(n, JSON.stringify(e)) : Promise.resolve() } function pst(n) { return typeof indexedDB > "u" ? Promise.resolve(null) : n ? kse(n) : Promise.resolve() } function OB(n) { return typeof indexedDB > "u" ? Promise.resolve(null) : Sse(n).then(e => e && JSON.parse(e)) } let hS = {}; function Yr(n, e) { let t = null; if (n.cache) { t = cv(n.cache); let d = hS[t]; if (d) return d.auto && d.reload(), d } typeof n == "string" && (n = { url: n, auto: !0 }); let r = n.debounce ? _k(a, n.debounce) : a, i = vr({ method: n.method, url: n.url, data: n.initialData || null, previousData: null, loading: !1, fetched: !1, error: null, promise: null, auto: n.auto, params: null, fetch: r, reload: r, submit: r, reset: s, update: o, setData: c }); async function a(d, f = {}) { let h = n.resourceFetcher || Xi("resourceFetcher") || xse; d instanceof Event && (d = null), d = d || i.params, n.makeParams && (d = n.makeParams.call(e, d)), i.params = d, i.previousData = i.data ? JSON.parse(JSON.stringify(i.data)) : null, i.loading = !0, i.error = null, n.onFetch && n.onFetch.call(e, i.params); let p = [n.beforeSubmit, f.beforeSubmit]; for (let w of p) w && w.call(e, i.params); let m = f.validate || n.validate, g = [n.onError, f.onError], y = [n.onSuccess, f.onSuccess], b = [n.onData, f.onData]; if (m) { let w; try { if (w = await m.call(e, i.params), w && typeof w == "string") throw new Error(w) } catch (v) { l(v, g); return } } try { i.promise = h({ ...n, params: d || n.params }); let w = await i.promise; MB(t, w), i.data = u(w), i.fetched = !0; for (let v of y) v && v.call(e, w); for (let v of b) v && v.call(e, w) } catch (w) { l(w, g) } return i.loading = !1, i.data } function o({ method: d, url: f, params: h, auto: p }) { d && d !== n.method && (i.method = d), f && f !== n.url && (i.url = f), h && h !== n.params && (i.params = h), p !== void 0 && p !== i.auto && (i.auto = p) } function s() { i.data = n.initialData || null, i.previousData = null, i.loading = !1, i.fetched = !1, i.error = null, i.params = null, i.auto = n.auto } function l(d, f) { i.loading = !1, i.previousData && (i.data = i.previousData), i.error = d; for (let h of f) h && h.call(e, d); if (f.every(h => h == null)) { let h = Xi("fallbackErrorHandler"); if (h) try { h(d) } catch (p) { console.warn("Error in fallbackErrorHandler", p) } } throw d } function c(d) { typeof d == "function" && (d = d.call(e, i.data)), i.data = u(d) } function u(d) { if (n.transform) { let f = n.transform.call(e, d); if (f != null) return f } return d } return t && !hS[t] && (hS[t] = i, OB(t).then(d => { var f; (i.loading || !i.fetched) && d && (c(d), (f = n.onData) == null || f.call(e, d)) })), n.auto && i.fetch(), i } function cv(n) { return n ? (typeof n == "string" && (n = [n]), JSON.stringify(n)) : null } function Cse(n) { return n = cv(n), hS[n] || null } function Ase(n, e, t) { mst(n, e), n.on("list_update", r => { r.doctype == e && t(r.name) }) } let EW = {}; function mst(n, e) { EW[e] || (n.emit("doctype_subscribe", e), EW[e] = !0) } let sL = vr({}), eg = {}; function gst(n, e) { var y, b, w, v, S; if (!n.doctype) throw new Error("List resource requires doctype"); let t = cv(n.cache); if (t) { let x = sL[t]; if (x) return x.auto && x.reload(), x } let r = Xi("defaultListUrl") || "frappe.client.get_list", i = Xi("defaultDocInsertUrl") || "frappe.client.insert", a = Xi("defaultDocUpdateUrl") || "frappe.client.set_value", o = Xi("defaultDocDeleteUrl") || "frappe.client.delete", s = Xi("defaultRunDocMethodUrl") || "run_doc_method", l = vr({ doctype: n.doctype, fields: n.fields, filters: n.filters, orFilters: n.orFilters, orderBy: n.orderBy, start: n.start || 0, pageLength: n.pageLength || 20, groupBy: n.groupBy, parent: n.parent, debug: n.debug || 0, originalData: null, dataMap: {}, data: null, previous: p, hasPreviousPage: !1, next: m, hasNextPage: !0, auto: n.auto, list: Yr({ url: n.url || r, makeParams() { return { doctype: l.doctype, fields: l.fields, filters: l.filters, or_filters: l.orFilters, order_by: l.orderBy, start: l.start, limit: l.pageLength, limit_start: l.start, limit_page_length: l.pageLength, group_by: l.groupBy, parent: l.parent, debug: l.debug } }, onSuccess(x) { var A; l.hasPreviousPage = !!l.start, l.hasNextPage = !(x.length < l.pageLength); let k; !l.start || l.start == 0 ? k = x : l.start > 0 && (k = l.originalData.concat(x)), MB(t, k), h(k), (A = n.onSuccess) == null || A.call(e, l.data) }, onError: n.onError }, e), fetchOne: Yr({ url: n.url || r, makeParams(x) { return { doctype: l.doctype, fields: l.fields || "*", filters: { name: x } } }, onSuccess(x) { var k, A; if (x.length > 0 && l.originalData) { let C = x[0]; k0(l.doctype, C) } (A = (k = n.fetchOne) == null ? void 0 : k.onSuccess) == null || A.call(e, l.data) }, onError: (y = n.fetchOne) == null ? void 0 : y.onError }, e), insert: Yr({ url: i, makeParams(x) { return { doc: { doctype: l.doctype, ...x } } }, onSuccess(x) { var k, A; l.list.fetch(), (A = (k = n.insert) == null ? void 0 : k.onSuccess) == null || A.call(e, x) }, onError: (b = n.insert) == null ? void 0 : b.onError }, e), setValue: Yr({ url: a, makeParams(x) { let { name: k, ...A } = x; return { doctype: l.doctype, name: k, fieldname: A } }, onSuccess(x) { var k, A; k0(l.doctype, x), (A = (k = n.setValue) == null ? void 0 : k.onSuccess) == null || A.call(e, x) }, onError: (w = n.setValue) == null ? void 0 : w.onError }, e), delete: Yr({ url: o, makeParams(x) { return { doctype: l.doctype, name: x } }, onSuccess(x) { var k, A; l.list.fetch(), (A = (k = n.delete) == null ? void 0 : k.onSuccess) == null || A.call(e, x) }, onError: (v = n.delete) == null ? void 0 : v.onError }, e), runDocMethod: Yr({ url: s, makeParams({ method: x, name: k, ...A }) { return { dt: l.doctype, dn: k, method: x, args: A } }, onSuccess(x) { var k, A; if (x.docs) for (let C of x.docs) k0(C.doctype, C); (A = (k = n.runDocMethod) == null ? void 0 : k.onSuccess) == null || A.call(e, x) }, onError: (S = n.runDocMethod) == null ? void 0 : S.onError }, e), update: c, fetch: f, reload: d, setData: h, transform: u, getRow: g }); function c(x) { Object.assign(l, x) } function u(x) { if (n.transform) { let k = n.transform.call(e, x); if (k != null) return k } return x } function d() { let x = l.start, k = l.pageLength; return l.start > 0 && (l.start = 0, l.pageLength = l.originalData.length), l.list.fetch().finally(() => { l.start = x, l.pageLength = k }) } function f() { d() } function h(x) { if (l.originalData = x, typeof x == "function" && (x = x.call(e, l.data)), l.data = u(x), Array.isArray(l.data)) { l.dataMap = {}; for (let k of l.data) { if (!k.name) continue; let A = k.name.toString(); l.dataMap[A] = k } } } function p() { l.start = l.start - l.pageLength, l.list.fetch() } function m() { l.start = l.start + l.pageLength, l.list.fetch() } function g(x) { let k = x.toString(); return l.dataMap[k] } return n.realtime && (e != null && e.$socket) && Ase(e.$socket, l.doctype, x => { var k; (k = l.originalData) != null && k.find(A => A.name === x) && l.fetchOne.submit(x) }), t && (sL[t] = l, OB(t).then(x => { var k; (l.list.loading || !l.list.fetched) && x && (h(x), (k = n.onData) == null || k.call(e, x)) })), n.auto && l.list.fetch(), eg[l.doctype] = eg[l.doctype] || [], eg[l.doctype].push(l), l } function Ese(n) { return n = cv(n), sL[n] || null } function k0(n, e) { if (!e.name) return; let t = eg[n] || []; for (let r of t) if (r.originalData) { for (let i of r.originalData) if (i.name && i.name == e.name) { delete i._previousData; let a = JSON.stringify(i); for (let o in i) o in e && (i[o] = e[o]); i._previousData = a } r.data = r.transform(r.originalData) } } function vst(n, e) { let t = eg[n] || []; for (let r of t) r.originalData && (r.originalData = r.originalData.filter(i => i.name.toString() !== e.toString()), r.data = r.transform(r.originalData)) } function yst(n, e) { let t = eg[n] || []; for (let r of t) if (r.originalData) { for (let i of r.originalData) if (i.name && i.name == e.name) { let a = JSON.parse(i._previousData); for (let o in i) i[o] = a[o]; delete i._previousData } r.data = r.transform(r.originalData) } } let lL = vr({}); function _st(n, e) { var p; if (!(n.doctype && n.name)) return; let t = cv([n.doctype, n.name]), r = lL[t]; if (r) return r.auto && r.reload(), r; let i = Xi("defaultDocGetUrl") || "frappe.client.get", a = Xi("defaultDocUpdateUrl") || "frappe.client.set_value", o = Xi("defaultDocDeleteUrl") || "frappe.client.delete", s = Xi("defaultRunDocMethodUrl") || "run_doc_method", l = { url: a, makeParams(m) { return { doctype: u.doctype, name: u.name, fieldname: m } }, beforeSubmit(m) { u.previousDoc = JSON.stringify(u.doc), Object.assign(u.doc, m.fieldname || {}), k0(u.doctype, u.doc) }, onSuccess(m) { var g, y; u.doc = h(m), u.originalDoc = JSON.parse(JSON.stringify(u.doc)), (y = (g = n.setValue) == null ? void 0 : g.onSuccess) == null || y.call(e, m) }, onError(m) { var g, y; u.doc = JSON.parse(u.previousDoc), (y = (g = n.setValue) == null ? void 0 : g.onError) == null || y.call(e, m), yst(u.doctype, u.doc) } }; const c = n.auto !== void 0; let u = vr({ doctype: n.doctype, name: n.name, doc: null, originalDoc: null, isDirty: !1, auto: c ? n.auto : !0, get: Yr({ url: i, makeParams() { return { doctype: u.doctype, name: u.name } }, onSuccess(m) { var g; MB(t, m), u.doc = h(m), u.originalDoc = JSON.parse(JSON.stringify(u.doc)), (g = n.onSuccess) == null || g.call(e, u.doc) }, onError(m) { var g; pst(t), u.doc = null, u.originalDoc = null, (g = n.onError) == null || g.call(e, m) } }, e), setValue: Yr(l, e), setValueDebounced: Yr({ ...l, debounce: n.debounce || 500 }, e), save: Yr({ ...l, makeParams() { let m = JSON.parse(JSON.stringify(u.doc)); return delete m.doctype, delete m.name, { doctype: u.doctype, name: u.name, fieldname: m } } }, e), delete: Yr({ url: o, makeParams() { return { doctype: u.doctype, name: u.name } }, onSuccess() { var m, g; u.doc = null, (g = (m = n.delete) == null ? void 0 : m.onSuccess) == null || g.call(e), vst(u.doctype, u.name) }, onError: (p = n.delete) == null ? void 0 : p.onError }, e), reload: d, setDoc: f }); Ct(() => u.doc, () => { u.isDirty = JSON.stringify(u.doc) !== JSON.stringify(u.originalDoc) }, { deep: !0 }); for (let m in n.whitelistedMethods) { let g = n.whitelistedMethods[m]; typeof g == "string" && (g = { method: g }); let { method: y, onSuccess: b, makeParams: w, transform: v, ...S } = g; u[m] = Yr({ url: s, makeParams(x) { return x = w ? w.call(e, x) : x, { dt: u.doctype, dn: u.name, method: y, args: x } }, transform(x) { if (v) { let k = v.call(e, x.message); if (k != null) return k } return x.message }, onSuccess(x) { if (x.docs) { for (let k of x.docs) if (k.doctype === u.doctype && k.name.toString() === u.name.toString()) { u.doc = h(k), k0(u.doctype, u.doc); break } } b == null || b.call(e, x.message) }, ...S }, e) } function d() { return u.get.fetch() } function f(m) { typeof m == "function" && (m = m.call(e, u.doc)), u.doc = h(m) } function h(m) { if (n.transform) { let g = n.transform.call(e, m); if (typeof g == "object") return g } return m } return n.realtime && e.$socket && Ase(e.$socket, u.doctype, m => { m == u.name && u.get.fetch() }), lL[t] = u, OB(t).then(m => { (u.get.loading || !u.get.fetched) && m && (u.doc = h(m)) }), u.auto && u.get.fetch(), u } function bst(n, e) { let t = cv([n, e]); return lL[t] || null } let wst = n => ({
  created() {
    if (this.$options.resources) {
      this._resources = vr({}); for (let e in this.$options.resources) {
        let t = this.$options.resources[e]; if (typeof t == "function") Ct(() => {
          let r = null; try { r = t.call(this) } catch (i) {
            console.warn(`Failed to get resource options

`, i), r = null
          } return r
        }, (r, i) => { !r || !(!i || JSON.stringify(r) !== JSON.stringify(i)) || (this._resources[e] = MW(r, this)) }, { immediate: !0, deep: !0 }); else { let r = MW(t, this); this._resources[e] = r }
      }
    }
  }, methods: { $getResource(e) { return Cse(e) }, $getDocumentResource(e, t) { return bst(e, t) }, $getDoc(e, t) { let r = this.$getDocumentResource(e, t); return r ? r.doc : null }, $getListResource(e) { return Ese(e) }, $refetchResource(e) { let t = this.$getResource(e); t && t.fetch() } }, computed: { $resources() { return this._resources } }
}); function MW(n, e) { return n.type === "document" ? _st(n, e) : n.type === "list" ? gst(n, e) : Yr(n, e) } const xst = { install(n, e) { let t = wst(); n.mixin(t) } }; function Sst(n) {
  return xse({
    ...n, transformRequest: (e = {}) => { if (!e.url) throw new Error("[frappeRequest] options.url is required"); let t = Object.assign({ Accept: "application/json", "Content-Type": "application/json; charset=utf-8", "X-Frappe-Site-Name": window.location.hostname }, e.headers || {}); return window.csrf_token && window.csrf_token !== "{{ csrf_token }}" && (t["X-Frappe-CSRF-Token"] = window.csrf_token), !e.url.startsWith("/") && !e.url.startsWith("http") && (e.url = "/api/method/" + e.url), { ...e, method: e.method || "POST", headers: t } }, transformResponse: async (e, t) => {
      let r = t.url; if (e.ok) { const i = await e.json(); if (i.docs || r === "/api/method/login") return i; if (i.exc) try { console.groupCollapsed(r), console.log(t); let a = JSON.parse(i.exc); for (let o of a) console.log(o); console.groupEnd() } catch (a) { console.warn("Error printing debug messages", a) } return i.message } else {
        let i = await e.text(), a, o; try { a = JSON.parse(i) } catch { } let s = [[t.url, a.exc_type, a._error_message].filter(Boolean).join(" ")]; if (a.exc) { o = a.exc; try { o = JSON.parse(o)[0], console.log(o) } catch { } } let l = new Error(s.join(`
`)); throw l.exc_type = a.exc_type, l.exc = o, l.response = e, l.status = i.status, l.messages = a._server_messages ? JSON.parse(a._server_messages) : [], l.messages = l.messages.concat(a.message), l.messages = l.messages.map(c => { try { return JSON.parse(c).message } catch { return c } }), l.messages = l.messages.filter(Boolean), l.messages.length || (l.messages = a._error_message ? [a._error_message] : ["Internal Server Error"]), t.onError && t.onError(l), l
      }
    }, transformError: e => { throw n.onError && n.onError(e), e }
  })
} const Al = Object.create(null); Al.open = "0"; Al.close = "1"; Al.ping = "2"; Al.pong = "3"; Al.message = "4"; Al.upgrade = "5"; Al.noop = "6"; const pS = Object.create(null); Object.keys(Al).forEach(n => { pS[Al[n]] = n }); const cL = { type: "error", data: "parser error" }, Mse = typeof Blob == "function" || typeof Blob < "u" && Object.prototype.toString.call(Blob) === "[object BlobConstructor]", Ose = typeof ArrayBuffer == "function", Dse = n => typeof ArrayBuffer.isView == "function" ? ArrayBuffer.isView(n) : n && n.buffer instanceof ArrayBuffer, DB = ({ type: n, data: e }, t, r) => Mse && e instanceof Blob ? t ? r(e) : OW(e, r) : Ose && (e instanceof ArrayBuffer || Dse(e)) ? t ? r(e) : OW(new Blob([e]), r) : r(Al[n] + (e || "")), OW = (n, e) => { const t = new FileReader; return t.onload = function () { const r = t.result.split(",")[1]; e("b" + (r || "")) }, t.readAsDataURL(n) }; function DW(n) { return n instanceof Uint8Array ? n : n instanceof ArrayBuffer ? new Uint8Array(n) : new Uint8Array(n.buffer, n.byteOffset, n.byteLength) } let AD; function Tst(n, e) { if (Mse && n.data instanceof Blob) return n.data.arrayBuffer().then(DW).then(e); if (Ose && (n.data instanceof ArrayBuffer || Dse(n.data))) return e(DW(n.data)); DB(n, !1, t => { AD || (AD = new TextEncoder), e(AD.encode(t)) }) } const jW = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", Ly = typeof Uint8Array > "u" ? [] : new Uint8Array(256); for (let n = 0; n < jW.length; n++)Ly[jW.charCodeAt(n)] = n; const kst = n => { let e = n.length * .75, t = n.length, r, i = 0, a, o, s, l; n[n.length - 1] === "=" && (e--, n[n.length - 2] === "=" && e--); const c = new ArrayBuffer(e), u = new Uint8Array(c); for (r = 0; r < t; r += 4)a = Ly[n.charCodeAt(r)], o = Ly[n.charCodeAt(r + 1)], s = Ly[n.charCodeAt(r + 2)], l = Ly[n.charCodeAt(r + 3)], u[i++] = a << 2 | o >> 4, u[i++] = (o & 15) << 4 | s >> 2, u[i++] = (s & 3) << 6 | l & 63; return c }, Cst = typeof ArrayBuffer == "function", jB = (n, e) => { if (typeof n != "string") return { type: "message", data: jse(n, e) }; const t = n.charAt(0); return t === "b" ? { type: "message", data: Ast(n.substring(1), e) } : pS[t] ? n.length > 1 ? { type: pS[t], data: n.substring(1) } : { type: pS[t] } : cL }, Ast = (n, e) => { if (Cst) { const t = kst(n); return jse(t, e) } else return { base64: !0, data: n } }, jse = (n, e) => { switch (e) { case "blob": return n instanceof Blob ? n : new Blob([n]); case "arraybuffer": default: return n instanceof ArrayBuffer ? n : n.buffer } }, Pse = String.fromCharCode(30), Est = (n, e) => { const t = n.length, r = new Array(t); let i = 0; n.forEach((a, o) => { DB(a, !1, s => { r[o] = s, ++i === t && e(r.join(Pse)) }) }) }, Mst = (n, e) => { const t = n.split(Pse), r = []; for (let i = 0; i < t.length; i++) { const a = jB(t[i], e); if (r.push(a), a.type === "error") break } return r }; function Ost() { return new TransformStream({ transform(n, e) { Tst(n, t => { const r = t.length; let i; if (r < 126) i = new Uint8Array(1), new DataView(i.buffer).setUint8(0, r); else if (r < 65536) { i = new Uint8Array(3); const a = new DataView(i.buffer); a.setUint8(0, 126), a.setUint16(1, r) } else { i = new Uint8Array(9); const a = new DataView(i.buffer); a.setUint8(0, 127), a.setBigUint64(1, BigInt(r)) } n.data && typeof n.data != "string" && (i[0] |= 128), e.enqueue(i), e.enqueue(t) }) } }) } let ED; function Cx(n) { return n.reduce((e, t) => e + t.length, 0) } function Ax(n, e) { if (n[0].length === e) return n.shift(); const t = new Uint8Array(e); let r = 0; for (let i = 0; i < e; i++)t[i] = n[0][r++], r === n[0].length && (n.shift(), r = 0); return n.length && r < n[0].length && (n[0] = n[0].slice(r)), t } function Dst(n, e) { ED || (ED = new TextDecoder); const t = []; let r = 0, i = -1, a = !1; return new TransformStream({ transform(o, s) { for (t.push(o); ;) { if (r === 0) { if (Cx(t) < 1) break; const l = Ax(t, 1); a = (l[0] & 128) === 128, i = l[0] & 127, i < 126 ? r = 3 : i === 126 ? r = 1 : r = 2 } else if (r === 1) { if (Cx(t) < 2) break; const l = Ax(t, 2); i = new DataView(l.buffer, l.byteOffset, l.length).getUint16(0), r = 3 } else if (r === 2) { if (Cx(t) < 8) break; const l = Ax(t, 8), c = new DataView(l.buffer, l.byteOffset, l.length), u = c.getUint32(0); if (u > Math.pow(2, 53 - 32) - 1) { s.enqueue(cL); break } i = u * Math.pow(2, 32) + c.getUint32(4), r = 3 } else { if (Cx(t) < i) break; const l = Ax(t, i); s.enqueue(jB(a ? l : ED.decode(l), e)), r = 0 } if (i === 0 || i > n) { s.enqueue(cL); break } } } }) } const Ise = 4; function Mr(n) { if (n) return jst(n) } function jst(n) { for (var e in Mr.prototype) n[e] = Mr.prototype[e]; return n } Mr.prototype.on = Mr.prototype.addEventListener = function (n, e) { return this._callbacks = this._callbacks || {}, (this._callbacks["$" + n] = this._callbacks["$" + n] || []).push(e), this }; Mr.prototype.once = function (n, e) { function t() { this.off(n, t), e.apply(this, arguments) } return t.fn = e, this.on(n, t), this }; Mr.prototype.off = Mr.prototype.removeListener = Mr.prototype.removeAllListeners = Mr.prototype.removeEventListener = function (n, e) { if (this._callbacks = this._callbacks || {}, arguments.length == 0) return this._callbacks = {}, this; var t = this._callbacks["$" + n]; if (!t) return this; if (arguments.length == 1) return delete this._callbacks["$" + n], this; for (var r, i = 0; i < t.length; i++)if (r = t[i], r === e || r.fn === e) { t.splice(i, 1); break } return t.length === 0 && delete this._callbacks["$" + n], this }; Mr.prototype.emit = function (n) { this._callbacks = this._callbacks || {}; for (var e = new Array(arguments.length - 1), t = this._callbacks["$" + n], r = 1; r < arguments.length; r++)e[r - 1] = arguments[r]; if (t) { t = t.slice(0); for (var r = 0, i = t.length; r < i; ++r)t[r].apply(this, e) } return this }; Mr.prototype.emitReserved = Mr.prototype.emit; Mr.prototype.listeners = function (n) { return this._callbacks = this._callbacks || {}, this._callbacks["$" + n] || [] }; Mr.prototype.hasListeners = function (n) { return !!this.listeners(n).length }; const DC = (() => typeof Promise == "function" && typeof Promise.resolve == "function" ? e => Promise.resolve().then(e) : (e, t) => t(e, 0))(), xo = (() => typeof self < "u" ? self : typeof window < "u" ? window : Function("return this")())(), Pst = "arraybuffer"; function Lse(n, ...e) { return e.reduce((t, r) => (n.hasOwnProperty(r) && (t[r] = n[r]), t), {}) } const Ist = xo.setTimeout, Lst = xo.clearTimeout; function jC(n, e) { e.useNativeTimers ? (n.setTimeoutFn = Ist.bind(xo), n.clearTimeoutFn = Lst.bind(xo)) : (n.setTimeoutFn = xo.setTimeout.bind(xo), n.clearTimeoutFn = xo.clearTimeout.bind(xo)) } const Rst = 1.33; function Nst(n) { return typeof n == "string" ? Bst(n) : Math.ceil((n.byteLength || n.size) * Rst) } function Bst(n) { let e = 0, t = 0; for (let r = 0, i = n.length; r < i; r++)e = n.charCodeAt(r), e < 128 ? t += 1 : e < 2048 ? t += 2 : e < 55296 || e >= 57344 ? t += 3 : (r++, t += 4); return t } function Rse() { return Date.now().toString(36).substring(3) + Math.random().toString(36).substring(2, 5) } function $st(n) { let e = ""; for (let t in n) n.hasOwnProperty(t) && (e.length && (e += "&"), e += encodeURIComponent(t) + "=" + encodeURIComponent(n[t])); return e } function Fst(n) { let e = {}, t = n.split("&"); for (let r = 0, i = t.length; r < i; r++) { let a = t[r].split("="); e[decodeURIComponent(a[0])] = decodeURIComponent(a[1]) } return e } class zst extends Error { constructor(e, t, r) { super(e), this.description = t, this.context = r, this.type = "TransportError" } } class PB extends Mr { constructor(e) { super(), this.writable = !1, jC(this, e), this.opts = e, this.query = e.query, this.socket = e.socket, this.supportsBinary = !e.forceBase64 } onError(e, t, r) { return super.emitReserved("error", new zst(e, t, r)), this } open() { return this.readyState = "opening", this.doOpen(), this } close() { return (this.readyState === "opening" || this.readyState === "open") && (this.doClose(), this.onClose()), this } send(e) { this.readyState === "open" && this.write(e) } onOpen() { this.readyState = "open", this.writable = !0, super.emitReserved("open") } onData(e) { const t = jB(e, this.socket.binaryType); this.onPacket(t) } onPacket(e) { super.emitReserved("packet", e) } onClose(e) { this.readyState = "closed", super.emitReserved("close", e) } pause(e) { } createUri(e, t = {}) { return e + "://" + this._hostname() + this._port() + this.opts.path + this._query(t) } _hostname() { const e = this.opts.hostname; return e.indexOf(":") === -1 ? e : "[" + e + "]" } _port() { return this.opts.port && (this.opts.secure && +(this.opts.port !== 443) || !this.opts.secure && Number(this.opts.port) !== 80) ? ":" + this.opts.port : "" } _query(e) { const t = $st(e); return t.length ? "?" + t : "" } } class Vst extends PB { constructor() { super(...arguments), this._polling = !1 } get name() { return "polling" } doOpen() { this._poll() } pause(e) { this.readyState = "pausing"; const t = () => { this.readyState = "paused", e() }; if (this._polling || !this.writable) { let r = 0; this._polling && (r++, this.once("pollComplete", function () { --r || t() })), this.writable || (r++, this.once("drain", function () { --r || t() })) } else t() } _poll() { this._polling = !0, this.doPoll(), this.emitReserved("poll") } onData(e) { const t = r => { if (this.readyState === "opening" && r.type === "open" && this.onOpen(), r.type === "close") return this.onClose({ description: "transport closed by the server" }), !1; this.onPacket(r) }; Mst(e, this.socket.binaryType).forEach(t), this.readyState !== "closed" && (this._polling = !1, this.emitReserved("pollComplete"), this.readyState === "open" && this._poll()) } doClose() { const e = () => { this.write([{ type: "close" }]) }; this.readyState === "open" ? e() : this.once("open", e) } write(e) { this.writable = !1, Est(e, t => { this.doWrite(t, () => { this.writable = !0, this.emitReserved("drain") }) }) } uri() { const e = this.opts.secure ? "https" : "http", t = this.query || {}; return this.opts.timestampRequests !== !1 && (t[this.opts.timestampParam] = Rse()), !this.supportsBinary && !t.sid && (t.b64 = 1), this.createUri(e, t) } } let Nse = !1; try { Nse = typeof XMLHttpRequest < "u" && "withCredentials" in new XMLHttpRequest } catch { } const Hst = Nse; function Ust() { } class Gst extends Vst { constructor(e) { if (super(e), typeof location < "u") { const t = location.protocol === "https:"; let r = location.port; r || (r = t ? "443" : "80"), this.xd = typeof location < "u" && e.hostname !== location.hostname || r !== e.port } } doWrite(e, t) { const r = this.request({ method: "POST", data: e }); r.on("success", t), r.on("error", (i, a) => { this.onError("xhr post error", i, a) }) } doPoll() { const e = this.request(); e.on("data", this.onData.bind(this)), e.on("error", (t, r) => { this.onError("xhr poll error", t, r) }), this.pollXhr = e } } class gl extends Mr { constructor(e, t, r) { super(), this.createRequest = e, jC(this, r), this._opts = r, this._method = r.method || "GET", this._uri = t, this._data = r.data !== void 0 ? r.data : null, this._create() } _create() { var e; const t = Lse(this._opts, "agent", "pfx", "key", "passphrase", "cert", "ca", "ciphers", "rejectUnauthorized", "autoUnref"); t.xdomain = !!this._opts.xd; const r = this._xhr = this.createRequest(t); try { r.open(this._method, this._uri, !0); try { if (this._opts.extraHeaders) { r.setDisableHeaderCheck && r.setDisableHeaderCheck(!0); for (let i in this._opts.extraHeaders) this._opts.extraHeaders.hasOwnProperty(i) && r.setRequestHeader(i, this._opts.extraHeaders[i]) } } catch { } if (this._method === "POST") try { r.setRequestHeader("Content-type", "text/plain;charset=UTF-8") } catch { } try { r.setRequestHeader("Accept", "*/*") } catch { } (e = this._opts.cookieJar) === null || e === void 0 || e.addCookies(r), "withCredentials" in r && (r.withCredentials = this._opts.withCredentials), this._opts.requestTimeout && (r.timeout = this._opts.requestTimeout), r.onreadystatechange = () => { var i; r.readyState === 3 && ((i = this._opts.cookieJar) === null || i === void 0 || i.parseCookies(r.getResponseHeader("set-cookie"))), r.readyState === 4 && (r.status === 200 || r.status === 1223 ? this._onLoad() : this.setTimeoutFn(() => { this._onError(typeof r.status == "number" ? r.status : 0) }, 0)) }, r.send(this._data) } catch (i) { this.setTimeoutFn(() => { this._onError(i) }, 0); return } typeof document < "u" && (this._index = gl.requestsCount++, gl.requests[this._index] = this) } _onError(e) { this.emitReserved("error", e, this._xhr), this._cleanup(!0) } _cleanup(e) { if (!(typeof this._xhr > "u" || this._xhr === null)) { if (this._xhr.onreadystatechange = Ust, e) try { this._xhr.abort() } catch { } typeof document < "u" && delete gl.requests[this._index], this._xhr = null } } _onLoad() { const e = this._xhr.responseText; e !== null && (this.emitReserved("data", e), this.emitReserved("success"), this._cleanup()) } abort() { this._cleanup() } } gl.requestsCount = 0; gl.requests = {}; if (typeof document < "u") { if (typeof attachEvent == "function") attachEvent("onunload", PW); else if (typeof addEventListener == "function") { const n = "onpagehide" in xo ? "pagehide" : "unload"; addEventListener(n, PW, !1) } } function PW() { for (let n in gl.requests) gl.requests.hasOwnProperty(n) && gl.requests[n].abort() } const Wst = function () { const n = Bse({ xdomain: !1 }); return n && n.responseType !== null }(); class Kst extends Gst { constructor(e) { super(e); const t = e && e.forceBase64; this.supportsBinary = Wst && !t } request(e = {}) { return Object.assign(e, { xd: this.xd }, this.opts), new gl(Bse, this.uri(), e) } } function Bse(n) { const e = n.xdomain; try { if (typeof XMLHttpRequest < "u" && (!e || Hst)) return new XMLHttpRequest } catch { } if (!e) try { return new xo[["Active"].concat("Object").join("X")]("Microsoft.XMLHTTP") } catch { } } const $se = typeof navigator < "u" && typeof navigator.product == "string" && navigator.product.toLowerCase() === "reactnative"; class qst extends PB { get name() { return "websocket" } doOpen() { const e = this.uri(), t = this.opts.protocols, r = $se ? {} : Lse(this.opts, "agent", "perMessageDeflate", "pfx", "key", "passphrase", "cert", "ca", "ciphers", "rejectUnauthorized", "localAddress", "protocolVersion", "origin", "maxPayload", "family", "checkServerIdentity"); this.opts.extraHeaders && (r.headers = this.opts.extraHeaders); try { this.ws = this.createSocket(e, t, r) } catch (i) { return this.emitReserved("error", i) } this.ws.binaryType = this.socket.binaryType, this.addEventListeners() } addEventListeners() { this.ws.onopen = () => { this.opts.autoUnref && this.ws._socket.unref(), this.onOpen() }, this.ws.onclose = e => this.onClose({ description: "websocket connection closed", context: e }), this.ws.onmessage = e => this.onData(e.data), this.ws.onerror = e => this.onError("websocket error", e) } write(e) { this.writable = !1; for (let t = 0; t < e.length; t++) { const r = e[t], i = t === e.length - 1; DB(r, this.supportsBinary, a => { try { this.doWrite(r, a) } catch { } i && DC(() => { this.writable = !0, this.emitReserved("drain") }, this.setTimeoutFn) }) } } doClose() { typeof this.ws < "u" && (this.ws.close(), this.ws = null) } uri() { const e = this.opts.secure ? "wss" : "ws", t = this.query || {}; return this.opts.timestampRequests && (t[this.opts.timestampParam] = Rse()), this.supportsBinary || (t.b64 = 1), this.createUri(e, t) } } const MD = xo.WebSocket || xo.MozWebSocket; class Yst extends qst { createSocket(e, t, r) { return $se ? new MD(e, t, r) : t ? new MD(e, t) : new MD(e) } doWrite(e, t) { this.ws.send(t) } } class Zst extends PB { get name() { return "webtransport" } doOpen() { try { this._transport = new WebTransport(this.createUri("https"), this.opts.transportOptions[this.name]) } catch (e) { return this.emitReserved("error", e) } this._transport.closed.then(() => { this.onClose() }).catch(e => { this.onError("webtransport error", e) }), this._transport.ready.then(() => { this._transport.createBidirectionalStream().then(e => { const t = Dst(Number.MAX_SAFE_INTEGER, this.socket.binaryType), r = e.readable.pipeThrough(t).getReader(), i = Ost(); i.readable.pipeTo(e.writable), this._writer = i.writable.getWriter(); const a = () => { r.read().then(({ done: s, value: l }) => { s || (this.onPacket(l), a()) }).catch(s => { }) }; a(); const o = { type: "open" }; this.query.sid && (o.data = `{"sid":"${this.query.sid}"}`), this._writer.write(o).then(() => this.onOpen()) }) }) } write(e) { this.writable = !1; for (let t = 0; t < e.length; t++) { const r = e[t], i = t === e.length - 1; this._writer.write(r).then(() => { i && DC(() => { this.writable = !0, this.emitReserved("drain") }, this.setTimeoutFn) }) } } doClose() { var e; (e = this._transport) === null || e === void 0 || e.close() } } const Xst = { websocket: Yst, webtransport: Zst, polling: Kst }, Jst = /^(?:(?![^:@\/?#]+:[^:@\/]*@)(http|https|ws|wss):\/\/)?((?:(([^:@\/?#]*)(?::([^:@\/?#]*))?)?@)?((?:[a-f0-9]{0,4}:){2,7}[a-f0-9]{0,4}|[^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/, Qst = ["source", "protocol", "authority", "userInfo", "user", "password", "host", "port", "relative", "path", "directory", "file", "query", "anchor"]; function uL(n) { if (n.length > 8e3) throw "URI too long"; const e = n, t = n.indexOf("["), r = n.indexOf("]"); t != -1 && r != -1 && (n = n.substring(0, t) + n.substring(t, r).replace(/:/g, ";") + n.substring(r, n.length)); let i = Jst.exec(n || ""), a = {}, o = 14; for (; o--;)a[Qst[o]] = i[o] || ""; return t != -1 && r != -1 && (a.source = e, a.host = a.host.substring(1, a.host.length - 1).replace(/;/g, ":"), a.authority = a.authority.replace("[", "").replace("]", "").replace(/;/g, ":"), a.ipv6uri = !0), a.pathNames = elt(a, a.path), a.queryKey = tlt(a, a.query), a } function elt(n, e) { const t = /\/{2,9}/g, r = e.replace(t, "/").split("/"); return (e.slice(0, 1) == "/" || e.length === 0) && r.splice(0, 1), e.slice(-1) == "/" && r.splice(r.length - 1, 1), r } function tlt(n, e) { const t = {}; return e.replace(/(?:^|&)([^&=]*)=?([^&]*)/g, function (r, i, a) { i && (t[i] = a) }), t } const dL = typeof addEventListener == "function" && typeof removeEventListener == "function", mS = []; dL && addEventListener("offline", () => { mS.forEach(n => n()) }, !1); class ud extends Mr { constructor(e, t) { if (super(), this.binaryType = Pst, this.writeBuffer = [], this._prevBufferLen = 0, this._pingInterval = -1, this._pingTimeout = -1, this._maxPayload = -1, this._pingTimeoutTime = 1 / 0, e && typeof e == "object" && (t = e, e = null), e) { const r = uL(e); t.hostname = r.host, t.secure = r.protocol === "https" || r.protocol === "wss", t.port = r.port, r.query && (t.query = r.query) } else t.host && (t.hostname = uL(t.host).host); jC(this, t), this.secure = t.secure != null ? t.secure : typeof location < "u" && location.protocol === "https:", t.hostname && !t.port && (t.port = this.secure ? "443" : "80"), this.hostname = t.hostname || (typeof location < "u" ? location.hostname : "localhost"), this.port = t.port || (typeof location < "u" && location.port ? location.port : this.secure ? "443" : "80"), this.transports = [], this._transportsByName = {}, t.transports.forEach(r => { const i = r.prototype.name; this.transports.push(i), this._transportsByName[i] = r }), this.opts = Object.assign({ path: "/engine.io", agent: !1, withCredentials: !1, upgrade: !0, timestampParam: "t", rememberUpgrade: !1, addTrailingSlash: !0, rejectUnauthorized: !0, perMessageDeflate: { threshold: 1024 }, transportOptions: {}, closeOnBeforeunload: !1 }, t), this.opts.path = this.opts.path.replace(/\/$/, "") + (this.opts.addTrailingSlash ? "/" : ""), typeof this.opts.query == "string" && (this.opts.query = Fst(this.opts.query)), dL && (this.opts.closeOnBeforeunload && (this._beforeunloadEventListener = () => { this.transport && (this.transport.removeAllListeners(), this.transport.close()) }, addEventListener("beforeunload", this._beforeunloadEventListener, !1)), this.hostname !== "localhost" && (this._offlineEventListener = () => { this._onClose("transport close", { description: "network connection lost" }) }, mS.push(this._offlineEventListener))), this.opts.withCredentials && (this._cookieJar = void 0), this._open() } createTransport(e) { const t = Object.assign({}, this.opts.query); t.EIO = Ise, t.transport = e, this.id && (t.sid = this.id); const r = Object.assign({}, this.opts, { query: t, socket: this, hostname: this.hostname, secure: this.secure, port: this.port }, this.opts.transportOptions[e]); return new this._transportsByName[e](r) } _open() { if (this.transports.length === 0) { this.setTimeoutFn(() => { this.emitReserved("error", "No transports available") }, 0); return } const e = this.opts.rememberUpgrade && ud.priorWebsocketSuccess && this.transports.indexOf("websocket") !== -1 ? "websocket" : this.transports[0]; this.readyState = "opening"; const t = this.createTransport(e); t.open(), this.setTransport(t) } setTransport(e) { this.transport && this.transport.removeAllListeners(), this.transport = e, e.on("drain", this._onDrain.bind(this)).on("packet", this._onPacket.bind(this)).on("error", this._onError.bind(this)).on("close", t => this._onClose("transport close", t)) } onOpen() { this.readyState = "open", ud.priorWebsocketSuccess = this.transport.name === "websocket", this.emitReserved("open"), this.flush() } _onPacket(e) { if (this.readyState === "opening" || this.readyState === "open" || this.readyState === "closing") switch (this.emitReserved("packet", e), this.emitReserved("heartbeat"), e.type) { case "open": this.onHandshake(JSON.parse(e.data)); break; case "ping": this._sendPacket("pong"), this.emitReserved("ping"), this.emitReserved("pong"), this._resetPingTimeout(); break; case "error": const t = new Error("server error"); t.code = e.data, this._onError(t); break; case "message": this.emitReserved("data", e.data), this.emitReserved("message", e.data); break } } onHandshake(e) { this.emitReserved("handshake", e), this.id = e.sid, this.transport.query.sid = e.sid, this._pingInterval = e.pingInterval, this._pingTimeout = e.pingTimeout, this._maxPayload = e.maxPayload, this.onOpen(), this.readyState !== "closed" && this._resetPingTimeout() } _resetPingTimeout() { this.clearTimeoutFn(this._pingTimeoutTimer); const e = this._pingInterval + this._pingTimeout; this._pingTimeoutTime = Date.now() + e, this._pingTimeoutTimer = this.setTimeoutFn(() => { this._onClose("ping timeout") }, e), this.opts.autoUnref && this._pingTimeoutTimer.unref() } _onDrain() { this.writeBuffer.splice(0, this._prevBufferLen), this._prevBufferLen = 0, this.writeBuffer.length === 0 ? this.emitReserved("drain") : this.flush() } flush() { if (this.readyState !== "closed" && this.transport.writable && !this.upgrading && this.writeBuffer.length) { const e = this._getWritablePackets(); this.transport.send(e), this._prevBufferLen = e.length, this.emitReserved("flush") } } _getWritablePackets() { if (!(this._maxPayload && this.transport.name === "polling" && this.writeBuffer.length > 1)) return this.writeBuffer; let t = 1; for (let r = 0; r < this.writeBuffer.length; r++) { const i = this.writeBuffer[r].data; if (i && (t += Nst(i)), r > 0 && t > this._maxPayload) return this.writeBuffer.slice(0, r); t += 2 } return this.writeBuffer } _hasPingExpired() { if (!this._pingTimeoutTime) return !0; const e = Date.now() > this._pingTimeoutTime; return e && (this._pingTimeoutTime = 0, DC(() => { this._onClose("ping timeout") }, this.setTimeoutFn)), e } write(e, t, r) { return this._sendPacket("message", e, t, r), this } send(e, t, r) { return this._sendPacket("message", e, t, r), this } _sendPacket(e, t, r, i) { if (typeof t == "function" && (i = t, t = void 0), typeof r == "function" && (i = r, r = null), this.readyState === "closing" || this.readyState === "closed") return; r = r || {}, r.compress = r.compress !== !1; const a = { type: e, data: t, options: r }; this.emitReserved("packetCreate", a), this.writeBuffer.push(a), i && this.once("flush", i), this.flush() } close() { const e = () => { this._onClose("forced close"), this.transport.close() }, t = () => { this.off("upgrade", t), this.off("upgradeError", t), e() }, r = () => { this.once("upgrade", t), this.once("upgradeError", t) }; return (this.readyState === "opening" || this.readyState === "open") && (this.readyState = "closing", this.writeBuffer.length ? this.once("drain", () => { this.upgrading ? r() : e() }) : this.upgrading ? r() : e()), this } _onError(e) { if (ud.priorWebsocketSuccess = !1, this.opts.tryAllTransports && this.transports.length > 1 && this.readyState === "opening") return this.transports.shift(), this._open(); this.emitReserved("error", e), this._onClose("transport error", e) } _onClose(e, t) { if (this.readyState === "opening" || this.readyState === "open" || this.readyState === "closing") { if (this.clearTimeoutFn(this._pingTimeoutTimer), this.transport.removeAllListeners("close"), this.transport.close(), this.transport.removeAllListeners(), dL && (this._beforeunloadEventListener && removeEventListener("beforeunload", this._beforeunloadEventListener, !1), this._offlineEventListener)) { const r = mS.indexOf(this._offlineEventListener); r !== -1 && mS.splice(r, 1) } this.readyState = "closed", this.id = null, this.emitReserved("close", e, t), this.writeBuffer = [], this._prevBufferLen = 0 } } } ud.protocol = Ise; class nlt extends ud { constructor() { super(...arguments), this._upgrades = [] } onOpen() { if (super.onOpen(), this.readyState === "open" && this.opts.upgrade) for (let e = 0; e < this._upgrades.length; e++)this._probe(this._upgrades[e]) } _probe(e) { let t = this.createTransport(e), r = !1; ud.priorWebsocketSuccess = !1; const i = () => { r || (t.send([{ type: "ping", data: "probe" }]), t.once("packet", d => { if (!r) if (d.type === "pong" && d.data === "probe") { if (this.upgrading = !0, this.emitReserved("upgrading", t), !t) return; ud.priorWebsocketSuccess = t.name === "websocket", this.transport.pause(() => { r || this.readyState !== "closed" && (u(), this.setTransport(t), t.send([{ type: "upgrade" }]), this.emitReserved("upgrade", t), t = null, this.upgrading = !1, this.flush()) }) } else { const f = new Error("probe error"); f.transport = t.name, this.emitReserved("upgradeError", f) } })) }; function a() { r || (r = !0, u(), t.close(), t = null) } const o = d => { const f = new Error("probe error: " + d); f.transport = t.name, a(), this.emitReserved("upgradeError", f) }; function s() { o("transport closed") } function l() { o("socket closed") } function c(d) { t && d.name !== t.name && a() } const u = () => { t.removeListener("open", i), t.removeListener("error", o), t.removeListener("close", s), this.off("close", l), this.off("upgrading", c) }; t.once("open", i), t.once("error", o), t.once("close", s), this.once("close", l), this.once("upgrading", c), this._upgrades.indexOf("webtransport") !== -1 && e !== "webtransport" ? this.setTimeoutFn(() => { r || t.open() }, 200) : t.open() } onHandshake(e) { this._upgrades = this._filterUpgrades(e.upgrades), super.onHandshake(e) } _filterUpgrades(e) { const t = []; for (let r = 0; r < e.length; r++)~this.transports.indexOf(e[r]) && t.push(e[r]); return t } } let rlt = class extends nlt { constructor(e, t = {}) { const r = typeof e == "object" ? e : t; (!r.transports || r.transports && typeof r.transports[0] == "string") && (r.transports = (r.transports || ["polling", "websocket", "webtransport"]).map(i => Xst[i]).filter(i => !!i)), super(e, r) } }; function ilt(n, e = "", t) { let r = n; t = t || typeof location < "u" && location, n == null && (n = t.protocol + "//" + t.host), typeof n == "string" && (n.charAt(0) === "/" && (n.charAt(1) === "/" ? n = t.protocol + n : n = t.host + n), /^(https?|wss?):\/\//.test(n) || (typeof t < "u" ? n = t.protocol + "//" + n : n = "https://" + n), r = uL(n)), r.port || (/^(http|ws)$/.test(r.protocol) ? r.port = "80" : /^(http|ws)s$/.test(r.protocol) && (r.port = "443")), r.path = r.path || "/"; const a = r.host.indexOf(":") !== -1 ? "[" + r.host + "]" : r.host; return r.id = r.protocol + "://" + a + ":" + r.port + e, r.href = r.protocol + "://" + a + (t && t.port === r.port ? "" : ":" + r.port), r } const alt = typeof ArrayBuffer == "function", olt = n => typeof ArrayBuffer.isView == "function" ? ArrayBuffer.isView(n) : n.buffer instanceof ArrayBuffer, Fse = Object.prototype.toString, slt = typeof Blob == "function" || typeof Blob < "u" && Fse.call(Blob) === "[object BlobConstructor]", llt = typeof File == "function" || typeof File < "u" && Fse.call(File) === "[object FileConstructor]"; function IB(n) { return alt && (n instanceof ArrayBuffer || olt(n)) || slt && n instanceof Blob || llt && n instanceof File } function gS(n, e) { if (!n || typeof n != "object") return !1; if (Array.isArray(n)) { for (let t = 0, r = n.length; t < r; t++)if (gS(n[t])) return !0; return !1 } if (IB(n)) return !0; if (n.toJSON && typeof n.toJSON == "function" && arguments.length === 1) return gS(n.toJSON(), !0); for (const t in n) if (Object.prototype.hasOwnProperty.call(n, t) && gS(n[t])) return !0; return !1 } function clt(n) { const e = [], t = n.data, r = n; return r.data = fL(t, e), r.attachments = e.length, { packet: r, buffers: e } } function fL(n, e) { if (!n) return n; if (IB(n)) { const t = { _placeholder: !0, num: e.length }; return e.push(n), t } else if (Array.isArray(n)) { const t = new Array(n.length); for (let r = 0; r < n.length; r++)t[r] = fL(n[r], e); return t } else if (typeof n == "object" && !(n instanceof Date)) { const t = {}; for (const r in n) Object.prototype.hasOwnProperty.call(n, r) && (t[r] = fL(n[r], e)); return t } return n } function ult(n, e) { return n.data = hL(n.data, e), delete n.attachments, n } function hL(n, e) { if (!n) return n; if (n && n._placeholder === !0) { if (typeof n.num == "number" && n.num >= 0 && n.num < e.length) return e[n.num]; throw new Error("illegal attachments") } else if (Array.isArray(n)) for (let t = 0; t < n.length; t++)n[t] = hL(n[t], e); else if (typeof n == "object") for (const t in n) Object.prototype.hasOwnProperty.call(n, t) && (n[t] = hL(n[t], e)); return n } const dlt = ["connect", "connect_error", "disconnect", "disconnecting", "newListener", "removeListener"], flt = 5; var gn; (function (n) { n[n.CONNECT = 0] = "CONNECT", n[n.DISCONNECT = 1] = "DISCONNECT", n[n.EVENT = 2] = "EVENT", n[n.ACK = 3] = "ACK", n[n.CONNECT_ERROR = 4] = "CONNECT_ERROR", n[n.BINARY_EVENT = 5] = "BINARY_EVENT", n[n.BINARY_ACK = 6] = "BINARY_ACK" })(gn || (gn = {})); class hlt { constructor(e) { this.replacer = e } encode(e) { return (e.type === gn.EVENT || e.type === gn.ACK) && gS(e) ? this.encodeAsBinary({ type: e.type === gn.EVENT ? gn.BINARY_EVENT : gn.BINARY_ACK, nsp: e.nsp, data: e.data, id: e.id }) : [this.encodeAsString(e)] } encodeAsString(e) { let t = "" + e.type; return (e.type === gn.BINARY_EVENT || e.type === gn.BINARY_ACK) && (t += e.attachments + "-"), e.nsp && e.nsp !== "/" && (t += e.nsp + ","), e.id != null && (t += e.id), e.data != null && (t += JSON.stringify(e.data, this.replacer)), t } encodeAsBinary(e) { const t = clt(e), r = this.encodeAsString(t.packet), i = t.buffers; return i.unshift(r), i } } function IW(n) { return Object.prototype.toString.call(n) === "[object Object]" } class LB extends Mr { constructor(e) { super(), this.reviver = e } add(e) { let t; if (typeof e == "string") { if (this.reconstructor) throw new Error("got plaintext data when reconstructing a packet"); t = this.decodeString(e); const r = t.type === gn.BINARY_EVENT; r || t.type === gn.BINARY_ACK ? (t.type = r ? gn.EVENT : gn.ACK, this.reconstructor = new plt(t), t.attachments === 0 && super.emitReserved("decoded", t)) : super.emitReserved("decoded", t) } else if (IB(e) || e.base64) if (this.reconstructor) t = this.reconstructor.takeBinaryData(e), t && (this.reconstructor = null, super.emitReserved("decoded", t)); else throw new Error("got binary data when not reconstructing a packet"); else throw new Error("Unknown type: " + e) } decodeString(e) { let t = 0; const r = { type: Number(e.charAt(0)) }; if (gn[r.type] === void 0) throw new Error("unknown packet type " + r.type); if (r.type === gn.BINARY_EVENT || r.type === gn.BINARY_ACK) { const a = t + 1; for (; e.charAt(++t) !== "-" && t != e.length;); const o = e.substring(a, t); if (o != Number(o) || e.charAt(t) !== "-") throw new Error("Illegal attachments"); r.attachments = Number(o) } if (e.charAt(t + 1) === "/") { const a = t + 1; for (; ++t && !(e.charAt(t) === "," || t === e.length);); r.nsp = e.substring(a, t) } else r.nsp = "/"; const i = e.charAt(t + 1); if (i !== "" && Number(i) == i) { const a = t + 1; for (; ++t;) { const o = e.charAt(t); if (o == null || Number(o) != o) { --t; break } if (t === e.length) break } r.id = Number(e.substring(a, t + 1)) } if (e.charAt(++t)) { const a = this.tryParse(e.substr(t)); if (LB.isPayloadValid(r.type, a)) r.data = a; else throw new Error("invalid payload") } return r } tryParse(e) { try { return JSON.parse(e, this.reviver) } catch { return !1 } } static isPayloadValid(e, t) { switch (e) { case gn.CONNECT: return IW(t); case gn.DISCONNECT: return t === void 0; case gn.CONNECT_ERROR: return typeof t == "string" || IW(t); case gn.EVENT: case gn.BINARY_EVENT: return Array.isArray(t) && (typeof t[0] == "number" || typeof t[0] == "string" && dlt.indexOf(t[0]) === -1); case gn.ACK: case gn.BINARY_ACK: return Array.isArray(t) } } destroy() { this.reconstructor && (this.reconstructor.finishedReconstruction(), this.reconstructor = null) } } class plt { constructor(e) { this.packet = e, this.buffers = [], this.reconPack = e } takeBinaryData(e) { if (this.buffers.push(e), this.buffers.length === this.reconPack.attachments) { const t = ult(this.reconPack, this.buffers); return this.finishedReconstruction(), t } return null } finishedReconstruction() { this.reconPack = null, this.buffers = [] } } const mlt = Object.freeze(Object.defineProperty({ __proto__: null, Decoder: LB, Encoder: hlt, get PacketType() { return gn }, protocol: flt }, Symbol.toStringTag, { value: "Module" })); function ls(n, e, t) { return n.on(e, t), function () { n.off(e, t) } } const glt = Object.freeze({ connect: 1, connect_error: 1, disconnect: 1, disconnecting: 1, newListener: 1, removeListener: 1 }); class zse extends Mr { constructor(e, t, r) { super(), this.connected = !1, this.recovered = !1, this.receiveBuffer = [], this.sendBuffer = [], this._queue = [], this._queueSeq = 0, this.ids = 0, this.acks = {}, this.flags = {}, this.io = e, this.nsp = t, r && r.auth && (this.auth = r.auth), this._opts = Object.assign({}, r), this.io._autoConnect && this.open() } get disconnected() { return !this.connected } subEvents() { if (this.subs) return; const e = this.io; this.subs = [ls(e, "open", this.onopen.bind(this)), ls(e, "packet", this.onpacket.bind(this)), ls(e, "error", this.onerror.bind(this)), ls(e, "close", this.onclose.bind(this))] } get active() { return !!this.subs } connect() { return this.connected ? this : (this.subEvents(), this.io._reconnecting || this.io.open(), this.io._readyState === "open" && this.onopen(), this) } open() { return this.connect() } send(...e) { return e.unshift("message"), this.emit.apply(this, e), this } emit(e, ...t) { var r, i, a; if (glt.hasOwnProperty(e)) throw new Error('"' + e.toString() + '" is a reserved event name'); if (t.unshift(e), this._opts.retries && !this.flags.fromQueue && !this.flags.volatile) return this._addToQueue(t), this; const o = { type: gn.EVENT, data: t }; if (o.options = {}, o.options.compress = this.flags.compress !== !1, typeof t[t.length - 1] == "function") { const u = this.ids++, d = t.pop(); this._registerAckCallback(u, d), o.id = u } const s = (i = (r = this.io.engine) === null || r === void 0 ? void 0 : r.transport) === null || i === void 0 ? void 0 : i.writable, l = this.connected && !(!((a = this.io.engine) === null || a === void 0) && a._hasPingExpired()); return this.flags.volatile && !s || (l ? (this.notifyOutgoingListeners(o), this.packet(o)) : this.sendBuffer.push(o)), this.flags = {}, this } _registerAckCallback(e, t) { var r; const i = (r = this.flags.timeout) !== null && r !== void 0 ? r : this._opts.ackTimeout; if (i === void 0) { this.acks[e] = t; return } const a = this.io.setTimeoutFn(() => { delete this.acks[e]; for (let s = 0; s < this.sendBuffer.length; s++)this.sendBuffer[s].id === e && this.sendBuffer.splice(s, 1); t.call(this, new Error("operation has timed out")) }, i), o = (...s) => { this.io.clearTimeoutFn(a), t.apply(this, s) }; o.withError = !0, this.acks[e] = o } emitWithAck(e, ...t) { return new Promise((r, i) => { const a = (o, s) => o ? i(o) : r(s); a.withError = !0, t.push(a), this.emit(e, ...t) }) } _addToQueue(e) { let t; typeof e[e.length - 1] == "function" && (t = e.pop()); const r = { id: this._queueSeq++, tryCount: 0, pending: !1, args: e, flags: Object.assign({ fromQueue: !0 }, this.flags) }; e.push((i, ...a) => r !== this._queue[0] ? void 0 : (i !== null ? r.tryCount > this._opts.retries && (this._queue.shift(), t && t(i)) : (this._queue.shift(), t && t(null, ...a)), r.pending = !1, this._drainQueue())), this._queue.push(r), this._drainQueue() } _drainQueue(e = !1) { if (!this.connected || this._queue.length === 0) return; const t = this._queue[0]; t.pending && !e || (t.pending = !0, t.tryCount++, this.flags = t.flags, this.emit.apply(this, t.args)) } packet(e) { e.nsp = this.nsp, this.io._packet(e) } onopen() { typeof this.auth == "function" ? this.auth(e => { this._sendConnectPacket(e) }) : this._sendConnectPacket(this.auth) } _sendConnectPacket(e) { this.packet({ type: gn.CONNECT, data: this._pid ? Object.assign({ pid: this._pid, offset: this._lastOffset }, e) : e }) } onerror(e) { this.connected || this.emitReserved("connect_error", e) } onclose(e, t) { this.connected = !1, delete this.id, this.emitReserved("disconnect", e, t), this._clearAcks() } _clearAcks() { Object.keys(this.acks).forEach(e => { if (!this.sendBuffer.some(r => String(r.id) === e)) { const r = this.acks[e]; delete this.acks[e], r.withError && r.call(this, new Error("socket has been disconnected")) } }) } onpacket(e) { if (e.nsp === this.nsp) switch (e.type) { case gn.CONNECT: e.data && e.data.sid ? this.onconnect(e.data.sid, e.data.pid) : this.emitReserved("connect_error", new Error("It seems you are trying to reach a Socket.IO server in v2.x with a v3.x client, but they are not compatible (more information here: https://socket.io/docs/v3/migrating-from-2-x-to-3-0/)")); break; case gn.EVENT: case gn.BINARY_EVENT: this.onevent(e); break; case gn.ACK: case gn.BINARY_ACK: this.onack(e); break; case gn.DISCONNECT: this.ondisconnect(); break; case gn.CONNECT_ERROR: this.destroy(); const r = new Error(e.data.message); r.data = e.data.data, this.emitReserved("connect_error", r); break } } onevent(e) { const t = e.data || []; e.id != null && t.push(this.ack(e.id)), this.connected ? this.emitEvent(t) : this.receiveBuffer.push(Object.freeze(t)) } emitEvent(e) { if (this._anyListeners && this._anyListeners.length) { const t = this._anyListeners.slice(); for (const r of t) r.apply(this, e) } super.emit.apply(this, e), this._pid && e.length && typeof e[e.length - 1] == "string" && (this._lastOffset = e[e.length - 1]) } ack(e) { const t = this; let r = !1; return function (...i) { r || (r = !0, t.packet({ type: gn.ACK, id: e, data: i })) } } onack(e) { const t = this.acks[e.id]; typeof t == "function" && (delete this.acks[e.id], t.withError && e.data.unshift(null), t.apply(this, e.data)) } onconnect(e, t) { this.id = e, this.recovered = t && this._pid === t, this._pid = t, this.connected = !0, this.emitBuffered(), this.emitReserved("connect"), this._drainQueue(!0) } emitBuffered() { this.receiveBuffer.forEach(e => this.emitEvent(e)), this.receiveBuffer = [], this.sendBuffer.forEach(e => { this.notifyOutgoingListeners(e), this.packet(e) }), this.sendBuffer = [] } ondisconnect() { this.destroy(), this.onclose("io server disconnect") } destroy() { this.subs && (this.subs.forEach(e => e()), this.subs = void 0), this.io._destroy(this) } disconnect() { return this.connected && this.packet({ type: gn.DISCONNECT }), this.destroy(), this.connected && this.onclose("io client disconnect"), this } close() { return this.disconnect() } compress(e) { return this.flags.compress = e, this } get volatile() { return this.flags.volatile = !0, this } timeout(e) { return this.flags.timeout = e, this } onAny(e) { return this._anyListeners = this._anyListeners || [], this._anyListeners.push(e), this } prependAny(e) { return this._anyListeners = this._anyListeners || [], this._anyListeners.unshift(e), this } offAny(e) { if (!this._anyListeners) return this; if (e) { const t = this._anyListeners; for (let r = 0; r < t.length; r++)if (e === t[r]) return t.splice(r, 1), this } else this._anyListeners = []; return this } listenersAny() { return this._anyListeners || [] } onAnyOutgoing(e) { return this._anyOutgoingListeners = this._anyOutgoingListeners || [], this._anyOutgoingListeners.push(e), this } prependAnyOutgoing(e) { return this._anyOutgoingListeners = this._anyOutgoingListeners || [], this._anyOutgoingListeners.unshift(e), this } offAnyOutgoing(e) { if (!this._anyOutgoingListeners) return this; if (e) { const t = this._anyOutgoingListeners; for (let r = 0; r < t.length; r++)if (e === t[r]) return t.splice(r, 1), this } else this._anyOutgoingListeners = []; return this } listenersAnyOutgoing() { return this._anyOutgoingListeners || [] } notifyOutgoingListeners(e) { if (this._anyOutgoingListeners && this._anyOutgoingListeners.length) { const t = this._anyOutgoingListeners.slice(); for (const r of t) r.apply(this, e.data) } } } function uv(n) { n = n || {}, this.ms = n.min || 100, this.max = n.max || 1e4, this.factor = n.factor || 2, this.jitter = n.jitter > 0 && n.jitter <= 1 ? n.jitter : 0, this.attempts = 0 } uv.prototype.duration = function () { var n = this.ms * Math.pow(this.factor, this.attempts++); if (this.jitter) { var e = Math.random(), t = Math.floor(e * this.jitter * n); n = Math.floor(e * 10) & 1 ? n + t : n - t } return Math.min(n, this.max) | 0 }; uv.prototype.reset = function () { this.attempts = 0 }; uv.prototype.setMin = function (n) { this.ms = n }; uv.prototype.setMax = function (n) { this.max = n }; uv.prototype.setJitter = function (n) { this.jitter = n }; class pL extends Mr { constructor(e, t) { var r; super(), this.nsps = {}, this.subs = [], e && typeof e == "object" && (t = e, e = void 0), t = t || {}, t.path = t.path || "/socket.io", this.opts = t, jC(this, t), this.reconnection(t.reconnection !== !1), this.reconnectionAttempts(t.reconnectionAttempts || 1 / 0), this.reconnectionDelay(t.reconnectionDelay || 1e3), this.reconnectionDelayMax(t.reconnectionDelayMax || 5e3), this.randomizationFactor((r = t.randomizationFactor) !== null && r !== void 0 ? r : .5), this.backoff = new uv({ min: this.reconnectionDelay(), max: this.reconnectionDelayMax(), jitter: this.randomizationFactor() }), this.timeout(t.timeout == null ? 2e4 : t.timeout), this._readyState = "closed", this.uri = e; const i = t.parser || mlt; this.encoder = new i.Encoder, this.decoder = new i.Decoder, this._autoConnect = t.autoConnect !== !1, this._autoConnect && this.open() } reconnection(e) { return arguments.length ? (this._reconnection = !!e, e || (this.skipReconnect = !0), this) : this._reconnection } reconnectionAttempts(e) { return e === void 0 ? this._reconnectionAttempts : (this._reconnectionAttempts = e, this) } reconnectionDelay(e) { var t; return e === void 0 ? this._reconnectionDelay : (this._reconnectionDelay = e, (t = this.backoff) === null || t === void 0 || t.setMin(e), this) } randomizationFactor(e) { var t; return e === void 0 ? this._randomizationFactor : (this._randomizationFactor = e, (t = this.backoff) === null || t === void 0 || t.setJitter(e), this) } reconnectionDelayMax(e) { var t; return e === void 0 ? this._reconnectionDelayMax : (this._reconnectionDelayMax = e, (t = this.backoff) === null || t === void 0 || t.setMax(e), this) } timeout(e) { return arguments.length ? (this._timeout = e, this) : this._timeout } maybeReconnectOnOpen() { !this._reconnecting && this._reconnection && this.backoff.attempts === 0 && this.reconnect() } open(e) { if (~this._readyState.indexOf("open")) return this; this.engine = new rlt(this.uri, this.opts); const t = this.engine, r = this; this._readyState = "opening", this.skipReconnect = !1; const i = ls(t, "open", function () { r.onopen(), e && e() }), a = s => { this.cleanup(), this._readyState = "closed", this.emitReserved("error", s), e ? e(s) : this.maybeReconnectOnOpen() }, o = ls(t, "error", a); if (this._timeout !== !1) { const s = this._timeout, l = this.setTimeoutFn(() => { i(), a(new Error("timeout")), t.close() }, s); this.opts.autoUnref && l.unref(), this.subs.push(() => { this.clearTimeoutFn(l) }) } return this.subs.push(i), this.subs.push(o), this } connect(e) { return this.open(e) } onopen() { this.cleanup(), this._readyState = "open", this.emitReserved("open"); const e = this.engine; this.subs.push(ls(e, "ping", this.onping.bind(this)), ls(e, "data", this.ondata.bind(this)), ls(e, "error", this.onerror.bind(this)), ls(e, "close", this.onclose.bind(this)), ls(this.decoder, "decoded", this.ondecoded.bind(this))) } onping() { this.emitReserved("ping") } ondata(e) { try { this.decoder.add(e) } catch (t) { this.onclose("parse error", t) } } ondecoded(e) { DC(() => { this.emitReserved("packet", e) }, this.setTimeoutFn) } onerror(e) { this.emitReserved("error", e) } socket(e, t) { let r = this.nsps[e]; return r ? this._autoConnect && !r.active && r.connect() : (r = new zse(this, e, t), this.nsps[e] = r), r } _destroy(e) { const t = Object.keys(this.nsps); for (const r of t) if (this.nsps[r].active) return; this._close() } _packet(e) { const t = this.encoder.encode(e); for (let r = 0; r < t.length; r++)this.engine.write(t[r], e.options) } cleanup() { this.subs.forEach(e => e()), this.subs.length = 0, this.decoder.destroy() } _close() { this.skipReconnect = !0, this._reconnecting = !1, this.onclose("forced close") } disconnect() { return this._close() } onclose(e, t) { var r; this.cleanup(), (r = this.engine) === null || r === void 0 || r.close(), this.backoff.reset(), this._readyState = "closed", this.emitReserved("close", e, t), this._reconnection && !this.skipReconnect && this.reconnect() } reconnect() { if (this._reconnecting || this.skipReconnect) return this; const e = this; if (this.backoff.attempts >= this._reconnectionAttempts) this.backoff.reset(), this.emitReserved("reconnect_failed"), this._reconnecting = !1; else { const t = this.backoff.duration(); this._reconnecting = !0; const r = this.setTimeoutFn(() => { e.skipReconnect || (this.emitReserved("reconnect_attempt", e.backoff.attempts), !e.skipReconnect && e.open(i => { i ? (e._reconnecting = !1, e.reconnect(), this.emitReserved("reconnect_error", i)) : e.onreconnect() })) }, t); this.opts.autoUnref && r.unref(), this.subs.push(() => { this.clearTimeoutFn(r) }) } } onreconnect() { const e = this.backoff.attempts; this._reconnecting = !1, this.backoff.reset(), this.emitReserved("reconnect", e) } } const my = {}; function vS(n, e) { typeof n == "object" && (e = n, n = void 0), e = e || {}; const t = ilt(n, e.path || "/socket.io"), r = t.source, i = t.id, a = t.path, o = my[i] && a in my[i].nsps, s = e.forceNew || e["force new connection"] || e.multiplex === !1 || o; let l; return s ? l = new pL(r, e) : (my[i] || (my[i] = new pL(r, e)), l = my[i]), t.query && !e.query && (e.query = t.queryKey), l.socket(t.path, e) } Object.assign(vS, { Manager: pL, Socket: zse, io: vS, connect: vS }); class vlt { constructor() { this.memoryStore = {}, this.useIndexedDB = typeof window < "u" && !!window.indexedDB } set(e, t) { if (!this.validateKey(e)) return Promise.resolve(null); try { return this.useIndexedDB ? Tse(e, JSON.stringify(t)) : (this.memoryStore[e] = JSON.stringify(t), Promise.resolve()) } catch (r) { return this.handleError(r, "save to") } } setMany(e) { try { if (this.useIndexedDB) { let t = []; for (const [r, i] of Object.entries(e)) t.push([r, JSON.stringify(i)]); return dst(t) } for (const [t, r] of Object.entries(e)) this.memoryStore[t] = JSON.stringify(r); return Promise.resolve() } catch (t) { return this.handleError(t, "save to") } } delete(e) { if (!this.validateKey(e)) return Promise.resolve(null); try { return this.useIndexedDB ? kse(e) : (delete this.memoryStore[e], Promise.resolve()) } catch (t) { return this.handleError(t, "delete from") } } get(e) { if (!this.validateKey(e)) return Promise.resolve(null); if (this.useIndexedDB) return Sse(e).then(t => { if (!t) return null; try { return JSON.parse(t) } catch (r) { return this.handleError(r, "parse data from") } }); try { const t = this.memoryStore[e]; return Promise.resolve(t ? JSON.parse(t) : null) } catch (t) { return this.handleError(t, "parse data from") } } async keys() { try { return this.useIndexedDB ? hst() : Promise.resolve(Object.keys(this.memoryStore)) } catch (e) { return console.error(`Failed to get keys from ${this.useIndexedDB ? "IndexedDB" : "memory store"}:`, e), Promise.resolve([]) } } validateKey(e) { return !!e } handleError(e, t) { return console.error(`Failed to ${t} ${this.useIndexedDB ? "IndexedDB" : "memory store"}:`, e), Promise.resolve(null) } } let lm = new vlt; class ylt { constructor() { this.cacheTimeout = 5 * 60 * 1e3, this.storePrefix = "doc:", this.docs = new Map, this.lastFetched = new Map } setCacheTimeout(e) { if (e < 1) throw new Error("Cache timeout must be at least 1 minute"); this.cacheTimeout = e * 60 * 1e3 } async setDoc(e) { if (!(e != null && e.doctype) || !(e != null && e.name)) throw new Error("Invalid doc: must have doctype and name"); e.name = e.name.toString(); const t = this.getKey(e.doctype, e.name); try { await lm.set(this.storePrefix + t, e), this.docs.has(t) || this.docs.set(t, he(null)); const r = this.docs.get(t); r && (r.value = e), this.lastFetched.set(t, Date.now()) } catch (r) { throw console.error("Failed to set doc in IDB:", r), r } } getDoc(e, t) { const r = Po(t); if (!e || !r) throw new Error("doctype and name are required"); const i = this.getKey(e, r); return this.docs.has(i) ? this.isStale(i) && this.loadDoc(i, !1) : (this.docs.set(i, he(null)), this.loadDoc(i, !0)), this.docs.get(i) } async loadDoc(e, t) { try { !t && this.isStale(e) && await this.cleanup(e); const r = await lm.get(this.storePrefix + e); if (r) { const i = this.docs.get(e); i && (i.value = r), this.lastFetched.set(e, Date.now()) } } catch (r) { throw console.error("Failed to load doc from IDB:", r), r } } async setDocs(e) { const t = {}; for (const r of e) { if (!(r != null && r.doctype) || !(r != null && r.name)) continue; r.name = r.name.toString(); const i = this.getKey(r.doctype, r.name); this.docs.has(i) || this.docs.set(i, he(null)); const a = this.docs.get(i); a && (a.value = r), this.lastFetched.set(i, Date.now()), t[this.storePrefix + i] = r } await lm.setMany(t) } async invalidateDoc(e, t) { if (!e || !t) return; const r = this.getKey(e, t); await this.cleanup(r) } removeDoc(e, t) { return this.invalidateDoc(e, t) } getKey(e, t) { return `${e.trim()}/${t.trim()}` } isStale(e) { const t = this.lastFetched.get(e); return t ? Date.now() - t > this.cacheTimeout : !0 } async cleanup(e) { this.docs.delete(e), this.lastFetched.delete(e), await lm.delete(this.storePrefix + e) } async clearAll() { try { const t = (await lm.keys()).filter(r => r.startsWith(this.storePrefix)); await Promise.all(t.map(r => lm.delete(r))), this.docs.clear(), this.lastFetched.clear() } catch (e) { throw console.error("Failed to clear all docs:", e), e } } } const _lt = new ylt; class blt { constructor() { this.byDocType = {} } addList(e, t) { this.ensureList(e), this.byDocType[e].push(t) } updateRows(e) { for (let t of e) this.updateRow(t.doctype, t) } updateRow(e, t) { this.ensureList(e), this.byDocType[e].forEach(r => { r.updateRow(t) }) } removeRow(e, t) { this.ensureList(e), this.byDocType[e].forEach(r => { r.removeRow(t) }) } ensureList(e) { this.byDocType[e] || (this.byDocType[e] = []) } } const wlt = new blt; cwe({
  options: {
    fetch: (...n) => fetch(...n), beforeFetch({ options: n }) { return n.headers = xlt(n.headers || {}), { options: n } }, afterFetch(n) { let e = JSON.parse(n.data); if (e.debug) { let t = n.response.url.replace(window.location.origin, ""); console.group(t); for (let r of e.debug) console.log(r == null ? void 0 : r.message); console.groupEnd() } if (e.docs) { let t = e.docs; for (let r of t) r.name = r.name.toString(); _lt.setDocs(t), wlt.updateRows(t) } return n.data = e.data, n }, onFetchError(n) {
      var e; if ((e = n.response) != null && e.ok && n.error) return console.error(`Fetch request succeeded but there was a programming error:

`, n.error), n; try { let i = JSON.parse(n.data).errors[0], a = i.message ? `: ${i.message}` : i.exception ? " (Traceback)" : "", o = new Error(`${i.type}${a}`); return o.title = i.title, o.type = i.type, o.exception = i.exception, n.error = o, n } catch (t) { return console.log("Error parsing error response:", t), n }
    }
  }
}); function xlt(n) { let e = null, t = null; typeof window < "u" && (e = window.location.hostname, t = window.csrf_token !== "{{ csrf_token }}" ? window.csrf_token : null); const r = { Accept: "application/json", "Content-Type": "application/json; charset=utf-8" }; return e && (r["X-Frappe-Site-Name"] = e), t && (r["X-Frappe-CSRF-Token"] = t), { ...n, ...r } }/*!
 * pinia v2.2.2
 * (c) 2024 Eduardo San Martin Morote
 * @license MIT
 */let Vse; const PC = n => Vse = n, Hse = Symbol(); function mL(n) { return n && typeof n == "object" && Object.prototype.toString.call(n) === "[object Object]" && typeof n.toJSON != "function" } var C0; (function (n) { n.direct = "direct", n.patchObject = "patch object", n.patchFunction = "patch function" })(C0 || (C0 = {})); function Slt() { const n = YW(!0), e = n.run(() => he({})); let t = [], r = []; const i = dn({ install(a) { PC(i), i._a = a, a.provide(Hse, i), a.config.globalProperties.$pinia = i, r.forEach(o => t.push(o)), r = [] }, use(a) { return !this._a && !j1e ? r.push(a) : t.push(a), this }, _p: t, _a: null, _e: n, _s: new Map, state: e }); return i } const Use = () => { }; function LW(n, e, t, r = Use) { n.push(e); const i = () => { const a = n.indexOf(e); a > -1 && (n.splice(a, 1), r()) }; return !t && Q_() && eb(i), i } function cm(n, ...e) { n.slice().forEach(t => { t(...e) }) } const Tlt = n => n(), RW = Symbol(), OD = Symbol(); function gL(n, e) { n instanceof Map && e instanceof Map ? e.forEach((t, r) => n.set(r, t)) : n instanceof Set && e instanceof Set && e.forEach(n.add, n); for (const t in e) { if (!e.hasOwnProperty(t)) continue; const r = e[t], i = n[t]; mL(i) && mL(r) && n.hasOwnProperty(t) && !Kn(r) && !ul(r) ? n[t] = gL(i, r) : n[t] = r } return n } const klt = Symbol(); function Clt(n) { return !mL(n) || !n.hasOwnProperty(klt) } const { assign: yu } = Object; function Alt(n) { return !!(Kn(n) && n.effect) } function Elt(n, e, t, r) { const { state: i, actions: a, getters: o } = e, s = t.state.value[n]; let l; function c() { s || (t.state.value[n] = i ? i() : {}); const u = tb(t.state.value[n]); return yu(u, a, Object.keys(o || {}).reduce((d, f) => (d[f] = dn(ne(() => { PC(t); const h = t._s.get(n); return o[f].call(h, h) })), d), {})) } return l = Gse(n, c, e, t, r, !0), l } function Gse(n, e, t = {}, r, i, a) { let o; const s = yu({ actions: {} }, t), l = { deep: !0 }; let c, u, d = [], f = [], h; const p = r.state.value[n]; !a && !p && (r.state.value[n] = {}), he({}); let m; function g(A) { let C; c = u = !1, typeof A == "function" ? (A(r.state.value[n]), C = { type: C0.patchFunction, storeId: n, events: h }) : (gL(r.state.value[n], A), C = { type: C0.patchObject, payload: A, storeId: n, events: h }); const E = m = Symbol(); Pr().then(() => { m === E && (c = !0) }), u = !0, cm(d, C, r.state.value[n]) } const y = a ? function () { const { state: C } = t, E = C ? C() : {}; this.$patch(O => { yu(O, E) }) } : Use; function b() { o.stop(), d = [], f = [], r._s.delete(n) } const w = (A, C = "") => { if (RW in A) return A[OD] = C, A; const E = function () { PC(r); const O = Array.from(arguments), j = [], I = []; function L(P) { j.push(P) } function R(P) { I.push(P) } cm(f, { args: O, name: E[OD], store: S, after: L, onError: R }); let D; try { D = A.apply(this && this.$id === n ? this : S, O) } catch (P) { throw cm(I, P), P } return D instanceof Promise ? D.then(P => (cm(j, P), P)).catch(P => (cm(I, P), Promise.reject(P))) : (cm(j, D), D) }; return E[RW] = !0, E[OD] = C, E }, v = { _p: r, $id: n, $onAction: LW.bind(null, f), $patch: g, $reset: y, $subscribe(A, C = {}) { const E = LW(d, A, C.detached, () => O()), O = o.run(() => Ct(() => r.state.value[n], j => { (C.flush === "sync" ? u : c) && A({ storeId: n, type: C0.direct, events: h }, j) }, yu({}, l, C))); return E }, $dispose: b }, S = vr(v); r._s.set(n, S); const k = (r._a && r._a.runWithContext || Tlt)(() => r._e.run(() => (o = YW()).run(() => e({ action: w })))); for (const A in k) { const C = k[A]; if (Kn(C) && !Alt(C) || ul(C)) a || (p && Clt(C) && (Kn(C) ? C.value = p[A] : gL(C, p[A])), r.state.value[n][A] = C); else if (typeof C == "function") { const E = w(C, A); k[A] = E, s.actions[A] = C } } return yu(S, k), yu(Vt(S), k), Object.defineProperty(S, "$state", { get: () => r.state.value[n], set: A => { g(C => { yu(C, A) }) } }), r._p.forEach(A => { yu(S, o.run(() => A({ store: S, app: r._a, pinia: r, options: s }))) }), p && a && t.hydrate && t.hydrate(S.$state, p), c = !0, u = !0, S } function IC(n, e, t) { let r, i; const a = typeof e == "function"; typeof n == "string" ? (r = n, i = a ? t : e) : (i = n, r = n.id); function o(s, l) { const c = eve(); return s = s || (c ? zn(Hse, null) : null), s && PC(s), s = Vse, s._s.has(r) || (a ? Gse(r, e, i, s) : Elt(r, i, s)), s._s.get(r) } return o.$id = r, o } function lft(n) { { n = Vt(n); const e = {}; for (const t in n) { const r = n[t]; (Kn(r) || ul(r)) && (e[t] = M0(n, t)) } return e } } let vL = he([]), Mlt = { name: "Dialogs", render() { return vL.value.map(n => $e(_Z, { options: n, modelValue: n.show, "onUpdate:modelValue": e => n.show = e }, { "body-content": () => [n.message && $e("p", { class: "text-p-base text-ink-gray-7" }, [n.message]), n.html && $e("div", { innerHTML: n.html }, null), $e(bR, { class: "mt-2", message: n.error }, null)] })) } }; function Olt(n) { let e = vr(n); e.key = "dialog-" + vL.value.length, e.show = !1, setTimeout(() => { e.show = !0 }, 0), vL.value.push(e) } var RT = { exports: {} };/**
 * @license
 * Lodash <https://lodash.com/>
 * Copyright OpenJS Foundation and other contributors <https://openjsf.org/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */RT.exports; (function (n, e) {
  (function () {
    var t, r = "4.17.21", i = 200, a = "Unsupported core-js use. Try https://npms.io/search?q=ponyfill.", o = "Expected a function", s = "Invalid `variable` option passed into `_.template`", l = "__lodash_hash_undefined__", c = 500, u = "__lodash_placeholder__", d = 1, f = 2, h = 4, p = 1, m = 2, g = 1, y = 2, b = 4, w = 8, v = 16, S = 32, x = 64, k = 128, A = 256, C = 512, E = 30, O = "...", j = 800, I = 16, L = 1, R = 2, D = 3, P = 1 / 0, B = 9007199254740991, F = 17976931348623157e292, K = 0 / 0, V = 4294967295, W = V - 1, J = V >>> 1, ie = [["ary", k], ["bind", g], ["bindKey", y], ["curry", w], ["curryRight", v], ["flip", C], ["partial", S], ["partialRight", x], ["rearg", A]], le = "[object Arguments]", De = "[object Array]", ae = "[object AsyncFunction]", pe = "[object Boolean]", se = "[object Date]", ge = "[object DOMException]", _e = "[object Error]", je = "[object Function]", U = "[object GeneratorFunction]", q = "[object Map]", ee = "[object Number]", de = "[object Null]", me = "[object Object]", fe = "[object Promise]", we = "[object Proxy]", Oe = "[object RegExp]", ve = "[object Set]", Se = "[object String]", Ke = "[object Symbol]", ze = "[object Undefined]", Xe = "[object WeakMap]", Ee = "[object WeakSet]", ce = "[object ArrayBuffer]", Te = "[object DataView]", Le = "[object Float32Array]", st = "[object Float64Array]", jt = "[object Int8Array]", Dn = "[object Int16Array]", rr = "[object Int32Array]", Ce = "[object Uint8Array]", it = "[object Uint8ClampedArray]", ct = "[object Uint16Array]", $t = "[object Uint32Array]", sn = /\b__p \+= '';/g, ni = /\b(__p \+=) '' \+/g, sa = /(__e\(.*?\)|\b__t\)) \+\n'';/g, Rl = /&(?:amp|lt|gt|quot|#39);/g, dv = /[&<>"']/g, Nl = RegExp(Rl.source), fv = RegExp(dv.source), hp = /<%-([\s\S]+?)%>/g, Gc = /<%([\s\S]+?)%>/g, zb = /<%=([\s\S]+?)%>/g, hv = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, pp = /^\w*$/, ole = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g, NC = /[\\^$.*+?()[\]{}|]/g, sle = RegExp(NC.source), BC = /^\s+/, lle = /\s/, cle = /\{(?:\n\/\* \[wrapped with .+\] \*\/)?\n?/, ule = /\{\n\/\* \[wrapped with (.+)\] \*/, dle = /,? & /, fle = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g, hle = /[()=,{}\[\]\/\s]/, ple = /\\(\\)?/g, mle = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g, $B = /\w*$/, gle = /^[-+]0x[0-9a-f]+$/i, vle = /^0b[01]+$/i, yle = /^\[object .+?Constructor\]$/, _le = /^0o[0-7]+$/i, ble = /^(?:0|[1-9]\d*)$/, wle = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g, Vb = /($^)/, xle = /['\n\r\u2028\u2029\\]/g, Hb = "\\ud800-\\udfff", Sle = "\\u0300-\\u036f", Tle = "\\ufe20-\\ufe2f", kle = "\\u20d0-\\u20ff", FB = Sle + Tle + kle, zB = "\\u2700-\\u27bf", VB = "a-z\\xdf-\\xf6\\xf8-\\xff", Cle = "\\xac\\xb1\\xd7\\xf7", Ale = "\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf", Ele = "\\u2000-\\u206f", Mle = " \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000", HB = "A-Z\\xc0-\\xd6\\xd8-\\xde", UB = "\\ufe0e\\ufe0f", GB = Cle + Ale + Ele + Mle, $C = "[']", Ole = "[" + Hb + "]", WB = "[" + GB + "]", Ub = "[" + FB + "]", KB = "\\d+", Dle = "[" + zB + "]", qB = "[" + VB + "]", YB = "[^" + Hb + GB + KB + zB + VB + HB + "]", FC = "\\ud83c[\\udffb-\\udfff]", jle = "(?:" + Ub + "|" + FC + ")", ZB = "[^" + Hb + "]", zC = "(?:\\ud83c[\\udde6-\\uddff]){2}", VC = "[\\ud800-\\udbff][\\udc00-\\udfff]", mp = "[" + HB + "]", XB = "\\u200d", JB = "(?:" + qB + "|" + YB + ")", Ple = "(?:" + mp + "|" + YB + ")", QB = "(?:" + $C + "(?:d|ll|m|re|s|t|ve))?", e5 = "(?:" + $C + "(?:D|LL|M|RE|S|T|VE))?", t5 = jle + "?", n5 = "[" + UB + "]?", Ile = "(?:" + XB + "(?:" + [ZB, zC, VC].join("|") + ")" + n5 + t5 + ")*", Lle = "\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])", Rle = "\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])", r5 = n5 + t5 + Ile, Nle = "(?:" + [Dle, zC, VC].join("|") + ")" + r5, Ble = "(?:" + [ZB + Ub + "?", Ub, zC, VC, Ole].join("|") + ")", $le = RegExp($C, "g"), Fle = RegExp(Ub, "g"), HC = RegExp(FC + "(?=" + FC + ")|" + Ble + r5, "g"), zle = RegExp([mp + "?" + qB + "+" + QB + "(?=" + [WB, mp, "$"].join("|") + ")", Ple + "+" + e5 + "(?=" + [WB, mp + JB, "$"].join("|") + ")", mp + "?" + JB + "+" + QB, mp + "+" + e5, Rle, Lle, KB, Nle].join("|"), "g"), Vle = RegExp("[" + XB + Hb + FB + UB + "]"), Hle = /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/, Ule = ["Array", "Buffer", "DataView", "Date", "Error", "Float32Array", "Float64Array", "Function", "Int8Array", "Int16Array", "Int32Array", "Map", "Math", "Object", "Promise", "RegExp", "Set", "String", "Symbol", "TypeError", "Uint8Array", "Uint8ClampedArray", "Uint16Array", "Uint32Array", "WeakMap", "_", "clearTimeout", "isFinite", "parseInt", "setTimeout"], Gle = -1, Zn = {}; Zn[Le] = Zn[st] = Zn[jt] = Zn[Dn] = Zn[rr] = Zn[Ce] = Zn[it] = Zn[ct] = Zn[$t] = !0, Zn[le] = Zn[De] = Zn[ce] = Zn[pe] = Zn[Te] = Zn[se] = Zn[_e] = Zn[je] = Zn[q] = Zn[ee] = Zn[me] = Zn[Oe] = Zn[ve] = Zn[Se] = Zn[Xe] = !1; var Gn = {}; Gn[le] = Gn[De] = Gn[ce] = Gn[Te] = Gn[pe] = Gn[se] = Gn[Le] = Gn[st] = Gn[jt] = Gn[Dn] = Gn[rr] = Gn[q] = Gn[ee] = Gn[me] = Gn[Oe] = Gn[ve] = Gn[Se] = Gn[Ke] = Gn[Ce] = Gn[it] = Gn[ct] = Gn[$t] = !0, Gn[_e] = Gn[je] = Gn[Xe] = !1; var Wle = { : "A", : "A", : "A", : "A", : "A", : "A", : "a", : "a", : "a", : "a", : "a", : "a", : "C", : "c", : "D", : "d", : "E", : "E", : "E", : "E", : "e", : "e", : "e", : "e", : "I", : "I", : "I", : "I", : "i", : "i", : "i", : "i", : "N", : "n", : "O", : "O", : "O", : "O", : "O", : "O", : "o", : "o", : "o", : "o", : "o", : "o", : "U", : "U", : "U", : "U", : "u", : "u", : "u", : "u", : "Y", : "y", : "y", : "Ae", : "ae", : "Th", : "th", : "ss", : "A", : "A", : "A", : "a", : "a", : "a", : "C", : "C", : "C", : "C", : "c", : "c", : "c", : "c", : "D", : "D", : "d", : "d", : "E", : "E", : "E", : "E", : "E", : "e", : "e", : "e", : "e", : "e", : "G", : "G", : "G", : "G", : "g", : "g", : "g", : "g", : "H", : "H", : "h", : "h", : "I", : "I", : "I", : "I", : "I", : "i", : "i", : "i", : "i", : "i", : "J", : "j", : "K", : "k", : "k", : "L", : "L", : "L", : "L", : "L", : "l", : "l", : "l", : "l", : "l", : "N", : "N", : "N", : "N", : "n", : "n", : "n", : "n", : "O", : "O", : "O", : "o", : "o", : "o", : "R", : "R", : "R", : "r", : "r", : "r", : "S", : "S", : "S", : "S", : "s", : "s", : "s", : "s", : "T", : "T", : "T", : "t", : "t", : "t", : "U", : "U", : "U", : "U", : "U", : "U", : "u", : "u", : "u", : "u", : "u", : "u", : "W", : "w", : "Y", : "y", : "Y", : "Z", : "Z", : "Z", : "z", : "z", : "z", : "IJ", : "ij", : "Oe", : "oe", : "'n", : "s" }, Kle = { "&": "&amp;", "<": "&lt;", ">": "&gt;", '"': "&quot;", "'": "&#39;" }, qle = { "&amp;": "&", "&lt;": "<", "&gt;": ">", "&quot;": '"', "&#39;": "'" }, Yle = { "\\": "\\", "'": "'", "\n": "n", "\r": "r", "\u2028": "u2028", "\u2029": "u2029" }, Zle = parseFloat, Xle = parseInt, i5 = typeof Du == "object" && Du && Du.Object === Object && Du, Jle = typeof self == "object" && self && self.Object === Object && self, ri = i5 || Jle || Function("return this")(), UC = e && !e.nodeType && e, qd = UC && !0 && n && !n.nodeType && n, a5 = qd && qd.exports === UC, GC = a5 && i5.process, Xa = function () { try { var oe = qd && qd.require && qd.require("util").types; return oe || GC && GC.binding && GC.binding("util") } catch { } }(), o5 = Xa && Xa.isArrayBuffer, s5 = Xa && Xa.isDate, l5 = Xa && Xa.isMap, c5 = Xa && Xa.isRegExp, u5 = Xa && Xa.isSet, d5 = Xa && Xa.isTypedArray; function Ma(oe, Me, xe) { switch (xe.length) { case 0: return oe.call(Me); case 1: return oe.call(Me, xe[0]); case 2: return oe.call(Me, xe[0], xe[1]); case 3: return oe.call(Me, xe[0], xe[1], xe[2]) }return oe.apply(Me, xe) } function Qle(oe, Me, xe, at) { for (var Ft = -1, An = oe == null ? 0 : oe.length; ++Ft < An;) { var Ir = oe[Ft]; Me(at, Ir, xe(Ir), oe) } return at } function Ja(oe, Me) { for (var xe = -1, at = oe == null ? 0 : oe.length; ++xe < at && Me(oe[xe], xe, oe) !== !1;); return oe } function ece(oe, Me) { for (var xe = oe == null ? 0 : oe.length; xe-- && Me(oe[xe], xe, oe) !== !1;); return oe } function f5(oe, Me) { for (var xe = -1, at = oe == null ? 0 : oe.length; ++xe < at;)if (!Me(oe[xe], xe, oe)) return !1; return !0 } function Wc(oe, Me) { for (var xe = -1, at = oe == null ? 0 : oe.length, Ft = 0, An = []; ++xe < at;) { var Ir = oe[xe]; Me(Ir, xe, oe) && (An[Ft++] = Ir) } return An } function Gb(oe, Me) { var xe = oe == null ? 0 : oe.length; return !!xe && gp(oe, Me, 0) > -1 } function WC(oe, Me, xe) { for (var at = -1, Ft = oe == null ? 0 : oe.length; ++at < Ft;)if (xe(Me, oe[at])) return !0; return !1 } function er(oe, Me) { for (var xe = -1, at = oe == null ? 0 : oe.length, Ft = Array(at); ++xe < at;)Ft[xe] = Me(oe[xe], xe, oe); return Ft } function Kc(oe, Me) { for (var xe = -1, at = Me.length, Ft = oe.length; ++xe < at;)oe[Ft + xe] = Me[xe]; return oe } function KC(oe, Me, xe, at) { var Ft = -1, An = oe == null ? 0 : oe.length; for (at && An && (xe = oe[++Ft]); ++Ft < An;)xe = Me(xe, oe[Ft], Ft, oe); return xe } function tce(oe, Me, xe, at) { var Ft = oe == null ? 0 : oe.length; for (at && Ft && (xe = oe[--Ft]); Ft--;)xe = Me(xe, oe[Ft], Ft, oe); return xe } function qC(oe, Me) { for (var xe = -1, at = oe == null ? 0 : oe.length; ++xe < at;)if (Me(oe[xe], xe, oe)) return !0; return !1 } var nce = YC("length"); function rce(oe) { return oe.split("") } function ice(oe) { return oe.match(fle) || [] } function h5(oe, Me, xe) { var at; return xe(oe, function (Ft, An, Ir) { if (Me(Ft, An, Ir)) return at = An, !1 }), at } function Wb(oe, Me, xe, at) { for (var Ft = oe.length, An = xe + (at ? 1 : -1); at ? An-- : ++An < Ft;)if (Me(oe[An], An, oe)) return An; return -1 } function gp(oe, Me, xe) { return Me === Me ? gce(oe, Me, xe) : Wb(oe, p5, xe) } function ace(oe, Me, xe, at) { for (var Ft = xe - 1, An = oe.length; ++Ft < An;)if (at(oe[Ft], Me)) return Ft; return -1 } function p5(oe) { return oe !== oe } function m5(oe, Me) { var xe = oe == null ? 0 : oe.length; return xe ? XC(oe, Me) / xe : K } function YC(oe) { return function (Me) { return Me == null ? t : Me[oe] } } function ZC(oe) { return function (Me) { return oe == null ? t : oe[Me] } } function g5(oe, Me, xe, at, Ft) { return Ft(oe, function (An, Ir, Vn) { xe = at ? (at = !1, An) : Me(xe, An, Ir, Vn) }), xe } function oce(oe, Me) { var xe = oe.length; for (oe.sort(Me); xe--;)oe[xe] = oe[xe].value; return oe } function XC(oe, Me) { for (var xe, at = -1, Ft = oe.length; ++at < Ft;) { var An = Me(oe[at]); An !== t && (xe = xe === t ? An : xe + An) } return xe } function JC(oe, Me) { for (var xe = -1, at = Array(oe); ++xe < oe;)at[xe] = Me(xe); return at } function sce(oe, Me) { return er(Me, function (xe) { return [xe, oe[xe]] }) } function v5(oe) { return oe && oe.slice(0, w5(oe) + 1).replace(BC, "") } function Oa(oe) { return function (Me) { return oe(Me) } } function QC(oe, Me) { return er(Me, function (xe) { return oe[xe] }) } function pv(oe, Me) { return oe.has(Me) } function y5(oe, Me) { for (var xe = -1, at = oe.length; ++xe < at && gp(Me, oe[xe], 0) > -1;); return xe } function _5(oe, Me) { for (var xe = oe.length; xe-- && gp(Me, oe[xe], 0) > -1;); return xe } function lce(oe, Me) { for (var xe = oe.length, at = 0; xe--;)oe[xe] === Me && ++at; return at } var cce = ZC(Wle), uce = ZC(Kle); function dce(oe) { return "\\" + Yle[oe] } function fce(oe, Me) { return oe == null ? t : oe[Me] } function vp(oe) { return Vle.test(oe) } function hce(oe) { return Hle.test(oe) } function pce(oe) { for (var Me, xe = []; !(Me = oe.next()).done;)xe.push(Me.value); return xe } function eA(oe) { var Me = -1, xe = Array(oe.size); return oe.forEach(function (at, Ft) { xe[++Me] = [Ft, at] }), xe } function b5(oe, Me) { return function (xe) { return oe(Me(xe)) } } function qc(oe, Me) { for (var xe = -1, at = oe.length, Ft = 0, An = []; ++xe < at;) { var Ir = oe[xe]; (Ir === Me || Ir === u) && (oe[xe] = u, An[Ft++] = xe) } return An } function Kb(oe) { var Me = -1, xe = Array(oe.size); return oe.forEach(function (at) { xe[++Me] = at }), xe } function mce(oe) { var Me = -1, xe = Array(oe.size); return oe.forEach(function (at) { xe[++Me] = [at, at] }), xe } function gce(oe, Me, xe) { for (var at = xe - 1, Ft = oe.length; ++at < Ft;)if (oe[at] === Me) return at; return -1 } function vce(oe, Me, xe) { for (var at = xe + 1; at--;)if (oe[at] === Me) return at; return at } function yp(oe) { return vp(oe) ? _ce(oe) : nce(oe) } function qo(oe) { return vp(oe) ? bce(oe) : rce(oe) } function w5(oe) { for (var Me = oe.length; Me-- && lle.test(oe.charAt(Me));); return Me } var yce = ZC(qle); function _ce(oe) { for (var Me = HC.lastIndex = 0; HC.test(oe);)++Me; return Me } function bce(oe) { return oe.match(HC) || [] } function wce(oe) { return oe.match(zle) || [] } var xce = function oe(Me) {
      Me = Me == null ? ri : _p.defaults(ri.Object(), Me, _p.pick(ri, Ule)); var xe = Me.Array, at = Me.Date, Ft = Me.Error, An = Me.Function, Ir = Me.Math, Vn = Me.Object, tA = Me.RegExp, Sce = Me.String, Qa = Me.TypeError, qb = xe.prototype, Tce = An.prototype, bp = Vn.prototype, Yb = Me["__core-js_shared__"], Zb = Tce.toString, jn = bp.hasOwnProperty, kce = 0, x5 = function () { var _ = /[^.]+$/.exec(Yb && Yb.keys && Yb.keys.IE_PROTO || ""); return _ ? "Symbol(src)_1." + _ : "" }(), Xb = bp.toString, Cce = Zb.call(Vn), Ace = ri._, Ece = tA("^" + Zb.call(jn).replace(NC, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"), Jb = a5 ? Me.Buffer : t, Yc = Me.Symbol, Qb = Me.Uint8Array, S5 = Jb ? Jb.allocUnsafe : t, e1 = b5(Vn.getPrototypeOf, Vn), T5 = Vn.create, k5 = bp.propertyIsEnumerable, t1 = qb.splice, C5 = Yc ? Yc.isConcatSpreadable : t, mv = Yc ? Yc.iterator : t, Yd = Yc ? Yc.toStringTag : t, n1 = function () { try { var _ = ef(Vn, "defineProperty"); return _({}, "", {}), _ } catch { } }(), Mce = Me.clearTimeout !== ri.clearTimeout && Me.clearTimeout, Oce = at && at.now !== ri.Date.now && at.now, Dce = Me.setTimeout !== ri.setTimeout && Me.setTimeout, r1 = Ir.ceil, i1 = Ir.floor, nA = Vn.getOwnPropertySymbols, jce = Jb ? Jb.isBuffer : t, A5 = Me.isFinite, Pce = qb.join, Ice = b5(Vn.keys, Vn), Lr = Ir.max, vi = Ir.min, Lce = at.now, Rce = Me.parseInt, E5 = Ir.random, Nce = qb.reverse, rA = ef(Me, "DataView"), gv = ef(Me, "Map"), iA = ef(Me, "Promise"), wp = ef(Me, "Set"), vv = ef(Me, "WeakMap"), yv = ef(Vn, "create"), a1 = vv && new vv, xp = {}, Bce = tf(rA), $ce = tf(gv), Fce = tf(iA), zce = tf(wp), Vce = tf(vv), o1 = Yc ? Yc.prototype : t, _v = o1 ? o1.valueOf : t, M5 = o1 ? o1.toString : t; function H(_) { if (ur(_) && !zt(_) && !(_ instanceof fn)) { if (_ instanceof eo) return _; if (jn.call(_, "__wrapped__")) return O8(_) } return new eo(_) } var Sp = function () { function _() { } return function (T) { if (!ir(T)) return {}; if (T5) return T5(T); _.prototype = T; var M = new _; return _.prototype = t, M } }(); function s1() { } function eo(_, T) { this.__wrapped__ = _, this.__actions__ = [], this.__chain__ = !!T, this.__index__ = 0, this.__values__ = t } H.templateSettings = { escape: hp, evaluate: Gc, interpolate: zb, variable: "", imports: { _: H } }, H.prototype = s1.prototype, H.prototype.constructor = H, eo.prototype = Sp(s1.prototype), eo.prototype.constructor = eo; function fn(_) { this.__wrapped__ = _, this.__actions__ = [], this.__dir__ = 1, this.__filtered__ = !1, this.__iteratees__ = [], this.__takeCount__ = V, this.__views__ = [] } function Hce() { var _ = new fn(this.__wrapped__); return _.__actions__ = la(this.__actions__), _.__dir__ = this.__dir__, _.__filtered__ = this.__filtered__, _.__iteratees__ = la(this.__iteratees__), _.__takeCount__ = this.__takeCount__, _.__views__ = la(this.__views__), _ } function Uce() { if (this.__filtered__) { var _ = new fn(this); _.__dir__ = -1, _.__filtered__ = !0 } else _ = this.clone(), _.__dir__ *= -1; return _ } function Gce() { var _ = this.__wrapped__.value(), T = this.__dir__, M = zt(_), N = T < 0, z = M ? _.length : 0, G = rde(0, z, this.__views__), Y = G.start, Q = G.end, ue = Q - Y, Pe = N ? Q : Y - 1, Ie = this.__iteratees__, Re = Ie.length, Je = 0, gt = vi(ue, this.__takeCount__); if (!M || !N && z == ue && gt == ue) return Q5(_, this.__actions__); var Ot = []; e: for (; ue-- && Je < gt;) { Pe += T; for (var Zt = -1, Dt = _[Pe]; ++Zt < Re;) { var ln = Ie[Zt], mn = ln.iteratee, Pa = ln.type, zi = mn(Dt); if (Pa == R) Dt = zi; else if (!zi) { if (Pa == L) continue e; break e } } Ot[Je++] = Dt } return Ot } fn.prototype = Sp(s1.prototype), fn.prototype.constructor = fn; function Zd(_) { var T = -1, M = _ == null ? 0 : _.length; for (this.clear(); ++T < M;) { var N = _[T]; this.set(N[0], N[1]) } } function Wce() { this.__data__ = yv ? yv(null) : {}, this.size = 0 } function Kce(_) { var T = this.has(_) && delete this.__data__[_]; return this.size -= T ? 1 : 0, T } function qce(_) { var T = this.__data__; if (yv) { var M = T[_]; return M === l ? t : M } return jn.call(T, _) ? T[_] : t } function Yce(_) { var T = this.__data__; return yv ? T[_] !== t : jn.call(T, _) } function Zce(_, T) { var M = this.__data__; return this.size += this.has(_) ? 0 : 1, M[_] = yv && T === t ? l : T, this } Zd.prototype.clear = Wce, Zd.prototype.delete = Kce, Zd.prototype.get = qce, Zd.prototype.has = Yce, Zd.prototype.set = Zce; function Bl(_) { var T = -1, M = _ == null ? 0 : _.length; for (this.clear(); ++T < M;) { var N = _[T]; this.set(N[0], N[1]) } } function Xce() { this.__data__ = [], this.size = 0 } function Jce(_) { var T = this.__data__, M = l1(T, _); if (M < 0) return !1; var N = T.length - 1; return M == N ? T.pop() : t1.call(T, M, 1), --this.size, !0 } function Qce(_) { var T = this.__data__, M = l1(T, _); return M < 0 ? t : T[M][1] } function eue(_) { return l1(this.__data__, _) > -1 } function tue(_, T) { var M = this.__data__, N = l1(M, _); return N < 0 ? (++this.size, M.push([_, T])) : M[N][1] = T, this } Bl.prototype.clear = Xce, Bl.prototype.delete = Jce, Bl.prototype.get = Qce, Bl.prototype.has = eue, Bl.prototype.set = tue; function $l(_) { var T = -1, M = _ == null ? 0 : _.length; for (this.clear(); ++T < M;) { var N = _[T]; this.set(N[0], N[1]) } } function nue() { this.size = 0, this.__data__ = { hash: new Zd, map: new (gv || Bl), string: new Zd } } function rue(_) { var T = b1(this, _).delete(_); return this.size -= T ? 1 : 0, T } function iue(_) { return b1(this, _).get(_) } function aue(_) { return b1(this, _).has(_) } function oue(_, T) { var M = b1(this, _), N = M.size; return M.set(_, T), this.size += M.size == N ? 0 : 1, this } $l.prototype.clear = nue, $l.prototype.delete = rue, $l.prototype.get = iue, $l.prototype.has = aue, $l.prototype.set = oue; function Xd(_) { var T = -1, M = _ == null ? 0 : _.length; for (this.__data__ = new $l; ++T < M;)this.add(_[T]) } function sue(_) { return this.__data__.set(_, l), this } function lue(_) { return this.__data__.has(_) } Xd.prototype.add = Xd.prototype.push = sue, Xd.prototype.has = lue; function Yo(_) { var T = this.__data__ = new Bl(_); this.size = T.size } function cue() { this.__data__ = new Bl, this.size = 0 } function uue(_) { var T = this.__data__, M = T.delete(_); return this.size = T.size, M } function due(_) { return this.__data__.get(_) } function fue(_) { return this.__data__.has(_) } function hue(_, T) { var M = this.__data__; if (M instanceof Bl) { var N = M.__data__; if (!gv || N.length < i - 1) return N.push([_, T]), this.size = ++M.size, this; M = this.__data__ = new $l(N) } return M.set(_, T), this.size = M.size, this } Yo.prototype.clear = cue, Yo.prototype.delete = uue, Yo.prototype.get = due, Yo.prototype.has = fue, Yo.prototype.set = hue; function O5(_, T) { var M = zt(_), N = !M && nf(_), z = !M && !N && eu(_), G = !M && !N && !z && Ap(_), Y = M || N || z || G, Q = Y ? JC(_.length, Sce) : [], ue = Q.length; for (var Pe in _) (T || jn.call(_, Pe)) && !(Y && (Pe == "length" || z && (Pe == "offset" || Pe == "parent") || G && (Pe == "buffer" || Pe == "byteLength" || Pe == "byteOffset") || Hl(Pe, ue))) && Q.push(Pe); return Q } function D5(_) { var T = _.length; return T ? _[mA(0, T - 1)] : t } function pue(_, T) { return w1(la(_), Jd(T, 0, _.length)) } function mue(_) { return w1(la(_)) } function aA(_, T, M) { (M !== t && !Zo(_[T], M) || M === t && !(T in _)) && Fl(_, T, M) } function bv(_, T, M) { var N = _[T]; (!(jn.call(_, T) && Zo(N, M)) || M === t && !(T in _)) && Fl(_, T, M) } function l1(_, T) { for (var M = _.length; M--;)if (Zo(_[M][0], T)) return M; return -1 } function gue(_, T, M, N) { return Zc(_, function (z, G, Y) { T(N, z, M(z), Y) }), N } function j5(_, T) { return _ && Ls(T, Kr(T), _) } function vue(_, T) { return _ && Ls(T, ua(T), _) } function Fl(_, T, M) { T == "__proto__" && n1 ? n1(_, T, { configurable: !0, enumerable: !0, value: M, writable: !0 }) : _[T] = M } function oA(_, T) { for (var M = -1, N = T.length, z = xe(N), G = _ == null; ++M < N;)z[M] = G ? t : FA(_, T[M]); return z } function Jd(_, T, M) { return _ === _ && (M !== t && (_ = _ <= M ? _ : M), T !== t && (_ = _ >= T ? _ : T)), _ } function to(_, T, M, N, z, G) { var Y, Q = T & d, ue = T & f, Pe = T & h; if (M && (Y = z ? M(_, N, z, G) : M(_)), Y !== t) return Y; if (!ir(_)) return _; var Ie = zt(_); if (Ie) { if (Y = ade(_), !Q) return la(_, Y) } else { var Re = yi(_), Je = Re == je || Re == U; if (eu(_)) return n8(_, Q); if (Re == me || Re == le || Je && !z) { if (Y = ue || Je ? {} : w8(_), !Q) return ue ? que(_, vue(Y, _)) : Kue(_, j5(Y, _)) } else { if (!Gn[Re]) return z ? _ : {}; Y = ode(_, Re, Q) } } G || (G = new Yo); var gt = G.get(_); if (gt) return gt; G.set(_, Y), Z8(_) ? _.forEach(function (Dt) { Y.add(to(Dt, T, M, Dt, _, G)) }) : q8(_) && _.forEach(function (Dt, ln) { Y.set(ln, to(Dt, T, M, ln, _, G)) }); var Ot = Pe ? ue ? CA : kA : ue ? ua : Kr, Zt = Ie ? t : Ot(_); return Ja(Zt || _, function (Dt, ln) { Zt && (ln = Dt, Dt = _[ln]), bv(Y, ln, to(Dt, T, M, ln, _, G)) }), Y } function yue(_) { var T = Kr(_); return function (M) { return P5(M, _, T) } } function P5(_, T, M) { var N = M.length; if (_ == null) return !N; for (_ = Vn(_); N--;) { var z = M[N], G = T[z], Y = _[z]; if (Y === t && !(z in _) || !G(Y)) return !1 } return !0 } function I5(_, T, M) { if (typeof _ != "function") throw new Qa(o); return Av(function () { _.apply(t, M) }, T) } function wv(_, T, M, N) { var z = -1, G = Gb, Y = !0, Q = _.length, ue = [], Pe = T.length; if (!Q) return ue; M && (T = er(T, Oa(M))), N ? (G = WC, Y = !1) : T.length >= i && (G = pv, Y = !1, T = new Xd(T)); e: for (; ++z < Q;) { var Ie = _[z], Re = M == null ? Ie : M(Ie); if (Ie = N || Ie !== 0 ? Ie : 0, Y && Re === Re) { for (var Je = Pe; Je--;)if (T[Je] === Re) continue e; ue.push(Ie) } else G(T, Re, N) || ue.push(Ie) } return ue } var Zc = s8(Is), L5 = s8(lA, !0); function _ue(_, T) { var M = !0; return Zc(_, function (N, z, G) { return M = !!T(N, z, G), M }), M } function c1(_, T, M) { for (var N = -1, z = _.length; ++N < z;) { var G = _[N], Y = T(G); if (Y != null && (Q === t ? Y === Y && !ja(Y) : M(Y, Q))) var Q = Y, ue = G } return ue } function bue(_, T, M, N) { var z = _.length; for (M = qt(M), M < 0 && (M = -M > z ? 0 : z + M), N = N === t || N > z ? z : qt(N), N < 0 && (N += z), N = M > N ? 0 : J8(N); M < N;)_[M++] = T; return _ } function R5(_, T) { var M = []; return Zc(_, function (N, z, G) { T(N, z, G) && M.push(N) }), M } function ii(_, T, M, N, z) { var G = -1, Y = _.length; for (M || (M = lde), z || (z = []); ++G < Y;) { var Q = _[G]; T > 0 && M(Q) ? T > 1 ? ii(Q, T - 1, M, N, z) : Kc(z, Q) : N || (z[z.length] = Q) } return z } var sA = l8(), N5 = l8(!0); function Is(_, T) { return _ && sA(_, T, Kr) } function lA(_, T) { return _ && N5(_, T, Kr) } function u1(_, T) { return Wc(T, function (M) { return Ul(_[M]) }) } function Qd(_, T) { T = Jc(T, _); for (var M = 0, N = T.length; _ != null && M < N;)_ = _[Rs(T[M++])]; return M && M == N ? _ : t } function B5(_, T, M) { var N = T(_); return zt(_) ? N : Kc(N, M(_)) } function $i(_) { return _ == null ? _ === t ? ze : de : Yd && Yd in Vn(_) ? nde(_) : mde(_) } function cA(_, T) { return _ > T } function wue(_, T) { return _ != null && jn.call(_, T) } function xue(_, T) { return _ != null && T in Vn(_) } function Sue(_, T, M) { return _ >= vi(T, M) && _ < Lr(T, M) } function uA(_, T, M) { for (var N = M ? WC : Gb, z = _[0].length, G = _.length, Y = G, Q = xe(G), ue = 1 / 0, Pe = []; Y--;) { var Ie = _[Y]; Y && T && (Ie = er(Ie, Oa(T))), ue = vi(Ie.length, ue), Q[Y] = !M && (T || z >= 120 && Ie.length >= 120) ? new Xd(Y && Ie) : t } Ie = _[0]; var Re = -1, Je = Q[0]; e: for (; ++Re < z && Pe.length < ue;) { var gt = Ie[Re], Ot = T ? T(gt) : gt; if (gt = M || gt !== 0 ? gt : 0, !(Je ? pv(Je, Ot) : N(Pe, Ot, M))) { for (Y = G; --Y;) { var Zt = Q[Y]; if (!(Zt ? pv(Zt, Ot) : N(_[Y], Ot, M))) continue e } Je && Je.push(Ot), Pe.push(gt) } } return Pe } function Tue(_, T, M, N) { return Is(_, function (z, G, Y) { T(N, M(z), G, Y) }), N } function xv(_, T, M) { T = Jc(T, _), _ = k8(_, T); var N = _ == null ? _ : _[Rs(ro(T))]; return N == null ? t : Ma(N, _, M) } function $5(_) { return ur(_) && $i(_) == le } function kue(_) { return ur(_) && $i(_) == ce } function Cue(_) { return ur(_) && $i(_) == se } function Sv(_, T, M, N, z) { return _ === T ? !0 : _ == null || T == null || !ur(_) && !ur(T) ? _ !== _ && T !== T : Aue(_, T, M, N, Sv, z) } function Aue(_, T, M, N, z, G) { var Y = zt(_), Q = zt(T), ue = Y ? De : yi(_), Pe = Q ? De : yi(T); ue = ue == le ? me : ue, Pe = Pe == le ? me : Pe; var Ie = ue == me, Re = Pe == me, Je = ue == Pe; if (Je && eu(_)) { if (!eu(T)) return !1; Y = !0, Ie = !1 } if (Je && !Ie) return G || (G = new Yo), Y || Ap(_) ? y8(_, T, M, N, z, G) : ede(_, T, ue, M, N, z, G); if (!(M & p)) { var gt = Ie && jn.call(_, "__wrapped__"), Ot = Re && jn.call(T, "__wrapped__"); if (gt || Ot) { var Zt = gt ? _.value() : _, Dt = Ot ? T.value() : T; return G || (G = new Yo), z(Zt, Dt, M, N, G) } } return Je ? (G || (G = new Yo), tde(_, T, M, N, z, G)) : !1 } function Eue(_) { return ur(_) && yi(_) == q } function dA(_, T, M, N) { var z = M.length, G = z, Y = !N; if (_ == null) return !G; for (_ = Vn(_); z--;) { var Q = M[z]; if (Y && Q[2] ? Q[1] !== _[Q[0]] : !(Q[0] in _)) return !1 } for (; ++z < G;) { Q = M[z]; var ue = Q[0], Pe = _[ue], Ie = Q[1]; if (Y && Q[2]) { if (Pe === t && !(ue in _)) return !1 } else { var Re = new Yo; if (N) var Je = N(Pe, Ie, ue, _, T, Re); if (!(Je === t ? Sv(Ie, Pe, p | m, N, Re) : Je)) return !1 } } return !0 } function F5(_) { if (!ir(_) || ude(_)) return !1; var T = Ul(_) ? Ece : yle; return T.test(tf(_)) } function Mue(_) { return ur(_) && $i(_) == Oe } function Oue(_) { return ur(_) && yi(_) == ve } function Due(_) { return ur(_) && A1(_.length) && !!Zn[$i(_)] } function z5(_) { return typeof _ == "function" ? _ : _ == null ? da : typeof _ == "object" ? zt(_) ? U5(_[0], _[1]) : H5(_) : c4(_) } function fA(_) { if (!Cv(_)) return Ice(_); var T = []; for (var M in Vn(_)) jn.call(_, M) && M != "constructor" && T.push(M); return T } function jue(_) { if (!ir(_)) return pde(_); var T = Cv(_), M = []; for (var N in _) N == "constructor" && (T || !jn.call(_, N)) || M.push(N); return M } function hA(_, T) { return _ < T } function V5(_, T) { var M = -1, N = ca(_) ? xe(_.length) : []; return Zc(_, function (z, G, Y) { N[++M] = T(z, G, Y) }), N } function H5(_) { var T = EA(_); return T.length == 1 && T[0][2] ? S8(T[0][0], T[0][1]) : function (M) { return M === _ || dA(M, _, T) } } function U5(_, T) { return OA(_) && x8(T) ? S8(Rs(_), T) : function (M) { var N = FA(M, _); return N === t && N === T ? zA(M, _) : Sv(T, N, p | m) } } function d1(_, T, M, N, z) { _ !== T && sA(T, function (G, Y) { if (z || (z = new Yo), ir(G)) Pue(_, T, Y, M, d1, N, z); else { var Q = N ? N(jA(_, Y), G, Y + "", _, T, z) : t; Q === t && (Q = G), aA(_, Y, Q) } }, ua) } function Pue(_, T, M, N, z, G, Y) { var Q = jA(_, M), ue = jA(T, M), Pe = Y.get(ue); if (Pe) { aA(_, M, Pe); return } var Ie = G ? G(Q, ue, M + "", _, T, Y) : t, Re = Ie === t; if (Re) { var Je = zt(ue), gt = !Je && eu(ue), Ot = !Je && !gt && Ap(ue); Ie = ue, Je || gt || Ot ? zt(Q) ? Ie = Q : _r(Q) ? Ie = la(Q) : gt ? (Re = !1, Ie = n8(ue, !0)) : Ot ? (Re = !1, Ie = r8(ue, !0)) : Ie = [] : Ev(ue) || nf(ue) ? (Ie = Q, nf(Q) ? Ie = Q8(Q) : (!ir(Q) || Ul(Q)) && (Ie = w8(ue))) : Re = !1 } Re && (Y.set(ue, Ie), z(Ie, ue, N, G, Y), Y.delete(ue)), aA(_, M, Ie) } function G5(_, T) { var M = _.length; if (M) return T += T < 0 ? M : 0, Hl(T, M) ? _[T] : t } function W5(_, T, M) { T.length ? T = er(T, function (G) { return zt(G) ? function (Y) { return Qd(Y, G.length === 1 ? G[0] : G) } : G }) : T = [da]; var N = -1; T = er(T, Oa(At())); var z = V5(_, function (G, Y, Q) { var ue = er(T, function (Pe) { return Pe(G) }); return { criteria: ue, index: ++N, value: G } }); return oce(z, function (G, Y) { return Wue(G, Y, M) }) } function Iue(_, T) { return K5(_, T, function (M, N) { return zA(_, N) }) } function K5(_, T, M) { for (var N = -1, z = T.length, G = {}; ++N < z;) { var Y = T[N], Q = Qd(_, Y); M(Q, Y) && Tv(G, Jc(Y, _), Q) } return G } function Lue(_) { return function (T) { return Qd(T, _) } } function pA(_, T, M, N) { var z = N ? ace : gp, G = -1, Y = T.length, Q = _; for (_ === T && (T = la(T)), M && (Q = er(_, Oa(M))); ++G < Y;)for (var ue = 0, Pe = T[G], Ie = M ? M(Pe) : Pe; (ue = z(Q, Ie, ue, N)) > -1;)Q !== _ && t1.call(Q, ue, 1), t1.call(_, ue, 1); return _ } function q5(_, T) { for (var M = _ ? T.length : 0, N = M - 1; M--;) { var z = T[M]; if (M == N || z !== G) { var G = z; Hl(z) ? t1.call(_, z, 1) : yA(_, z) } } return _ } function mA(_, T) { return _ + i1(E5() * (T - _ + 1)) } function Rue(_, T, M, N) { for (var z = -1, G = Lr(r1((T - _) / (M || 1)), 0), Y = xe(G); G--;)Y[N ? G : ++z] = _, _ += M; return Y } function gA(_, T) { var M = ""; if (!_ || T < 1 || T > B) return M; do T % 2 && (M += _), T = i1(T / 2), T && (_ += _); while (T); return M } function an(_, T) { return PA(T8(_, T, da), _ + "") } function Nue(_) { return D5(Ep(_)) } function Bue(_, T) { var M = Ep(_); return w1(M, Jd(T, 0, M.length)) } function Tv(_, T, M, N) { if (!ir(_)) return _; T = Jc(T, _); for (var z = -1, G = T.length, Y = G - 1, Q = _; Q != null && ++z < G;) { var ue = Rs(T[z]), Pe = M; if (ue === "__proto__" || ue === "constructor" || ue === "prototype") return _; if (z != Y) { var Ie = Q[ue]; Pe = N ? N(Ie, ue, Q) : t, Pe === t && (Pe = ir(Ie) ? Ie : Hl(T[z + 1]) ? [] : {}) } bv(Q, ue, Pe), Q = Q[ue] } return _ } var Y5 = a1 ? function (_, T) { return a1.set(_, T), _ } : da, $ue = n1 ? function (_, T) { return n1(_, "toString", { configurable: !0, enumerable: !1, value: HA(T), writable: !0 }) } : da; function Fue(_) { return w1(Ep(_)) } function no(_, T, M) { var N = -1, z = _.length; T < 0 && (T = -T > z ? 0 : z + T), M = M > z ? z : M, M < 0 && (M += z), z = T > M ? 0 : M - T >>> 0, T >>>= 0; for (var G = xe(z); ++N < z;)G[N] = _[N + T]; return G } function zue(_, T) { var M; return Zc(_, function (N, z, G) { return M = T(N, z, G), !M }), !!M } function f1(_, T, M) { var N = 0, z = _ == null ? N : _.length; if (typeof T == "number" && T === T && z <= J) { for (; N < z;) { var G = N + z >>> 1, Y = _[G]; Y !== null && !ja(Y) && (M ? Y <= T : Y < T) ? N = G + 1 : z = G } return z } return vA(_, T, da, M) } function vA(_, T, M, N) { var z = 0, G = _ == null ? 0 : _.length; if (G === 0) return 0; T = M(T); for (var Y = T !== T, Q = T === null, ue = ja(T), Pe = T === t; z < G;) { var Ie = i1((z + G) / 2), Re = M(_[Ie]), Je = Re !== t, gt = Re === null, Ot = Re === Re, Zt = ja(Re); if (Y) var Dt = N || Ot; else Pe ? Dt = Ot && (N || Je) : Q ? Dt = Ot && Je && (N || !gt) : ue ? Dt = Ot && Je && !gt && (N || !Zt) : gt || Zt ? Dt = !1 : Dt = N ? Re <= T : Re < T; Dt ? z = Ie + 1 : G = Ie } return vi(G, W) } function Z5(_, T) { for (var M = -1, N = _.length, z = 0, G = []; ++M < N;) { var Y = _[M], Q = T ? T(Y) : Y; if (!M || !Zo(Q, ue)) { var ue = Q; G[z++] = Y === 0 ? 0 : Y } } return G } function X5(_) { return typeof _ == "number" ? _ : ja(_) ? K : +_ } function Da(_) { if (typeof _ == "string") return _; if (zt(_)) return er(_, Da) + ""; if (ja(_)) return M5 ? M5.call(_) : ""; var T = _ + ""; return T == "0" && 1 / _ == -P ? "-0" : T } function Xc(_, T, M) { var N = -1, z = Gb, G = _.length, Y = !0, Q = [], ue = Q; if (M) Y = !1, z = WC; else if (G >= i) { var Pe = T ? null : Jue(_); if (Pe) return Kb(Pe); Y = !1, z = pv, ue = new Xd } else ue = T ? [] : Q; e: for (; ++N < G;) { var Ie = _[N], Re = T ? T(Ie) : Ie; if (Ie = M || Ie !== 0 ? Ie : 0, Y && Re === Re) { for (var Je = ue.length; Je--;)if (ue[Je] === Re) continue e; T && ue.push(Re), Q.push(Ie) } else z(ue, Re, M) || (ue !== Q && ue.push(Re), Q.push(Ie)) } return Q } function yA(_, T) { return T = Jc(T, _), _ = k8(_, T), _ == null || delete _[Rs(ro(T))] } function J5(_, T, M, N) { return Tv(_, T, M(Qd(_, T)), N) } function h1(_, T, M, N) { for (var z = _.length, G = N ? z : -1; (N ? G-- : ++G < z) && T(_[G], G, _);); return M ? no(_, N ? 0 : G, N ? G + 1 : z) : no(_, N ? G + 1 : 0, N ? z : G) } function Q5(_, T) { var M = _; return M instanceof fn && (M = M.value()), KC(T, function (N, z) { return z.func.apply(z.thisArg, Kc([N], z.args)) }, M) } function _A(_, T, M) { var N = _.length; if (N < 2) return N ? Xc(_[0]) : []; for (var z = -1, G = xe(N); ++z < N;)for (var Y = _[z], Q = -1; ++Q < N;)Q != z && (G[z] = wv(G[z] || Y, _[Q], T, M)); return Xc(ii(G, 1), T, M) } function e8(_, T, M) { for (var N = -1, z = _.length, G = T.length, Y = {}; ++N < z;) { var Q = N < G ? T[N] : t; M(Y, _[N], Q) } return Y } function bA(_) { return _r(_) ? _ : [] } function wA(_) { return typeof _ == "function" ? _ : da } function Jc(_, T) { return zt(_) ? _ : OA(_, T) ? [_] : M8(En(_)) } var Vue = an; function Qc(_, T, M) { var N = _.length; return M = M === t ? N : M, !T && M >= N ? _ : no(_, T, M) } var t8 = Mce || function (_) { return ri.clearTimeout(_) }; function n8(_, T) { if (T) return _.slice(); var M = _.length, N = S5 ? S5(M) : new _.constructor(M); return _.copy(N), N } function xA(_) { var T = new _.constructor(_.byteLength); return new Qb(T).set(new Qb(_)), T } function Hue(_, T) { var M = T ? xA(_.buffer) : _.buffer; return new _.constructor(M, _.byteOffset, _.byteLength) } function Uue(_) { var T = new _.constructor(_.source, $B.exec(_)); return T.lastIndex = _.lastIndex, T } function Gue(_) { return _v ? Vn(_v.call(_)) : {} } function r8(_, T) { var M = T ? xA(_.buffer) : _.buffer; return new _.constructor(M, _.byteOffset, _.length) } function i8(_, T) { if (_ !== T) { var M = _ !== t, N = _ === null, z = _ === _, G = ja(_), Y = T !== t, Q = T === null, ue = T === T, Pe = ja(T); if (!Q && !Pe && !G && _ > T || G && Y && ue && !Q && !Pe || N && Y && ue || !M && ue || !z) return 1; if (!N && !G && !Pe && _ < T || Pe && M && z && !N && !G || Q && M && z || !Y && z || !ue) return -1 } return 0 } function Wue(_, T, M) { for (var N = -1, z = _.criteria, G = T.criteria, Y = z.length, Q = M.length; ++N < Y;) { var ue = i8(z[N], G[N]); if (ue) { if (N >= Q) return ue; var Pe = M[N]; return ue * (Pe == "desc" ? -1 : 1) } } return _.index - T.index } function a8(_, T, M, N) { for (var z = -1, G = _.length, Y = M.length, Q = -1, ue = T.length, Pe = Lr(G - Y, 0), Ie = xe(ue + Pe), Re = !N; ++Q < ue;)Ie[Q] = T[Q]; for (; ++z < Y;)(Re || z < G) && (Ie[M[z]] = _[z]); for (; Pe--;)Ie[Q++] = _[z++]; return Ie } function o8(_, T, M, N) { for (var z = -1, G = _.length, Y = -1, Q = M.length, ue = -1, Pe = T.length, Ie = Lr(G - Q, 0), Re = xe(Ie + Pe), Je = !N; ++z < Ie;)Re[z] = _[z]; for (var gt = z; ++ue < Pe;)Re[gt + ue] = T[ue]; for (; ++Y < Q;)(Je || z < G) && (Re[gt + M[Y]] = _[z++]); return Re } function la(_, T) { var M = -1, N = _.length; for (T || (T = xe(N)); ++M < N;)T[M] = _[M]; return T } function Ls(_, T, M, N) { var z = !M; M || (M = {}); for (var G = -1, Y = T.length; ++G < Y;) { var Q = T[G], ue = N ? N(M[Q], _[Q], Q, M, _) : t; ue === t && (ue = _[Q]), z ? Fl(M, Q, ue) : bv(M, Q, ue) } return M } function Kue(_, T) { return Ls(_, MA(_), T) } function que(_, T) { return Ls(_, _8(_), T) } function p1(_, T) { return function (M, N) { var z = zt(M) ? Qle : gue, G = T ? T() : {}; return z(M, _, At(N, 2), G) } } function Tp(_) { return an(function (T, M) { var N = -1, z = M.length, G = z > 1 ? M[z - 1] : t, Y = z > 2 ? M[2] : t; for (G = _.length > 3 && typeof G == "function" ? (z--, G) : t, Y && Fi(M[0], M[1], Y) && (G = z < 3 ? t : G, z = 1), T = Vn(T); ++N < z;) { var Q = M[N]; Q && _(T, Q, N, G) } return T }) } function s8(_, T) { return function (M, N) { if (M == null) return M; if (!ca(M)) return _(M, N); for (var z = M.length, G = T ? z : -1, Y = Vn(M); (T ? G-- : ++G < z) && N(Y[G], G, Y) !== !1;); return M } } function l8(_) { return function (T, M, N) { for (var z = -1, G = Vn(T), Y = N(T), Q = Y.length; Q--;) { var ue = Y[_ ? Q : ++z]; if (M(G[ue], ue, G) === !1) break } return T } } function Yue(_, T, M) { var N = T & g, z = kv(_); function G() { var Y = this && this !== ri && this instanceof G ? z : _; return Y.apply(N ? M : this, arguments) } return G } function c8(_) { return function (T) { T = En(T); var M = vp(T) ? qo(T) : t, N = M ? M[0] : T.charAt(0), z = M ? Qc(M, 1).join("") : T.slice(1); return N[_]() + z } } function kp(_) { return function (T) { return KC(s4(o4(T).replace($le, "")), _, "") } } function kv(_) { return function () { var T = arguments; switch (T.length) { case 0: return new _; case 1: return new _(T[0]); case 2: return new _(T[0], T[1]); case 3: return new _(T[0], T[1], T[2]); case 4: return new _(T[0], T[1], T[2], T[3]); case 5: return new _(T[0], T[1], T[2], T[3], T[4]); case 6: return new _(T[0], T[1], T[2], T[3], T[4], T[5]); case 7: return new _(T[0], T[1], T[2], T[3], T[4], T[5], T[6]) }var M = Sp(_.prototype), N = _.apply(M, T); return ir(N) ? N : M } } function Zue(_, T, M) { var N = kv(_); function z() { for (var G = arguments.length, Y = xe(G), Q = G, ue = Cp(z); Q--;)Y[Q] = arguments[Q]; var Pe = G < 3 && Y[0] !== ue && Y[G - 1] !== ue ? [] : qc(Y, ue); if (G -= Pe.length, G < M) return p8(_, T, m1, z.placeholder, t, Y, Pe, t, t, M - G); var Ie = this && this !== ri && this instanceof z ? N : _; return Ma(Ie, this, Y) } return z } function u8(_) { return function (T, M, N) { var z = Vn(T); if (!ca(T)) { var G = At(M, 3); T = Kr(T), M = function (Q) { return G(z[Q], Q, z) } } var Y = _(T, M, N); return Y > -1 ? z[G ? T[Y] : Y] : t } } function d8(_) { return Vl(function (T) { var M = T.length, N = M, z = eo.prototype.thru; for (_ && T.reverse(); N--;) { var G = T[N]; if (typeof G != "function") throw new Qa(o); if (z && !Y && _1(G) == "wrapper") var Y = new eo([], !0) } for (N = Y ? N : M; ++N < M;) { G = T[N]; var Q = _1(G), ue = Q == "wrapper" ? AA(G) : t; ue && DA(ue[0]) && ue[1] == (k | w | S | A) && !ue[4].length && ue[9] == 1 ? Y = Y[_1(ue[0])].apply(Y, ue[3]) : Y = G.length == 1 && DA(G) ? Y[Q]() : Y.thru(G) } return function () { var Pe = arguments, Ie = Pe[0]; if (Y && Pe.length == 1 && zt(Ie)) return Y.plant(Ie).value(); for (var Re = 0, Je = M ? T[Re].apply(this, Pe) : Ie; ++Re < M;)Je = T[Re].call(this, Je); return Je } }) } function m1(_, T, M, N, z, G, Y, Q, ue, Pe) { var Ie = T & k, Re = T & g, Je = T & y, gt = T & (w | v), Ot = T & C, Zt = Je ? t : kv(_); function Dt() { for (var ln = arguments.length, mn = xe(ln), Pa = ln; Pa--;)mn[Pa] = arguments[Pa]; if (gt) var zi = Cp(Dt), Ia = lce(mn, zi); if (N && (mn = a8(mn, N, z, gt)), G && (mn = o8(mn, G, Y, gt)), ln -= Ia, gt && ln < Pe) { var br = qc(mn, zi); return p8(_, T, m1, Dt.placeholder, M, mn, br, Q, ue, Pe - ln) } var Xo = Re ? M : this, Wl = Je ? Xo[_] : _; return ln = mn.length, Q ? mn = gde(mn, Q) : Ot && ln > 1 && mn.reverse(), Ie && ue < ln && (mn.length = ue), this && this !== ri && this instanceof Dt && (Wl = Zt || kv(Wl)), Wl.apply(Xo, mn) } return Dt } function f8(_, T) { return function (M, N) { return Tue(M, _, T(N), {}) } } function g1(_, T) { return function (M, N) { var z; if (M === t && N === t) return T; if (M !== t && (z = M), N !== t) { if (z === t) return N; typeof M == "string" || typeof N == "string" ? (M = Da(M), N = Da(N)) : (M = X5(M), N = X5(N)), z = _(M, N) } return z } } function SA(_) { return Vl(function (T) { return T = er(T, Oa(At())), an(function (M) { var N = this; return _(T, function (z) { return Ma(z, N, M) }) }) }) } function v1(_, T) { T = T === t ? " " : Da(T); var M = T.length; if (M < 2) return M ? gA(T, _) : T; var N = gA(T, r1(_ / yp(T))); return vp(T) ? Qc(qo(N), 0, _).join("") : N.slice(0, _) } function Xue(_, T, M, N) { var z = T & g, G = kv(_); function Y() { for (var Q = -1, ue = arguments.length, Pe = -1, Ie = N.length, Re = xe(Ie + ue), Je = this && this !== ri && this instanceof Y ? G : _; ++Pe < Ie;)Re[Pe] = N[Pe]; for (; ue--;)Re[Pe++] = arguments[++Q]; return Ma(Je, z ? M : this, Re) } return Y } function h8(_) { return function (T, M, N) { return N && typeof N != "number" && Fi(T, M, N) && (M = N = t), T = Gl(T), M === t ? (M = T, T = 0) : M = Gl(M), N = N === t ? T < M ? 1 : -1 : Gl(N), Rue(T, M, N, _) } } function y1(_) { return function (T, M) { return typeof T == "string" && typeof M == "string" || (T = io(T), M = io(M)), _(T, M) } } function p8(_, T, M, N, z, G, Y, Q, ue, Pe) { var Ie = T & w, Re = Ie ? Y : t, Je = Ie ? t : Y, gt = Ie ? G : t, Ot = Ie ? t : G; T |= Ie ? S : x, T &= ~(Ie ? x : S), T & b || (T &= ~(g | y)); var Zt = [_, T, z, gt, Re, Ot, Je, Q, ue, Pe], Dt = M.apply(t, Zt); return DA(_) && C8(Dt, Zt), Dt.placeholder = N, A8(Dt, _, T) } function TA(_) { var T = Ir[_]; return function (M, N) { if (M = io(M), N = N == null ? 0 : vi(qt(N), 292), N && A5(M)) { var z = (En(M) + "e").split("e"), G = T(z[0] + "e" + (+z[1] + N)); return z = (En(G) + "e").split("e"), +(z[0] + "e" + (+z[1] - N)) } return T(M) } } var Jue = wp && 1 / Kb(new wp([, -0]))[1] == P ? function (_) { return new wp(_) } : WA; function m8(_) { return function (T) { var M = yi(T); return M == q ? eA(T) : M == ve ? mce(T) : sce(T, _(T)) } } function zl(_, T, M, N, z, G, Y, Q) { var ue = T & y; if (!ue && typeof _ != "function") throw new Qa(o); var Pe = N ? N.length : 0; if (Pe || (T &= ~(S | x), N = z = t), Y = Y === t ? Y : Lr(qt(Y), 0), Q = Q === t ? Q : qt(Q), Pe -= z ? z.length : 0, T & x) { var Ie = N, Re = z; N = z = t } var Je = ue ? t : AA(_), gt = [_, T, M, N, z, Ie, Re, G, Y, Q]; if (Je && hde(gt, Je), _ = gt[0], T = gt[1], M = gt[2], N = gt[3], z = gt[4], Q = gt[9] = gt[9] === t ? ue ? 0 : _.length : Lr(gt[9] - Pe, 0), !Q && T & (w | v) && (T &= ~(w | v)), !T || T == g) var Ot = Yue(_, T, M); else T == w || T == v ? Ot = Zue(_, T, Q) : (T == S || T == (g | S)) && !z.length ? Ot = Xue(_, T, M, N) : Ot = m1.apply(t, gt); var Zt = Je ? Y5 : C8; return A8(Zt(Ot, gt), _, T) } function g8(_, T, M, N) { return _ === t || Zo(_, bp[M]) && !jn.call(N, M) ? T : _ } function v8(_, T, M, N, z, G) { return ir(_) && ir(T) && (G.set(T, _), d1(_, T, t, v8, G), G.delete(T)), _ } function Que(_) { return Ev(_) ? t : _ } function y8(_, T, M, N, z, G) { var Y = M & p, Q = _.length, ue = T.length; if (Q != ue && !(Y && ue > Q)) return !1; var Pe = G.get(_), Ie = G.get(T); if (Pe && Ie) return Pe == T && Ie == _; var Re = -1, Je = !0, gt = M & m ? new Xd : t; for (G.set(_, T), G.set(T, _); ++Re < Q;) { var Ot = _[Re], Zt = T[Re]; if (N) var Dt = Y ? N(Zt, Ot, Re, T, _, G) : N(Ot, Zt, Re, _, T, G); if (Dt !== t) { if (Dt) continue; Je = !1; break } if (gt) { if (!qC(T, function (ln, mn) { if (!pv(gt, mn) && (Ot === ln || z(Ot, ln, M, N, G))) return gt.push(mn) })) { Je = !1; break } } else if (!(Ot === Zt || z(Ot, Zt, M, N, G))) { Je = !1; break } } return G.delete(_), G.delete(T), Je } function ede(_, T, M, N, z, G, Y) { switch (M) { case Te: if (_.byteLength != T.byteLength || _.byteOffset != T.byteOffset) return !1; _ = _.buffer, T = T.buffer; case ce: return !(_.byteLength != T.byteLength || !G(new Qb(_), new Qb(T))); case pe: case se: case ee: return Zo(+_, +T); case _e: return _.name == T.name && _.message == T.message; case Oe: case Se: return _ == T + ""; case q: var Q = eA; case ve: var ue = N & p; if (Q || (Q = Kb), _.size != T.size && !ue) return !1; var Pe = Y.get(_); if (Pe) return Pe == T; N |= m, Y.set(_, T); var Ie = y8(Q(_), Q(T), N, z, G, Y); return Y.delete(_), Ie; case Ke: if (_v) return _v.call(_) == _v.call(T) }return !1 } function tde(_, T, M, N, z, G) { var Y = M & p, Q = kA(_), ue = Q.length, Pe = kA(T), Ie = Pe.length; if (ue != Ie && !Y) return !1; for (var Re = ue; Re--;) { var Je = Q[Re]; if (!(Y ? Je in T : jn.call(T, Je))) return !1 } var gt = G.get(_), Ot = G.get(T); if (gt && Ot) return gt == T && Ot == _; var Zt = !0; G.set(_, T), G.set(T, _); for (var Dt = Y; ++Re < ue;) { Je = Q[Re]; var ln = _[Je], mn = T[Je]; if (N) var Pa = Y ? N(mn, ln, Je, T, _, G) : N(ln, mn, Je, _, T, G); if (!(Pa === t ? ln === mn || z(ln, mn, M, N, G) : Pa)) { Zt = !1; break } Dt || (Dt = Je == "constructor") } if (Zt && !Dt) { var zi = _.constructor, Ia = T.constructor; zi != Ia && "constructor" in _ && "constructor" in T && !(typeof zi == "function" && zi instanceof zi && typeof Ia == "function" && Ia instanceof Ia) && (Zt = !1) } return G.delete(_), G.delete(T), Zt } function Vl(_) { return PA(T8(_, t, P8), _ + "") } function kA(_) { return B5(_, Kr, MA) } function CA(_) { return B5(_, ua, _8) } var AA = a1 ? function (_) { return a1.get(_) } : WA; function _1(_) { for (var T = _.name + "", M = xp[T], N = jn.call(xp, T) ? M.length : 0; N--;) { var z = M[N], G = z.func; if (G == null || G == _) return z.name } return T } function Cp(_) { var T = jn.call(H, "placeholder") ? H : _; return T.placeholder } function At() { var _ = H.iteratee || UA; return _ = _ === UA ? z5 : _, arguments.length ? _(arguments[0], arguments[1]) : _ } function b1(_, T) { var M = _.__data__; return cde(T) ? M[typeof T == "string" ? "string" : "hash"] : M.map } function EA(_) { for (var T = Kr(_), M = T.length; M--;) { var N = T[M], z = _[N]; T[M] = [N, z, x8(z)] } return T } function ef(_, T) { var M = fce(_, T); return F5(M) ? M : t } function nde(_) { var T = jn.call(_, Yd), M = _[Yd]; try { _[Yd] = t; var N = !0 } catch { } var z = Xb.call(_); return N && (T ? _[Yd] = M : delete _[Yd]), z } var MA = nA ? function (_) { return _ == null ? [] : (_ = Vn(_), Wc(nA(_), function (T) { return k5.call(_, T) })) } : KA, _8 = nA ? function (_) { for (var T = []; _;)Kc(T, MA(_)), _ = e1(_); return T } : KA, yi = $i; (rA && yi(new rA(new ArrayBuffer(1))) != Te || gv && yi(new gv) != q || iA && yi(iA.resolve()) != fe || wp && yi(new wp) != ve || vv && yi(new vv) != Xe) && (yi = function (_) { var T = $i(_), M = T == me ? _.constructor : t, N = M ? tf(M) : ""; if (N) switch (N) { case Bce: return Te; case $ce: return q; case Fce: return fe; case zce: return ve; case Vce: return Xe }return T }); function rde(_, T, M) { for (var N = -1, z = M.length; ++N < z;) { var G = M[N], Y = G.size; switch (G.type) { case "drop": _ += Y; break; case "dropRight": T -= Y; break; case "take": T = vi(T, _ + Y); break; case "takeRight": _ = Lr(_, T - Y); break } } return { start: _, end: T } } function ide(_) { var T = _.match(ule); return T ? T[1].split(dle) : [] } function b8(_, T, M) { T = Jc(T, _); for (var N = -1, z = T.length, G = !1; ++N < z;) { var Y = Rs(T[N]); if (!(G = _ != null && M(_, Y))) break; _ = _[Y] } return G || ++N != z ? G : (z = _ == null ? 0 : _.length, !!z && A1(z) && Hl(Y, z) && (zt(_) || nf(_))) } function ade(_) { var T = _.length, M = new _.constructor(T); return T && typeof _[0] == "string" && jn.call(_, "index") && (M.index = _.index, M.input = _.input), M } function w8(_) { return typeof _.constructor == "function" && !Cv(_) ? Sp(e1(_)) : {} } function ode(_, T, M) { var N = _.constructor; switch (T) { case ce: return xA(_); case pe: case se: return new N(+_); case Te: return Hue(_, M); case Le: case st: case jt: case Dn: case rr: case Ce: case it: case ct: case $t: return r8(_, M); case q: return new N; case ee: case Se: return new N(_); case Oe: return Uue(_); case ve: return new N; case Ke: return Gue(_) } } function sde(_, T) {
        var M = T.length; if (!M) return _; var N = M - 1; return T[N] = (M > 1 ? "& " : "") + T[N], T = T.join(M > 2 ? ", " : " "), _.replace(cle, `{
/* [wrapped with `+ T + `] */
`)
      } function lde(_) { return zt(_) || nf(_) || !!(C5 && _ && _[C5]) } function Hl(_, T) { var M = typeof _; return T = T ?? B, !!T && (M == "number" || M != "symbol" && ble.test(_)) && _ > -1 && _ % 1 == 0 && _ < T } function Fi(_, T, M) { if (!ir(M)) return !1; var N = typeof T; return (N == "number" ? ca(M) && Hl(T, M.length) : N == "string" && T in M) ? Zo(M[T], _) : !1 } function OA(_, T) { if (zt(_)) return !1; var M = typeof _; return M == "number" || M == "symbol" || M == "boolean" || _ == null || ja(_) ? !0 : pp.test(_) || !hv.test(_) || T != null && _ in Vn(T) } function cde(_) { var T = typeof _; return T == "string" || T == "number" || T == "symbol" || T == "boolean" ? _ !== "__proto__" : _ === null } function DA(_) { var T = _1(_), M = H[T]; if (typeof M != "function" || !(T in fn.prototype)) return !1; if (_ === M) return !0; var N = AA(M); return !!N && _ === N[0] } function ude(_) { return !!x5 && x5 in _ } var dde = Yb ? Ul : qA; function Cv(_) { var T = _ && _.constructor, M = typeof T == "function" && T.prototype || bp; return _ === M } function x8(_) { return _ === _ && !ir(_) } function S8(_, T) { return function (M) { return M == null ? !1 : M[_] === T && (T !== t || _ in Vn(M)) } } function fde(_) { var T = k1(_, function (N) { return M.size === c && M.clear(), N }), M = T.cache; return T } function hde(_, T) { var M = _[1], N = T[1], z = M | N, G = z < (g | y | k), Y = N == k && M == w || N == k && M == A && _[7].length <= T[8] || N == (k | A) && T[7].length <= T[8] && M == w; if (!(G || Y)) return _; N & g && (_[2] = T[2], z |= M & g ? 0 : b); var Q = T[3]; if (Q) { var ue = _[3]; _[3] = ue ? a8(ue, Q, T[4]) : Q, _[4] = ue ? qc(_[3], u) : T[4] } return Q = T[5], Q && (ue = _[5], _[5] = ue ? o8(ue, Q, T[6]) : Q, _[6] = ue ? qc(_[5], u) : T[6]), Q = T[7], Q && (_[7] = Q), N & k && (_[8] = _[8] == null ? T[8] : vi(_[8], T[8])), _[9] == null && (_[9] = T[9]), _[0] = T[0], _[1] = z, _ } function pde(_) { var T = []; if (_ != null) for (var M in Vn(_)) T.push(M); return T } function mde(_) { return Xb.call(_) } function T8(_, T, M) { return T = Lr(T === t ? _.length - 1 : T, 0), function () { for (var N = arguments, z = -1, G = Lr(N.length - T, 0), Y = xe(G); ++z < G;)Y[z] = N[T + z]; z = -1; for (var Q = xe(T + 1); ++z < T;)Q[z] = N[z]; return Q[T] = M(Y), Ma(_, this, Q) } } function k8(_, T) { return T.length < 2 ? _ : Qd(_, no(T, 0, -1)) } function gde(_, T) { for (var M = _.length, N = vi(T.length, M), z = la(_); N--;) { var G = T[N]; _[N] = Hl(G, M) ? z[G] : t } return _ } function jA(_, T) { if (!(T === "constructor" && typeof _[T] == "function") && T != "__proto__") return _[T] } var C8 = E8(Y5), Av = Dce || function (_, T) { return ri.setTimeout(_, T) }, PA = E8($ue); function A8(_, T, M) { var N = T + ""; return PA(_, sde(N, vde(ide(N), M))) } function E8(_) { var T = 0, M = 0; return function () { var N = Lce(), z = I - (N - M); if (M = N, z > 0) { if (++T >= j) return arguments[0] } else T = 0; return _.apply(t, arguments) } } function w1(_, T) { var M = -1, N = _.length, z = N - 1; for (T = T === t ? N : T; ++M < T;) { var G = mA(M, z), Y = _[G]; _[G] = _[M], _[M] = Y } return _.length = T, _ } var M8 = fde(function (_) { var T = []; return _.charCodeAt(0) === 46 && T.push(""), _.replace(ole, function (M, N, z, G) { T.push(z ? G.replace(ple, "$1") : N || M) }), T }); function Rs(_) { if (typeof _ == "string" || ja(_)) return _; var T = _ + ""; return T == "0" && 1 / _ == -P ? "-0" : T } function tf(_) { if (_ != null) { try { return Zb.call(_) } catch { } try { return _ + "" } catch { } } return "" } function vde(_, T) { return Ja(ie, function (M) { var N = "_." + M[0]; T & M[1] && !Gb(_, N) && _.push(N) }), _.sort() } function O8(_) { if (_ instanceof fn) return _.clone(); var T = new eo(_.__wrapped__, _.__chain__); return T.__actions__ = la(_.__actions__), T.__index__ = _.__index__, T.__values__ = _.__values__, T } function yde(_, T, M) { (M ? Fi(_, T, M) : T === t) ? T = 1 : T = Lr(qt(T), 0); var N = _ == null ? 0 : _.length; if (!N || T < 1) return []; for (var z = 0, G = 0, Y = xe(r1(N / T)); z < N;)Y[G++] = no(_, z, z += T); return Y } function _de(_) { for (var T = -1, M = _ == null ? 0 : _.length, N = 0, z = []; ++T < M;) { var G = _[T]; G && (z[N++] = G) } return z } function bde() { var _ = arguments.length; if (!_) return []; for (var T = xe(_ - 1), M = arguments[0], N = _; N--;)T[N - 1] = arguments[N]; return Kc(zt(M) ? la(M) : [M], ii(T, 1)) } var wde = an(function (_, T) { return _r(_) ? wv(_, ii(T, 1, _r, !0)) : [] }), xde = an(function (_, T) { var M = ro(T); return _r(M) && (M = t), _r(_) ? wv(_, ii(T, 1, _r, !0), At(M, 2)) : [] }), Sde = an(function (_, T) { var M = ro(T); return _r(M) && (M = t), _r(_) ? wv(_, ii(T, 1, _r, !0), t, M) : [] }); function Tde(_, T, M) { var N = _ == null ? 0 : _.length; return N ? (T = M || T === t ? 1 : qt(T), no(_, T < 0 ? 0 : T, N)) : [] } function kde(_, T, M) { var N = _ == null ? 0 : _.length; return N ? (T = M || T === t ? 1 : qt(T), T = N - T, no(_, 0, T < 0 ? 0 : T)) : [] } function Cde(_, T) { return _ && _.length ? h1(_, At(T, 3), !0, !0) : [] } function Ade(_, T) { return _ && _.length ? h1(_, At(T, 3), !0) : [] } function Ede(_, T, M, N) { var z = _ == null ? 0 : _.length; return z ? (M && typeof M != "number" && Fi(_, T, M) && (M = 0, N = z), bue(_, T, M, N)) : [] } function D8(_, T, M) { var N = _ == null ? 0 : _.length; if (!N) return -1; var z = M == null ? 0 : qt(M); return z < 0 && (z = Lr(N + z, 0)), Wb(_, At(T, 3), z) } function j8(_, T, M) { var N = _ == null ? 0 : _.length; if (!N) return -1; var z = N - 1; return M !== t && (z = qt(M), z = M < 0 ? Lr(N + z, 0) : vi(z, N - 1)), Wb(_, At(T, 3), z, !0) } function P8(_) { var T = _ == null ? 0 : _.length; return T ? ii(_, 1) : [] } function Mde(_) { var T = _ == null ? 0 : _.length; return T ? ii(_, P) : [] } function Ode(_, T) { var M = _ == null ? 0 : _.length; return M ? (T = T === t ? 1 : qt(T), ii(_, T)) : [] } function Dde(_) { for (var T = -1, M = _ == null ? 0 : _.length, N = {}; ++T < M;) { var z = _[T]; N[z[0]] = z[1] } return N } function I8(_) { return _ && _.length ? _[0] : t } function jde(_, T, M) { var N = _ == null ? 0 : _.length; if (!N) return -1; var z = M == null ? 0 : qt(M); return z < 0 && (z = Lr(N + z, 0)), gp(_, T, z) } function Pde(_) { var T = _ == null ? 0 : _.length; return T ? no(_, 0, -1) : [] } var Ide = an(function (_) { var T = er(_, bA); return T.length && T[0] === _[0] ? uA(T) : [] }), Lde = an(function (_) { var T = ro(_), M = er(_, bA); return T === ro(M) ? T = t : M.pop(), M.length && M[0] === _[0] ? uA(M, At(T, 2)) : [] }), Rde = an(function (_) { var T = ro(_), M = er(_, bA); return T = typeof T == "function" ? T : t, T && M.pop(), M.length && M[0] === _[0] ? uA(M, t, T) : [] }); function Nde(_, T) { return _ == null ? "" : Pce.call(_, T) } function ro(_) { var T = _ == null ? 0 : _.length; return T ? _[T - 1] : t } function Bde(_, T, M) { var N = _ == null ? 0 : _.length; if (!N) return -1; var z = N; return M !== t && (z = qt(M), z = z < 0 ? Lr(N + z, 0) : vi(z, N - 1)), T === T ? vce(_, T, z) : Wb(_, p5, z, !0) } function $de(_, T) { return _ && _.length ? G5(_, qt(T)) : t } var Fde = an(L8); function L8(_, T) { return _ && _.length && T && T.length ? pA(_, T) : _ } function zde(_, T, M) { return _ && _.length && T && T.length ? pA(_, T, At(M, 2)) : _ } function Vde(_, T, M) { return _ && _.length && T && T.length ? pA(_, T, t, M) : _ } var Hde = Vl(function (_, T) { var M = _ == null ? 0 : _.length, N = oA(_, T); return q5(_, er(T, function (z) { return Hl(z, M) ? +z : z }).sort(i8)), N }); function Ude(_, T) { var M = []; if (!(_ && _.length)) return M; var N = -1, z = [], G = _.length; for (T = At(T, 3); ++N < G;) { var Y = _[N]; T(Y, N, _) && (M.push(Y), z.push(N)) } return q5(_, z), M } function IA(_) { return _ == null ? _ : Nce.call(_) } function Gde(_, T, M) { var N = _ == null ? 0 : _.length; return N ? (M && typeof M != "number" && Fi(_, T, M) ? (T = 0, M = N) : (T = T == null ? 0 : qt(T), M = M === t ? N : qt(M)), no(_, T, M)) : [] } function Wde(_, T) { return f1(_, T) } function Kde(_, T, M) { return vA(_, T, At(M, 2)) } function qde(_, T) { var M = _ == null ? 0 : _.length; if (M) { var N = f1(_, T); if (N < M && Zo(_[N], T)) return N } return -1 } function Yde(_, T) { return f1(_, T, !0) } function Zde(_, T, M) { return vA(_, T, At(M, 2), !0) } function Xde(_, T) { var M = _ == null ? 0 : _.length; if (M) { var N = f1(_, T, !0) - 1; if (Zo(_[N], T)) return N } return -1 } function Jde(_) { return _ && _.length ? Z5(_) : [] } function Qde(_, T) { return _ && _.length ? Z5(_, At(T, 2)) : [] } function efe(_) { var T = _ == null ? 0 : _.length; return T ? no(_, 1, T) : [] } function tfe(_, T, M) { return _ && _.length ? (T = M || T === t ? 1 : qt(T), no(_, 0, T < 0 ? 0 : T)) : [] } function nfe(_, T, M) { var N = _ == null ? 0 : _.length; return N ? (T = M || T === t ? 1 : qt(T), T = N - T, no(_, T < 0 ? 0 : T, N)) : [] } function rfe(_, T) { return _ && _.length ? h1(_, At(T, 3), !1, !0) : [] } function ife(_, T) { return _ && _.length ? h1(_, At(T, 3)) : [] } var afe = an(function (_) { return Xc(ii(_, 1, _r, !0)) }), ofe = an(function (_) { var T = ro(_); return _r(T) && (T = t), Xc(ii(_, 1, _r, !0), At(T, 2)) }), sfe = an(function (_) { var T = ro(_); return T = typeof T == "function" ? T : t, Xc(ii(_, 1, _r, !0), t, T) }); function lfe(_) { return _ && _.length ? Xc(_) : [] } function cfe(_, T) { return _ && _.length ? Xc(_, At(T, 2)) : [] } function ufe(_, T) { return T = typeof T == "function" ? T : t, _ && _.length ? Xc(_, t, T) : [] } function LA(_) { if (!(_ && _.length)) return []; var T = 0; return _ = Wc(_, function (M) { if (_r(M)) return T = Lr(M.length, T), !0 }), JC(T, function (M) { return er(_, YC(M)) }) } function R8(_, T) { if (!(_ && _.length)) return []; var M = LA(_); return T == null ? M : er(M, function (N) { return Ma(T, t, N) }) } var dfe = an(function (_, T) { return _r(_) ? wv(_, T) : [] }), ffe = an(function (_) { return _A(Wc(_, _r)) }), hfe = an(function (_) { var T = ro(_); return _r(T) && (T = t), _A(Wc(_, _r), At(T, 2)) }), pfe = an(function (_) { var T = ro(_); return T = typeof T == "function" ? T : t, _A(Wc(_, _r), t, T) }), mfe = an(LA); function gfe(_, T) { return e8(_ || [], T || [], bv) } function vfe(_, T) { return e8(_ || [], T || [], Tv) } var yfe = an(function (_) { var T = _.length, M = T > 1 ? _[T - 1] : t; return M = typeof M == "function" ? (_.pop(), M) : t, R8(_, M) }); function N8(_) { var T = H(_); return T.__chain__ = !0, T } function _fe(_, T) { return T(_), _ } function x1(_, T) { return T(_) } var bfe = Vl(function (_) { var T = _.length, M = T ? _[0] : 0, N = this.__wrapped__, z = function (G) { return oA(G, _) }; return T > 1 || this.__actions__.length || !(N instanceof fn) || !Hl(M) ? this.thru(z) : (N = N.slice(M, +M + (T ? 1 : 0)), N.__actions__.push({ func: x1, args: [z], thisArg: t }), new eo(N, this.__chain__).thru(function (G) { return T && !G.length && G.push(t), G })) }); function wfe() { return N8(this) } function xfe() { return new eo(this.value(), this.__chain__) } function Sfe() { this.__values__ === t && (this.__values__ = X8(this.value())); var _ = this.__index__ >= this.__values__.length, T = _ ? t : this.__values__[this.__index__++]; return { done: _, value: T } } function Tfe() { return this } function kfe(_) { for (var T, M = this; M instanceof s1;) { var N = O8(M); N.__index__ = 0, N.__values__ = t, T ? z.__wrapped__ = N : T = N; var z = N; M = M.__wrapped__ } return z.__wrapped__ = _, T } function Cfe() { var _ = this.__wrapped__; if (_ instanceof fn) { var T = _; return this.__actions__.length && (T = new fn(this)), T = T.reverse(), T.__actions__.push({ func: x1, args: [IA], thisArg: t }), new eo(T, this.__chain__) } return this.thru(IA) } function Afe() { return Q5(this.__wrapped__, this.__actions__) } var Efe = p1(function (_, T, M) { jn.call(_, M) ? ++_[M] : Fl(_, M, 1) }); function Mfe(_, T, M) { var N = zt(_) ? f5 : _ue; return M && Fi(_, T, M) && (T = t), N(_, At(T, 3)) } function Ofe(_, T) { var M = zt(_) ? Wc : R5; return M(_, At(T, 3)) } var Dfe = u8(D8), jfe = u8(j8); function Pfe(_, T) { return ii(S1(_, T), 1) } function Ife(_, T) { return ii(S1(_, T), P) } function Lfe(_, T, M) { return M = M === t ? 1 : qt(M), ii(S1(_, T), M) } function B8(_, T) { var M = zt(_) ? Ja : Zc; return M(_, At(T, 3)) } function $8(_, T) { var M = zt(_) ? ece : L5; return M(_, At(T, 3)) } var Rfe = p1(function (_, T, M) { jn.call(_, M) ? _[M].push(T) : Fl(_, M, [T]) }); function Nfe(_, T, M, N) { _ = ca(_) ? _ : Ep(_), M = M && !N ? qt(M) : 0; var z = _.length; return M < 0 && (M = Lr(z + M, 0)), E1(_) ? M <= z && _.indexOf(T, M) > -1 : !!z && gp(_, T, M) > -1 } var Bfe = an(function (_, T, M) { var N = -1, z = typeof T == "function", G = ca(_) ? xe(_.length) : []; return Zc(_, function (Y) { G[++N] = z ? Ma(T, Y, M) : xv(Y, T, M) }), G }), $fe = p1(function (_, T, M) { Fl(_, M, T) }); function S1(_, T) { var M = zt(_) ? er : V5; return M(_, At(T, 3)) } function Ffe(_, T, M, N) { return _ == null ? [] : (zt(T) || (T = T == null ? [] : [T]), M = N ? t : M, zt(M) || (M = M == null ? [] : [M]), W5(_, T, M)) } var zfe = p1(function (_, T, M) { _[M ? 0 : 1].push(T) }, function () { return [[], []] }); function Vfe(_, T, M) { var N = zt(_) ? KC : g5, z = arguments.length < 3; return N(_, At(T, 4), M, z, Zc) } function Hfe(_, T, M) { var N = zt(_) ? tce : g5, z = arguments.length < 3; return N(_, At(T, 4), M, z, L5) } function Ufe(_, T) { var M = zt(_) ? Wc : R5; return M(_, C1(At(T, 3))) } function Gfe(_) { var T = zt(_) ? D5 : Nue; return T(_) } function Wfe(_, T, M) { (M ? Fi(_, T, M) : T === t) ? T = 1 : T = qt(T); var N = zt(_) ? pue : Bue; return N(_, T) } function Kfe(_) { var T = zt(_) ? mue : Fue; return T(_) } function qfe(_) { if (_ == null) return 0; if (ca(_)) return E1(_) ? yp(_) : _.length; var T = yi(_); return T == q || T == ve ? _.size : fA(_).length } function Yfe(_, T, M) { var N = zt(_) ? qC : zue; return M && Fi(_, T, M) && (T = t), N(_, At(T, 3)) } var Zfe = an(function (_, T) { if (_ == null) return []; var M = T.length; return M > 1 && Fi(_, T[0], T[1]) ? T = [] : M > 2 && Fi(T[0], T[1], T[2]) && (T = [T[0]]), W5(_, ii(T, 1), []) }), T1 = Oce || function () { return ri.Date.now() }; function Xfe(_, T) { if (typeof T != "function") throw new Qa(o); return _ = qt(_), function () { if (--_ < 1) return T.apply(this, arguments) } } function F8(_, T, M) { return T = M ? t : T, T = _ && T == null ? _.length : T, zl(_, k, t, t, t, t, T) } function z8(_, T) { var M; if (typeof T != "function") throw new Qa(o); return _ = qt(_), function () { return --_ > 0 && (M = T.apply(this, arguments)), _ <= 1 && (T = t), M } } var RA = an(function (_, T, M) { var N = g; if (M.length) { var z = qc(M, Cp(RA)); N |= S } return zl(_, N, T, M, z) }), V8 = an(function (_, T, M) { var N = g | y; if (M.length) { var z = qc(M, Cp(V8)); N |= S } return zl(T, N, _, M, z) }); function H8(_, T, M) { T = M ? t : T; var N = zl(_, w, t, t, t, t, t, T); return N.placeholder = H8.placeholder, N } function U8(_, T, M) { T = M ? t : T; var N = zl(_, v, t, t, t, t, t, T); return N.placeholder = U8.placeholder, N } function G8(_, T, M) { var N, z, G, Y, Q, ue, Pe = 0, Ie = !1, Re = !1, Je = !0; if (typeof _ != "function") throw new Qa(o); T = io(T) || 0, ir(M) && (Ie = !!M.leading, Re = "maxWait" in M, G = Re ? Lr(io(M.maxWait) || 0, T) : G, Je = "trailing" in M ? !!M.trailing : Je); function gt(br) { var Xo = N, Wl = z; return N = z = t, Pe = br, Y = _.apply(Wl, Xo), Y } function Ot(br) { return Pe = br, Q = Av(ln, T), Ie ? gt(br) : Y } function Zt(br) { var Xo = br - ue, Wl = br - Pe, u4 = T - Xo; return Re ? vi(u4, G - Wl) : u4 } function Dt(br) { var Xo = br - ue, Wl = br - Pe; return ue === t || Xo >= T || Xo < 0 || Re && Wl >= G } function ln() { var br = T1(); if (Dt(br)) return mn(br); Q = Av(ln, Zt(br)) } function mn(br) { return Q = t, Je && N ? gt(br) : (N = z = t, Y) } function Pa() { Q !== t && t8(Q), Pe = 0, N = ue = z = Q = t } function zi() { return Q === t ? Y : mn(T1()) } function Ia() { var br = T1(), Xo = Dt(br); if (N = arguments, z = this, ue = br, Xo) { if (Q === t) return Ot(ue); if (Re) return t8(Q), Q = Av(ln, T), gt(ue) } return Q === t && (Q = Av(ln, T)), Y } return Ia.cancel = Pa, Ia.flush = zi, Ia } var Jfe = an(function (_, T) { return I5(_, 1, T) }), Qfe = an(function (_, T, M) { return I5(_, io(T) || 0, M) }); function ehe(_) { return zl(_, C) } function k1(_, T) { if (typeof _ != "function" || T != null && typeof T != "function") throw new Qa(o); var M = function () { var N = arguments, z = T ? T.apply(this, N) : N[0], G = M.cache; if (G.has(z)) return G.get(z); var Y = _.apply(this, N); return M.cache = G.set(z, Y) || G, Y }; return M.cache = new (k1.Cache || $l), M } k1.Cache = $l; function C1(_) { if (typeof _ != "function") throw new Qa(o); return function () { var T = arguments; switch (T.length) { case 0: return !_.call(this); case 1: return !_.call(this, T[0]); case 2: return !_.call(this, T[0], T[1]); case 3: return !_.call(this, T[0], T[1], T[2]) }return !_.apply(this, T) } } function the(_) { return z8(2, _) } var nhe = Vue(function (_, T) { T = T.length == 1 && zt(T[0]) ? er(T[0], Oa(At())) : er(ii(T, 1), Oa(At())); var M = T.length; return an(function (N) { for (var z = -1, G = vi(N.length, M); ++z < G;)N[z] = T[z].call(this, N[z]); return Ma(_, this, N) }) }), NA = an(function (_, T) { var M = qc(T, Cp(NA)); return zl(_, S, t, T, M) }), W8 = an(function (_, T) { var M = qc(T, Cp(W8)); return zl(_, x, t, T, M) }), rhe = Vl(function (_, T) { return zl(_, A, t, t, t, T) }); function ihe(_, T) { if (typeof _ != "function") throw new Qa(o); return T = T === t ? T : qt(T), an(_, T) } function ahe(_, T) { if (typeof _ != "function") throw new Qa(o); return T = T == null ? 0 : Lr(qt(T), 0), an(function (M) { var N = M[T], z = Qc(M, 0, T); return N && Kc(z, N), Ma(_, this, z) }) } function ohe(_, T, M) { var N = !0, z = !0; if (typeof _ != "function") throw new Qa(o); return ir(M) && (N = "leading" in M ? !!M.leading : N, z = "trailing" in M ? !!M.trailing : z), G8(_, T, { leading: N, maxWait: T, trailing: z }) } function she(_) { return F8(_, 1) } function lhe(_, T) { return NA(wA(T), _) } function che() { if (!arguments.length) return []; var _ = arguments[0]; return zt(_) ? _ : [_] } function uhe(_) { return to(_, h) } function dhe(_, T) { return T = typeof T == "function" ? T : t, to(_, h, T) } function fhe(_) { return to(_, d | h) } function hhe(_, T) { return T = typeof T == "function" ? T : t, to(_, d | h, T) } function phe(_, T) { return T == null || P5(_, T, Kr(T)) } function Zo(_, T) { return _ === T || _ !== _ && T !== T } var mhe = y1(cA), ghe = y1(function (_, T) { return _ >= T }), nf = $5(function () { return arguments }()) ? $5 : function (_) { return ur(_) && jn.call(_, "callee") && !k5.call(_, "callee") }, zt = xe.isArray, vhe = o5 ? Oa(o5) : kue; function ca(_) { return _ != null && A1(_.length) && !Ul(_) } function _r(_) { return ur(_) && ca(_) } function yhe(_) { return _ === !0 || _ === !1 || ur(_) && $i(_) == pe } var eu = jce || qA, _he = s5 ? Oa(s5) : Cue; function bhe(_) { return ur(_) && _.nodeType === 1 && !Ev(_) } function whe(_) { if (_ == null) return !0; if (ca(_) && (zt(_) || typeof _ == "string" || typeof _.splice == "function" || eu(_) || Ap(_) || nf(_))) return !_.length; var T = yi(_); if (T == q || T == ve) return !_.size; if (Cv(_)) return !fA(_).length; for (var M in _) if (jn.call(_, M)) return !1; return !0 } function xhe(_, T) { return Sv(_, T) } function She(_, T, M) { M = typeof M == "function" ? M : t; var N = M ? M(_, T) : t; return N === t ? Sv(_, T, t, M) : !!N } function BA(_) { if (!ur(_)) return !1; var T = $i(_); return T == _e || T == ge || typeof _.message == "string" && typeof _.name == "string" && !Ev(_) } function The(_) { return typeof _ == "number" && A5(_) } function Ul(_) { if (!ir(_)) return !1; var T = $i(_); return T == je || T == U || T == ae || T == we } function K8(_) { return typeof _ == "number" && _ == qt(_) } function A1(_) { return typeof _ == "number" && _ > -1 && _ % 1 == 0 && _ <= B } function ir(_) { var T = typeof _; return _ != null && (T == "object" || T == "function") } function ur(_) { return _ != null && typeof _ == "object" } var q8 = l5 ? Oa(l5) : Eue; function khe(_, T) { return _ === T || dA(_, T, EA(T)) } function Che(_, T, M) { return M = typeof M == "function" ? M : t, dA(_, T, EA(T), M) } function Ahe(_) { return Y8(_) && _ != +_ } function Ehe(_) { if (dde(_)) throw new Ft(a); return F5(_) } function Mhe(_) { return _ === null } function Ohe(_) { return _ == null } function Y8(_) { return typeof _ == "number" || ur(_) && $i(_) == ee } function Ev(_) { if (!ur(_) || $i(_) != me) return !1; var T = e1(_); if (T === null) return !0; var M = jn.call(T, "constructor") && T.constructor; return typeof M == "function" && M instanceof M && Zb.call(M) == Cce } var $A = c5 ? Oa(c5) : Mue; function Dhe(_) { return K8(_) && _ >= -B && _ <= B } var Z8 = u5 ? Oa(u5) : Oue; function E1(_) { return typeof _ == "string" || !zt(_) && ur(_) && $i(_) == Se } function ja(_) { return typeof _ == "symbol" || ur(_) && $i(_) == Ke } var Ap = d5 ? Oa(d5) : Due; function jhe(_) { return _ === t } function Phe(_) { return ur(_) && yi(_) == Xe } function Ihe(_) { return ur(_) && $i(_) == Ee } var Lhe = y1(hA), Rhe = y1(function (_, T) { return _ <= T }); function X8(_) { if (!_) return []; if (ca(_)) return E1(_) ? qo(_) : la(_); if (mv && _[mv]) return pce(_[mv]()); var T = yi(_), M = T == q ? eA : T == ve ? Kb : Ep; return M(_) } function Gl(_) { if (!_) return _ === 0 ? _ : 0; if (_ = io(_), _ === P || _ === -P) { var T = _ < 0 ? -1 : 1; return T * F } return _ === _ ? _ : 0 } function qt(_) { var T = Gl(_), M = T % 1; return T === T ? M ? T - M : T : 0 } function J8(_) { return _ ? Jd(qt(_), 0, V) : 0 } function io(_) { if (typeof _ == "number") return _; if (ja(_)) return K; if (ir(_)) { var T = typeof _.valueOf == "function" ? _.valueOf() : _; _ = ir(T) ? T + "" : T } if (typeof _ != "string") return _ === 0 ? _ : +_; _ = v5(_); var M = vle.test(_); return M || _le.test(_) ? Xle(_.slice(2), M ? 2 : 8) : gle.test(_) ? K : +_ } function Q8(_) { return Ls(_, ua(_)) } function Nhe(_) { return _ ? Jd(qt(_), -B, B) : _ === 0 ? _ : 0 } function En(_) { return _ == null ? "" : Da(_) } var Bhe = Tp(function (_, T) { if (Cv(T) || ca(T)) { Ls(T, Kr(T), _); return } for (var M in T) jn.call(T, M) && bv(_, M, T[M]) }), e4 = Tp(function (_, T) { Ls(T, ua(T), _) }), M1 = Tp(function (_, T, M, N) { Ls(T, ua(T), _, N) }), $he = Tp(function (_, T, M, N) { Ls(T, Kr(T), _, N) }), Fhe = Vl(oA); function zhe(_, T) { var M = Sp(_); return T == null ? M : j5(M, T) } var Vhe = an(function (_, T) { _ = Vn(_); var M = -1, N = T.length, z = N > 2 ? T[2] : t; for (z && Fi(T[0], T[1], z) && (N = 1); ++M < N;)for (var G = T[M], Y = ua(G), Q = -1, ue = Y.length; ++Q < ue;) { var Pe = Y[Q], Ie = _[Pe]; (Ie === t || Zo(Ie, bp[Pe]) && !jn.call(_, Pe)) && (_[Pe] = G[Pe]) } return _ }), Hhe = an(function (_) { return _.push(t, v8), Ma(t4, t, _) }); function Uhe(_, T) { return h5(_, At(T, 3), Is) } function Ghe(_, T) { return h5(_, At(T, 3), lA) } function Whe(_, T) { return _ == null ? _ : sA(_, At(T, 3), ua) } function Khe(_, T) { return _ == null ? _ : N5(_, At(T, 3), ua) } function qhe(_, T) { return _ && Is(_, At(T, 3)) } function Yhe(_, T) { return _ && lA(_, At(T, 3)) } function Zhe(_) { return _ == null ? [] : u1(_, Kr(_)) } function Xhe(_) { return _ == null ? [] : u1(_, ua(_)) } function FA(_, T, M) { var N = _ == null ? t : Qd(_, T); return N === t ? M : N } function Jhe(_, T) { return _ != null && b8(_, T, wue) } function zA(_, T) { return _ != null && b8(_, T, xue) } var Qhe = f8(function (_, T, M) { T != null && typeof T.toString != "function" && (T = Xb.call(T)), _[T] = M }, HA(da)), epe = f8(function (_, T, M) { T != null && typeof T.toString != "function" && (T = Xb.call(T)), jn.call(_, T) ? _[T].push(M) : _[T] = [M] }, At), tpe = an(xv); function Kr(_) { return ca(_) ? O5(_) : fA(_) } function ua(_) { return ca(_) ? O5(_, !0) : jue(_) } function npe(_, T) { var M = {}; return T = At(T, 3), Is(_, function (N, z, G) { Fl(M, T(N, z, G), N) }), M } function rpe(_, T) { var M = {}; return T = At(T, 3), Is(_, function (N, z, G) { Fl(M, z, T(N, z, G)) }), M } var ipe = Tp(function (_, T, M) { d1(_, T, M) }), t4 = Tp(function (_, T, M, N) { d1(_, T, M, N) }), ape = Vl(function (_, T) { var M = {}; if (_ == null) return M; var N = !1; T = er(T, function (G) { return G = Jc(G, _), N || (N = G.length > 1), G }), Ls(_, CA(_), M), N && (M = to(M, d | f | h, Que)); for (var z = T.length; z--;)yA(M, T[z]); return M }); function ope(_, T) { return n4(_, C1(At(T))) } var spe = Vl(function (_, T) { return _ == null ? {} : Iue(_, T) }); function n4(_, T) { if (_ == null) return {}; var M = er(CA(_), function (N) { return [N] }); return T = At(T), K5(_, M, function (N, z) { return T(N, z[0]) }) } function lpe(_, T, M) { T = Jc(T, _); var N = -1, z = T.length; for (z || (z = 1, _ = t); ++N < z;) { var G = _ == null ? t : _[Rs(T[N])]; G === t && (N = z, G = M), _ = Ul(G) ? G.call(_) : G } return _ } function cpe(_, T, M) { return _ == null ? _ : Tv(_, T, M) } function upe(_, T, M, N) { return N = typeof N == "function" ? N : t, _ == null ? _ : Tv(_, T, M, N) } var r4 = m8(Kr), i4 = m8(ua); function dpe(_, T, M) { var N = zt(_), z = N || eu(_) || Ap(_); if (T = At(T, 4), M == null) { var G = _ && _.constructor; z ? M = N ? new G : [] : ir(_) ? M = Ul(G) ? Sp(e1(_)) : {} : M = {} } return (z ? Ja : Is)(_, function (Y, Q, ue) { return T(M, Y, Q, ue) }), M } function fpe(_, T) { return _ == null ? !0 : yA(_, T) } function hpe(_, T, M) { return _ == null ? _ : J5(_, T, wA(M)) } function ppe(_, T, M, N) { return N = typeof N == "function" ? N : t, _ == null ? _ : J5(_, T, wA(M), N) } function Ep(_) { return _ == null ? [] : QC(_, Kr(_)) } function mpe(_) { return _ == null ? [] : QC(_, ua(_)) } function gpe(_, T, M) { return M === t && (M = T, T = t), M !== t && (M = io(M), M = M === M ? M : 0), T !== t && (T = io(T), T = T === T ? T : 0), Jd(io(_), T, M) } function vpe(_, T, M) { return T = Gl(T), M === t ? (M = T, T = 0) : M = Gl(M), _ = io(_), Sue(_, T, M) } function ype(_, T, M) { if (M && typeof M != "boolean" && Fi(_, T, M) && (T = M = t), M === t && (typeof T == "boolean" ? (M = T, T = t) : typeof _ == "boolean" && (M = _, _ = t)), _ === t && T === t ? (_ = 0, T = 1) : (_ = Gl(_), T === t ? (T = _, _ = 0) : T = Gl(T)), _ > T) { var N = _; _ = T, T = N } if (M || _ % 1 || T % 1) { var z = E5(); return vi(_ + z * (T - _ + Zle("1e-" + ((z + "").length - 1))), T) } return mA(_, T) } var _pe = kp(function (_, T, M) { return T = T.toLowerCase(), _ + (M ? a4(T) : T) }); function a4(_) { return VA(En(_).toLowerCase()) } function o4(_) { return _ = En(_), _ && _.replace(wle, cce).replace(Fle, "") } function bpe(_, T, M) { _ = En(_), T = Da(T); var N = _.length; M = M === t ? N : Jd(qt(M), 0, N); var z = M; return M -= T.length, M >= 0 && _.slice(M, z) == T } function wpe(_) { return _ = En(_), _ && fv.test(_) ? _.replace(dv, uce) : _ } function xpe(_) { return _ = En(_), _ && sle.test(_) ? _.replace(NC, "\\$&") : _ } var Spe = kp(function (_, T, M) { return _ + (M ? "-" : "") + T.toLowerCase() }), Tpe = kp(function (_, T, M) { return _ + (M ? " " : "") + T.toLowerCase() }), kpe = c8("toLowerCase"); function Cpe(_, T, M) { _ = En(_), T = qt(T); var N = T ? yp(_) : 0; if (!T || N >= T) return _; var z = (T - N) / 2; return v1(i1(z), M) + _ + v1(r1(z), M) } function Ape(_, T, M) { _ = En(_), T = qt(T); var N = T ? yp(_) : 0; return T && N < T ? _ + v1(T - N, M) : _ } function Epe(_, T, M) { _ = En(_), T = qt(T); var N = T ? yp(_) : 0; return T && N < T ? v1(T - N, M) + _ : _ } function Mpe(_, T, M) { return M || T == null ? T = 0 : T && (T = +T), Rce(En(_).replace(BC, ""), T || 0) } function Ope(_, T, M) { return (M ? Fi(_, T, M) : T === t) ? T = 1 : T = qt(T), gA(En(_), T) } function Dpe() { var _ = arguments, T = En(_[0]); return _.length < 3 ? T : T.replace(_[1], _[2]) } var jpe = kp(function (_, T, M) { return _ + (M ? "_" : "") + T.toLowerCase() }); function Ppe(_, T, M) { return M && typeof M != "number" && Fi(_, T, M) && (T = M = t), M = M === t ? V : M >>> 0, M ? (_ = En(_), _ && (typeof T == "string" || T != null && !$A(T)) && (T = Da(T), !T && vp(_)) ? Qc(qo(_), 0, M) : _.split(T, M)) : [] } var Ipe = kp(function (_, T, M) { return _ + (M ? " " : "") + VA(T) }); function Lpe(_, T, M) { return _ = En(_), M = M == null ? 0 : Jd(qt(M), 0, _.length), T = Da(T), _.slice(M, M + T.length) == T } function Rpe(_, T, M) {
        var N = H.templateSettings; M && Fi(_, T, M) && (T = t), _ = En(_), T = M1({}, T, N, g8); var z = M1({}, T.imports, N.imports, g8), G = Kr(z), Y = QC(z, G), Q, ue, Pe = 0, Ie = T.interpolate || Vb, Re = "__p += '", Je = tA((T.escape || Vb).source + "|" + Ie.source + "|" + (Ie === zb ? mle : Vb).source + "|" + (T.evaluate || Vb).source + "|$", "g"), gt = "//# sourceURL=" + (jn.call(T, "sourceURL") ? (T.sourceURL + "").replace(/\s/g, " ") : "lodash.templateSources[" + ++Gle + "]") + `
`; _.replace(Je, function (Dt, ln, mn, Pa, zi, Ia) {
          return mn || (mn = Pa), Re += _.slice(Pe, Ia).replace(xle, dce), ln && (Q = !0, Re += `' +
__e(`+ ln + `) +
'`), zi && (ue = !0, Re += `';
`+ zi + `;
__p += '`), mn && (Re += `' +
((__t = (`+ mn + `)) == null ? '' : __t) +
'`), Pe = Ia + Dt.length, Dt
        }), Re += `';
`; var Ot = jn.call(T, "variable") && T.variable; if (!Ot) Re = `with (obj) {
`+ Re + `
}
`; else if (hle.test(Ot)) throw new Ft(s); Re = (ue ? Re.replace(sn, "") : Re).replace(ni, "$1").replace(sa, "$1;"), Re = "function(" + (Ot || "obj") + `) {
`+ (Ot ? "" : `obj || (obj = {});
`) + "var __t, __p = ''" + (Q ? ", __e = _.escape" : "") + (ue ? `, __j = Array.prototype.join;
function print() { __p += __j.call(arguments, '') }
`: `;
`) + Re + `return __p
}`; var Zt = l4(function () { return An(G, gt + "return " + Re).apply(t, Y) }); if (Zt.source = Re, BA(Zt)) throw Zt; return Zt
      } function Npe(_) { return En(_).toLowerCase() } function Bpe(_) { return En(_).toUpperCase() } function $pe(_, T, M) { if (_ = En(_), _ && (M || T === t)) return v5(_); if (!_ || !(T = Da(T))) return _; var N = qo(_), z = qo(T), G = y5(N, z), Y = _5(N, z) + 1; return Qc(N, G, Y).join("") } function Fpe(_, T, M) { if (_ = En(_), _ && (M || T === t)) return _.slice(0, w5(_) + 1); if (!_ || !(T = Da(T))) return _; var N = qo(_), z = _5(N, qo(T)) + 1; return Qc(N, 0, z).join("") } function zpe(_, T, M) { if (_ = En(_), _ && (M || T === t)) return _.replace(BC, ""); if (!_ || !(T = Da(T))) return _; var N = qo(_), z = y5(N, qo(T)); return Qc(N, z).join("") } function Vpe(_, T) { var M = E, N = O; if (ir(T)) { var z = "separator" in T ? T.separator : z; M = "length" in T ? qt(T.length) : M, N = "omission" in T ? Da(T.omission) : N } _ = En(_); var G = _.length; if (vp(_)) { var Y = qo(_); G = Y.length } if (M >= G) return _; var Q = M - yp(N); if (Q < 1) return N; var ue = Y ? Qc(Y, 0, Q).join("") : _.slice(0, Q); if (z === t) return ue + N; if (Y && (Q += ue.length - Q), $A(z)) { if (_.slice(Q).search(z)) { var Pe, Ie = ue; for (z.global || (z = tA(z.source, En($B.exec(z)) + "g")), z.lastIndex = 0; Pe = z.exec(Ie);)var Re = Pe.index; ue = ue.slice(0, Re === t ? Q : Re) } } else if (_.indexOf(Da(z), Q) != Q) { var Je = ue.lastIndexOf(z); Je > -1 && (ue = ue.slice(0, Je)) } return ue + N } function Hpe(_) { return _ = En(_), _ && Nl.test(_) ? _.replace(Rl, yce) : _ } var Upe = kp(function (_, T, M) { return _ + (M ? " " : "") + T.toUpperCase() }), VA = c8("toUpperCase"); function s4(_, T, M) { return _ = En(_), T = M ? t : T, T === t ? hce(_) ? wce(_) : ice(_) : _.match(T) || [] } var l4 = an(function (_, T) { try { return Ma(_, t, T) } catch (M) { return BA(M) ? M : new Ft(M) } }), Gpe = Vl(function (_, T) { return Ja(T, function (M) { M = Rs(M), Fl(_, M, RA(_[M], _)) }), _ }); function Wpe(_) { var T = _ == null ? 0 : _.length, M = At(); return _ = T ? er(_, function (N) { if (typeof N[1] != "function") throw new Qa(o); return [M(N[0]), N[1]] }) : [], an(function (N) { for (var z = -1; ++z < T;) { var G = _[z]; if (Ma(G[0], this, N)) return Ma(G[1], this, N) } }) } function Kpe(_) { return yue(to(_, d)) } function HA(_) { return function () { return _ } } function qpe(_, T) { return _ == null || _ !== _ ? T : _ } var Ype = d8(), Zpe = d8(!0); function da(_) { return _ } function UA(_) { return z5(typeof _ == "function" ? _ : to(_, d)) } function Xpe(_) { return H5(to(_, d)) } function Jpe(_, T) { return U5(_, to(T, d)) } var Qpe = an(function (_, T) { return function (M) { return xv(M, _, T) } }), eme = an(function (_, T) { return function (M) { return xv(_, M, T) } }); function GA(_, T, M) { var N = Kr(T), z = u1(T, N); M == null && !(ir(T) && (z.length || !N.length)) && (M = T, T = _, _ = this, z = u1(T, Kr(T))); var G = !(ir(M) && "chain" in M) || !!M.chain, Y = Ul(_); return Ja(z, function (Q) { var ue = T[Q]; _[Q] = ue, Y && (_.prototype[Q] = function () { var Pe = this.__chain__; if (G || Pe) { var Ie = _(this.__wrapped__), Re = Ie.__actions__ = la(this.__actions__); return Re.push({ func: ue, args: arguments, thisArg: _ }), Ie.__chain__ = Pe, Ie } return ue.apply(_, Kc([this.value()], arguments)) }) }), _ } function tme() { return ri._ === this && (ri._ = Ace), this } function WA() { } function nme(_) { return _ = qt(_), an(function (T) { return G5(T, _) }) } var rme = SA(er), ime = SA(f5), ame = SA(qC); function c4(_) { return OA(_) ? YC(Rs(_)) : Lue(_) } function ome(_) { return function (T) { return _ == null ? t : Qd(_, T) } } var sme = h8(), lme = h8(!0); function KA() { return [] } function qA() { return !1 } function cme() { return {} } function ume() { return "" } function dme() { return !0 } function fme(_, T) { if (_ = qt(_), _ < 1 || _ > B) return []; var M = V, N = vi(_, V); T = At(T), _ -= V; for (var z = JC(N, T); ++M < _;)T(M); return z } function hme(_) { return zt(_) ? er(_, Rs) : ja(_) ? [_] : la(M8(En(_))) } function pme(_) { var T = ++kce; return En(_) + T } var mme = g1(function (_, T) { return _ + T }, 0), gme = TA("ceil"), vme = g1(function (_, T) { return _ / T }, 1), yme = TA("floor"); function _me(_) { return _ && _.length ? c1(_, da, cA) : t } function bme(_, T) { return _ && _.length ? c1(_, At(T, 2), cA) : t } function wme(_) { return m5(_, da) } function xme(_, T) { return m5(_, At(T, 2)) } function Sme(_) { return _ && _.length ? c1(_, da, hA) : t } function Tme(_, T) { return _ && _.length ? c1(_, At(T, 2), hA) : t } var kme = g1(function (_, T) { return _ * T }, 1), Cme = TA("round"), Ame = g1(function (_, T) { return _ - T }, 0); function Eme(_) { return _ && _.length ? XC(_, da) : 0 } function Mme(_, T) { return _ && _.length ? XC(_, At(T, 2)) : 0 } return H.after = Xfe, H.ary = F8, H.assign = Bhe, H.assignIn = e4, H.assignInWith = M1, H.assignWith = $he, H.at = Fhe, H.before = z8, H.bind = RA, H.bindAll = Gpe, H.bindKey = V8, H.castArray = che, H.chain = N8, H.chunk = yde, H.compact = _de, H.concat = bde, H.cond = Wpe, H.conforms = Kpe, H.constant = HA, H.countBy = Efe, H.create = zhe, H.curry = H8, H.curryRight = U8, H.debounce = G8, H.defaults = Vhe, H.defaultsDeep = Hhe, H.defer = Jfe, H.delay = Qfe, H.difference = wde, H.differenceBy = xde, H.differenceWith = Sde, H.drop = Tde, H.dropRight = kde, H.dropRightWhile = Cde, H.dropWhile = Ade, H.fill = Ede, H.filter = Ofe, H.flatMap = Pfe, H.flatMapDeep = Ife, H.flatMapDepth = Lfe, H.flatten = P8, H.flattenDeep = Mde, H.flattenDepth = Ode, H.flip = ehe, H.flow = Ype, H.flowRight = Zpe, H.fromPairs = Dde, H.functions = Zhe, H.functionsIn = Xhe, H.groupBy = Rfe, H.initial = Pde, H.intersection = Ide, H.intersectionBy = Lde, H.intersectionWith = Rde, H.invert = Qhe, H.invertBy = epe, H.invokeMap = Bfe, H.iteratee = UA, H.keyBy = $fe, H.keys = Kr, H.keysIn = ua, H.map = S1, H.mapKeys = npe, H.mapValues = rpe, H.matches = Xpe, H.matchesProperty = Jpe, H.memoize = k1, H.merge = ipe, H.mergeWith = t4, H.method = Qpe, H.methodOf = eme, H.mixin = GA, H.negate = C1, H.nthArg = nme, H.omit = ape, H.omitBy = ope, H.once = the, H.orderBy = Ffe, H.over = rme, H.overArgs = nhe, H.overEvery = ime, H.overSome = ame, H.partial = NA, H.partialRight = W8, H.partition = zfe, H.pick = spe, H.pickBy = n4, H.property = c4, H.propertyOf = ome, H.pull = Fde, H.pullAll = L8, H.pullAllBy = zde, H.pullAllWith = Vde, H.pullAt = Hde, H.range = sme, H.rangeRight = lme, H.rearg = rhe, H.reject = Ufe, H.remove = Ude, H.rest = ihe, H.reverse = IA, H.sampleSize = Wfe, H.set = cpe, H.setWith = upe, H.shuffle = Kfe, H.slice = Gde, H.sortBy = Zfe, H.sortedUniq = Jde, H.sortedUniqBy = Qde, H.split = Ppe, H.spread = ahe, H.tail = efe, H.take = tfe, H.takeRight = nfe, H.takeRightWhile = rfe, H.takeWhile = ife, H.tap = _fe, H.throttle = ohe, H.thru = x1, H.toArray = X8, H.toPairs = r4, H.toPairsIn = i4, H.toPath = hme, H.toPlainObject = Q8, H.transform = dpe, H.unary = she, H.union = afe, H.unionBy = ofe, H.unionWith = sfe, H.uniq = lfe, H.uniqBy = cfe, H.uniqWith = ufe, H.unset = fpe, H.unzip = LA, H.unzipWith = R8, H.update = hpe, H.updateWith = ppe, H.values = Ep, H.valuesIn = mpe, H.without = dfe, H.words = s4, H.wrap = lhe, H.xor = ffe, H.xorBy = hfe, H.xorWith = pfe, H.zip = mfe, H.zipObject = gfe, H.zipObjectDeep = vfe, H.zipWith = yfe, H.entries = r4, H.entriesIn = i4, H.extend = e4, H.extendWith = M1, GA(H, H), H.add = mme, H.attempt = l4, H.camelCase = _pe, H.capitalize = a4, H.ceil = gme, H.clamp = gpe, H.clone = uhe, H.cloneDeep = fhe, H.cloneDeepWith = hhe, H.cloneWith = dhe, H.conformsTo = phe, H.deburr = o4, H.defaultTo = qpe, H.divide = vme, H.endsWith = bpe, H.eq = Zo, H.escape = wpe, H.escapeRegExp = xpe, H.every = Mfe, H.find = Dfe, H.findIndex = D8, H.findKey = Uhe, H.findLast = jfe, H.findLastIndex = j8, H.findLastKey = Ghe, H.floor = yme, H.forEach = B8, H.forEachRight = $8, H.forIn = Whe, H.forInRight = Khe, H.forOwn = qhe, H.forOwnRight = Yhe, H.get = FA, H.gt = mhe, H.gte = ghe, H.has = Jhe, H.hasIn = zA, H.head = I8, H.identity = da, H.includes = Nfe, H.indexOf = jde, H.inRange = vpe, H.invoke = tpe, H.isArguments = nf, H.isArray = zt, H.isArrayBuffer = vhe, H.isArrayLike = ca, H.isArrayLikeObject = _r, H.isBoolean = yhe, H.isBuffer = eu, H.isDate = _he, H.isElement = bhe, H.isEmpty = whe, H.isEqual = xhe, H.isEqualWith = She, H.isError = BA, H.isFinite = The, H.isFunction = Ul, H.isInteger = K8, H.isLength = A1, H.isMap = q8, H.isMatch = khe, H.isMatchWith = Che, H.isNaN = Ahe, H.isNative = Ehe, H.isNil = Ohe, H.isNull = Mhe, H.isNumber = Y8, H.isObject = ir, H.isObjectLike = ur, H.isPlainObject = Ev, H.isRegExp = $A, H.isSafeInteger = Dhe, H.isSet = Z8, H.isString = E1, H.isSymbol = ja, H.isTypedArray = Ap, H.isUndefined = jhe, H.isWeakMap = Phe, H.isWeakSet = Ihe, H.join = Nde, H.kebabCase = Spe, H.last = ro, H.lastIndexOf = Bde, H.lowerCase = Tpe, H.lowerFirst = kpe, H.lt = Lhe, H.lte = Rhe, H.max = _me, H.maxBy = bme, H.mean = wme, H.meanBy = xme, H.min = Sme, H.minBy = Tme, H.stubArray = KA, H.stubFalse = qA, H.stubObject = cme, H.stubString = ume, H.stubTrue = dme, H.multiply = kme, H.nth = $de, H.noConflict = tme, H.noop = WA, H.now = T1, H.pad = Cpe, H.padEnd = Ape, H.padStart = Epe, H.parseInt = Mpe, H.random = ype, H.reduce = Vfe, H.reduceRight = Hfe, H.repeat = Ope, H.replace = Dpe, H.result = lpe, H.round = Cme, H.runInContext = oe, H.sample = Gfe, H.size = qfe, H.snakeCase = jpe, H.some = Yfe, H.sortedIndex = Wde, H.sortedIndexBy = Kde, H.sortedIndexOf = qde, H.sortedLastIndex = Yde, H.sortedLastIndexBy = Zde, H.sortedLastIndexOf = Xde, H.startCase = Ipe, H.startsWith = Lpe, H.subtract = Ame, H.sum = Eme, H.sumBy = Mme, H.template = Rpe, H.times = fme, H.toFinite = Gl, H.toInteger = qt, H.toLength = J8, H.toLower = Npe, H.toNumber = io, H.toSafeInteger = Nhe, H.toString = En, H.toUpper = Bpe, H.trim = $pe, H.trimEnd = Fpe, H.trimStart = zpe, H.truncate = Vpe, H.unescape = Hpe, H.uniqueId = pme, H.upperCase = Upe, H.upperFirst = VA, H.each = B8, H.eachRight = $8, H.first = I8, GA(H, function () { var _ = {}; return Is(H, function (T, M) { jn.call(H.prototype, M) || (_[M] = T) }), _ }(), { chain: !1 }), H.VERSION = r, Ja(["bind", "bindKey", "curry", "curryRight", "partial", "partialRight"], function (_) { H[_].placeholder = H }), Ja(["drop", "take"], function (_, T) { fn.prototype[_] = function (M) { M = M === t ? 1 : Lr(qt(M), 0); var N = this.__filtered__ && !T ? new fn(this) : this.clone(); return N.__filtered__ ? N.__takeCount__ = vi(M, N.__takeCount__) : N.__views__.push({ size: vi(M, V), type: _ + (N.__dir__ < 0 ? "Right" : "") }), N }, fn.prototype[_ + "Right"] = function (M) { return this.reverse()[_](M).reverse() } }), Ja(["filter", "map", "takeWhile"], function (_, T) { var M = T + 1, N = M == L || M == D; fn.prototype[_] = function (z) { var G = this.clone(); return G.__iteratees__.push({ iteratee: At(z, 3), type: M }), G.__filtered__ = G.__filtered__ || N, G } }), Ja(["head", "last"], function (_, T) { var M = "take" + (T ? "Right" : ""); fn.prototype[_] = function () { return this[M](1).value()[0] } }), Ja(["initial", "tail"], function (_, T) { var M = "drop" + (T ? "" : "Right"); fn.prototype[_] = function () { return this.__filtered__ ? new fn(this) : this[M](1) } }), fn.prototype.compact = function () { return this.filter(da) }, fn.prototype.find = function (_) { return this.filter(_).head() }, fn.prototype.findLast = function (_) { return this.reverse().find(_) }, fn.prototype.invokeMap = an(function (_, T) { return typeof _ == "function" ? new fn(this) : this.map(function (M) { return xv(M, _, T) }) }), fn.prototype.reject = function (_) { return this.filter(C1(At(_))) }, fn.prototype.slice = function (_, T) { _ = qt(_); var M = this; return M.__filtered__ && (_ > 0 || T < 0) ? new fn(M) : (_ < 0 ? M = M.takeRight(-_) : _ && (M = M.drop(_)), T !== t && (T = qt(T), M = T < 0 ? M.dropRight(-T) : M.take(T - _)), M) }, fn.prototype.takeRightWhile = function (_) { return this.reverse().takeWhile(_).reverse() }, fn.prototype.toArray = function () { return this.take(V) }, Is(fn.prototype, function (_, T) { var M = /^(?:filter|find|map|reject)|While$/.test(T), N = /^(?:head|last)$/.test(T), z = H[N ? "take" + (T == "last" ? "Right" : "") : T], G = N || /^find/.test(T); z && (H.prototype[T] = function () { var Y = this.__wrapped__, Q = N ? [1] : arguments, ue = Y instanceof fn, Pe = Q[0], Ie = ue || zt(Y), Re = function (ln) { var mn = z.apply(H, Kc([ln], Q)); return N && Je ? mn[0] : mn }; Ie && M && typeof Pe == "function" && Pe.length != 1 && (ue = Ie = !1); var Je = this.__chain__, gt = !!this.__actions__.length, Ot = G && !Je, Zt = ue && !gt; if (!G && Ie) { Y = Zt ? Y : new fn(this); var Dt = _.apply(Y, Q); return Dt.__actions__.push({ func: x1, args: [Re], thisArg: t }), new eo(Dt, Je) } return Ot && Zt ? _.apply(this, Q) : (Dt = this.thru(Re), Ot ? N ? Dt.value()[0] : Dt.value() : Dt) }) }), Ja(["pop", "push", "shift", "sort", "splice", "unshift"], function (_) { var T = qb[_], M = /^(?:push|sort|unshift)$/.test(_) ? "tap" : "thru", N = /^(?:pop|shift)$/.test(_); H.prototype[_] = function () { var z = arguments; if (N && !this.__chain__) { var G = this.value(); return T.apply(zt(G) ? G : [], z) } return this[M](function (Y) { return T.apply(zt(Y) ? Y : [], z) }) } }), Is(fn.prototype, function (_, T) { var M = H[T]; if (M) { var N = M.name + ""; jn.call(xp, N) || (xp[N] = []), xp[N].push({ name: T, func: M }) } }), xp[m1(t, y).name] = [{ name: "wrapper", func: t }], fn.prototype.clone = Hce, fn.prototype.reverse = Uce, fn.prototype.value = Gce, H.prototype.at = bfe, H.prototype.chain = wfe, H.prototype.commit = xfe, H.prototype.next = Sfe, H.prototype.plant = kfe, H.prototype.reverse = Cfe, H.prototype.toJSON = H.prototype.valueOf = H.prototype.value = Afe, H.prototype.first = H.prototype.head, mv && (H.prototype[mv] = Tfe), H
    }, _p = xce(); qd ? ((qd.exports = _p)._ = _p, UC._ = _p) : ri._ = _p
  }).call(Du)
})(RT, RT.exports); var Wse = RT.exports; const Dlt = { class: "lucide lucide-chevron-up", xmlns: "http://www.w3.org/2000/svg", width: "24", height: "24", viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", "stroke-width": "1.5", "stroke-linecap": "round", "stroke-linejoin": "round" }; function jlt(n, e) { return Z(), ye("svg", Dlt, e[0] || (e[0] = [re("path", { d: "m18 15-6-6-6 6" }, null, -1)])) } const Plt = dn({ name: "lucide-chevron-up", render: jlt }), Ilt = { class: "lucide lucide-command", xmlns: "http://www.w3.org/2000/svg", width: "24", height: "24", viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", "stroke-width": "1.5", "stroke-linecap": "round", "stroke-linejoin": "round" }; function Llt(n, e) { return Z(), ye("svg", Ilt, e[0] || (e[0] = [re("path", { d: "M15 6v12a3 3 0 1 0 3-3H6a3 3 0 1 0 3 3V6a3 3 0 1 0-3 3h12a3 3 0 1 0-3-3" }, null, -1)])) } const Rlt = dn({ name: "lucide-command", render: Llt }); function Nlt() { const n = navigator.userAgent.indexOf("Mac OS X") != -1; return { altKey: n ? "" : "Alt", controlKey: n ? "" : "Ctrl", isMac: n, metaKey: n ? "" : "Meta", modifier: n ? "meta" : "control", modifierIcon: n ? Rlt : Plt } } const { isMac: Blt, controlKey: $lt, altKey: Flt, metaKey: zlt } = Nlt(); class Vlt { constructor(e, t, r, i) { this.isActive = e, this.keyCombination = t, this.handler = r, this.help = i } get display() { return this.keyCombination.map(e => { switch (e) { case "Control": return $lt; case "Alt": return Flt; case "Meta": return zlt; default: return e } }) } } const Hlt = IC("keymap", () => { const n = hwe({ passive: !1, onEventFired(s) { const l = e.value.find(c => c.isActive); l && (s.preventDefault(), l.handler()) } }), e = he([]), t = he(!1); function r(s, l, c) { const u = Array.isArray(s) ? s : [s]; i(u); const d = o(u), f = n[d.join("+")], h = new Vlt(f, d, l, c); e.value.push(h) } function i(s) { const l = o(s); e.value = e.value.filter(c => !Wse.isEqual(c.keyCombination, l)) } function a(s) { t.value = s ?? !t.value } function o(s) { return Blt ? s.map(l => l === "Control" ? "Meta" : l) : s } return { add: r, isOpen: t, items: e, remove: i, toggleVisibility: a } }), Ult = { key: 0, class: "space-y-2" }, Glt = { class: "text-base" }, Wlt = { class: "flex gap-1" }, Klt = { key: 1, class: "text-gray-700" }, qlt = We({ __name: "KeymapDialog", setup(n) { const e = Hlt(), t = { title: "Shortcuts" }; return (r, i) => { const a = Cc("Dialog"); return Z(), Ye(a, { modelValue: X(e).isOpen, "onUpdate:modelValue": i[0] || (i[0] = o => X(e).isOpen = o), options: t }, { "body-content": Ue(() => [X(Wse.isEmpty)(X(e).items) ? (Z(), ye("div", Klt, "No shortcuts defined")) : (Z(), ye("div", Ult, [(Z(!0), ye(Qt, null, Wa(X(e).items, o => (Z(), ye("div", { key: o.keyCombination.join(), class: "flex items-center justify-between" }, [re("div", Glt, Ht(o.help), 1), re("div", Wlt, [(Z(!0), ye(Qt, null, Wa(o.display, s => (Z(), Ye(X(MY), { key: s, label: s, theme: "gray", variant: "outline", size: "lg" }, null, 8, ["label"]))), 128))])]))), 128))]))]), _: 1 }, 8, ["modelValue"]) } } }), Ylt = 9e3; function Zlt() { let n = window.location.hostname, e = window.site_name || n, t = window.location.port ? `:${Ylt}` : "", i = `${t ? "http" : "https"}://${n}${t}/${e}`; const a = vS(i, { withCredentials: !0, reconnectionAttempts: 5 }); return a.on("refetch_resource", o => { if (o.cache_key) { const s = Cse(o.cache_key) || Ese(o.cache_key); s && s.reload() } }), a } const Kse = Zlt(), Xlt = IC("config", () => { const n = Yr({ url: "terrasuitehelpdesk.api.config.get_config", auto: !0 }), e = ne(() => n.data || {}), t = ne(() => e.value.brand_logo), r = ne(() => !!parseInt(e.value.restrict_tickets_by_agent_group)), i = ne(() => !!parseInt(e.value.skip_email_workflow)), a = ne(() => !!parseInt(e.value.prefer_knowledge_base)), o = ne(() => !!parseInt(e.value.is_feedback_mandatory)); return Kse.on("helpdesk:settings-updated", () => n.reload()), { brandLogo: t, config: e, preferKnowledgeBase: a, skipEmailWorkflow: i, isFeedbackMandatory: o, teamRestrictionApplied: r } }); (function (n, e) { var t, r, i, a; e.__SV || (window.posthog = e, e._i = [], e.init = function (o, s, l) { function c(d, f) { var h = f.split("."); h.length == 2 && (d = d[h[0]], f = h[1]), d[f] = function () { d.push([f].concat(Array.prototype.slice.call(arguments, 0))) } } (i = n.createElement("script")).type = "text/javascript", i.async = !0, i.src = s.api_host + "/static/array.js", (a = n.getElementsByTagName("script")[0]).parentNode.insertBefore(i, a); var u = e; for (l !== void 0 ? u = e[l] = [] : l = "posthog", u.people = u.people || [], u.toString = function (d) { var f = "posthog"; return l !== "posthog" && (f += "." + l), d || (f += " (stub)"), f }, u.people.toString = function () { return u.toString(1) + ".people (stub)" }, t = "capture identify alias people.set people.set_once set_config register register_once unregister opt_out_capturing has_opted_out_capturing opt_in_capturing reset isFeatureEnabled onFeatureFlags".split(" "), r = 0; r < t.length; r++)c(u, t[r]); e._i.push([o, s, l]) }, e.__SV = 1) })(document, window.posthog || []); const Jlt = "helpdesk", Qlt = window.location.hostname, ect = he({ enabled: !1, project_id: "", host: "" }); let tct = window.posthog, Ry = Yr({ url: "terrasuitehelpdesk.api.telemetry.get_posthog_settings", cache: "posthog_settings", onSuccess: n => nct(n) }); function qse() { return Ry.data ? Ry.data.enable_telemetry && Ry.data.posthog_project_id && Ry.data.posthog_host : !1 } async function nct(n) { qse() && tct.init(n.posthog_project_id, { api_host: n.posthog_host, autocapture: !1, person_profiles: "identified_only", disable_session_recording: !0, advanced_disable_decide: !0, loaded: e => { window.posthog = e, e.identify(Qlt) } }) } function cft(n, e = { data: { user: "" } }) { qse() && window.posthog.capture(`${Jlt}_${n}`, e) } function rct() { ect.value.enabled && window.posthog && window.posthog.__loaded && window.posthog.sessionRecordingStarted() && window.posthog.stopSessionRecording() } function ict(n) { var e; n.config.globalProperties.posthog = window.posthog, (e = window.posthog) != null && e.length || Ry.fetch() } const act = { class: "lucide lucide-wifi", xmlns: "http://www.w3.org/2000/svg", width: "24", height: "24", viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", "stroke-width": "1.5", "stroke-linecap": "round", "stroke-linejoin": "round" }; function oct(n, e) { return Z(), ye("svg", act, e[0] || (e[0] = [re("path", { d: "M12 20h.01" }, null, -1), re("path", { d: "M2 8.82a15 15 0 0 1 20 0" }, null, -1), re("path", { d: "M5 12.859a10 10 0 0 1 14 0" }, null, -1), re("path", { d: "M8.5 16.429a5 5 0 0 1 7 0" }, null, -1)])) } const sct = dn({ name: "lucide-wifi", render: oct }), lct = { class: "lucide lucide-wifi-off", xmlns: "http://www.w3.org/2000/svg", width: "24", height: "24", viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", "stroke-width": "1.5", "stroke-linecap": "round", "stroke-linejoin": "round" }; function cct(n, e) { return Z(), ye("svg", lct, e[0] || (e[0] = [rk('<path d="M12 20h.01"></path><path d="M8.5 16.429a5 5 0 0 1 7 0"></path><path d="M5 12.859a10 10 0 0 1 5.17-2.69"></path><path d="M19 12.859a10 10 0 0 0-2.007-1.523"></path><path d="M2 8.82a15 15 0 0 1 4.177-2.643"></path><path d="M22 8.82a15 15 0 0 0-11.288-3.764"></path><path d="m2 2 20 20"></path>', 7)])) } const uct = dn({ name: "lucide-wifi-off", render: cct }), dct = (n, e) => { const t = n[e]; return t ? typeof t == "function" ? t() : Promise.resolve(t) : new Promise((r, i) => { (typeof queueMicrotask == "function" ? queueMicrotask : setTimeout)(i.bind(null, new Error("Unknown variable dynamic import: " + e))) }) }; function fct() { const n = vr({ width: window.innerWidth, height: window.innerHeight }), e = () => { n.width = window.innerWidth, n.height = window.innerHeight }; un(() => { window.addEventListener("resize", e) }), cr(() => { window.removeEventListener("resize", e) }); const t = 640, r = ne(() => n.width < t); return { size: n, isMobileView: r } } const hct = IC("user", () => { const n = BB(), e = vr({}), t = he({}), r = Yr({ url: "terrasuitehelpdesk.api.session.get_users", cache: "Users", initialData: [], transform(c) { for (const u of c) u.full_name = o(u.email), e[u.name] = u; return c }, onError(c) { c && c.exc_type === "AuthenticationError" && (window.location.href = NB) } }), i = r.fetch; function a(c) { return (!c || c === "sessionUser") && (c = n.username), e[c] || (e[c] = { name: c, email: c, full_name: o(c), user_image: null, role: null }), e[c] } function o(c) { let u = c.split("@")[0]; return u = u.charAt(0).toUpperCase() + u.slice(1), u } function s(c) { if ((!c || c === "sessionUser") && (c = n.username), t.value[c]) return t.value[c]; const d = a(c).role; return t.value[c] = d, d } function l(c, u) { t.value[c] = u } return { users: r, init: i, getUser: a, getUserRole: s, updateUserRoleCache: l } }); var Yse = { exports: {} }; (function (n, e) { (function (t, r) { n.exports = r() })(Du, function () { var t = 1e3, r = 6e4, i = 36e5, a = "millisecond", o = "second", s = "minute", l = "hour", c = "day", u = "week", d = "month", f = "quarter", h = "year", p = "date", m = "Invalid Date", g = /^(\d{4})[-/]?(\d{1,2})?[-/]?(\d{0,2})[Tt\s]*(\d{1,2})?:?(\d{1,2})?:?(\d{1,2})?[.:]?(\d+)?$/, y = /\[([^\]]+)]|Y{1,4}|M{1,4}|D{1,2}|d{1,4}|H{1,2}|h{1,2}|a|A|m{1,2}|s{1,2}|Z{1,2}|SSS/g, b = { name: "en", weekdays: "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"), months: "January_February_March_April_May_June_July_August_September_October_November_December".split("_"), ordinal: function (L) { var R = ["th", "st", "nd", "rd"], D = L % 100; return "[" + L + (R[(D - 20) % 10] || R[D] || R[0]) + "]" } }, w = function (L, R, D) { var P = String(L); return !P || P.length >= R ? L : "" + Array(R + 1 - P.length).join(D) + L }, v = { s: w, z: function (L) { var R = -L.utcOffset(), D = Math.abs(R), P = Math.floor(D / 60), B = D % 60; return (R <= 0 ? "+" : "-") + w(P, 2, "0") + ":" + w(B, 2, "0") }, m: function L(R, D) { if (R.date() < D.date()) return -L(D, R); var P = 12 * (D.year() - R.year()) + (D.month() - R.month()), B = R.clone().add(P, d), F = D - B < 0, K = R.clone().add(P + (F ? -1 : 1), d); return +(-(P + (D - B) / (F ? B - K : K - B)) || 0) }, a: function (L) { return L < 0 ? Math.ceil(L) || 0 : Math.floor(L) }, p: function (L) { return { M: d, y: h, w: u, d: c, D: p, h: l, m: s, s: o, ms: a, Q: f }[L] || String(L || "").toLowerCase().replace(/s$/, "") }, u: function (L) { return L === void 0 } }, S = "en", x = {}; x[S] = b; var k = "$isDayjsObject", A = function (L) { return L instanceof j || !(!L || !L[k]) }, C = function L(R, D, P) { var B; if (!R) return S; if (typeof R == "string") { var F = R.toLowerCase(); x[F] && (B = F), D && (x[F] = D, B = F); var K = R.split("-"); if (!B && K.length > 1) return L(K[0]) } else { var V = R.name; x[V] = R, B = V } return !P && B && (S = B), B || !P && S }, E = function (L, R) { if (A(L)) return L.clone(); var D = typeof R == "object" ? R : {}; return D.date = L, D.args = arguments, new j(D) }, O = v; O.l = C, O.i = A, O.w = function (L, R) { return E(L, { locale: R.$L, utc: R.$u, x: R.$x, $offset: R.$offset }) }; var j = function () { function L(D) { this.$L = C(D.locale, null, !0), this.parse(D), this.$x = this.$x || D.x || {}, this[k] = !0 } var R = L.prototype; return R.parse = function (D) { this.$d = function (P) { var B = P.date, F = P.utc; if (B === null) return new Date(NaN); if (O.u(B)) return new Date; if (B instanceof Date) return new Date(B); if (typeof B == "string" && !/Z$/i.test(B)) { var K = B.match(g); if (K) { var V = K[2] - 1 || 0, W = (K[7] || "0").substring(0, 3); return F ? new Date(Date.UTC(K[1], V, K[3] || 1, K[4] || 0, K[5] || 0, K[6] || 0, W)) : new Date(K[1], V, K[3] || 1, K[4] || 0, K[5] || 0, K[6] || 0, W) } } return new Date(B) }(D), this.init() }, R.init = function () { var D = this.$d; this.$y = D.getFullYear(), this.$M = D.getMonth(), this.$D = D.getDate(), this.$W = D.getDay(), this.$H = D.getHours(), this.$m = D.getMinutes(), this.$s = D.getSeconds(), this.$ms = D.getMilliseconds() }, R.$utils = function () { return O }, R.isValid = function () { return this.$d.toString() !== m }, R.isSame = function (D, P) { var B = E(D); return this.startOf(P) <= B && B <= this.endOf(P) }, R.isAfter = function (D, P) { return E(D) < this.startOf(P) }, R.isBefore = function (D, P) { return this.endOf(P) < E(D) }, R.$g = function (D, P, B) { return O.u(D) ? this[P] : this.set(B, D) }, R.unix = function () { return Math.floor(this.valueOf() / 1e3) }, R.valueOf = function () { return this.$d.getTime() }, R.startOf = function (D, P) { var B = this, F = !!O.u(P) || P, K = O.p(D), V = function (se, ge) { var _e = O.w(B.$u ? Date.UTC(B.$y, ge, se) : new Date(B.$y, ge, se), B); return F ? _e : _e.endOf(c) }, W = function (se, ge) { return O.w(B.toDate()[se].apply(B.toDate("s"), (F ? [0, 0, 0, 0] : [23, 59, 59, 999]).slice(ge)), B) }, J = this.$W, ie = this.$M, le = this.$D, De = "set" + (this.$u ? "UTC" : ""); switch (K) { case h: return F ? V(1, 0) : V(31, 11); case d: return F ? V(1, ie) : V(0, ie + 1); case u: var ae = this.$locale().weekStart || 0, pe = (J < ae ? J + 7 : J) - ae; return V(F ? le - pe : le + (6 - pe), ie); case c: case p: return W(De + "Hours", 0); case l: return W(De + "Minutes", 1); case s: return W(De + "Seconds", 2); case o: return W(De + "Milliseconds", 3); default: return this.clone() } }, R.endOf = function (D) { return this.startOf(D, !1) }, R.$set = function (D, P) { var B, F = O.p(D), K = "set" + (this.$u ? "UTC" : ""), V = (B = {}, B[c] = K + "Date", B[p] = K + "Date", B[d] = K + "Month", B[h] = K + "FullYear", B[l] = K + "Hours", B[s] = K + "Minutes", B[o] = K + "Seconds", B[a] = K + "Milliseconds", B)[F], W = F === c ? this.$D + (P - this.$W) : P; if (F === d || F === h) { var J = this.clone().set(p, 1); J.$d[V](W), J.init(), this.$d = J.set(p, Math.min(this.$D, J.daysInMonth())).$d } else V && this.$d[V](W); return this.init(), this }, R.set = function (D, P) { return this.clone().$set(D, P) }, R.get = function (D) { return this[O.p(D)]() }, R.add = function (D, P) { var B, F = this; D = Number(D); var K = O.p(P), V = function (ie) { var le = E(F); return O.w(le.date(le.date() + Math.round(ie * D)), F) }; if (K === d) return this.set(d, this.$M + D); if (K === h) return this.set(h, this.$y + D); if (K === c) return V(1); if (K === u) return V(7); var W = (B = {}, B[s] = r, B[l] = i, B[o] = t, B)[K] || 1, J = this.$d.getTime() + D * W; return O.w(J, this) }, R.subtract = function (D, P) { return this.add(-1 * D, P) }, R.format = function (D) { var P = this, B = this.$locale(); if (!this.isValid()) return B.invalidDate || m; var F = D || "YYYY-MM-DDTHH:mm:ssZ", K = O.z(this), V = this.$H, W = this.$m, J = this.$M, ie = B.weekdays, le = B.months, De = B.meridiem, ae = function (ge, _e, je, U) { return ge && (ge[_e] || ge(P, F)) || je[_e].slice(0, U) }, pe = function (ge) { return O.s(V % 12 || 12, ge, "0") }, se = De || function (ge, _e, je) { var U = ge < 12 ? "AM" : "PM"; return je ? U.toLowerCase() : U }; return F.replace(y, function (ge, _e) { return _e || function (je) { switch (je) { case "YY": return String(P.$y).slice(-2); case "YYYY": return O.s(P.$y, 4, "0"); case "M": return J + 1; case "MM": return O.s(J + 1, 2, "0"); case "MMM": return ae(B.monthsShort, J, le, 3); case "MMMM": return ae(le, J); case "D": return P.$D; case "DD": return O.s(P.$D, 2, "0"); case "d": return String(P.$W); case "dd": return ae(B.weekdaysMin, P.$W, ie, 2); case "ddd": return ae(B.weekdaysShort, P.$W, ie, 3); case "dddd": return ie[P.$W]; case "H": return String(V); case "HH": return O.s(V, 2, "0"); case "h": return pe(1); case "hh": return pe(2); case "a": return se(V, W, !0); case "A": return se(V, W, !1); case "m": return String(W); case "mm": return O.s(W, 2, "0"); case "s": return String(P.$s); case "ss": return O.s(P.$s, 2, "0"); case "SSS": return O.s(P.$ms, 3, "0"); case "Z": return K }return null }(ge) || K.replace(":", "") }) }, R.utcOffset = function () { return 15 * -Math.round(this.$d.getTimezoneOffset() / 15) }, R.diff = function (D, P, B) { var F, K = this, V = O.p(P), W = E(D), J = (W.utcOffset() - this.utcOffset()) * r, ie = this - W, le = function () { return O.m(K, W) }; switch (V) { case h: F = le() / 12; break; case d: F = le(); break; case f: F = le() / 3; break; case u: F = (ie - J) / 6048e5; break; case c: F = (ie - J) / 864e5; break; case l: F = ie / i; break; case s: F = ie / r; break; case o: F = ie / t; break; default: F = ie }return B ? F : O.a(F) }, R.daysInMonth = function () { return this.endOf(d).$D }, R.$locale = function () { return x[this.$L] }, R.locale = function (D, P) { if (!D) return this.$L; var B = this.clone(), F = C(D, P, !0); return F && (B.$L = F), B }, R.clone = function () { return O.w(this.$d, this) }, R.toDate = function () { return new Date(this.valueOf()) }, R.toJSON = function () { return this.isValid() ? this.toISOString() : null }, R.toISOString = function () { return this.$d.toISOString() }, R.toString = function () { return this.$d.toUTCString() }, L }(), I = j.prototype; return E.prototype = I, [["$ms", a], ["$s", o], ["$m", s], ["$H", l], ["$W", c], ["$M", d], ["$y", h], ["$D", p]].forEach(function (L) { I[L[1]] = function (R) { return this.$g(R, L[0], L[1]) } }), E.extend = function (L, R) { return L.$i || (L(R, j, E), L.$i = !0), E }, E.locale = C, E.isDayjs = A, E.unix = function (L) { return E(1e3 * L) }, E.en = x[S], E.Ls = x, E.p = {}, E }) })(Yse); var pct = Yse.exports; const NW = ck(pct), mct = [{ emoji: "", names: ["grinning"], tags: ["smile", "happy"], description: "grinning face", category: "Smileys & Emotion" }, { emoji: "", names: ["smiley"], tags: ["happy", "joy", "haha"], description: "grinning face with big eyes", category: "Smileys & Emotion" }, { emoji: "", names: ["smile"], tags: ["happy", "joy", "laugh", "pleased"], description: "grinning face with smiling eyes", category: "Smileys & Emotion" }, { emoji: "", names: ["grin"], tags: [], description: "beaming face with smiling eyes", category: "Smileys & Emotion" }, { emoji: "", names: ["laughing", "satisfied"], tags: ["happy", "haha"], description: "grinning squinting face", category: "Smileys & Emotion" }, { emoji: "", names: ["sweat_smile"], tags: ["hot"], description: "grinning face with sweat", category: "Smileys & Emotion" }, { emoji: "", names: ["rofl"], tags: ["lol", "laughing"], description: "rolling on the floor laughing", category: "Smileys & Emotion" }, { emoji: "", names: ["joy"], tags: ["tears"], description: "face with tears of joy", category: "Smileys & Emotion" }, { emoji: "", names: ["slightly_smiling_face"], tags: [], description: "slightly smiling face", category: "Smileys & Emotion" }, { emoji: "", names: ["upside_down_face"], tags: [], description: "upside-down face", category: "Smileys & Emotion" }, { emoji: "", names: ["melting_face"], tags: ["sarcasm", "dread"], description: "melting face", category: "Smileys & Emotion" }, { emoji: "", names: ["wink"], tags: ["flirt"], description: "winking face", category: "Smileys & Emotion" }, { emoji: "", names: ["blush"], tags: ["proud"], description: "smiling face with smiling eyes", category: "Smileys & Emotion" }, { emoji: "", names: ["innocent"], tags: ["angel"], description: "smiling face with halo", category: "Smileys & Emotion" }, { emoji: "", names: ["smiling_face_with_three_hearts"], tags: ["love"], description: "smiling face with hearts", category: "Smileys & Emotion" }, { emoji: "", names: ["heart_eyes"], tags: ["love", "crush"], description: "smiling face with heart-eyes", category: "Smileys & Emotion" }, { emoji: "", names: ["star_struck"], tags: ["eyes"], description: "star-struck", category: "Smileys & Emotion" }, { emoji: "", names: ["kissing_heart"], tags: ["flirt"], description: "face blowing a kiss", category: "Smileys & Emotion" }, { emoji: "", names: ["kissing"], tags: [], description: "kissing face", category: "Smileys & Emotion" }, { emoji: "", names: ["relaxed"], tags: ["blush", "pleased"], description: "smiling face", category: "Smileys & Emotion" }, { emoji: "", names: ["kissing_closed_eyes"], tags: [], description: "kissing face with closed eyes", category: "Smileys & Emotion" }, { emoji: "", names: ["kissing_smiling_eyes"], tags: [], description: "kissing face with smiling eyes", category: "Smileys & Emotion" }, { emoji: "", names: ["smiling_face_with_tear"], tags: [], description: "smiling face with tear", category: "Smileys & Emotion" }, { emoji: "", names: ["yum"], tags: ["tongue", "lick"], description: "face savoring food", category: "Smileys & Emotion" }, { emoji: "", names: ["stuck_out_tongue"], tags: [], description: "face with tongue", category: "Smileys & Emotion" }, { emoji: "", names: ["stuck_out_tongue_winking_eye"], tags: ["prank", "silly"], description: "winking face with tongue", category: "Smileys & Emotion" }, { emoji: "", names: ["zany_face"], tags: ["goofy", "wacky"], description: "zany face", category: "Smileys & Emotion" }, { emoji: "", names: ["stuck_out_tongue_closed_eyes"], tags: ["prank"], description: "squinting face with tongue", category: "Smileys & Emotion" }, { emoji: "", names: ["money_mouth_face"], tags: ["rich"], description: "money-mouth face", category: "Smileys & Emotion" }, { emoji: "", names: ["hugs"], tags: [], description: "smiling face with open hands", category: "Smileys & Emotion" }, { emoji: "", names: ["hand_over_mouth"], tags: ["quiet", "whoops"], description: "face with hand over mouth", category: "Smileys & Emotion" }, { emoji: "", names: ["face_with_open_eyes_and_hand_over_mouth"], tags: ["gasp", "shock"], description: "face with open eyes and hand over mouth", category: "Smileys & Emotion" }, { emoji: "", names: ["face_with_peeking_eye"], tags: [], description: "face with peeking eye", category: "Smileys & Emotion" }, { emoji: "", names: ["shushing_face"], tags: ["silence", "quiet"], description: "shushing face", category: "Smileys & Emotion" }, { emoji: "", names: ["thinking"], tags: [], description: "thinking face", category: "Smileys & Emotion" }, { emoji: "", names: ["saluting_face"], tags: ["respect"], description: "saluting face", category: "Smileys & Emotion" }, { emoji: "", names: ["zipper_mouth_face"], tags: ["silence", "hush"], description: "zipper-mouth face", category: "Smileys & Emotion" }, { emoji: "", names: ["raised_eyebrow"], tags: ["suspicious"], description: "face with raised eyebrow", category: "Smileys & Emotion" }, { emoji: "", names: ["neutral_face"], tags: ["meh"], description: "neutral face", category: "Smileys & Emotion" }, { emoji: "", names: ["expressionless"], tags: [], description: "expressionless face", category: "Smileys & Emotion" }, { emoji: "", names: ["no_mouth"], tags: ["mute", "silence"], description: "face without mouth", category: "Smileys & Emotion" }, { emoji: "", names: ["dotted_line_face"], tags: ["invisible"], description: "dotted line face", category: "Smileys & Emotion" }, { emoji: "", names: ["face_in_clouds"], tags: [], description: "face in clouds", category: "Smileys & Emotion" }, { emoji: "", names: ["smirk"], tags: ["smug"], description: "smirking face", category: "Smileys & Emotion" }, { emoji: "", names: ["unamused"], tags: ["meh"], description: "unamused face", category: "Smileys & Emotion" }, { emoji: "", names: ["roll_eyes"], tags: [], description: "face with rolling eyes", category: "Smileys & Emotion" }, { emoji: "", names: ["grimacing"], tags: [], description: "grimacing face", category: "Smileys & Emotion" }, { emoji: "", names: ["face_exhaling"], tags: [], description: "face exhaling", category: "Smileys & Emotion" }, { emoji: "", names: ["lying_face"], tags: ["liar"], description: "lying face", category: "Smileys & Emotion" }, { emoji: "", names: ["shaking_face"], tags: ["shock"], description: "shaking face", category: "Smileys & Emotion" }, { emoji: "", names: ["relieved"], tags: ["whew"], description: "relieved face", category: "Smileys & Emotion" }, { emoji: "", names: ["pensive"], tags: [], description: "pensive face", category: "Smileys & Emotion" }, { emoji: "", names: ["sleepy"], tags: ["tired"], description: "sleepy face", category: "Smileys & Emotion" }, { emoji: "", names: ["drooling_face"], tags: [], description: "drooling face", category: "Smileys & Emotion" }, { emoji: "", names: ["sleeping"], tags: ["zzz"], description: "sleeping face", category: "Smileys & Emotion" }, { emoji: "", names: ["mask"], tags: ["sick", "ill"], description: "face with medical mask", category: "Smileys & Emotion" }, { emoji: "", names: ["face_with_thermometer"], tags: ["sick"], description: "face with thermometer", category: "Smileys & Emotion" }, { emoji: "", names: ["face_with_head_bandage"], tags: ["hurt"], description: "face with head-bandage", category: "Smileys & Emotion" }, { emoji: "", names: ["nauseated_face"], tags: ["sick", "barf", "disgusted"], description: "nauseated face", category: "Smileys & Emotion" }, { emoji: "", names: ["vomiting_face"], tags: ["barf", "sick"], description: "face vomiting", category: "Smileys & Emotion" }, { emoji: "", names: ["sneezing_face"], tags: ["achoo", "sick"], description: "sneezing face", category: "Smileys & Emotion" }, { emoji: "", names: ["hot_face"], tags: ["heat", "sweating"], description: "hot face", category: "Smileys & Emotion" }, { emoji: "", names: ["cold_face"], tags: ["freezing", "ice"], description: "cold face", category: "Smileys & Emotion" }, { emoji: "", names: ["woozy_face"], tags: ["groggy"], description: "woozy face", category: "Smileys & Emotion" }, { emoji: "", names: ["dizzy_face"], tags: [], description: "face with crossed-out eyes", category: "Smileys & Emotion" }, { emoji: "", names: ["face_with_spiral_eyes"], tags: [], description: "face with spiral eyes", category: "Smileys & Emotion" }, { emoji: "", names: ["exploding_head"], tags: ["mind", "blown"], description: "exploding head", category: "Smileys & Emotion" }, { emoji: "", names: ["cowboy_hat_face"], tags: [], description: "cowboy hat face", category: "Smileys & Emotion" }, { emoji: "", names: ["partying_face"], tags: ["celebration", "birthday"], description: "partying face", category: "Smileys & Emotion" }, { emoji: "", names: ["disguised_face"], tags: [], description: "disguised face", category: "Smileys & Emotion" }, { emoji: "", names: ["sunglasses"], tags: ["cool"], description: "smiling face with sunglasses", category: "Smileys & Emotion" }, { emoji: "", names: ["nerd_face"], tags: ["geek", "glasses"], description: "nerd face", category: "Smileys & Emotion" }, { emoji: "", names: ["monocle_face"], tags: [], description: "face with monocle", category: "Smileys & Emotion" }, { emoji: "", names: ["confused"], tags: [], description: "confused face", category: "Smileys & Emotion" }, { emoji: "", names: ["face_with_diagonal_mouth"], tags: ["confused"], description: "face with diagonal mouth", category: "Smileys & Emotion" }, { emoji: "", names: ["worried"], tags: ["nervous"], description: "worried face", category: "Smileys & Emotion" }, { emoji: "", names: ["slightly_frowning_face"], tags: [], description: "slightly frowning face", category: "Smileys & Emotion" }, { emoji: "", names: ["frowning_face"], tags: [], description: "frowning face", category: "Smileys & Emotion" }, { emoji: "", names: ["open_mouth"], tags: ["surprise", "impressed", "wow"], description: "face with open mouth", category: "Smileys & Emotion" }, { emoji: "", names: ["hushed"], tags: ["silence", "speechless"], description: "hushed face", category: "Smileys & Emotion" }, { emoji: "", names: ["astonished"], tags: ["amazed", "gasp"], description: "astonished face", category: "Smileys & Emotion" }, { emoji: "", names: ["flushed"], tags: [], description: "flushed face", category: "Smileys & Emotion" }, { emoji: "", names: ["pleading_face"], tags: ["puppy", "eyes"], description: "pleading face", category: "Smileys & Emotion" }, { emoji: "", names: ["face_holding_back_tears"], tags: ["tears", "gratitude"], description: "face holding back tears", category: "Smileys & Emotion" }, { emoji: "", names: ["frowning"], tags: [], description: "frowning face with open mouth", category: "Smileys & Emotion" }, { emoji: "", names: ["anguished"], tags: ["stunned"], description: "anguished face", category: "Smileys & Emotion" }, { emoji: "", names: ["fearful"], tags: ["scared", "shocked", "oops"], description: "fearful face", category: "Smileys & Emotion" }, { emoji: "", names: ["cold_sweat"], tags: ["nervous"], description: "anxious face with sweat", category: "Smileys & Emotion" }, { emoji: "", names: ["disappointed_relieved"], tags: ["phew", "sweat", "nervous"], description: "sad but relieved face", category: "Smileys & Emotion" }, { emoji: "", names: ["cry"], tags: ["sad", "tear"], description: "crying face", category: "Smileys & Emotion" }, { emoji: "", names: ["sob"], tags: ["sad", "cry", "bawling"], description: "loudly crying face", category: "Smileys & Emotion" }, { emoji: "", names: ["scream"], tags: ["horror", "shocked"], description: "face screaming in fear", category: "Smileys & Emotion" }, { emoji: "", names: ["confounded"], tags: [], description: "confounded face", category: "Smileys & Emotion" }, { emoji: "", names: ["persevere"], tags: ["struggling"], description: "persevering face", category: "Smileys & Emotion" }, { emoji: "", names: ["disappointed"], tags: ["sad"], description: "disappointed face", category: "Smileys & Emotion" }, { emoji: "", names: ["sweat"], tags: [], description: "downcast face with sweat", category: "Smileys & Emotion" }, { emoji: "", names: ["weary"], tags: ["tired"], description: "weary face", category: "Smileys & Emotion" }, { emoji: "", names: ["tired_face"], tags: ["upset", "whine"], description: "tired face", category: "Smileys & Emotion" }, { emoji: "", names: ["yawning_face"], tags: [], description: "yawning face", category: "Smileys & Emotion" }, { emoji: "", names: ["triumph"], tags: ["smug"], description: "face with steam from nose", category: "Smileys & Emotion" }, { emoji: "", names: ["rage", "pout"], tags: ["angry"], description: "enraged face", category: "Smileys & Emotion" }, { emoji: "", names: ["angry"], tags: ["mad", "annoyed"], description: "angry face", category: "Smileys & Emotion" }, { emoji: "", names: ["cursing_face"], tags: ["foul"], description: "face with symbols on mouth", category: "Smileys & Emotion" }, { emoji: "", names: ["smiling_imp"], tags: ["devil", "evil", "horns"], description: "smiling face with horns", category: "Smileys & Emotion" }, { emoji: "", names: ["imp"], tags: ["angry", "devil", "evil", "horns"], description: "angry face with horns", category: "Smileys & Emotion" }, { emoji: "", names: ["skull"], tags: ["dead", "danger", "poison"], description: "skull", category: "Smileys & Emotion" }, { emoji: "", names: ["skull_and_crossbones"], tags: ["danger", "pirate"], description: "skull and crossbones", category: "Smileys & Emotion" }, { emoji: "", names: ["hankey", "poop", "shit"], tags: ["crap"], description: "pile of poo", category: "Smileys & Emotion" }, { emoji: "", names: ["clown_face"], tags: [], description: "clown face", category: "Smileys & Emotion" }, { emoji: "", names: ["japanese_ogre"], tags: ["monster"], description: "ogre", category: "Smileys & Emotion" }, { emoji: "", names: ["japanese_goblin"], tags: [], description: "goblin", category: "Smileys & Emotion" }, { emoji: "", names: ["ghost"], tags: ["halloween"], description: "ghost", category: "Smileys & Emotion" }, { emoji: "", names: ["alien"], tags: ["ufo"], description: "alien", category: "Smileys & Emotion" }, { emoji: "", names: ["space_invader"], tags: ["game", "retro"], description: "alien monster", category: "Smileys & Emotion" }, { emoji: "", names: ["robot"], tags: [], description: "robot", category: "Smileys & Emotion" }, { emoji: "", names: ["smiley_cat"], tags: [], description: "grinning cat", category: "Smileys & Emotion" }, { emoji: "", names: ["smile_cat"], tags: [], description: "grinning cat with smiling eyes", category: "Smileys & Emotion" }, { emoji: "", names: ["joy_cat"], tags: [], description: "cat with tears of joy", category: "Smileys & Emotion" }, { emoji: "", names: ["heart_eyes_cat"], tags: [], description: "smiling cat with heart-eyes", category: "Smileys & Emotion" }, { emoji: "", names: ["smirk_cat"], tags: [], description: "cat with wry smile", category: "Smileys & Emotion" }, { emoji: "", names: ["kissing_cat"], tags: [], description: "kissing cat", category: "Smileys & Emotion" }, { emoji: "", names: ["scream_cat"], tags: ["horror"], description: "weary cat", category: "Smileys & Emotion" }, { emoji: "", names: ["crying_cat_face"], tags: ["sad", "tear"], description: "crying cat", category: "Smileys & Emotion" }, { emoji: "", names: ["pouting_cat"], tags: [], description: "pouting cat", category: "Smileys & Emotion" }, { emoji: "", names: ["see_no_evil"], tags: ["monkey", "blind", "ignore"], description: "see-no-evil monkey", category: "Smileys & Emotion" }, { emoji: "", names: ["hear_no_evil"], tags: ["monkey", "deaf"], description: "hear-no-evil monkey", category: "Smileys & Emotion" }, { emoji: "", names: ["speak_no_evil"], tags: ["monkey", "mute", "hush"], description: "speak-no-evil monkey", category: "Smileys & Emotion" }, { emoji: "", names: ["love_letter"], tags: ["email", "envelope"], description: "love letter", category: "Smileys & Emotion" }, { emoji: "", names: ["cupid"], tags: ["love", "heart"], description: "heart with arrow", category: "Smileys & Emotion" }, { emoji: "", names: ["gift_heart"], tags: ["chocolates"], description: "heart with ribbon", category: "Smileys & Emotion" }, { emoji: "", names: ["sparkling_heart"], tags: [], description: "sparkling heart", category: "Smileys & Emotion" }, { emoji: "", names: ["heartpulse"], tags: [], description: "growing heart", category: "Smileys & Emotion" }, { emoji: "", names: ["heartbeat"], tags: [], description: "beating heart", category: "Smileys & Emotion" }, { emoji: "", names: ["revolving_hearts"], tags: [], description: "revolving hearts", category: "Smileys & Emotion" }, { emoji: "", names: ["two_hearts"], tags: [], description: "two hearts", category: "Smileys & Emotion" }, { emoji: "", names: ["heart_decoration"], tags: [], description: "heart decoration", category: "Smileys & Emotion" }, { emoji: "", names: ["heavy_heart_exclamation"], tags: [], description: "heart exclamation", category: "Smileys & Emotion" }, { emoji: "", names: ["broken_heart"], tags: [], description: "broken heart", category: "Smileys & Emotion" }, { emoji: "", names: ["heart_on_fire"], tags: [], description: "heart on fire", category: "Smileys & Emotion" }, { emoji: "", names: ["mending_heart"], tags: [], description: "mending heart", category: "Smileys & Emotion" }, { emoji: "", names: ["heart"], tags: ["love"], description: "red heart", category: "Smileys & Emotion" }, { emoji: "", names: ["pink_heart"], tags: [], description: "pink heart", category: "Smileys & Emotion" }, { emoji: "", names: ["orange_heart"], tags: [], description: "orange heart", category: "Smileys & Emotion" }, { emoji: "", names: ["yellow_heart"], tags: [], description: "yellow heart", category: "Smileys & Emotion" }, { emoji: "", names: ["green_heart"], tags: [], description: "green heart", category: "Smileys & Emotion" }, { emoji: "", names: ["blue_heart"], tags: [], description: "blue heart", category: "Smileys & Emotion" }, { emoji: "", names: ["light_blue_heart"], tags: [], description: "light blue heart", category: "Smileys & Emotion" }, { emoji: "", names: ["purple_heart"], tags: [], description: "purple heart", category: "Smileys & Emotion" }, { emoji: "", names: ["brown_heart"], tags: [], description: "brown heart", category: "Smileys & Emotion" }, { emoji: "", names: ["black_heart"], tags: [], description: "black heart", category: "Smileys & Emotion" }, { emoji: "", names: ["grey_heart"], tags: [], description: "grey heart", category: "Smileys & Emotion" }, { emoji: "", names: ["white_heart"], tags: [], description: "white heart", category: "Smileys & Emotion" }, { emoji: "", names: ["kiss"], tags: ["lipstick"], description: "kiss mark", category: "Smileys & Emotion" }, { emoji: "", names: ["100"], tags: ["score", "perfect"], description: "hundred points", category: "Smileys & Emotion" }, { emoji: "", names: ["anger"], tags: ["angry"], description: "anger symbol", category: "Smileys & Emotion" }, { emoji: "", names: ["boom", "collision"], tags: ["explode"], description: "collision", category: "Smileys & Emotion" }, { emoji: "", names: ["dizzy"], tags: ["star"], description: "dizzy", category: "Smileys & Emotion" }, { emoji: "", names: ["sweat_drops"], tags: ["water", "workout"], description: "sweat droplets", category: "Smileys & Emotion" }, { emoji: "", names: ["dash"], tags: ["wind", "blow", "fast"], description: "dashing away", category: "Smileys & Emotion" }, { emoji: "", names: ["hole"], tags: [], description: "hole", category: "Smileys & Emotion" }, { emoji: "", names: ["speech_balloon"], tags: ["comment"], description: "speech balloon", category: "Smileys & Emotion" }, { emoji: "", names: ["eye_speech_bubble"], tags: [], description: "eye in speech bubble", category: "Smileys & Emotion" }, { emoji: "", names: ["left_speech_bubble"], tags: [], description: "left speech bubble", category: "Smileys & Emotion" }, { emoji: "", names: ["right_anger_bubble"], tags: [], description: "right anger bubble", category: "Smileys & Emotion" }, { emoji: "", names: ["thought_balloon"], tags: ["thinking"], description: "thought balloon", category: "Smileys & Emotion" }, { emoji: "", names: ["zzz"], tags: ["sleeping"], description: "ZZZ", category: "Smileys & Emotion" }, { emoji: "", names: ["wave"], tags: ["goodbye"], description: "waving hand", category: "People & Body" }, { emoji: "", names: ["raised_back_of_hand"], tags: [], description: "raised back of hand", category: "People & Body" }, { emoji: "", names: ["raised_hand_with_fingers_splayed"], tags: [], description: "hand with fingers splayed", category: "People & Body" }, { emoji: "", names: ["hand", "raised_hand"], tags: ["highfive", "stop"], description: "raised hand", category: "People & Body" }, { emoji: "", names: ["vulcan_salute"], tags: ["prosper", "spock"], description: "vulcan salute", category: "People & Body" }, { emoji: "", names: ["rightwards_hand"], tags: [], description: "rightwards hand", category: "People & Body" }, { emoji: "", names: ["leftwards_hand"], tags: [], description: "leftwards hand", category: "People & Body" }, { emoji: "", names: ["palm_down_hand"], tags: [], description: "palm down hand", category: "People & Body" }, { emoji: "", names: ["palm_up_hand"], tags: [], description: "palm up hand", category: "People & Body" }, { emoji: "", names: ["leftwards_pushing_hand"], tags: [], description: "leftwards pushing hand", category: "People & Body" }, { emoji: "", names: ["rightwards_pushing_hand"], tags: [], description: "rightwards pushing hand", category: "People & Body" }, { emoji: "", names: ["ok_hand"], tags: [], description: "OK hand", category: "People & Body" }, { emoji: "", names: ["pinched_fingers"], tags: [], description: "pinched fingers", category: "People & Body" }, { emoji: "", names: ["pinching_hand"], tags: [], description: "pinching hand", category: "People & Body" }, { emoji: "", names: ["v"], tags: ["victory", "peace"], description: "victory hand", category: "People & Body" }, { emoji: "", names: ["crossed_fingers"], tags: ["luck", "hopeful"], description: "crossed fingers", category: "People & Body" }, { emoji: "", names: ["hand_with_index_finger_and_thumb_crossed"], tags: [], description: "hand with index finger and thumb crossed", category: "People & Body" }, { emoji: "", names: ["love_you_gesture"], tags: [], description: "love-you gesture", category: "People & Body" }, { emoji: "", names: ["metal"], tags: [], description: "sign of the horns", category: "People & Body" }, { emoji: "", names: ["call_me_hand"], tags: [], description: "call me hand", category: "People & Body" }, { emoji: "", names: ["point_left"], tags: [], description: "backhand index pointing left", category: "People & Body" }, { emoji: "", names: ["point_right"], tags: [], description: "backhand index pointing right", category: "People & Body" }, { emoji: "", names: ["point_up_2"], tags: [], description: "backhand index pointing up", category: "People & Body" }, { emoji: "", names: ["middle_finger", "fu"], tags: [], description: "middle finger", category: "People & Body" }, { emoji: "", names: ["point_down"], tags: [], description: "backhand index pointing down", category: "People & Body" }, { emoji: "", names: ["point_up"], tags: [], description: "index pointing up", category: "People & Body" }, { emoji: "", names: ["index_pointing_at_the_viewer"], tags: [], description: "index pointing at the viewer", category: "People & Body" }, { emoji: "", names: ["+1", "thumbsup"], tags: ["approve", "ok"], description: "thumbs up", category: "People & Body" }, { emoji: "", names: ["-1", "thumbsdown"], tags: ["disapprove", "bury"], description: "thumbs down", category: "People & Body" }, { emoji: "", names: ["fist_raised", "fist"], tags: ["power"], description: "raised fist", category: "People & Body" }, { emoji: "", names: ["fist_oncoming", "facepunch", "punch"], tags: ["attack"], description: "oncoming fist", category: "People & Body" }, { emoji: "", names: ["fist_left"], tags: [], description: "left-facing fist", category: "People & Body" }, { emoji: "", names: ["fist_right"], tags: [], description: "right-facing fist", category: "People & Body" }, { emoji: "", names: ["clap"], tags: ["praise", "applause"], description: "clapping hands", category: "People & Body" }, { emoji: "", names: ["raised_hands"], tags: ["hooray"], description: "raising hands", category: "People & Body" }, { emoji: "", names: ["heart_hands"], tags: ["love"], description: "heart hands", category: "People & Body" }, { emoji: "", names: ["open_hands"], tags: [], description: "open hands", category: "People & Body" }, { emoji: "", names: ["palms_up_together"], tags: [], description: "palms up together", category: "People & Body" }, { emoji: "", names: ["handshake"], tags: ["deal"], description: "handshake", category: "People & Body" }, { emoji: "", names: ["pray"], tags: ["please", "hope", "wish"], description: "folded hands", category: "People & Body" }, { emoji: "", names: ["writing_hand"], tags: [], description: "writing hand", category: "People & Body" }, { emoji: "", names: ["nail_care"], tags: ["beauty", "manicure"], description: "nail polish", category: "People & Body" }, { emoji: "", names: ["selfie"], tags: [], description: "selfie", category: "People & Body" }, { emoji: "", names: ["muscle"], tags: ["flex", "bicep", "strong", "workout"], description: "flexed biceps", category: "People & Body" }, { emoji: "", names: ["mechanical_arm"], tags: [], description: "mechanical arm", category: "People & Body" }, { emoji: "", names: ["mechanical_leg"], tags: [], description: "mechanical leg", category: "People & Body" }, { emoji: "", names: ["leg"], tags: [], description: "leg", category: "People & Body" }, { emoji: "", names: ["foot"], tags: [], description: "foot", category: "People & Body" }, { emoji: "", names: ["ear"], tags: ["hear", "sound", "listen"], description: "ear", category: "People & Body" }, { emoji: "", names: ["ear_with_hearing_aid"], tags: [], description: "ear with hearing aid", category: "People & Body" }, { emoji: "", names: ["nose"], tags: ["smell"], description: "nose", category: "People & Body" }, { emoji: "", names: ["brain"], tags: [], description: "brain", category: "People & Body" }, { emoji: "", names: ["anatomical_heart"], tags: [], description: "anatomical heart", category: "People & Body" }, { emoji: "", names: ["lungs"], tags: [], description: "lungs", category: "People & Body" }, { emoji: "", names: ["tooth"], tags: [], description: "tooth", category: "People & Body" }, { emoji: "", names: ["bone"], tags: [], description: "bone", category: "People & Body" }, { emoji: "", names: ["eyes"], tags: ["look", "see", "watch"], description: "eyes", category: "People & Body" }, { emoji: "", names: ["eye"], tags: [], description: "eye", category: "People & Body" }, { emoji: "", names: ["tongue"], tags: ["taste"], description: "tongue", category: "People & Body" }, { emoji: "", names: ["lips"], tags: ["kiss"], description: "mouth", category: "People & Body" }, { emoji: "", names: ["biting_lip"], tags: [], description: "biting lip", category: "People & Body" }, { emoji: "", names: ["baby"], tags: ["child", "newborn"], description: "baby", category: "People & Body" }, { emoji: "", names: ["child"], tags: [], description: "child", category: "People & Body" }, { emoji: "", names: ["boy"], tags: ["child"], description: "boy", category: "People & Body" }, { emoji: "", names: ["girl"], tags: ["child"], description: "girl", category: "People & Body" }, { emoji: "", names: ["adult"], tags: [], description: "person", category: "People & Body" }, { emoji: "", names: ["blond_haired_person"], tags: [], description: "person: blond hair", category: "People & Body" }, { emoji: "", names: ["man"], tags: ["mustache", "father", "dad"], description: "man", category: "People & Body" }, { emoji: "", names: ["bearded_person"], tags: [], description: "person: beard", category: "People & Body" }, { emoji: "", names: ["man_beard"], tags: [], description: "man: beard", category: "People & Body" }, { emoji: "", names: ["woman_beard"], tags: [], description: "woman: beard", category: "People & Body" }, { emoji: "", names: ["red_haired_man"], tags: [], description: "man: red hair", category: "People & Body" }, { emoji: "", names: ["curly_haired_man"], tags: [], description: "man: curly hair", category: "People & Body" }, { emoji: "", names: ["white_haired_man"], tags: [], description: "man: white hair", category: "People & Body" }, { emoji: "", names: ["bald_man"], tags: [], description: "man: bald", category: "People & Body" }, { emoji: "", names: ["woman"], tags: ["girls"], description: "woman", category: "People & Body" }, { emoji: "", names: ["red_haired_woman"], tags: [], description: "woman: red hair", category: "People & Body" }, { emoji: "", names: ["person_red_hair"], tags: [], description: "person: red hair", category: "People & Body" }, { emoji: "", names: ["curly_haired_woman"], tags: [], description: "woman: curly hair", category: "People & Body" }, { emoji: "", names: ["person_curly_hair"], tags: [], description: "person: curly hair", category: "People & Body" }, { emoji: "", names: ["white_haired_woman"], tags: [], description: "woman: white hair", category: "People & Body" }, { emoji: "", names: ["person_white_hair"], tags: [], description: "person: white hair", category: "People & Body" }, { emoji: "", names: ["bald_woman"], tags: [], description: "woman: bald", category: "People & Body" }, { emoji: "", names: ["person_bald"], tags: [], description: "person: bald", category: "People & Body" }, { emoji: "", names: ["blond_haired_woman", "blonde_woman"], tags: [], description: "woman: blond hair", category: "People & Body" }, { emoji: "", names: ["blond_haired_man"], tags: [], description: "man: blond hair", category: "People & Body" }, { emoji: "", names: ["older_adult"], tags: [], description: "older person", category: "People & Body" }, { emoji: "", names: ["older_man"], tags: [], description: "old man", category: "People & Body" }, { emoji: "", names: ["older_woman"], tags: [], description: "old woman", category: "People & Body" }, { emoji: "", names: ["frowning_person"], tags: [], description: "person frowning", category: "People & Body" }, { emoji: "", names: ["frowning_man"], tags: [], description: "man frowning", category: "People & Body" }, { emoji: "", names: ["frowning_woman"], tags: [], description: "woman frowning", category: "People & Body" }, { emoji: "", names: ["pouting_face"], tags: [], description: "person pouting", category: "People & Body" }, { emoji: "", names: ["pouting_man"], tags: [], description: "man pouting", category: "People & Body" }, { emoji: "", names: ["pouting_woman"], tags: [], description: "woman pouting", category: "People & Body" }, { emoji: "", names: ["no_good"], tags: ["stop", "halt", "denied"], description: "person gesturing NO", category: "People & Body" }, { emoji: "", names: ["no_good_man", "ng_man"], tags: ["stop", "halt", "denied"], description: "man gesturing NO", category: "People & Body" }, { emoji: "", names: ["no_good_woman", "ng_woman"], tags: ["stop", "halt", "denied"], description: "woman gesturing NO", category: "People & Body" }, { emoji: "", names: ["ok_person"], tags: [], description: "person gesturing OK", category: "People & Body" }, { emoji: "", names: ["ok_man"], tags: [], description: "man gesturing OK", category: "People & Body" }, { emoji: "", names: ["ok_woman"], tags: [], description: "woman gesturing OK", category: "People & Body" }, { emoji: "", names: ["tipping_hand_person", "information_desk_person"], tags: [], description: "person tipping hand", category: "People & Body" }, { emoji: "", names: ["tipping_hand_man", "sassy_man"], tags: ["information"], description: "man tipping hand", category: "People & Body" }, { emoji: "", names: ["tipping_hand_woman", "sassy_woman"], tags: ["information"], description: "woman tipping hand", category: "People & Body" }, { emoji: "", names: ["raising_hand"], tags: [], description: "person raising hand", category: "People & Body" }, { emoji: "", names: ["raising_hand_man"], tags: [], description: "man raising hand", category: "People & Body" }, { emoji: "", names: ["raising_hand_woman"], tags: [], description: "woman raising hand", category: "People & Body" }, { emoji: "", names: ["deaf_person"], tags: [], description: "deaf person", category: "People & Body" }, { emoji: "", names: ["deaf_man"], tags: [], description: "deaf man", category: "People & Body" }, { emoji: "", names: ["deaf_woman"], tags: [], description: "deaf woman", category: "People & Body" }, { emoji: "", names: ["bow"], tags: ["respect", "thanks"], description: "person bowing", category: "People & Body" }, { emoji: "", names: ["bowing_man"], tags: ["respect", "thanks"], description: "man bowing", category: "People & Body" }, { emoji: "", names: ["bowing_woman"], tags: ["respect", "thanks"], description: "woman bowing", category: "People & Body" }, { emoji: "", names: ["facepalm"], tags: [], description: "person facepalming", category: "People & Body" }, { emoji: "", names: ["man_facepalming"], tags: [], description: "man facepalming", category: "People & Body" }, { emoji: "", names: ["woman_facepalming"], tags: [], description: "woman facepalming", category: "People & Body" }, { emoji: "", names: ["shrug"], tags: [], description: "person shrugging", category: "People & Body" }, { emoji: "", names: ["man_shrugging"], tags: [], description: "man shrugging", category: "People & Body" }, { emoji: "", names: ["woman_shrugging"], tags: [], description: "woman shrugging", category: "People & Body" }, { emoji: "", names: ["health_worker"], tags: [], description: "health worker", category: "People & Body" }, { emoji: "", names: ["man_health_worker"], tags: ["doctor", "nurse"], description: "man health worker", category: "People & Body" }, { emoji: "", names: ["woman_health_worker"], tags: ["doctor", "nurse"], description: "woman health worker", category: "People & Body" }, { emoji: "", names: ["student"], tags: [], description: "student", category: "People & Body" }, { emoji: "", names: ["man_student"], tags: ["graduation"], description: "man student", category: "People & Body" }, { emoji: "", names: ["woman_student"], tags: ["graduation"], description: "woman student", category: "People & Body" }, { emoji: "", names: ["teacher"], tags: [], description: "teacher", category: "People & Body" }, { emoji: "", names: ["man_teacher"], tags: ["school", "professor"], description: "man teacher", category: "People & Body" }, { emoji: "", names: ["woman_teacher"], tags: ["school", "professor"], description: "woman teacher", category: "People & Body" }, { emoji: "", names: ["judge"], tags: [], description: "judge", category: "People & Body" }, { emoji: "", names: ["man_judge"], tags: ["justice"], description: "man judge", category: "People & Body" }, { emoji: "", names: ["woman_judge"], tags: ["justice"], description: "woman judge", category: "People & Body" }, { emoji: "", names: ["farmer"], tags: [], description: "farmer", category: "People & Body" }, { emoji: "", names: ["man_farmer"], tags: [], description: "man farmer", category: "People & Body" }, { emoji: "", names: ["woman_farmer"], tags: [], description: "woman farmer", category: "People & Body" }, { emoji: "", names: ["cook"], tags: [], description: "cook", category: "People & Body" }, { emoji: "", names: ["man_cook"], tags: ["chef"], description: "man cook", category: "People & Body" }, { emoji: "", names: ["woman_cook"], tags: ["chef"], description: "woman cook", category: "People & Body" }, { emoji: "", names: ["mechanic"], tags: [], description: "mechanic", category: "People & Body" }, { emoji: "", names: ["man_mechanic"], tags: [], description: "man mechanic", category: "People & Body" }, { emoji: "", names: ["woman_mechanic"], tags: [], description: "woman mechanic", category: "People & Body" }, { emoji: "", names: ["factory_worker"], tags: [], description: "factory worker", category: "People & Body" }, { emoji: "", names: ["man_factory_worker"], tags: [], description: "man factory worker", category: "People & Body" }, { emoji: "", names: ["woman_factory_worker"], tags: [], description: "woman factory worker", category: "People & Body" }, { emoji: "", names: ["office_worker"], tags: [], description: "office worker", category: "People & Body" }, { emoji: "", names: ["man_office_worker"], tags: ["business"], description: "man office worker", category: "People & Body" }, { emoji: "", names: ["woman_office_worker"], tags: ["business"], description: "woman office worker", category: "People & Body" }, { emoji: "", names: ["scientist"], tags: [], description: "scientist", category: "People & Body" }, { emoji: "", names: ["man_scientist"], tags: ["research"], description: "man scientist", category: "People & Body" }, { emoji: "", names: ["woman_scientist"], tags: ["research"], description: "woman scientist", category: "People & Body" }, { emoji: "", names: ["technologist"], tags: [], description: "technologist", category: "People & Body" }, { emoji: "", names: ["man_technologist"], tags: ["coder"], description: "man technologist", category: "People & Body" }, { emoji: "", names: ["woman_technologist"], tags: ["coder"], description: "woman technologist", category: "People & Body" }, { emoji: "", names: ["singer"], tags: [], description: "singer", category: "People & Body" }, { emoji: "", names: ["man_singer"], tags: ["rockstar"], description: "man singer", category: "People & Body" }, { emoji: "", names: ["woman_singer"], tags: ["rockstar"], description: "woman singer", category: "People & Body" }, { emoji: "", names: ["artist"], tags: [], description: "artist", category: "People & Body" }, { emoji: "", names: ["man_artist"], tags: ["painter"], description: "man artist", category: "People & Body" }, { emoji: "", names: ["woman_artist"], tags: ["painter"], description: "woman artist", category: "People & Body" }, { emoji: "", names: ["pilot"], tags: [], description: "pilot", category: "People & Body" }, { emoji: "", names: ["man_pilot"], tags: [], description: "man pilot", category: "People & Body" }, { emoji: "", names: ["woman_pilot"], tags: [], description: "woman pilot", category: "People & Body" }, { emoji: "", names: ["astronaut"], tags: [], description: "astronaut", category: "People & Body" }, { emoji: "", names: ["man_astronaut"], tags: ["space"], description: "man astronaut", category: "People & Body" }, { emoji: "", names: ["woman_astronaut"], tags: ["space"], description: "woman astronaut", category: "People & Body" }, { emoji: "", names: ["firefighter"], tags: [], description: "firefighter", category: "People & Body" }, { emoji: "", names: ["man_firefighter"], tags: [], description: "man firefighter", category: "People & Body" }, { emoji: "", names: ["woman_firefighter"], tags: [], description: "woman firefighter", category: "People & Body" }, { emoji: "", names: ["police_officer", "cop"], tags: ["law"], description: "police officer", category: "People & Body" }, { emoji: "", names: ["policeman"], tags: ["law", "cop"], description: "man police officer", category: "People & Body" }, { emoji: "", names: ["policewoman"], tags: ["law", "cop"], description: "woman police officer", category: "People & Body" }, { emoji: "", names: ["detective"], tags: ["sleuth"], description: "detective", category: "People & Body" }, { emoji: "", names: ["male_detective"], tags: ["sleuth"], description: "man detective", category: "People & Body" }, { emoji: "", names: ["female_detective"], tags: ["sleuth"], description: "woman detective", category: "People & Body" }, { emoji: "", names: ["guard"], tags: [], description: "guard", category: "People & Body" }, { emoji: "", names: ["guardsman"], tags: [], description: "man guard", category: "People & Body" }, { emoji: "", names: ["guardswoman"], tags: [], description: "woman guard", category: "People & Body" }, { emoji: "", names: ["ninja"], tags: [], description: "ninja", category: "People & Body" }, { emoji: "", names: ["construction_worker"], tags: ["helmet"], description: "construction worker", category: "People & Body" }, { emoji: "", names: ["construction_worker_man"], tags: ["helmet"], description: "man construction worker", category: "People & Body" }, { emoji: "", names: ["construction_worker_woman"], tags: ["helmet"], description: "woman construction worker", category: "People & Body" }, { emoji: "", names: ["person_with_crown"], tags: [], description: "person with crown", category: "People & Body" }, { emoji: "", names: ["prince"], tags: ["crown", "royal"], description: "prince", category: "People & Body" }, { emoji: "", names: ["princess"], tags: ["crown", "royal"], description: "princess", category: "People & Body" }, { emoji: "", names: ["person_with_turban"], tags: [], description: "person wearing turban", category: "People & Body" }, { emoji: "", names: ["man_with_turban"], tags: [], description: "man wearing turban", category: "People & Body" }, { emoji: "", names: ["woman_with_turban"], tags: [], description: "woman wearing turban", category: "People & Body" }, { emoji: "", names: ["man_with_gua_pi_mao"], tags: [], description: "person with skullcap", category: "People & Body" }, { emoji: "", names: ["woman_with_headscarf"], tags: ["hijab"], description: "woman with headscarf", category: "People & Body" }, { emoji: "", names: ["person_in_tuxedo"], tags: ["groom", "marriage", "wedding"], description: "person in tuxedo", category: "People & Body" }, { emoji: "", names: ["man_in_tuxedo"], tags: [], description: "man in tuxedo", category: "People & Body" }, { emoji: "", names: ["woman_in_tuxedo"], tags: [], description: "woman in tuxedo", category: "People & Body" }, { emoji: "", names: ["person_with_veil"], tags: ["marriage", "wedding"], description: "person with veil", category: "People & Body" }, { emoji: "", names: ["man_with_veil"], tags: [], description: "man with veil", category: "People & Body" }, { emoji: "", names: ["woman_with_veil", "bride_with_veil"], tags: [], description: "woman with veil", category: "People & Body" }, { emoji: "", names: ["pregnant_woman"], tags: [], description: "pregnant woman", category: "People & Body" }, { emoji: "", names: ["pregnant_man"], tags: [], description: "pregnant man", category: "People & Body" }, { emoji: "", names: ["pregnant_person"], tags: [], description: "pregnant person", category: "People & Body" }, { emoji: "", names: ["breast_feeding"], tags: ["nursing"], description: "breast-feeding", category: "People & Body" }, { emoji: "", names: ["woman_feeding_baby"], tags: [], description: "woman feeding baby", category: "People & Body" }, { emoji: "", names: ["man_feeding_baby"], tags: [], description: "man feeding baby", category: "People & Body" }, { emoji: "", names: ["person_feeding_baby"], tags: [], description: "person feeding baby", category: "People & Body" }, { emoji: "", names: ["angel"], tags: [], description: "baby angel", category: "People & Body" }, { emoji: "", names: ["santa"], tags: ["christmas"], description: "Santa Claus", category: "People & Body" }, { emoji: "", names: ["mrs_claus"], tags: ["santa"], description: "Mrs. Claus", category: "People & Body" }, { emoji: "", names: ["mx_claus"], tags: [], description: "mx claus", category: "People & Body" }, { emoji: "", names: ["superhero"], tags: [], description: "superhero", category: "People & Body" }, { emoji: "", names: ["superhero_man"], tags: [], description: "man superhero", category: "People & Body" }, { emoji: "", names: ["superhero_woman"], tags: [], description: "woman superhero", category: "People & Body" }, { emoji: "", names: ["supervillain"], tags: [], description: "supervillain", category: "People & Body" }, { emoji: "", names: ["supervillain_man"], tags: [], description: "man supervillain", category: "People & Body" }, { emoji: "", names: ["supervillain_woman"], tags: [], description: "woman supervillain", category: "People & Body" }, { emoji: "", names: ["mage"], tags: ["wizard"], description: "mage", category: "People & Body" }, { emoji: "", names: ["mage_man"], tags: ["wizard"], description: "man mage", category: "People & Body" }, { emoji: "", names: ["mage_woman"], tags: ["wizard"], description: "woman mage", category: "People & Body" }, { emoji: "", names: ["fairy"], tags: [], description: "fairy", category: "People & Body" }, { emoji: "", names: ["fairy_man"], tags: [], description: "man fairy", category: "People & Body" }, { emoji: "", names: ["fairy_woman"], tags: [], description: "woman fairy", category: "People & Body" }, { emoji: "", names: ["vampire"], tags: [], description: "vampire", category: "People & Body" }, { emoji: "", names: ["vampire_man"], tags: [], description: "man vampire", category: "People & Body" }, { emoji: "", names: ["vampire_woman"], tags: [], description: "woman vampire", category: "People & Body" }, { emoji: "", names: ["merperson"], tags: [], description: "merperson", category: "People & Body" }, { emoji: "", names: ["merman"], tags: [], description: "merman", category: "People & Body" }, { emoji: "", names: ["mermaid"], tags: [], description: "mermaid", category: "People & Body" }, { emoji: "", names: ["elf"], tags: [], description: "elf", category: "People & Body" }, { emoji: "", names: ["elf_man"], tags: [], description: "man elf", category: "People & Body" }, { emoji: "", names: ["elf_woman"], tags: [], description: "woman elf", category: "People & Body" }, { emoji: "", names: ["genie"], tags: [], description: "genie", category: "People & Body" }, { emoji: "", names: ["genie_man"], tags: [], description: "man genie", category: "People & Body" }, { emoji: "", names: ["genie_woman"], tags: [], description: "woman genie", category: "People & Body" }, { emoji: "", names: ["zombie"], tags: [], description: "zombie", category: "People & Body" }, { emoji: "", names: ["zombie_man"], tags: [], description: "man zombie", category: "People & Body" }, { emoji: "", names: ["zombie_woman"], tags: [], description: "woman zombie", category: "People & Body" }, { emoji: "", names: ["troll"], tags: [], description: "troll", category: "People & Body" }, { emoji: "", names: ["massage"], tags: ["spa"], description: "person getting massage", category: "People & Body" }, { emoji: "", names: ["massage_man"], tags: ["spa"], description: "man getting massage", category: "People & Body" }, { emoji: "", names: ["massage_woman"], tags: ["spa"], description: "woman getting massage", category: "People & Body" }, { emoji: "", names: ["haircut"], tags: ["beauty"], description: "person getting haircut", category: "People & Body" }, { emoji: "", names: ["haircut_man"], tags: [], description: "man getting haircut", category: "People & Body" }, { emoji: "", names: ["haircut_woman"], tags: [], description: "woman getting haircut", category: "People & Body" }, { emoji: "", names: ["walking"], tags: [], description: "person walking", category: "People & Body" }, { emoji: "", names: ["walking_man"], tags: [], description: "man walking", category: "People & Body" }, { emoji: "", names: ["walking_woman"], tags: [], description: "woman walking", category: "People & Body" }, { emoji: "", names: ["standing_person"], tags: [], description: "person standing", category: "People & Body" }, { emoji: "", names: ["standing_man"], tags: [], description: "man standing", category: "People & Body" }, { emoji: "", names: ["standing_woman"], tags: [], description: "woman standing", category: "People & Body" }, { emoji: "", names: ["kneeling_person"], tags: [], description: "person kneeling", category: "People & Body" }, { emoji: "", names: ["kneeling_man"], tags: [], description: "man kneeling", category: "People & Body" }, { emoji: "", names: ["kneeling_woman"], tags: [], description: "woman kneeling", category: "People & Body" }, { emoji: "", names: ["person_with_probing_cane"], tags: [], description: "person with white cane", category: "People & Body" }, { emoji: "", names: ["man_with_probing_cane"], tags: [], description: "man with white cane", category: "People & Body" }, { emoji: "", names: ["woman_with_probing_cane"], tags: [], description: "woman with white cane", category: "People & Body" }, { emoji: "", names: ["person_in_motorized_wheelchair"], tags: [], description: "person in motorized wheelchair", category: "People & Body" }, { emoji: "", names: ["man_in_motorized_wheelchair"], tags: [], description: "man in motorized wheelchair", category: "People & Body" }, { emoji: "", names: ["woman_in_motorized_wheelchair"], tags: [], description: "woman in motorized wheelchair", category: "People & Body" }, { emoji: "", names: ["person_in_manual_wheelchair"], tags: [], description: "person in manual wheelchair", category: "People & Body" }, { emoji: "", names: ["man_in_manual_wheelchair"], tags: [], description: "man in manual wheelchair", category: "People & Body" }, { emoji: "", names: ["woman_in_manual_wheelchair"], tags: [], description: "woman in manual wheelchair", category: "People & Body" }, { emoji: "", names: ["runner", "running"], tags: ["exercise", "workout", "marathon"], description: "person running", category: "People & Body" }, { emoji: "", names: ["running_man"], tags: ["exercise", "workout", "marathon"], description: "man running", category: "People & Body" }, { emoji: "", names: ["running_woman"], tags: ["exercise", "workout", "marathon"], description: "woman running", category: "People & Body" }, { emoji: "", names: ["woman_dancing", "dancer"], tags: ["dress"], description: "woman dancing", category: "People & Body" }, { emoji: "", names: ["man_dancing"], tags: ["dancer"], description: "man dancing", category: "People & Body" }, { emoji: "", names: ["business_suit_levitating"], tags: [], description: "person in suit levitating", category: "People & Body" }, { emoji: "", names: ["dancers"], tags: ["bunny"], description: "people with bunny ears", category: "People & Body" }, { emoji: "", names: ["dancing_men"], tags: ["bunny"], description: "men with bunny ears", category: "People & Body" }, { emoji: "", names: ["dancing_women"], tags: ["bunny"], description: "women with bunny ears", category: "People & Body" }, { emoji: "", names: ["sauna_person"], tags: ["steamy"], description: "person in steamy room", category: "People & Body" }, { emoji: "", names: ["sauna_man"], tags: ["steamy"], description: "man in steamy room", category: "People & Body" }, { emoji: "", names: ["sauna_woman"], tags: ["steamy"], description: "woman in steamy room", category: "People & Body" }, { emoji: "", names: ["climbing"], tags: ["bouldering"], description: "person climbing", category: "People & Body" }, { emoji: "", names: ["climbing_man"], tags: ["bouldering"], description: "man climbing", category: "People & Body" }, { emoji: "", names: ["climbing_woman"], tags: ["bouldering"], description: "woman climbing", category: "People & Body" }, { emoji: "", names: ["person_fencing"], tags: [], description: "person fencing", category: "People & Body" }, { emoji: "", names: ["horse_racing"], tags: [], description: "horse racing", category: "People & Body" }, { emoji: "", names: ["skier"], tags: [], description: "skier", category: "People & Body" }, { emoji: "", names: ["snowboarder"], tags: [], description: "snowboarder", category: "People & Body" }, { emoji: "", names: ["golfing"], tags: [], description: "person golfing", category: "People & Body" }, { emoji: "", names: ["golfing_man"], tags: [], description: "man golfing", category: "People & Body" }, { emoji: "", names: ["golfing_woman"], tags: [], description: "woman golfing", category: "People & Body" }, { emoji: "", names: ["surfer"], tags: [], description: "person surfing", category: "People & Body" }, { emoji: "", names: ["surfing_man"], tags: [], description: "man surfing", category: "People & Body" }, { emoji: "", names: ["surfing_woman"], tags: [], description: "woman surfing", category: "People & Body" }, { emoji: "", names: ["rowboat"], tags: [], description: "person rowing boat", category: "People & Body" }, { emoji: "", names: ["rowing_man"], tags: [], description: "man rowing boat", category: "People & Body" }, { emoji: "", names: ["rowing_woman"], tags: [], description: "woman rowing boat", category: "People & Body" }, { emoji: "", names: ["swimmer"], tags: [], description: "person swimming", category: "People & Body" }, { emoji: "", names: ["swimming_man"], tags: [], description: "man swimming", category: "People & Body" }, { emoji: "", names: ["swimming_woman"], tags: [], description: "woman swimming", category: "People & Body" }, { emoji: "", names: ["bouncing_ball_person"], tags: ["basketball"], description: "person bouncing ball", category: "People & Body" }, { emoji: "", names: ["bouncing_ball_man", "basketball_man"], tags: [], description: "man bouncing ball", category: "People & Body" }, { emoji: "", names: ["bouncing_ball_woman", "basketball_woman"], tags: [], description: "woman bouncing ball", category: "People & Body" }, { emoji: "", names: ["weight_lifting"], tags: ["gym", "workout"], description: "person lifting weights", category: "People & Body" }, { emoji: "", names: ["weight_lifting_man"], tags: ["gym", "workout"], description: "man lifting weights", category: "People & Body" }, { emoji: "", names: ["weight_lifting_woman"], tags: ["gym", "workout"], description: "woman lifting weights", category: "People & Body" }, { emoji: "", names: ["bicyclist"], tags: [], description: "person biking", category: "People & Body" }, { emoji: "", names: ["biking_man"], tags: [], description: "man biking", category: "People & Body" }, { emoji: "", names: ["biking_woman"], tags: [], description: "woman biking", category: "People & Body" }, { emoji: "", names: ["mountain_bicyclist"], tags: [], description: "person mountain biking", category: "People & Body" }, { emoji: "", names: ["mountain_biking_man"], tags: [], description: "man mountain biking", category: "People & Body" }, { emoji: "", names: ["mountain_biking_woman"], tags: [], description: "woman mountain biking", category: "People & Body" }, { emoji: "", names: ["cartwheeling"], tags: [], description: "person cartwheeling", category: "People & Body" }, { emoji: "", names: ["man_cartwheeling"], tags: [], description: "man cartwheeling", category: "People & Body" }, { emoji: "", names: ["woman_cartwheeling"], tags: [], description: "woman cartwheeling", category: "People & Body" }, { emoji: "", names: ["wrestling"], tags: [], description: "people wrestling", category: "People & Body" }, { emoji: "", names: ["men_wrestling"], tags: [], description: "men wrestling", category: "People & Body" }, { emoji: "", names: ["women_wrestling"], tags: [], description: "women wrestling", category: "People & Body" }, { emoji: "", names: ["water_polo"], tags: [], description: "person playing water polo", category: "People & Body" }, { emoji: "", names: ["man_playing_water_polo"], tags: [], description: "man playing water polo", category: "People & Body" }, { emoji: "", names: ["woman_playing_water_polo"], tags: [], description: "woman playing water polo", category: "People & Body" }, { emoji: "", names: ["handball_person"], tags: [], description: "person playing handball", category: "People & Body" }, { emoji: "", names: ["man_playing_handball"], tags: [], description: "man playing handball", category: "People & Body" }, { emoji: "", names: ["woman_playing_handball"], tags: [], description: "woman playing handball", category: "People & Body" }, { emoji: "", names: ["juggling_person"], tags: [], description: "person juggling", category: "People & Body" }, { emoji: "", names: ["man_juggling"], tags: [], description: "man juggling", category: "People & Body" }, { emoji: "", names: ["woman_juggling"], tags: [], description: "woman juggling", category: "People & Body" }, { emoji: "", names: ["lotus_position"], tags: ["meditation"], description: "person in lotus position", category: "People & Body" }, { emoji: "", names: ["lotus_position_man"], tags: ["meditation"], description: "man in lotus position", category: "People & Body" }, { emoji: "", names: ["lotus_position_woman"], tags: ["meditation"], description: "woman in lotus position", category: "People & Body" }, { emoji: "", names: ["bath"], tags: ["shower"], description: "person taking bath", category: "People & Body" }, { emoji: "", names: ["sleeping_bed"], tags: [], description: "person in bed", category: "People & Body" }, { emoji: "", names: ["people_holding_hands"], tags: ["couple", "date"], description: "people holding hands", category: "People & Body" }, { emoji: "", names: ["two_women_holding_hands"], tags: ["couple", "date"], description: "women holding hands", category: "People & Body" }, { emoji: "", names: ["couple"], tags: ["date"], description: "woman and man holding hands", category: "People & Body" }, { emoji: "", names: ["two_men_holding_hands"], tags: ["couple", "date"], description: "men holding hands", category: "People & Body" }, { emoji: "", names: ["couplekiss"], tags: [], description: "kiss", category: "People & Body" }, { emoji: "", names: ["couplekiss_man_woman"], tags: [], description: "kiss: woman, man", category: "People & Body" }, { emoji: "", names: ["couplekiss_man_man"], tags: [], description: "kiss: man, man", category: "People & Body" }, { emoji: "", names: ["couplekiss_woman_woman"], tags: [], description: "kiss: woman, woman", category: "People & Body" }, { emoji: "", names: ["couple_with_heart"], tags: [], description: "couple with heart", category: "People & Body" }, { emoji: "", names: ["couple_with_heart_woman_man"], tags: [], description: "couple with heart: woman, man", category: "People & Body" }, { emoji: "", names: ["couple_with_heart_man_man"], tags: [], description: "couple with heart: man, man", category: "People & Body" }, { emoji: "", names: ["couple_with_heart_woman_woman"], tags: [], description: "couple with heart: woman, woman", category: "People & Body" }, { emoji: "", names: ["family"], tags: ["home", "parents", "child"], description: "family", category: "People & Body" }, { emoji: "", names: ["family_man_woman_boy"], tags: [], description: "family: man, woman, boy", category: "People & Body" }, { emoji: "", names: ["family_man_woman_girl"], tags: [], description: "family: man, woman, girl", category: "People & Body" }, { emoji: "", names: ["family_man_woman_girl_boy"], tags: [], description: "family: man, woman, girl, boy", category: "People & Body" }, { emoji: "", names: ["family_man_woman_boy_boy"], tags: [], description: "family: man, woman, boy, boy", category: "People & Body" }, { emoji: "", names: ["family_man_woman_girl_girl"], tags: [], description: "family: man, woman, girl, girl", category: "People & Body" }, { emoji: "", names: ["family_man_man_boy"], tags: [], description: "family: man, man, boy", category: "People & Body" }, { emoji: "", names: ["family_man_man_girl"], tags: [], description: "family: man, man, girl", category: "People & Body" }, { emoji: "", names: ["family_man_man_girl_boy"], tags: [], description: "family: man, man, girl, boy", category: "People & Body" }, { emoji: "", names: ["family_man_man_boy_boy"], tags: [], description: "family: man, man, boy, boy", category: "People & Body" }, { emoji: "", names: ["family_man_man_girl_girl"], tags: [], description: "family: man, man, girl, girl", category: "People & Body" }, { emoji: "", names: ["family_woman_woman_boy"], tags: [], description: "family: woman, woman, boy", category: "People & Body" }, { emoji: "", names: ["family_woman_woman_girl"], tags: [], description: "family: woman, woman, girl", category: "People & Body" }, { emoji: "", names: ["family_woman_woman_girl_boy"], tags: [], description: "family: woman, woman, girl, boy", category: "People & Body" }, { emoji: "", names: ["family_woman_woman_boy_boy"], tags: [], description: "family: woman, woman, boy, boy", category: "People & Body" }, { emoji: "", names: ["family_woman_woman_girl_girl"], tags: [], description: "family: woman, woman, girl, girl", category: "People & Body" }, { emoji: "", names: ["family_man_boy"], tags: [], description: "family: man, boy", category: "People & Body" }, { emoji: "", names: ["family_man_boy_boy"], tags: [], description: "family: man, boy, boy", category: "People & Body" }, { emoji: "", names: ["family_man_girl"], tags: [], description: "family: man, girl", category: "People & Body" }, { emoji: "", names: ["family_man_girl_boy"], tags: [], description: "family: man, girl, boy", category: "People & Body" }, { emoji: "", names: ["family_man_girl_girl"], tags: [], description: "family: man, girl, girl", category: "People & Body" }, { emoji: "", names: ["family_woman_boy"], tags: [], description: "family: woman, boy", category: "People & Body" }, { emoji: "", names: ["family_woman_boy_boy"], tags: [], description: "family: woman, boy, boy", category: "People & Body" }, { emoji: "", names: ["family_woman_girl"], tags: [], description: "family: woman, girl", category: "People & Body" }, { emoji: "", names: ["family_woman_girl_boy"], tags: [], description: "family: woman, girl, boy", category: "People & Body" }, { emoji: "", names: ["family_woman_girl_girl"], tags: [], description: "family: woman, girl, girl", category: "People & Body" }, { emoji: "", names: ["speaking_head"], tags: [], description: "speaking head", category: "People & Body" }, { emoji: "", names: ["bust_in_silhouette"], tags: ["user"], description: "bust in silhouette", category: "People & Body" }, { emoji: "", names: ["busts_in_silhouette"], tags: ["users", "group", "team"], description: "busts in silhouette", category: "People & Body" }, { emoji: "", names: ["people_hugging"], tags: [], description: "people hugging", category: "People & Body" }, { emoji: "", names: ["footprints"], tags: ["feet", "tracks"], description: "footprints", category: "People & Body" }, { emoji: "", names: ["monkey_face"], tags: [], description: "monkey face", category: "Animals & Nature" }, { emoji: "", names: ["monkey"], tags: [], description: "monkey", category: "Animals & Nature" }, { emoji: "", names: ["gorilla"], tags: [], description: "gorilla", category: "Animals & Nature" }, { emoji: "", names: ["orangutan"], tags: [], description: "orangutan", category: "Animals & Nature" }, { emoji: "", names: ["dog"], tags: ["pet"], description: "dog face", category: "Animals & Nature" }, { emoji: "", names: ["dog2"], tags: [], description: "dog", category: "Animals & Nature" }, { emoji: "", names: ["guide_dog"], tags: [], description: "guide dog", category: "Animals & Nature" }, { emoji: "", names: ["service_dog"], tags: [], description: "service dog", category: "Animals & Nature" }, { emoji: "", names: ["poodle"], tags: ["dog"], description: "poodle", category: "Animals & Nature" }, { emoji: "", names: ["wolf"], tags: [], description: "wolf", category: "Animals & Nature" }, { emoji: "", names: ["fox_face"], tags: [], description: "fox", category: "Animals & Nature" }, { emoji: "", names: ["raccoon"], tags: [], description: "raccoon", category: "Animals & Nature" }, { emoji: "", names: ["cat"], tags: ["pet"], description: "cat face", category: "Animals & Nature" }, { emoji: "", names: ["cat2"], tags: [], description: "cat", category: "Animals & Nature" }, { emoji: "", names: ["black_cat"], tags: [], description: "black cat", category: "Animals & Nature" }, { emoji: "", names: ["lion"], tags: [], description: "lion", category: "Animals & Nature" }, { emoji: "", names: ["tiger"], tags: [], description: "tiger face", category: "Animals & Nature" }, { emoji: "", names: ["tiger2"], tags: [], description: "tiger", category: "Animals & Nature" }, { emoji: "", names: ["leopard"], tags: [], description: "leopard", category: "Animals & Nature" }, { emoji: "", names: ["horse"], tags: [], description: "horse face", category: "Animals & Nature" }, { emoji: "", names: ["moose"], tags: ["canada"], description: "moose", category: "Animals & Nature" }, { emoji: "", names: ["donkey"], tags: ["mule"], description: "donkey", category: "Animals & Nature" }, { emoji: "", names: ["racehorse"], tags: ["speed"], description: "horse", category: "Animals & Nature" }, { emoji: "", names: ["unicorn"], tags: [], description: "unicorn", category: "Animals & Nature" }, { emoji: "", names: ["zebra"], tags: [], description: "zebra", category: "Animals & Nature" }, { emoji: "", names: ["deer"], tags: [], description: "deer", category: "Animals & Nature" }, { emoji: "", names: ["bison"], tags: [], description: "bison", category: "Animals & Nature" }, { emoji: "", names: ["cow"], tags: [], description: "cow face", category: "Animals & Nature" }, { emoji: "", names: ["ox"], tags: [], description: "ox", category: "Animals & Nature" }, { emoji: "", names: ["water_buffalo"], tags: [], description: "water buffalo", category: "Animals & Nature" }, { emoji: "", names: ["cow2"], tags: [], description: "cow", category: "Animals & Nature" }, { emoji: "", names: ["pig"], tags: [], description: "pig face", category: "Animals & Nature" }, { emoji: "", names: ["pig2"], tags: [], description: "pig", category: "Animals & Nature" }, { emoji: "", names: ["boar"], tags: [], description: "boar", category: "Animals & Nature" }, { emoji: "", names: ["pig_nose"], tags: [], description: "pig nose", category: "Animals & Nature" }, { emoji: "", names: ["ram"], tags: [], description: "ram", category: "Animals & Nature" }, { emoji: "", names: ["sheep"], tags: [], description: "ewe", category: "Animals & Nature" }, { emoji: "", names: ["goat"], tags: [], description: "goat", category: "Animals & Nature" }, { emoji: "", names: ["dromedary_camel"], tags: ["desert"], description: "camel", category: "Animals & Nature" }, { emoji: "", names: ["camel"], tags: [], description: "two-hump camel", category: "Animals & Nature" }, { emoji: "", names: ["llama"], tags: [], description: "llama", category: "Animals & Nature" }, { emoji: "", names: ["giraffe"], tags: [], description: "giraffe", category: "Animals & Nature" }, { emoji: "", names: ["elephant"], tags: [], description: "elephant", category: "Animals & Nature" }, { emoji: "", names: ["mammoth"], tags: [], description: "mammoth", category: "Animals & Nature" }, { emoji: "", names: ["rhinoceros"], tags: [], description: "rhinoceros", category: "Animals & Nature" }, { emoji: "", names: ["hippopotamus"], tags: [], description: "hippopotamus", category: "Animals & Nature" }, { emoji: "", names: ["mouse"], tags: [], description: "mouse face", category: "Animals & Nature" }, { emoji: "", names: ["mouse2"], tags: [], description: "mouse", category: "Animals & Nature" }, { emoji: "", names: ["rat"], tags: [], description: "rat", category: "Animals & Nature" }, { emoji: "", names: ["hamster"], tags: ["pet"], description: "hamster", category: "Animals & Nature" }, { emoji: "", names: ["rabbit"], tags: ["bunny"], description: "rabbit face", category: "Animals & Nature" }, { emoji: "", names: ["rabbit2"], tags: [], description: "rabbit", category: "Animals & Nature" }, { emoji: "", names: ["chipmunk"], tags: [], description: "chipmunk", category: "Animals & Nature" }, { emoji: "", names: ["beaver"], tags: [], description: "beaver", category: "Animals & Nature" }, { emoji: "", names: ["hedgehog"], tags: [], description: "hedgehog", category: "Animals & Nature" }, { emoji: "", names: ["bat"], tags: [], description: "bat", category: "Animals & Nature" }, { emoji: "", names: ["bear"], tags: [], description: "bear", category: "Animals & Nature" }, { emoji: "", names: ["polar_bear"], tags: [], description: "polar bear", category: "Animals & Nature" }, { emoji: "", names: ["koala"], tags: [], description: "koala", category: "Animals & Nature" }, { emoji: "", names: ["panda_face"], tags: [], description: "panda", category: "Animals & Nature" }, { emoji: "", names: ["sloth"], tags: [], description: "sloth", category: "Animals & Nature" }, { emoji: "", names: ["otter"], tags: [], description: "otter", category: "Animals & Nature" }, { emoji: "", names: ["skunk"], tags: [], description: "skunk", category: "Animals & Nature" }, { emoji: "", names: ["kangaroo"], tags: [], description: "kangaroo", category: "Animals & Nature" }, { emoji: "", names: ["badger"], tags: [], description: "badger", category: "Animals & Nature" }, { emoji: "", names: ["feet", "paw_prints"], tags: [], description: "paw prints", category: "Animals & Nature" }, { emoji: "", names: ["turkey"], tags: ["thanksgiving"], description: "turkey", category: "Animals & Nature" }, { emoji: "", names: ["chicken"], tags: [], description: "chicken", category: "Animals & Nature" }, { emoji: "", names: ["rooster"], tags: [], description: "rooster", category: "Animals & Nature" }, { emoji: "", names: ["hatching_chick"], tags: [], description: "hatching chick", category: "Animals & Nature" }, { emoji: "", names: ["baby_chick"], tags: [], description: "baby chick", category: "Animals & Nature" }, { emoji: "", names: ["hatched_chick"], tags: [], description: "front-facing baby chick", category: "Animals & Nature" }, { emoji: "", names: ["bird"], tags: [], description: "bird", category: "Animals & Nature" }, { emoji: "", names: ["penguin"], tags: [], description: "penguin", category: "Animals & Nature" }, { emoji: "", names: ["dove"], tags: ["peace"], description: "dove", category: "Animals & Nature" }, { emoji: "", names: ["eagle"], tags: [], description: "eagle", category: "Animals & Nature" }, { emoji: "", names: ["duck"], tags: [], description: "duck", category: "Animals & Nature" }, { emoji: "", names: ["swan"], tags: [], description: "swan", category: "Animals & Nature" }, { emoji: "", names: ["owl"], tags: [], description: "owl", category: "Animals & Nature" }, { emoji: "", names: ["dodo"], tags: [], description: "dodo", category: "Animals & Nature" }, { emoji: "", names: ["feather"], tags: [], description: "feather", category: "Animals & Nature" }, { emoji: "", names: ["flamingo"], tags: [], description: "flamingo", category: "Animals & Nature" }, { emoji: "", names: ["peacock"], tags: [], description: "peacock", category: "Animals & Nature" }, { emoji: "", names: ["parrot"], tags: [], description: "parrot", category: "Animals & Nature" }, { emoji: "", names: ["wing"], tags: ["fly"], description: "wing", category: "Animals & Nature" }, { emoji: "", names: ["black_bird"], tags: [], description: "black bird", category: "Animals & Nature" }, { emoji: "", names: ["goose"], tags: ["honk"], description: "goose", category: "Animals & Nature" }, { emoji: "", names: ["frog"], tags: [], description: "frog", category: "Animals & Nature" }, { emoji: "", names: ["crocodile"], tags: [], description: "crocodile", category: "Animals & Nature" }, { emoji: "", names: ["turtle"], tags: ["slow"], description: "turtle", category: "Animals & Nature" }, { emoji: "", names: ["lizard"], tags: [], description: "lizard", category: "Animals & Nature" }, { emoji: "", names: ["snake"], tags: [], description: "snake", category: "Animals & Nature" }, { emoji: "", names: ["dragon_face"], tags: [], description: "dragon face", category: "Animals & Nature" }, { emoji: "", names: ["dragon"], tags: [], description: "dragon", category: "Animals & Nature" }, { emoji: "", names: ["sauropod"], tags: ["dinosaur"], description: "sauropod", category: "Animals & Nature" }, { emoji: "", names: ["t-rex"], tags: ["dinosaur"], description: "T-Rex", category: "Animals & Nature" }, { emoji: "", names: ["whale"], tags: ["sea"], description: "spouting whale", category: "Animals & Nature" }, { emoji: "", names: ["whale2"], tags: [], description: "whale", category: "Animals & Nature" }, { emoji: "", names: ["dolphin", "flipper"], tags: [], description: "dolphin", category: "Animals & Nature" }, { emoji: "", names: ["seal"], tags: [], description: "seal", category: "Animals & Nature" }, { emoji: "", names: ["fish"], tags: [], description: "fish", category: "Animals & Nature" }, { emoji: "", names: ["tropical_fish"], tags: [], description: "tropical fish", category: "Animals & Nature" }, { emoji: "", names: ["blowfish"], tags: [], description: "blowfish", category: "Animals & Nature" }, { emoji: "", names: ["shark"], tags: [], description: "shark", category: "Animals & Nature" }, { emoji: "", names: ["octopus"], tags: [], description: "octopus", category: "Animals & Nature" }, { emoji: "", names: ["shell"], tags: ["sea", "beach"], description: "spiral shell", category: "Animals & Nature" }, { emoji: "", names: ["coral"], tags: [], description: "coral", category: "Animals & Nature" }, { emoji: "", names: ["jellyfish"], tags: [], description: "jellyfish", category: "Animals & Nature" }, { emoji: "", names: ["snail"], tags: ["slow"], description: "snail", category: "Animals & Nature" }, { emoji: "", names: ["butterfly"], tags: [], description: "butterfly", category: "Animals & Nature" }, { emoji: "", names: ["bug"], tags: [], description: "bug", category: "Animals & Nature" }, { emoji: "", names: ["ant"], tags: [], description: "ant", category: "Animals & Nature" }, { emoji: "", names: ["bee", "honeybee"], tags: [], description: "honeybee", category: "Animals & Nature" }, { emoji: "", names: ["beetle"], tags: [], description: "beetle", category: "Animals & Nature" }, { emoji: "", names: ["lady_beetle"], tags: ["bug"], description: "lady beetle", category: "Animals & Nature" }, { emoji: "", names: ["cricket"], tags: [], description: "cricket", category: "Animals & Nature" }, { emoji: "", names: ["cockroach"], tags: [], description: "cockroach", category: "Animals & Nature" }, { emoji: "", names: ["spider"], tags: [], description: "spider", category: "Animals & Nature" }, { emoji: "", names: ["spider_web"], tags: [], description: "spider web", category: "Animals & Nature" }, { emoji: "", names: ["scorpion"], tags: [], description: "scorpion", category: "Animals & Nature" }, { emoji: "", names: ["mosquito"], tags: [], description: "mosquito", category: "Animals & Nature" }, { emoji: "", names: ["fly"], tags: [], description: "fly", category: "Animals & Nature" }, { emoji: "", names: ["worm"], tags: [], description: "worm", category: "Animals & Nature" }, { emoji: "", names: ["microbe"], tags: ["germ"], description: "microbe", category: "Animals & Nature" }, { emoji: "", names: ["bouquet"], tags: ["flowers"], description: "bouquet", category: "Animals & Nature" }, { emoji: "", names: ["cherry_blossom"], tags: ["flower", "spring"], description: "cherry blossom", category: "Animals & Nature" }, { emoji: "", names: ["white_flower"], tags: [], description: "white flower", category: "Animals & Nature" }, { emoji: "", names: ["lotus"], tags: [], description: "lotus", category: "Animals & Nature" }, { emoji: "", names: ["rosette"], tags: [], description: "rosette", category: "Animals & Nature" }, { emoji: "", names: ["rose"], tags: ["flower"], description: "rose", category: "Animals & Nature" }, { emoji: "", names: ["wilted_flower"], tags: [], description: "wilted flower", category: "Animals & Nature" }, { emoji: "", names: ["hibiscus"], tags: [], description: "hibiscus", category: "Animals & Nature" }, { emoji: "", names: ["sunflower"], tags: [], description: "sunflower", category: "Animals & Nature" }, { emoji: "", names: ["blossom"], tags: [], description: "blossom", category: "Animals & Nature" }, { emoji: "", names: ["tulip"], tags: ["flower"], description: "tulip", category: "Animals & Nature" }, { emoji: "", names: ["hyacinth"], tags: [], description: "hyacinth", category: "Animals & Nature" }, { emoji: "", names: ["seedling"], tags: ["plant"], description: "seedling", category: "Animals & Nature" }, { emoji: "", names: ["potted_plant"], tags: [], description: "potted plant", category: "Animals & Nature" }, { emoji: "", names: ["evergreen_tree"], tags: ["wood"], description: "evergreen tree", category: "Animals & Nature" }, { emoji: "", names: ["deciduous_tree"], tags: ["wood"], description: "deciduous tree", category: "Animals & Nature" }, { emoji: "", names: ["palm_tree"], tags: [], description: "palm tree", category: "Animals & Nature" }, { emoji: "", names: ["cactus"], tags: [], description: "cactus", category: "Animals & Nature" }, { emoji: "", names: ["ear_of_rice"], tags: [], description: "sheaf of rice", category: "Animals & Nature" }, { emoji: "", names: ["herb"], tags: [], description: "herb", category: "Animals & Nature" }, { emoji: "", names: ["shamrock"], tags: [], description: "shamrock", category: "Animals & Nature" }, { emoji: "", names: ["four_leaf_clover"], tags: ["luck"], description: "four leaf clover", category: "Animals & Nature" }, { emoji: "", names: ["maple_leaf"], tags: ["canada"], description: "maple leaf", category: "Animals & Nature" }, { emoji: "", names: ["fallen_leaf"], tags: ["autumn"], description: "fallen leaf", category: "Animals & Nature" }, { emoji: "", names: ["leaves"], tags: ["leaf"], description: "leaf fluttering in wind", category: "Animals & Nature" }, { emoji: "", names: ["empty_nest"], tags: [], description: "empty nest", category: "Animals & Nature" }, { emoji: "", names: ["nest_with_eggs"], tags: [], description: "nest with eggs", category: "Animals & Nature" }, { emoji: "", names: ["mushroom"], tags: ["fungus"], description: "mushroom", category: "Animals & Nature" }, { emoji: "", names: ["grapes"], tags: [], description: "grapes", category: "Food & Drink" }, { emoji: "", names: ["melon"], tags: [], description: "melon", category: "Food & Drink" }, { emoji: "", names: ["watermelon"], tags: [], description: "watermelon", category: "Food & Drink" }, { emoji: "", names: ["tangerine", "orange", "mandarin"], tags: [], description: "tangerine", category: "Food & Drink" }, { emoji: "", names: ["lemon"], tags: [], description: "lemon", category: "Food & Drink" }, { emoji: "", names: ["banana"], tags: ["fruit"], description: "banana", category: "Food & Drink" }, { emoji: "", names: ["pineapple"], tags: [], description: "pineapple", category: "Food & Drink" }, { emoji: "", names: ["mango"], tags: [], description: "mango", category: "Food & Drink" }, { emoji: "", names: ["apple"], tags: [], description: "red apple", category: "Food & Drink" }, { emoji: "", names: ["green_apple"], tags: ["fruit"], description: "green apple", category: "Food & Drink" }, { emoji: "", names: ["pear"], tags: [], description: "pear", category: "Food & Drink" }, { emoji: "", names: ["peach"], tags: [], description: "peach", category: "Food & Drink" }, { emoji: "", names: ["cherries"], tags: ["fruit"], description: "cherries", category: "Food & Drink" }, { emoji: "", names: ["strawberry"], tags: ["fruit"], description: "strawberry", category: "Food & Drink" }, { emoji: "", names: ["blueberries"], tags: [], description: "blueberries", category: "Food & Drink" }, { emoji: "", names: ["kiwi_fruit"], tags: [], description: "kiwi fruit", category: "Food & Drink" }, { emoji: "", names: ["tomato"], tags: [], description: "tomato", category: "Food & Drink" }, { emoji: "", names: ["olive"], tags: [], description: "olive", category: "Food & Drink" }, { emoji: "", names: ["coconut"], tags: [], description: "coconut", category: "Food & Drink" }, { emoji: "", names: ["avocado"], tags: [], description: "avocado", category: "Food & Drink" }, { emoji: "", names: ["eggplant"], tags: ["aubergine"], description: "eggplant", category: "Food & Drink" }, { emoji: "", names: ["potato"], tags: [], description: "potato", category: "Food & Drink" }, { emoji: "", names: ["carrot"], tags: [], description: "carrot", category: "Food & Drink" }, { emoji: "", names: ["corn"], tags: [], description: "ear of corn", category: "Food & Drink" }, { emoji: "", names: ["hot_pepper"], tags: ["spicy"], description: "hot pepper", category: "Food & Drink" }, { emoji: "", names: ["bell_pepper"], tags: [], description: "bell pepper", category: "Food & Drink" }, { emoji: "", names: ["cucumber"], tags: [], description: "cucumber", category: "Food & Drink" }, { emoji: "", names: ["leafy_green"], tags: [], description: "leafy green", category: "Food & Drink" }, { emoji: "", names: ["broccoli"], tags: [], description: "broccoli", category: "Food & Drink" }, { emoji: "", names: ["garlic"], tags: [], description: "garlic", category: "Food & Drink" }, { emoji: "", names: ["onion"], tags: [], description: "onion", category: "Food & Drink" }, { emoji: "", names: ["peanuts"], tags: [], description: "peanuts", category: "Food & Drink" }, { emoji: "", names: ["beans"], tags: [], description: "beans", category: "Food & Drink" }, { emoji: "", names: ["chestnut"], tags: [], description: "chestnut", category: "Food & Drink" }, { emoji: "", names: ["ginger_root"], tags: [], description: "ginger root", category: "Food & Drink" }, { emoji: "", names: ["pea_pod"], tags: [], description: "pea pod", category: "Food & Drink" }, { emoji: "", names: ["bread"], tags: ["toast"], description: "bread", category: "Food & Drink" }, { emoji: "", names: ["croissant"], tags: [], description: "croissant", category: "Food & Drink" }, { emoji: "", names: ["baguette_bread"], tags: [], description: "baguette bread", category: "Food & Drink" }, { emoji: "", names: ["flatbread"], tags: [], description: "flatbread", category: "Food & Drink" }, { emoji: "", names: ["pretzel"], tags: [], description: "pretzel", category: "Food & Drink" }, { emoji: "", names: ["bagel"], tags: [], description: "bagel", category: "Food & Drink" }, { emoji: "", names: ["pancakes"], tags: [], description: "pancakes", category: "Food & Drink" }, { emoji: "", names: ["waffle"], tags: [], description: "waffle", category: "Food & Drink" }, { emoji: "", names: ["cheese"], tags: [], description: "cheese wedge", category: "Food & Drink" }, { emoji: "", names: ["meat_on_bone"], tags: [], description: "meat on bone", category: "Food & Drink" }, { emoji: "", names: ["poultry_leg"], tags: ["meat", "chicken"], description: "poultry leg", category: "Food & Drink" }, { emoji: "", names: ["cut_of_meat"], tags: [], description: "cut of meat", category: "Food & Drink" }, { emoji: "", names: ["bacon"], tags: [], description: "bacon", category: "Food & Drink" }, { emoji: "", names: ["hamburger"], tags: ["burger"], description: "hamburger", category: "Food & Drink" }, { emoji: "", names: ["fries"], tags: [], description: "french fries", category: "Food & Drink" }, { emoji: "", names: ["pizza"], tags: [], description: "pizza", category: "Food & Drink" }, { emoji: "", names: ["hotdog"], tags: [], description: "hot dog", category: "Food & Drink" }, { emoji: "", names: ["sandwich"], tags: [], description: "sandwich", category: "Food & Drink" }, { emoji: "", names: ["taco"], tags: [], description: "taco", category: "Food & Drink" }, { emoji: "", names: ["burrito"], tags: [], description: "burrito", category: "Food & Drink" }, { emoji: "", names: ["tamale"], tags: [], description: "tamale", category: "Food & Drink" }, { emoji: "", names: ["stuffed_flatbread"], tags: [], description: "stuffed flatbread", category: "Food & Drink" }, { emoji: "", names: ["falafel"], tags: [], description: "falafel", category: "Food & Drink" }, { emoji: "", names: ["egg"], tags: [], description: "egg", category: "Food & Drink" }, { emoji: "", names: ["fried_egg"], tags: ["breakfast"], description: "cooking", category: "Food & Drink" }, { emoji: "", names: ["shallow_pan_of_food"], tags: ["paella", "curry"], description: "shallow pan of food", category: "Food & Drink" }, { emoji: "", names: ["stew"], tags: [], description: "pot of food", category: "Food & Drink" }, { emoji: "", names: ["fondue"], tags: [], description: "fondue", category: "Food & Drink" }, { emoji: "", names: ["bowl_with_spoon"], tags: [], description: "bowl with spoon", category: "Food & Drink" }, { emoji: "", names: ["green_salad"], tags: [], description: "green salad", category: "Food & Drink" }, { emoji: "", names: ["popcorn"], tags: [], description: "popcorn", category: "Food & Drink" }, { emoji: "", names: ["butter"], tags: [], description: "butter", category: "Food & Drink" }, { emoji: "", names: ["salt"], tags: [], description: "salt", category: "Food & Drink" }, { emoji: "", names: ["canned_food"], tags: [], description: "canned food", category: "Food & Drink" }, { emoji: "", names: ["bento"], tags: [], description: "bento box", category: "Food & Drink" }, { emoji: "", names: ["rice_cracker"], tags: [], description: "rice cracker", category: "Food & Drink" }, { emoji: "", names: ["rice_ball"], tags: [], description: "rice ball", category: "Food & Drink" }, { emoji: "", names: ["rice"], tags: [], description: "cooked rice", category: "Food & Drink" }, { emoji: "", names: ["curry"], tags: [], description: "curry rice", category: "Food & Drink" }, { emoji: "", names: ["ramen"], tags: ["noodle"], description: "steaming bowl", category: "Food & Drink" }, { emoji: "", names: ["spaghetti"], tags: ["pasta"], description: "spaghetti", category: "Food & Drink" }, { emoji: "", names: ["sweet_potato"], tags: [], description: "roasted sweet potato", category: "Food & Drink" }, { emoji: "", names: ["oden"], tags: [], description: "oden", category: "Food & Drink" }, { emoji: "", names: ["sushi"], tags: [], description: "sushi", category: "Food & Drink" }, { emoji: "", names: ["fried_shrimp"], tags: ["tempura"], description: "fried shrimp", category: "Food & Drink" }, { emoji: "", names: ["fish_cake"], tags: [], description: "fish cake with swirl", category: "Food & Drink" }, { emoji: "", names: ["moon_cake"], tags: [], description: "moon cake", category: "Food & Drink" }, { emoji: "", names: ["dango"], tags: [], description: "dango", category: "Food & Drink" }, { emoji: "", names: ["dumpling"], tags: [], description: "dumpling", category: "Food & Drink" }, { emoji: "", names: ["fortune_cookie"], tags: [], description: "fortune cookie", category: "Food & Drink" }, { emoji: "", names: ["takeout_box"], tags: [], description: "takeout box", category: "Food & Drink" }, { emoji: "", names: ["crab"], tags: [], description: "crab", category: "Food & Drink" }, { emoji: "", names: ["lobster"], tags: [], description: "lobster", category: "Food & Drink" }, { emoji: "", names: ["shrimp"], tags: [], description: "shrimp", category: "Food & Drink" }, { emoji: "", names: ["squid"], tags: [], description: "squid", category: "Food & Drink" }, { emoji: "", names: ["oyster"], tags: [], description: "oyster", category: "Food & Drink" }, { emoji: "", names: ["icecream"], tags: [], description: "soft ice cream", category: "Food & Drink" }, { emoji: "", names: ["shaved_ice"], tags: [], description: "shaved ice", category: "Food & Drink" }, { emoji: "", names: ["ice_cream"], tags: [], description: "ice cream", category: "Food & Drink" }, { emoji: "", names: ["doughnut"], tags: [], description: "doughnut", category: "Food & Drink" }, { emoji: "", names: ["cookie"], tags: [], description: "cookie", category: "Food & Drink" }, { emoji: "", names: ["birthday"], tags: ["party"], description: "birthday cake", category: "Food & Drink" }, { emoji: "", names: ["cake"], tags: ["dessert"], description: "shortcake", category: "Food & Drink" }, { emoji: "", names: ["cupcake"], tags: [], description: "cupcake", category: "Food & Drink" }, { emoji: "", names: ["pie"], tags: [], description: "pie", category: "Food & Drink" }, { emoji: "", names: ["chocolate_bar"], tags: [], description: "chocolate bar", category: "Food & Drink" }, { emoji: "", names: ["candy"], tags: ["sweet"], description: "candy", category: "Food & Drink" }, { emoji: "", names: ["lollipop"], tags: [], description: "lollipop", category: "Food & Drink" }, { emoji: "", names: ["custard"], tags: [], description: "custard", category: "Food & Drink" }, { emoji: "", names: ["honey_pot"], tags: [], description: "honey pot", category: "Food & Drink" }, { emoji: "", names: ["baby_bottle"], tags: ["milk"], description: "baby bottle", category: "Food & Drink" }, { emoji: "", names: ["milk_glass"], tags: [], description: "glass of milk", category: "Food & Drink" }, { emoji: "", names: ["coffee"], tags: ["cafe", "espresso"], description: "hot beverage", category: "Food & Drink" }, { emoji: "", names: ["teapot"], tags: [], description: "teapot", category: "Food & Drink" }, { emoji: "", names: ["tea"], tags: ["green", "breakfast"], description: "teacup without handle", category: "Food & Drink" }, { emoji: "", names: ["sake"], tags: [], description: "sake", category: "Food & Drink" }, { emoji: "", names: ["champagne"], tags: ["bottle", "bubbly", "celebration"], description: "bottle with popping cork", category: "Food & Drink" }, { emoji: "", names: ["wine_glass"], tags: [], description: "wine glass", category: "Food & Drink" }, { emoji: "", names: ["cocktail"], tags: ["drink"], description: "cocktail glass", category: "Food & Drink" }, { emoji: "", names: ["tropical_drink"], tags: ["summer", "vacation"], description: "tropical drink", category: "Food & Drink" }, { emoji: "", names: ["beer"], tags: ["drink"], description: "beer mug", category: "Food & Drink" }, { emoji: "", names: ["beers"], tags: ["drinks"], description: "clinking beer mugs", category: "Food & Drink" }, { emoji: "", names: ["clinking_glasses"], tags: ["cheers", "toast"], description: "clinking glasses", category: "Food & Drink" }, { emoji: "", names: ["tumbler_glass"], tags: ["whisky"], description: "tumbler glass", category: "Food & Drink" }, { emoji: "", names: ["pouring_liquid"], tags: [], description: "pouring liquid", category: "Food & Drink" }, { emoji: "", names: ["cup_with_straw"], tags: [], description: "cup with straw", category: "Food & Drink" }, { emoji: "", names: ["bubble_tea"], tags: [], description: "bubble tea", category: "Food & Drink" }, { emoji: "", names: ["beverage_box"], tags: [], description: "beverage box", category: "Food & Drink" }, { emoji: "", names: ["mate"], tags: [], description: "mate", category: "Food & Drink" }, { emoji: "", names: ["ice_cube"], tags: [], description: "ice", category: "Food & Drink" }, { emoji: "", names: ["chopsticks"], tags: [], description: "chopsticks", category: "Food & Drink" }, { emoji: "", names: ["plate_with_cutlery"], tags: ["dining", "dinner"], description: "fork and knife with plate", category: "Food & Drink" }, { emoji: "", names: ["fork_and_knife"], tags: ["cutlery"], description: "fork and knife", category: "Food & Drink" }, { emoji: "", names: ["spoon"], tags: [], description: "spoon", category: "Food & Drink" }, { emoji: "", names: ["hocho", "knife"], tags: ["cut", "chop"], description: "kitchen knife", category: "Food & Drink" }, { emoji: "", names: ["jar"], tags: [], description: "jar", category: "Food & Drink" }, { emoji: "", names: ["amphora"], tags: [], description: "amphora", category: "Food & Drink" }, { emoji: "", names: ["earth_africa"], tags: ["globe", "world", "international"], description: "globe showing Europe-Africa", category: "Travel & Places" }, { emoji: "", names: ["earth_americas"], tags: ["globe", "world", "international"], description: "globe showing Americas", category: "Travel & Places" }, { emoji: "", names: ["earth_asia"], tags: ["globe", "world", "international"], description: "globe showing Asia-Australia", category: "Travel & Places" }, { emoji: "", names: ["globe_with_meridians"], tags: ["world", "global", "international"], description: "globe with meridians", category: "Travel & Places" }, { emoji: "", names: ["world_map"], tags: ["travel"], description: "world map", category: "Travel & Places" }, { emoji: "", names: ["japan"], tags: [], description: "map of Japan", category: "Travel & Places" }, { emoji: "", names: ["compass"], tags: [], description: "compass", category: "Travel & Places" }, { emoji: "", names: ["mountain_snow"], tags: [], description: "snow-capped mountain", category: "Travel & Places" }, { emoji: "", names: ["mountain"], tags: [], description: "mountain", category: "Travel & Places" }, { emoji: "", names: ["volcano"], tags: [], description: "volcano", category: "Travel & Places" }, { emoji: "", names: ["mount_fuji"], tags: [], description: "mount fuji", category: "Travel & Places" }, { emoji: "", names: ["camping"], tags: [], description: "camping", category: "Travel & Places" }, { emoji: "", names: ["beach_umbrella"], tags: [], description: "beach with umbrella", category: "Travel & Places" }, { emoji: "", names: ["desert"], tags: [], description: "desert", category: "Travel & Places" }, { emoji: "", names: ["desert_island"], tags: [], description: "desert island", category: "Travel & Places" }, { emoji: "", names: ["national_park"], tags: [], description: "national park", category: "Travel & Places" }, { emoji: "", names: ["stadium"], tags: [], description: "stadium", category: "Travel & Places" }, { emoji: "", names: ["classical_building"], tags: [], description: "classical building", category: "Travel & Places" }, { emoji: "", names: ["building_construction"], tags: [], description: "building construction", category: "Travel & Places" }, { emoji: "", names: ["bricks"], tags: [], description: "brick", category: "Travel & Places" }, { emoji: "", names: ["rock"], tags: [], description: "rock", category: "Travel & Places" }, { emoji: "", names: ["wood"], tags: [], description: "wood", category: "Travel & Places" }, { emoji: "", names: ["hut"], tags: [], description: "hut", category: "Travel & Places" }, { emoji: "", names: ["houses"], tags: [], description: "houses", category: "Travel & Places" }, { emoji: "", names: ["derelict_house"], tags: [], description: "derelict house", category: "Travel & Places" }, { emoji: "", names: ["house"], tags: [], description: "house", category: "Travel & Places" }, { emoji: "", names: ["house_with_garden"], tags: [], description: "house with garden", category: "Travel & Places" }, { emoji: "", names: ["office"], tags: [], description: "office building", category: "Travel & Places" }, { emoji: "", names: ["post_office"], tags: [], description: "Japanese post office", category: "Travel & Places" }, { emoji: "", names: ["european_post_office"], tags: [], description: "post office", category: "Travel & Places" }, { emoji: "", names: ["hospital"], tags: [], description: "hospital", category: "Travel & Places" }, { emoji: "", names: ["bank"], tags: [], description: "bank", category: "Travel & Places" }, { emoji: "", names: ["hotel"], tags: [], description: "hotel", category: "Travel & Places" }, { emoji: "", names: ["love_hotel"], tags: [], description: "love hotel", category: "Travel & Places" }, { emoji: "", names: ["convenience_store"], tags: [], description: "convenience store", category: "Travel & Places" }, { emoji: "", names: ["school"], tags: [], description: "school", category: "Travel & Places" }, { emoji: "", names: ["department_store"], tags: [], description: "department store", category: "Travel & Places" }, { emoji: "", names: ["factory"], tags: [], description: "factory", category: "Travel & Places" }, { emoji: "", names: ["japanese_castle"], tags: [], description: "Japanese castle", category: "Travel & Places" }, { emoji: "", names: ["european_castle"], tags: [], description: "castle", category: "Travel & Places" }, { emoji: "", names: ["wedding"], tags: ["marriage"], description: "wedding", category: "Travel & Places" }, { emoji: "", names: ["tokyo_tower"], tags: [], description: "Tokyo tower", category: "Travel & Places" }, { emoji: "", names: ["statue_of_liberty"], tags: [], description: "Statue of Liberty", category: "Travel & Places" }, { emoji: "", names: ["church"], tags: [], description: "church", category: "Travel & Places" }, { emoji: "", names: ["mosque"], tags: [], description: "mosque", category: "Travel & Places" }, { emoji: "", names: ["hindu_temple"], tags: [], description: "hindu temple", category: "Travel & Places" }, { emoji: "", names: ["synagogue"], tags: [], description: "synagogue", category: "Travel & Places" }, { emoji: "", names: ["shinto_shrine"], tags: [], description: "shinto shrine", category: "Travel & Places" }, { emoji: "", names: ["kaaba"], tags: [], description: "kaaba", category: "Travel & Places" }, { emoji: "", names: ["fountain"], tags: [], description: "fountain", category: "Travel & Places" }, { emoji: "", names: ["tent"], tags: ["camping"], description: "tent", category: "Travel & Places" }, { emoji: "", names: ["foggy"], tags: ["karl"], description: "foggy", category: "Travel & Places" }, { emoji: "", names: ["night_with_stars"], tags: [], description: "night with stars", category: "Travel & Places" }, { emoji: "", names: ["cityscape"], tags: ["skyline"], description: "cityscape", category: "Travel & Places" }, { emoji: "", names: ["sunrise_over_mountains"], tags: [], description: "sunrise over mountains", category: "Travel & Places" }, { emoji: "", names: ["sunrise"], tags: [], description: "sunrise", category: "Travel & Places" }, { emoji: "", names: ["city_sunset"], tags: [], description: "cityscape at dusk", category: "Travel & Places" }, { emoji: "", names: ["city_sunrise"], tags: [], description: "sunset", category: "Travel & Places" }, { emoji: "", names: ["bridge_at_night"], tags: [], description: "bridge at night", category: "Travel & Places" }, { emoji: "", names: ["hotsprings"], tags: [], description: "hot springs", category: "Travel & Places" }, { emoji: "", names: ["carousel_horse"], tags: [], description: "carousel horse", category: "Travel & Places" }, { emoji: "", names: ["playground_slide"], tags: [], description: "playground slide", category: "Travel & Places" }, { emoji: "", names: ["ferris_wheel"], tags: [], description: "ferris wheel", category: "Travel & Places" }, { emoji: "", names: ["roller_coaster"], tags: [], description: "roller coaster", category: "Travel & Places" }, { emoji: "", names: ["barber"], tags: [], description: "barber pole", category: "Travel & Places" }, { emoji: "", names: ["circus_tent"], tags: [], description: "circus tent", category: "Travel & Places" }, { emoji: "", names: ["steam_locomotive"], tags: ["train"], description: "locomotive", category: "Travel & Places" }, { emoji: "", names: ["railway_car"], tags: [], description: "railway car", category: "Travel & Places" }, { emoji: "", names: ["bullettrain_side"], tags: ["train"], description: "high-speed train", category: "Travel & Places" }, { emoji: "", names: ["bullettrain_front"], tags: ["train"], description: "bullet train", category: "Travel & Places" }, { emoji: "", names: ["train2"], tags: [], description: "train", category: "Travel & Places" }, { emoji: "", names: ["metro"], tags: [], description: "metro", category: "Travel & Places" }, { emoji: "", names: ["light_rail"], tags: [], description: "light rail", category: "Travel & Places" }, { emoji: "", names: ["station"], tags: [], description: "station", category: "Travel & Places" }, { emoji: "", names: ["tram"], tags: [], description: "tram", category: "Travel & Places" }, { emoji: "", names: ["monorail"], tags: [], description: "monorail", category: "Travel & Places" }, { emoji: "", names: ["mountain_railway"], tags: [], description: "mountain railway", category: "Travel & Places" }, { emoji: "", names: ["train"], tags: [], description: "tram car", category: "Travel & Places" }, { emoji: "", names: ["bus"], tags: [], description: "bus", category: "Travel & Places" }, { emoji: "", names: ["oncoming_bus"], tags: [], description: "oncoming bus", category: "Travel & Places" }, { emoji: "", names: ["trolleybus"], tags: [], description: "trolleybus", category: "Travel & Places" }, { emoji: "", names: ["minibus"], tags: [], description: "minibus", category: "Travel & Places" }, { emoji: "", names: ["ambulance"], tags: [], description: "ambulance", category: "Travel & Places" }, { emoji: "", names: ["fire_engine"], tags: [], description: "fire engine", category: "Travel & Places" }, { emoji: "", names: ["police_car"], tags: [], description: "police car", category: "Travel & Places" }, { emoji: "", names: ["oncoming_police_car"], tags: [], description: "oncoming police car", category: "Travel & Places" }, { emoji: "", names: ["taxi"], tags: [], description: "taxi", category: "Travel & Places" }, { emoji: "", names: ["oncoming_taxi"], tags: [], description: "oncoming taxi", category: "Travel & Places" }, { emoji: "", names: ["car", "red_car"], tags: [], description: "automobile", category: "Travel & Places" }, { emoji: "", names: ["oncoming_automobile"], tags: [], description: "oncoming automobile", category: "Travel & Places" }, { emoji: "", names: ["blue_car"], tags: [], description: "sport utility vehicle", category: "Travel & Places" }, { emoji: "", names: ["pickup_truck"], tags: [], description: "pickup truck", category: "Travel & Places" }, { emoji: "", names: ["truck"], tags: [], description: "delivery truck", category: "Travel & Places" }, { emoji: "", names: ["articulated_lorry"], tags: [], description: "articulated lorry", category: "Travel & Places" }, { emoji: "", names: ["tractor"], tags: [], description: "tractor", category: "Travel & Places" }, { emoji: "", names: ["racing_car"], tags: [], description: "racing car", category: "Travel & Places" }, { emoji: "", names: ["motorcycle"], tags: [], description: "motorcycle", category: "Travel & Places" }, { emoji: "", names: ["motor_scooter"], tags: [], description: "motor scooter", category: "Travel & Places" }, { emoji: "", names: ["manual_wheelchair"], tags: [], description: "manual wheelchair", category: "Travel & Places" }, { emoji: "", names: ["motorized_wheelchair"], tags: [], description: "motorized wheelchair", category: "Travel & Places" }, { emoji: "", names: ["auto_rickshaw"], tags: [], description: "auto rickshaw", category: "Travel & Places" }, { emoji: "", names: ["bike"], tags: ["bicycle"], description: "bicycle", category: "Travel & Places" }, { emoji: "", names: ["kick_scooter"], tags: [], description: "kick scooter", category: "Travel & Places" }, { emoji: "", names: ["skateboard"], tags: [], description: "skateboard", category: "Travel & Places" }, { emoji: "", names: ["roller_skate"], tags: [], description: "roller skate", category: "Travel & Places" }, { emoji: "", names: ["busstop"], tags: [], description: "bus stop", category: "Travel & Places" }, { emoji: "", names: ["motorway"], tags: [], description: "motorway", category: "Travel & Places" }, { emoji: "", names: ["railway_track"], tags: [], description: "railway track", category: "Travel & Places" }, { emoji: "", names: ["oil_drum"], tags: [], description: "oil drum", category: "Travel & Places" }, { emoji: "", names: ["fuelpump"], tags: [], description: "fuel pump", category: "Travel & Places" }, { emoji: "", names: ["wheel"], tags: [], description: "wheel", category: "Travel & Places" }, { emoji: "", names: ["rotating_light"], tags: ["911", "emergency"], description: "police car light", category: "Travel & Places" }, { emoji: "", names: ["traffic_light"], tags: [], description: "horizontal traffic light", category: "Travel & Places" }, { emoji: "", names: ["vertical_traffic_light"], tags: ["semaphore"], description: "vertical traffic light", category: "Travel & Places" }, { emoji: "", names: ["stop_sign"], tags: [], description: "stop sign", category: "Travel & Places" }, { emoji: "", names: ["construction"], tags: ["wip"], description: "construction", category: "Travel & Places" }, { emoji: "", names: ["anchor"], tags: ["ship"], description: "anchor", category: "Travel & Places" }, { emoji: "", names: ["ring_buoy"], tags: ["life preserver"], description: "ring buoy", category: "Travel & Places" }, { emoji: "", names: ["boat", "sailboat"], tags: [], description: "sailboat", category: "Travel & Places" }, { emoji: "", names: ["canoe"], tags: [], description: "canoe", category: "Travel & Places" }, { emoji: "", names: ["speedboat"], tags: ["ship"], description: "speedboat", category: "Travel & Places" }, { emoji: "", names: ["passenger_ship"], tags: ["cruise"], description: "passenger ship", category: "Travel & Places" }, { emoji: "", names: ["ferry"], tags: [], description: "ferry", category: "Travel & Places" }, { emoji: "", names: ["motor_boat"], tags: [], description: "motor boat", category: "Travel & Places" }, { emoji: "", names: ["ship"], tags: [], description: "ship", category: "Travel & Places" }, { emoji: "", names: ["airplane"], tags: ["flight"], description: "airplane", category: "Travel & Places" }, { emoji: "", names: ["small_airplane"], tags: ["flight"], description: "small airplane", category: "Travel & Places" }, { emoji: "", names: ["flight_departure"], tags: [], description: "airplane departure", category: "Travel & Places" }, { emoji: "", names: ["flight_arrival"], tags: [], description: "airplane arrival", category: "Travel & Places" }, { emoji: "", names: ["parachute"], tags: [], description: "parachute", category: "Travel & Places" }, { emoji: "", names: ["seat"], tags: [], description: "seat", category: "Travel & Places" }, { emoji: "", names: ["helicopter"], tags: [], description: "helicopter", category: "Travel & Places" }, { emoji: "", names: ["suspension_railway"], tags: [], description: "suspension railway", category: "Travel & Places" }, { emoji: "", names: ["mountain_cableway"], tags: [], description: "mountain cableway", category: "Travel & Places" }, { emoji: "", names: ["aerial_tramway"], tags: [], description: "aerial tramway", category: "Travel & Places" }, { emoji: "", names: ["artificial_satellite"], tags: ["orbit", "space"], description: "satellite", category: "Travel & Places" }, { emoji: "", names: ["rocket"], tags: ["ship", "launch"], description: "rocket", category: "Travel & Places" }, { emoji: "", names: ["flying_saucer"], tags: ["ufo"], description: "flying saucer", category: "Travel & Places" }, { emoji: "", names: ["bellhop_bell"], tags: [], description: "bellhop bell", category: "Travel & Places" }, { emoji: "", names: ["luggage"], tags: [], description: "luggage", category: "Travel & Places" }, { emoji: "", names: ["hourglass"], tags: ["time"], description: "hourglass done", category: "Travel & Places" }, { emoji: "", names: ["hourglass_flowing_sand"], tags: ["time"], description: "hourglass not done", category: "Travel & Places" }, { emoji: "", names: ["watch"], tags: ["time"], description: "watch", category: "Travel & Places" }, { emoji: "", names: ["alarm_clock"], tags: ["morning"], description: "alarm clock", category: "Travel & Places" }, { emoji: "", names: ["stopwatch"], tags: [], description: "stopwatch", category: "Travel & Places" }, { emoji: "", names: ["timer_clock"], tags: [], description: "timer clock", category: "Travel & Places" }, { emoji: "", names: ["mantelpiece_clock"], tags: [], description: "mantelpiece clock", category: "Travel & Places" }, { emoji: "", names: ["clock12"], tags: [], description: "twelve oclock", category: "Travel & Places" }, { emoji: "", names: ["clock1230"], tags: [], description: "twelve-thirty", category: "Travel & Places" }, { emoji: "", names: ["clock1"], tags: [], description: "one oclock", category: "Travel & Places" }, { emoji: "", names: ["clock130"], tags: [], description: "one-thirty", category: "Travel & Places" }, { emoji: "", names: ["clock2"], tags: [], description: "two oclock", category: "Travel & Places" }, { emoji: "", names: ["clock230"], tags: [], description: "two-thirty", category: "Travel & Places" }, { emoji: "", names: ["clock3"], tags: [], description: "three oclock", category: "Travel & Places" }, { emoji: "", names: ["clock330"], tags: [], description: "three-thirty", category: "Travel & Places" }, { emoji: "", names: ["clock4"], tags: [], description: "four oclock", category: "Travel & Places" }, { emoji: "", names: ["clock430"], tags: [], description: "four-thirty", category: "Travel & Places" }, { emoji: "", names: ["clock5"], tags: [], description: "five oclock", category: "Travel & Places" }, { emoji: "", names: ["clock530"], tags: [], description: "five-thirty", category: "Travel & Places" }, { emoji: "", names: ["clock6"], tags: [], description: "six oclock", category: "Travel & Places" }, { emoji: "", names: ["clock630"], tags: [], description: "six-thirty", category: "Travel & Places" }, { emoji: "", names: ["clock7"], tags: [], description: "seven oclock", category: "Travel & Places" }, { emoji: "", names: ["clock730"], tags: [], description: "seven-thirty", category: "Travel & Places" }, { emoji: "", names: ["clock8"], tags: [], description: "eight oclock", category: "Travel & Places" }, { emoji: "", names: ["clock830"], tags: [], description: "eight-thirty", category: "Travel & Places" }, { emoji: "", names: ["clock9"], tags: [], description: "nine oclock", category: "Travel & Places" }, { emoji: "", names: ["clock930"], tags: [], description: "nine-thirty", category: "Travel & Places" }, { emoji: "", names: ["clock10"], tags: [], description: "ten oclock", category: "Travel & Places" }, { emoji: "", names: ["clock1030"], tags: [], description: "ten-thirty", category: "Travel & Places" }, { emoji: "", names: ["clock11"], tags: [], description: "eleven oclock", category: "Travel & Places" }, { emoji: "", names: ["clock1130"], tags: [], description: "eleven-thirty", category: "Travel & Places" }, { emoji: "", names: ["new_moon"], tags: [], description: "new moon", category: "Travel & Places" }, { emoji: "", names: ["waxing_crescent_moon"], tags: [], description: "waxing crescent moon", category: "Travel & Places" }, { emoji: "", names: ["first_quarter_moon"], tags: [], description: "first quarter moon", category: "Travel & Places" }, { emoji: "", names: ["moon", "waxing_gibbous_moon"], tags: [], description: "waxing gibbous moon", category: "Travel & Places" }, { emoji: "", names: ["full_moon"], tags: [], description: "full moon", category: "Travel & Places" }, { emoji: "", names: ["waning_gibbous_moon"], tags: [], description: "waning gibbous moon", category: "Travel & Places" }, { emoji: "", names: ["last_quarter_moon"], tags: [], description: "last quarter moon", category: "Travel & Places" }, { emoji: "", names: ["waning_crescent_moon"], tags: [], description: "waning crescent moon", category: "Travel & Places" }, { emoji: "", names: ["crescent_moon"], tags: ["night"], description: "crescent moon", category: "Travel & Places" }, { emoji: "", names: ["new_moon_with_face"], tags: [], description: "new moon face", category: "Travel & Places" }, { emoji: "", names: ["first_quarter_moon_with_face"], tags: [], description: "first quarter moon face", category: "Travel & Places" }, { emoji: "", names: ["last_quarter_moon_with_face"], tags: [], description: "last quarter moon face", category: "Travel & Places" }, { emoji: "", names: ["thermometer"], tags: [], description: "thermometer", category: "Travel & Places" }, { emoji: "", names: ["sunny"], tags: ["weather"], description: "sun", category: "Travel & Places" }, { emoji: "", names: ["full_moon_with_face"], tags: [], description: "full moon face", category: "Travel & Places" }, { emoji: "", names: ["sun_with_face"], tags: ["summer"], description: "sun with face", category: "Travel & Places" }, { emoji: "", names: ["ringed_planet"], tags: [], description: "ringed planet", category: "Travel & Places" }, { emoji: "", names: ["star"], tags: [], description: "star", category: "Travel & Places" }, { emoji: "", names: ["star2"], tags: [], description: "glowing star", category: "Travel & Places" }, { emoji: "", names: ["stars"], tags: [], description: "shooting star", category: "Travel & Places" }, { emoji: "", names: ["milky_way"], tags: [], description: "milky way", category: "Travel & Places" }, { emoji: "", names: ["cloud"], tags: [], description: "cloud", category: "Travel & Places" }, { emoji: "", names: ["partly_sunny"], tags: ["weather", "cloud"], description: "sun behind cloud", category: "Travel & Places" }, { emoji: "", names: ["cloud_with_lightning_and_rain"], tags: [], description: "cloud with lightning and rain", category: "Travel & Places" }, { emoji: "", names: ["sun_behind_small_cloud"], tags: [], description: "sun behind small cloud", category: "Travel & Places" }, { emoji: "", names: ["sun_behind_large_cloud"], tags: [], description: "sun behind large cloud", category: "Travel & Places" }, { emoji: "", names: ["sun_behind_rain_cloud"], tags: [], description: "sun behind rain cloud", category: "Travel & Places" }, { emoji: "", names: ["cloud_with_rain"], tags: [], description: "cloud with rain", category: "Travel & Places" }, { emoji: "", names: ["cloud_with_snow"], tags: [], description: "cloud with snow", category: "Travel & Places" }, { emoji: "", names: ["cloud_with_lightning"], tags: [], description: "cloud with lightning", category: "Travel & Places" }, { emoji: "", names: ["tornado"], tags: [], description: "tornado", category: "Travel & Places" }, { emoji: "", names: ["fog"], tags: [], description: "fog", category: "Travel & Places" }, { emoji: "", names: ["wind_face"], tags: [], description: "wind face", category: "Travel & Places" }, { emoji: "", names: ["cyclone"], tags: ["swirl"], description: "cyclone", category: "Travel & Places" }, { emoji: "", names: ["rainbow"], tags: [], description: "rainbow", category: "Travel & Places" }, { emoji: "", names: ["closed_umbrella"], tags: ["weather", "rain"], description: "closed umbrella", category: "Travel & Places" }, { emoji: "", names: ["open_umbrella"], tags: [], description: "umbrella", category: "Travel & Places" }, { emoji: "", names: ["umbrella"], tags: ["rain", "weather"], description: "umbrella with rain drops", category: "Travel & Places" }, { emoji: "", names: ["parasol_on_ground"], tags: ["beach_umbrella"], description: "umbrella on ground", category: "Travel & Places" }, { emoji: "", names: ["zap"], tags: ["lightning", "thunder"], description: "high voltage", category: "Travel & Places" }, { emoji: "", names: ["snowflake"], tags: ["winter", "cold", "weather"], description: "snowflake", category: "Travel & Places" }, { emoji: "", names: ["snowman_with_snow"], tags: ["winter", "christmas"], description: "snowman", category: "Travel & Places" }, { emoji: "", names: ["snowman"], tags: ["winter"], description: "snowman without snow", category: "Travel & Places" }, { emoji: "", names: ["comet"], tags: [], description: "comet", category: "Travel & Places" }, { emoji: "", names: ["fire"], tags: ["burn"], description: "fire", category: "Travel & Places" }, { emoji: "", names: ["droplet"], tags: ["water"], description: "droplet", category: "Travel & Places" }, { emoji: "", names: ["ocean"], tags: ["sea"], description: "water wave", category: "Travel & Places" }, { emoji: "", names: ["jack_o_lantern"], tags: ["halloween"], description: "jack-o-lantern", category: "Activities" }, { emoji: "", names: ["christmas_tree"], tags: [], description: "Christmas tree", category: "Activities" }, { emoji: "", names: ["fireworks"], tags: ["festival", "celebration"], description: "fireworks", category: "Activities" }, { emoji: "", names: ["sparkler"], tags: [], description: "sparkler", category: "Activities" }, { emoji: "", names: ["firecracker"], tags: [], description: "firecracker", category: "Activities" }, { emoji: "", names: ["sparkles"], tags: ["shiny"], description: "sparkles", category: "Activities" }, { emoji: "", names: ["balloon"], tags: ["party", "birthday"], description: "balloon", category: "Activities" }, { emoji: "", names: ["tada"], tags: ["hooray", "party"], description: "party popper", category: "Activities" }, { emoji: "", names: ["confetti_ball"], tags: [], description: "confetti ball", category: "Activities" }, { emoji: "", names: ["tanabata_tree"], tags: [], description: "tanabata tree", category: "Activities" }, { emoji: "", names: ["bamboo"], tags: [], description: "pine decoration", category: "Activities" }, { emoji: "", names: ["dolls"], tags: [], description: "Japanese dolls", category: "Activities" }, { emoji: "", names: ["flags"], tags: [], description: "carp streamer", category: "Activities" }, { emoji: "", names: ["wind_chime"], tags: [], description: "wind chime", category: "Activities" }, { emoji: "", names: ["rice_scene"], tags: [], description: "moon viewing ceremony", category: "Activities" }, { emoji: "", names: ["red_envelope"], tags: [], description: "red envelope", category: "Activities" }, { emoji: "", names: ["ribbon"], tags: [], description: "ribbon", category: "Activities" }, { emoji: "", names: ["gift"], tags: ["present", "birthday", "christmas"], description: "wrapped gift", category: "Activities" }, { emoji: "", names: ["reminder_ribbon"], tags: [], description: "reminder ribbon", category: "Activities" }, { emoji: "", names: ["tickets"], tags: [], description: "admission tickets", category: "Activities" }, { emoji: "", names: ["ticket"], tags: [], description: "ticket", category: "Activities" }, { emoji: "", names: ["medal_military"], tags: [], description: "military medal", category: "Activities" }, { emoji: "", names: ["trophy"], tags: ["award", "contest", "winner"], description: "trophy", category: "Activities" }, { emoji: "", names: ["medal_sports"], tags: ["gold", "winner"], description: "sports medal", category: "Activities" }, { emoji: "", names: ["1st_place_medal"], tags: ["gold"], description: "1st place medal", category: "Activities" }, { emoji: "", names: ["2nd_place_medal"], tags: ["silver"], description: "2nd place medal", category: "Activities" }, { emoji: "", names: ["3rd_place_medal"], tags: ["bronze"], description: "3rd place medal", category: "Activities" }, { emoji: "", names: ["soccer"], tags: ["sports"], description: "soccer ball", category: "Activities" }, { emoji: "", names: ["baseball"], tags: ["sports"], description: "baseball", category: "Activities" }, { emoji: "", names: ["softball"], tags: [], description: "softball", category: "Activities" }, { emoji: "", names: ["basketball"], tags: ["sports"], description: "basketball", category: "Activities" }, { emoji: "", names: ["volleyball"], tags: [], description: "volleyball", category: "Activities" }, { emoji: "", names: ["football"], tags: ["sports"], description: "american football", category: "Activities" }, { emoji: "", names: ["rugby_football"], tags: [], description: "rugby football", category: "Activities" }, { emoji: "", names: ["tennis"], tags: ["sports"], description: "tennis", category: "Activities" }, { emoji: "", names: ["flying_disc"], tags: [], description: "flying disc", category: "Activities" }, { emoji: "", names: ["bowling"], tags: [], description: "bowling", category: "Activities" }, { emoji: "", names: ["cricket_game"], tags: [], description: "cricket game", category: "Activities" }, { emoji: "", names: ["field_hockey"], tags: [], description: "field hockey", category: "Activities" }, { emoji: "", names: ["ice_hockey"], tags: [], description: "ice hockey", category: "Activities" }, { emoji: "", names: ["lacrosse"], tags: [], description: "lacrosse", category: "Activities" }, { emoji: "", names: ["ping_pong"], tags: [], description: "ping pong", category: "Activities" }, { emoji: "", names: ["badminton"], tags: [], description: "badminton", category: "Activities" }, { emoji: "", names: ["boxing_glove"], tags: [], description: "boxing glove", category: "Activities" }, { emoji: "", names: ["martial_arts_uniform"], tags: [], description: "martial arts uniform", category: "Activities" }, { emoji: "", names: ["goal_net"], tags: [], description: "goal net", category: "Activities" }, { emoji: "", names: ["golf"], tags: [], description: "flag in hole", category: "Activities" }, { emoji: "", names: ["ice_skate"], tags: ["skating"], description: "ice skate", category: "Activities" }, { emoji: "", names: ["fishing_pole_and_fish"], tags: [], description: "fishing pole", category: "Activities" }, { emoji: "", names: ["diving_mask"], tags: [], description: "diving mask", category: "Activities" }, { emoji: "", names: ["running_shirt_with_sash"], tags: ["marathon"], description: "running shirt", category: "Activities" }, { emoji: "", names: ["ski"], tags: [], description: "skis", category: "Activities" }, { emoji: "", names: ["sled"], tags: [], description: "sled", category: "Activities" }, { emoji: "", names: ["curling_stone"], tags: [], description: "curling stone", category: "Activities" }, { emoji: "", names: ["dart"], tags: ["target"], description: "bullseye", category: "Activities" }, { emoji: "", names: ["yo_yo"], tags: [], description: "yo-yo", category: "Activities" }, { emoji: "", names: ["kite"], tags: [], description: "kite", category: "Activities" }, { emoji: "", names: ["gun"], tags: ["shoot", "weapon"], description: "water pistol", category: "Activities" }, { emoji: "", names: ["8ball"], tags: ["pool", "billiards"], description: "pool 8 ball", category: "Activities" }, { emoji: "", names: ["crystal_ball"], tags: ["fortune"], description: "crystal ball", category: "Activities" }, { emoji: "", names: ["magic_wand"], tags: [], description: "magic wand", category: "Activities" }, { emoji: "", names: ["video_game"], tags: ["play", "controller", "console"], description: "video game", category: "Activities" }, { emoji: "", names: ["joystick"], tags: [], description: "joystick", category: "Activities" }, { emoji: "", names: ["slot_machine"], tags: [], description: "slot machine", category: "Activities" }, { emoji: "", names: ["game_die"], tags: ["dice", "gambling"], description: "game die", category: "Activities" }, { emoji: "", names: ["jigsaw"], tags: [], description: "puzzle piece", category: "Activities" }, { emoji: "", names: ["teddy_bear"], tags: [], description: "teddy bear", category: "Activities" }, { emoji: "", names: ["pinata"], tags: [], description: "piata", category: "Activities" }, { emoji: "", names: ["mirror_ball"], tags: ["disco", "party"], description: "mirror ball", category: "Activities" }, { emoji: "", names: ["nesting_dolls"], tags: [], description: "nesting dolls", category: "Activities" }, { emoji: "", names: ["spades"], tags: [], description: "spade suit", category: "Activities" }, { emoji: "", names: ["hearts"], tags: [], description: "heart suit", category: "Activities" }, { emoji: "", names: ["diamonds"], tags: [], description: "diamond suit", category: "Activities" }, { emoji: "", names: ["clubs"], tags: [], description: "club suit", category: "Activities" }, { emoji: "", names: ["chess_pawn"], tags: [], description: "chess pawn", category: "Activities" }, { emoji: "", names: ["black_joker"], tags: [], description: "joker", category: "Activities" }, { emoji: "", names: ["mahjong"], tags: [], description: "mahjong red dragon", category: "Activities" }, { emoji: "", names: ["flower_playing_cards"], tags: [], description: "flower playing cards", category: "Activities" }, { emoji: "", names: ["performing_arts"], tags: ["theater", "drama"], description: "performing arts", category: "Activities" }, { emoji: "", names: ["framed_picture"], tags: [], description: "framed picture", category: "Activities" }, { emoji: "", names: ["art"], tags: ["design", "paint"], description: "artist palette", category: "Activities" }, { emoji: "", names: ["thread"], tags: [], description: "thread", category: "Activities" }, { emoji: "", names: ["sewing_needle"], tags: [], description: "sewing needle", category: "Activities" }, { emoji: "", names: ["yarn"], tags: [], description: "yarn", category: "Activities" }, { emoji: "", names: ["knot"], tags: [], description: "knot", category: "Activities" }, { emoji: "", names: ["eyeglasses"], tags: ["glasses"], description: "glasses", category: "Objects" }, { emoji: "", names: ["dark_sunglasses"], tags: [], description: "sunglasses", category: "Objects" }, { emoji: "", names: ["goggles"], tags: [], description: "goggles", category: "Objects" }, { emoji: "", names: ["lab_coat"], tags: [], description: "lab coat", category: "Objects" }, { emoji: "", names: ["safety_vest"], tags: [], description: "safety vest", category: "Objects" }, { emoji: "", names: ["necktie"], tags: ["shirt", "formal"], description: "necktie", category: "Objects" }, { emoji: "", names: ["shirt", "tshirt"], tags: [], description: "t-shirt", category: "Objects" }, { emoji: "", names: ["jeans"], tags: ["pants"], description: "jeans", category: "Objects" }, { emoji: "", names: ["scarf"], tags: [], description: "scarf", category: "Objects" }, { emoji: "", names: ["gloves"], tags: [], description: "gloves", category: "Objects" }, { emoji: "", names: ["coat"], tags: [], description: "coat", category: "Objects" }, { emoji: "", names: ["socks"], tags: [], description: "socks", category: "Objects" }, { emoji: "", names: ["dress"], tags: [], description: "dress", category: "Objects" }, { emoji: "", names: ["kimono"], tags: [], description: "kimono", category: "Objects" }, { emoji: "", names: ["sari"], tags: [], description: "sari", category: "Objects" }, { emoji: "", names: ["one_piece_swimsuit"], tags: [], description: "one-piece swimsuit", category: "Objects" }, { emoji: "", names: ["swim_brief"], tags: [], description: "briefs", category: "Objects" }, { emoji: "", names: ["shorts"], tags: [], description: "shorts", category: "Objects" }, { emoji: "", names: ["bikini"], tags: ["beach"], description: "bikini", category: "Objects" }, { emoji: "", names: ["womans_clothes"], tags: [], description: "womans clothes", category: "Objects" }, { emoji: "", names: ["folding_hand_fan"], tags: ["sensu"], description: "folding hand fan", category: "Objects" }, { emoji: "", names: ["purse"], tags: [], description: "purse", category: "Objects" }, { emoji: "", names: ["handbag"], tags: ["bag"], description: "handbag", category: "Objects" }, { emoji: "", names: ["pouch"], tags: ["bag"], description: "clutch bag", category: "Objects" }, { emoji: "", names: ["shopping"], tags: ["bags"], description: "shopping bags", category: "Objects" }, { emoji: "", names: ["school_satchel"], tags: [], description: "backpack", category: "Objects" }, { emoji: "", names: ["thong_sandal"], tags: [], description: "thong sandal", category: "Objects" }, { emoji: "", names: ["mans_shoe", "shoe"], tags: [], description: "mans shoe", category: "Objects" }, { emoji: "", names: ["athletic_shoe"], tags: ["sneaker", "sport", "running"], description: "running shoe", category: "Objects" }, { emoji: "", names: ["hiking_boot"], tags: [], description: "hiking boot", category: "Objects" }, { emoji: "", names: ["flat_shoe"], tags: [], description: "flat shoe", category: "Objects" }, { emoji: "", names: ["high_heel"], tags: ["shoe"], description: "high-heeled shoe", category: "Objects" }, { emoji: "", names: ["sandal"], tags: ["shoe"], description: "womans sandal", category: "Objects" }, { emoji: "", names: ["ballet_shoes"], tags: [], description: "ballet shoes", category: "Objects" }, { emoji: "", names: ["boot"], tags: [], description: "womans boot", category: "Objects" }, { emoji: "", names: ["hair_pick"], tags: [], description: "hair pick", category: "Objects" }, { emoji: "", names: ["crown"], tags: ["king", "queen", "royal"], description: "crown", category: "Objects" }, { emoji: "", names: ["womans_hat"], tags: [], description: "womans hat", category: "Objects" }, { emoji: "", names: ["tophat"], tags: ["hat", "classy"], description: "top hat", category: "Objects" }, { emoji: "", names: ["mortar_board"], tags: ["education", "college", "university", "graduation"], description: "graduation cap", category: "Objects" }, { emoji: "", names: ["billed_cap"], tags: [], description: "billed cap", category: "Objects" }, { emoji: "", names: ["military_helmet"], tags: [], description: "military helmet", category: "Objects" }, { emoji: "", names: ["rescue_worker_helmet"], tags: [], description: "rescue workers helmet", category: "Objects" }, { emoji: "", names: ["prayer_beads"], tags: [], description: "prayer beads", category: "Objects" }, { emoji: "", names: ["lipstick"], tags: ["makeup"], description: "lipstick", category: "Objects" }, { emoji: "", names: ["ring"], tags: ["wedding", "marriage", "engaged"], description: "ring", category: "Objects" }, { emoji: "", names: ["gem"], tags: ["diamond"], description: "gem stone", category: "Objects" }, { emoji: "", names: ["mute"], tags: ["sound", "volume"], description: "muted speaker", category: "Objects" }, { emoji: "", names: ["speaker"], tags: [], description: "speaker low volume", category: "Objects" }, { emoji: "", names: ["sound"], tags: ["volume"], description: "speaker medium volume", category: "Objects" }, { emoji: "", names: ["loud_sound"], tags: ["volume"], description: "speaker high volume", category: "Objects" }, { emoji: "", names: ["loudspeaker"], tags: ["announcement"], description: "loudspeaker", category: "Objects" }, { emoji: "", names: ["mega"], tags: [], description: "megaphone", category: "Objects" }, { emoji: "", names: ["postal_horn"], tags: [], description: "postal horn", category: "Objects" }, { emoji: "", names: ["bell"], tags: ["sound", "notification"], description: "bell", category: "Objects" }, { emoji: "", names: ["no_bell"], tags: ["volume", "off"], description: "bell with slash", category: "Objects" }, { emoji: "", names: ["musical_score"], tags: [], description: "musical score", category: "Objects" }, { emoji: "", names: ["musical_note"], tags: [], description: "musical note", category: "Objects" }, { emoji: "", names: ["notes"], tags: ["music"], description: "musical notes", category: "Objects" }, { emoji: "", names: ["studio_microphone"], tags: ["podcast"], description: "studio microphone", category: "Objects" }, { emoji: "", names: ["level_slider"], tags: [], description: "level slider", category: "Objects" }, { emoji: "", names: ["control_knobs"], tags: [], description: "control knobs", category: "Objects" }, { emoji: "", names: ["microphone"], tags: ["sing"], description: "microphone", category: "Objects" }, { emoji: "", names: ["headphones"], tags: ["music", "earphones"], description: "headphone", category: "Objects" }, { emoji: "", names: ["radio"], tags: ["podcast"], description: "radio", category: "Objects" }, { emoji: "", names: ["saxophone"], tags: [], description: "saxophone", category: "Objects" }, { emoji: "", names: ["accordion"], tags: [], description: "accordion", category: "Objects" }, { emoji: "", names: ["guitar"], tags: ["rock"], description: "guitar", category: "Objects" }, { emoji: "", names: ["musical_keyboard"], tags: ["piano"], description: "musical keyboard", category: "Objects" }, { emoji: "", names: ["trumpet"], tags: [], description: "trumpet", category: "Objects" }, { emoji: "", names: ["violin"], tags: [], description: "violin", category: "Objects" }, { emoji: "", names: ["banjo"], tags: [], description: "banjo", category: "Objects" }, { emoji: "", names: ["drum"], tags: [], description: "drum", category: "Objects" }, { emoji: "", names: ["long_drum"], tags: [], description: "long drum", category: "Objects" }, { emoji: "", names: ["maracas"], tags: ["shaker"], description: "maracas", category: "Objects" }, { emoji: "", names: ["flute"], tags: ["recorder"], description: "flute", category: "Objects" }, { emoji: "", names: ["iphone"], tags: ["smartphone", "mobile"], description: "mobile phone", category: "Objects" }, { emoji: "", names: ["calling"], tags: ["call", "incoming"], description: "mobile phone with arrow", category: "Objects" }, { emoji: "", names: ["phone", "telephone"], tags: [], description: "telephone", category: "Objects" }, { emoji: "", names: ["telephone_receiver"], tags: ["phone", "call"], description: "telephone receiver", category: "Objects" }, { emoji: "", names: ["pager"], tags: [], description: "pager", category: "Objects" }, { emoji: "", names: ["fax"], tags: [], description: "fax machine", category: "Objects" }, { emoji: "", names: ["battery"], tags: ["power"], description: "battery", category: "Objects" }, { emoji: "", names: ["low_battery"], tags: [], description: "low battery", category: "Objects" }, { emoji: "", names: ["electric_plug"], tags: [], description: "electric plug", category: "Objects" }, { emoji: "", names: ["computer"], tags: ["desktop", "screen"], description: "laptop", category: "Objects" }, { emoji: "", names: ["desktop_computer"], tags: [], description: "desktop computer", category: "Objects" }, { emoji: "", names: ["printer"], tags: [], description: "printer", category: "Objects" }, { emoji: "", names: ["keyboard"], tags: [], description: "keyboard", category: "Objects" }, { emoji: "", names: ["computer_mouse"], tags: [], description: "computer mouse", category: "Objects" }, { emoji: "", names: ["trackball"], tags: [], description: "trackball", category: "Objects" }, { emoji: "", names: ["minidisc"], tags: [], description: "computer disk", category: "Objects" }, { emoji: "", names: ["floppy_disk"], tags: ["save"], description: "floppy disk", category: "Objects" }, { emoji: "", names: ["cd"], tags: [], description: "optical disk", category: "Objects" }, { emoji: "", names: ["dvd"], tags: [], description: "dvd", category: "Objects" }, { emoji: "", names: ["abacus"], tags: [], description: "abacus", category: "Objects" }, { emoji: "", names: ["movie_camera"], tags: ["film", "video"], description: "movie camera", category: "Objects" }, { emoji: "", names: ["film_strip"], tags: [], description: "film frames", category: "Objects" }, { emoji: "", names: ["film_projector"], tags: [], description: "film projector", category: "Objects" }, { emoji: "", names: ["clapper"], tags: ["film"], description: "clapper board", category: "Objects" }, { emoji: "", names: ["tv"], tags: [], description: "television", category: "Objects" }, { emoji: "", names: ["camera"], tags: ["photo"], description: "camera", category: "Objects" }, { emoji: "", names: ["camera_flash"], tags: ["photo"], description: "camera with flash", category: "Objects" }, { emoji: "", names: ["video_camera"], tags: [], description: "video camera", category: "Objects" }, { emoji: "", names: ["vhs"], tags: [], description: "videocassette", category: "Objects" }, { emoji: "", names: ["mag"], tags: ["search", "zoom"], description: "magnifying glass tilted left", category: "Objects" }, { emoji: "", names: ["mag_right"], tags: [], description: "magnifying glass tilted right", category: "Objects" }, { emoji: "", names: ["candle"], tags: [], description: "candle", category: "Objects" }, { emoji: "", names: ["bulb"], tags: ["idea", "light"], description: "light bulb", category: "Objects" }, { emoji: "", names: ["flashlight"], tags: [], description: "flashlight", category: "Objects" }, { emoji: "", names: ["izakaya_lantern", "lantern"], tags: [], description: "red paper lantern", category: "Objects" }, { emoji: "", names: ["diya_lamp"], tags: [], description: "diya lamp", category: "Objects" }, { emoji: "", names: ["notebook_with_decorative_cover"], tags: [], description: "notebook with decorative cover", category: "Objects" }, { emoji: "", names: ["closed_book"], tags: [], description: "closed book", category: "Objects" }, { emoji: "", names: ["book", "open_book"], tags: [], description: "open book", category: "Objects" }, { emoji: "", names: ["green_book"], tags: [], description: "green book", category: "Objects" }, { emoji: "", names: ["blue_book"], tags: [], description: "blue book", category: "Objects" }, { emoji: "", names: ["orange_book"], tags: [], description: "orange book", category: "Objects" }, { emoji: "", names: ["books"], tags: ["library"], description: "books", category: "Objects" }, { emoji: "", names: ["notebook"], tags: [], description: "notebook", category: "Objects" }, { emoji: "", names: ["ledger"], tags: [], description: "ledger", category: "Objects" }, { emoji: "", names: ["page_with_curl"], tags: [], description: "page with curl", category: "Objects" }, { emoji: "", names: ["scroll"], tags: ["document"], description: "scroll", category: "Objects" }, { emoji: "", names: ["page_facing_up"], tags: ["document"], description: "page facing up", category: "Objects" }, { emoji: "", names: ["newspaper"], tags: ["press"], description: "newspaper", category: "Objects" }, { emoji: "", names: ["newspaper_roll"], tags: ["press"], description: "rolled-up newspaper", category: "Objects" }, { emoji: "", names: ["bookmark_tabs"], tags: [], description: "bookmark tabs", category: "Objects" }, { emoji: "", names: ["bookmark"], tags: [], description: "bookmark", category: "Objects" }, { emoji: "", names: ["label"], tags: ["tag"], description: "label", category: "Objects" }, { emoji: "", names: ["moneybag"], tags: ["dollar", "cream"], description: "money bag", category: "Objects" }, { emoji: "", names: ["coin"], tags: [], description: "coin", category: "Objects" }, { emoji: "", names: ["yen"], tags: [], description: "yen banknote", category: "Objects" }, { emoji: "", names: ["dollar"], tags: ["money"], description: "dollar banknote", category: "Objects" }, { emoji: "", names: ["euro"], tags: [], description: "euro banknote", category: "Objects" }, { emoji: "", names: ["pound"], tags: [], description: "pound banknote", category: "Objects" }, { emoji: "", names: ["money_with_wings"], tags: ["dollar"], description: "money with wings", category: "Objects" }, { emoji: "", names: ["credit_card"], tags: ["subscription"], description: "credit card", category: "Objects" }, { emoji: "", names: ["receipt"], tags: [], description: "receipt", category: "Objects" }, { emoji: "", names: ["chart"], tags: [], description: "chart increasing with yen", category: "Objects" }, { emoji: "", names: ["envelope"], tags: ["letter", "email"], description: "envelope", category: "Objects" }, { emoji: "", names: ["email", "e-mail"], tags: [], description: "e-mail", category: "Objects" }, { emoji: "", names: ["incoming_envelope"], tags: [], description: "incoming envelope", category: "Objects" }, { emoji: "", names: ["envelope_with_arrow"], tags: [], description: "envelope with arrow", category: "Objects" }, { emoji: "", names: ["outbox_tray"], tags: [], description: "outbox tray", category: "Objects" }, { emoji: "", names: ["inbox_tray"], tags: [], description: "inbox tray", category: "Objects" }, { emoji: "", names: ["package"], tags: ["shipping"], description: "package", category: "Objects" }, { emoji: "", names: ["mailbox"], tags: [], description: "closed mailbox with raised flag", category: "Objects" }, { emoji: "", names: ["mailbox_closed"], tags: [], description: "closed mailbox with lowered flag", category: "Objects" }, { emoji: "", names: ["mailbox_with_mail"], tags: [], description: "open mailbox with raised flag", category: "Objects" }, { emoji: "", names: ["mailbox_with_no_mail"], tags: [], description: "open mailbox with lowered flag", category: "Objects" }, { emoji: "", names: ["postbox"], tags: [], description: "postbox", category: "Objects" }, { emoji: "", names: ["ballot_box"], tags: [], description: "ballot box with ballot", category: "Objects" }, { emoji: "", names: ["pencil2"], tags: [], description: "pencil", category: "Objects" }, { emoji: "", names: ["black_nib"], tags: [], description: "black nib", category: "Objects" }, { emoji: "", names: ["fountain_pen"], tags: [], description: "fountain pen", category: "Objects" }, { emoji: "", names: ["pen"], tags: [], description: "pen", category: "Objects" }, { emoji: "", names: ["paintbrush"], tags: [], description: "paintbrush", category: "Objects" }, { emoji: "", names: ["crayon"], tags: [], description: "crayon", category: "Objects" }, { emoji: "", names: ["memo", "pencil"], tags: ["document", "note"], description: "memo", category: "Objects" }, { emoji: "", names: ["briefcase"], tags: ["business"], description: "briefcase", category: "Objects" }, { emoji: "", names: ["file_folder"], tags: ["directory"], description: "file folder", category: "Objects" }, { emoji: "", names: ["open_file_folder"], tags: [], description: "open file folder", category: "Objects" }, { emoji: "", names: ["card_index_dividers"], tags: [], description: "card index dividers", category: "Objects" }, { emoji: "", names: ["date"], tags: ["calendar", "schedule"], description: "calendar", category: "Objects" }, { emoji: "", names: ["calendar"], tags: ["schedule"], description: "tear-off calendar", category: "Objects" }, { emoji: "", names: ["spiral_notepad"], tags: [], description: "spiral notepad", category: "Objects" }, { emoji: "", names: ["spiral_calendar"], tags: [], description: "spiral calendar", category: "Objects" }, { emoji: "", names: ["card_index"], tags: [], description: "card index", category: "Objects" }, { emoji: "", names: ["chart_with_upwards_trend"], tags: ["graph", "metrics"], description: "chart increasing", category: "Objects" }, { emoji: "", names: ["chart_with_downwards_trend"], tags: ["graph", "metrics"], description: "chart decreasing", category: "Objects" }, { emoji: "", names: ["bar_chart"], tags: ["stats", "metrics"], description: "bar chart", category: "Objects" }, { emoji: "", names: ["clipboard"], tags: [], description: "clipboard", category: "Objects" }, { emoji: "", names: ["pushpin"], tags: ["location"], description: "pushpin", category: "Objects" }, { emoji: "", names: ["round_pushpin"], tags: ["location"], description: "round pushpin", category: "Objects" }, { emoji: "", names: ["paperclip"], tags: [], description: "paperclip", category: "Objects" }, { emoji: "", names: ["paperclips"], tags: [], description: "linked paperclips", category: "Objects" }, { emoji: "", names: ["straight_ruler"], tags: [], description: "straight ruler", category: "Objects" }, { emoji: "", names: ["triangular_ruler"], tags: [], description: "triangular ruler", category: "Objects" }, { emoji: "", names: ["scissors"], tags: ["cut"], description: "scissors", category: "Objects" }, { emoji: "", names: ["card_file_box"], tags: [], description: "card file box", category: "Objects" }, { emoji: "", names: ["file_cabinet"], tags: [], description: "file cabinet", category: "Objects" }, { emoji: "", names: ["wastebasket"], tags: ["trash"], description: "wastebasket", category: "Objects" }, { emoji: "", names: ["lock"], tags: ["security", "private"], description: "locked", category: "Objects" }, { emoji: "", names: ["unlock"], tags: ["security"], description: "unlocked", category: "Objects" }, { emoji: "", names: ["lock_with_ink_pen"], tags: [], description: "locked with pen", category: "Objects" }, { emoji: "", names: ["closed_lock_with_key"], tags: ["security"], description: "locked with key", category: "Objects" }, { emoji: "", names: ["key"], tags: ["lock", "password"], description: "key", category: "Objects" }, { emoji: "", names: ["old_key"], tags: [], description: "old key", category: "Objects" }, { emoji: "", names: ["hammer"], tags: ["tool"], description: "hammer", category: "Objects" }, { emoji: "", names: ["axe"], tags: [], description: "axe", category: "Objects" }, { emoji: "", names: ["pick"], tags: [], description: "pick", category: "Objects" }, { emoji: "", names: ["hammer_and_pick"], tags: [], description: "hammer and pick", category: "Objects" }, { emoji: "", names: ["hammer_and_wrench"], tags: [], description: "hammer and wrench", category: "Objects" }, { emoji: "", names: ["dagger"], tags: [], description: "dagger", category: "Objects" }, { emoji: "", names: ["crossed_swords"], tags: [], description: "crossed swords", category: "Objects" }, { emoji: "", names: ["bomb"], tags: ["boom"], description: "bomb", category: "Objects" }, { emoji: "", names: ["boomerang"], tags: [], description: "boomerang", category: "Objects" }, { emoji: "", names: ["bow_and_arrow"], tags: ["archery"], description: "bow and arrow", category: "Objects" }, { emoji: "", names: ["shield"], tags: [], description: "shield", category: "Objects" }, { emoji: "", names: ["carpentry_saw"], tags: [], description: "carpentry saw", category: "Objects" }, { emoji: "", names: ["wrench"], tags: ["tool"], description: "wrench", category: "Objects" }, { emoji: "", names: ["screwdriver"], tags: [], description: "screwdriver", category: "Objects" }, { emoji: "", names: ["nut_and_bolt"], tags: [], description: "nut and bolt", category: "Objects" }, { emoji: "", names: ["gear"], tags: [], description: "gear", category: "Objects" }, { emoji: "", names: ["clamp"], tags: [], description: "clamp", category: "Objects" }, { emoji: "", names: ["balance_scale"], tags: [], description: "balance scale", category: "Objects" }, { emoji: "", names: ["probing_cane"], tags: [], description: "white cane", category: "Objects" }, { emoji: "", names: ["link"], tags: [], description: "link", category: "Objects" }, { emoji: "", names: ["chains"], tags: [], description: "chains", category: "Objects" }, { emoji: "", names: ["hook"], tags: [], description: "hook", category: "Objects" }, { emoji: "", names: ["toolbox"], tags: [], description: "toolbox", category: "Objects" }, { emoji: "", names: ["magnet"], tags: [], description: "magnet", category: "Objects" }, { emoji: "", names: ["ladder"], tags: [], description: "ladder", category: "Objects" }, { emoji: "", names: ["alembic"], tags: [], description: "alembic", category: "Objects" }, { emoji: "", names: ["test_tube"], tags: [], description: "test tube", category: "Objects" }, { emoji: "", names: ["petri_dish"], tags: [], description: "petri dish", category: "Objects" }, { emoji: "", names: ["dna"], tags: [], description: "dna", category: "Objects" }, { emoji: "", names: ["microscope"], tags: ["science", "laboratory", "investigate"], description: "microscope", category: "Objects" }, { emoji: "", names: ["telescope"], tags: [], description: "telescope", category: "Objects" }, { emoji: "", names: ["satellite"], tags: ["signal"], description: "satellite antenna", category: "Objects" }, { emoji: "", names: ["syringe"], tags: ["health", "hospital", "needle"], description: "syringe", category: "Objects" }, { emoji: "", names: ["drop_of_blood"], tags: [], description: "drop of blood", category: "Objects" }, { emoji: "", names: ["pill"], tags: ["health", "medicine"], description: "pill", category: "Objects" }, { emoji: "", names: ["adhesive_bandage"], tags: [], description: "adhesive bandage", category: "Objects" }, { emoji: "", names: ["crutch"], tags: [], description: "crutch", category: "Objects" }, { emoji: "", names: ["stethoscope"], tags: [], description: "stethoscope", category: "Objects" }, { emoji: "", names: ["x_ray"], tags: [], description: "x-ray", category: "Objects" }, { emoji: "", names: ["door"], tags: [], description: "door", category: "Objects" }, { emoji: "", names: ["elevator"], tags: [], description: "elevator", category: "Objects" }, { emoji: "", names: ["mirror"], tags: [], description: "mirror", category: "Objects" }, { emoji: "", names: ["window"], tags: [], description: "window", category: "Objects" }, { emoji: "", names: ["bed"], tags: [], description: "bed", category: "Objects" }, { emoji: "", names: ["couch_and_lamp"], tags: [], description: "couch and lamp", category: "Objects" }, { emoji: "", names: ["chair"], tags: [], description: "chair", category: "Objects" }, { emoji: "", names: ["toilet"], tags: ["wc"], description: "toilet", category: "Objects" }, { emoji: "", names: ["plunger"], tags: [], description: "plunger", category: "Objects" }, { emoji: "", names: ["shower"], tags: ["bath"], description: "shower", category: "Objects" }, { emoji: "", names: ["bathtub"], tags: [], description: "bathtub", category: "Objects" }, { emoji: "", names: ["mouse_trap"], tags: [], description: "mouse trap", category: "Objects" }, { emoji: "", names: ["razor"], tags: [], description: "razor", category: "Objects" }, { emoji: "", names: ["lotion_bottle"], tags: [], description: "lotion bottle", category: "Objects" }, { emoji: "", names: ["safety_pin"], tags: [], description: "safety pin", category: "Objects" }, { emoji: "", names: ["broom"], tags: [], description: "broom", category: "Objects" }, { emoji: "", names: ["basket"], tags: [], description: "basket", category: "Objects" }, { emoji: "", names: ["roll_of_paper"], tags: ["toilet"], description: "roll of paper", category: "Objects" }, { emoji: "", names: ["bucket"], tags: [], description: "bucket", category: "Objects" }, { emoji: "", names: ["soap"], tags: [], description: "soap", category: "Objects" }, { emoji: "", names: ["bubbles"], tags: [], description: "bubbles", category: "Objects" }, { emoji: "", names: ["toothbrush"], tags: [], description: "toothbrush", category: "Objects" }, { emoji: "", names: ["sponge"], tags: [], description: "sponge", category: "Objects" }, { emoji: "", names: ["fire_extinguisher"], tags: [], description: "fire extinguisher", category: "Objects" }, { emoji: "", names: ["shopping_cart"], tags: [], description: "shopping cart", category: "Objects" }, { emoji: "", names: ["smoking"], tags: ["cigarette"], description: "cigarette", category: "Objects" }, { emoji: "", names: ["coffin"], tags: ["funeral"], description: "coffin", category: "Objects" }, { emoji: "", names: ["headstone"], tags: [], description: "headstone", category: "Objects" }, { emoji: "", names: ["funeral_urn"], tags: [], description: "funeral urn", category: "Objects" }, { emoji: "", names: ["nazar_amulet"], tags: [], description: "nazar amulet", category: "Objects" }, { emoji: "", names: ["hamsa"], tags: [], description: "hamsa", category: "Objects" }, { emoji: "", names: ["moyai"], tags: ["stone"], description: "moai", category: "Objects" }, { emoji: "", names: ["placard"], tags: [], description: "placard", category: "Objects" }, { emoji: "", names: ["identification_card"], tags: [], description: "identification card", category: "Objects" }, { emoji: "", names: ["atm"], tags: [], description: "ATM sign", category: "Symbols" }, { emoji: "", names: ["put_litter_in_its_place"], tags: [], description: "litter in bin sign", category: "Symbols" }, { emoji: "", names: ["potable_water"], tags: [], description: "potable water", category: "Symbols" }, { emoji: "", names: ["wheelchair"], tags: ["accessibility"], description: "wheelchair symbol", category: "Symbols" }, { emoji: "", names: ["mens"], tags: [], description: "mens room", category: "Symbols" }, { emoji: "", names: ["womens"], tags: [], description: "womens room", category: "Symbols" }, { emoji: "", names: ["restroom"], tags: ["toilet"], description: "restroom", category: "Symbols" }, { emoji: "", names: ["baby_symbol"], tags: [], description: "baby symbol", category: "Symbols" }, { emoji: "", names: ["wc"], tags: ["toilet", "restroom"], description: "water closet", category: "Symbols" }, { emoji: "", names: ["passport_control"], tags: [], description: "passport control", category: "Symbols" }, { emoji: "", names: ["customs"], tags: [], description: "customs", category: "Symbols" }, { emoji: "", names: ["baggage_claim"], tags: ["airport"], description: "baggage claim", category: "Symbols" }, { emoji: "", names: ["left_luggage"], tags: [], description: "left luggage", category: "Symbols" }, { emoji: "", names: ["warning"], tags: ["wip"], description: "warning", category: "Symbols" }, { emoji: "", names: ["children_crossing"], tags: [], description: "children crossing", category: "Symbols" }, { emoji: "", names: ["no_entry"], tags: ["limit"], description: "no entry", category: "Symbols" }, { emoji: "", names: ["no_entry_sign"], tags: ["block", "forbidden"], description: "prohibited", category: "Symbols" }, { emoji: "", names: ["no_bicycles"], tags: [], description: "no bicycles", category: "Symbols" }, { emoji: "", names: ["no_smoking"], tags: [], description: "no smoking", category: "Symbols" }, { emoji: "", names: ["do_not_litter"], tags: [], description: "no littering", category: "Symbols" }, { emoji: "", names: ["non-potable_water"], tags: [], description: "non-potable water", category: "Symbols" }, { emoji: "", names: ["no_pedestrians"], tags: [], description: "no pedestrians", category: "Symbols" }, { emoji: "", names: ["no_mobile_phones"], tags: [], description: "no mobile phones", category: "Symbols" }, { emoji: "", names: ["underage"], tags: [], description: "no one under eighteen", category: "Symbols" }, { emoji: "", names: ["radioactive"], tags: [], description: "radioactive", category: "Symbols" }, { emoji: "", names: ["biohazard"], tags: [], description: "biohazard", category: "Symbols" }, { emoji: "", names: ["arrow_up"], tags: [], description: "up arrow", category: "Symbols" }, { emoji: "", names: ["arrow_upper_right"], tags: [], description: "up-right arrow", category: "Symbols" }, { emoji: "", names: ["arrow_right"], tags: [], description: "right arrow", category: "Symbols" }, { emoji: "", names: ["arrow_lower_right"], tags: [], description: "down-right arrow", category: "Symbols" }, { emoji: "", names: ["arrow_down"], tags: [], description: "down arrow", category: "Symbols" }, { emoji: "", names: ["arrow_lower_left"], tags: [], description: "down-left arrow", category: "Symbols" }, { emoji: "", names: ["arrow_left"], tags: [], description: "left arrow", category: "Symbols" }, { emoji: "", names: ["arrow_upper_left"], tags: [], description: "up-left arrow", category: "Symbols" }, { emoji: "", names: ["arrow_up_down"], tags: [], description: "up-down arrow", category: "Symbols" }, { emoji: "", names: ["left_right_arrow"], tags: [], description: "left-right arrow", category: "Symbols" }, { emoji: "", names: ["leftwards_arrow_with_hook"], tags: ["return"], description: "right arrow curving left", category: "Symbols" }, { emoji: "", names: ["arrow_right_hook"], tags: [], description: "left arrow curving right", category: "Symbols" }, { emoji: "", names: ["arrow_heading_up"], tags: [], description: "right arrow curving up", category: "Symbols" }, { emoji: "", names: ["arrow_heading_down"], tags: [], description: "right arrow curving down", category: "Symbols" }, { emoji: "", names: ["arrows_clockwise"], tags: [], description: "clockwise vertical arrows", category: "Symbols" }, { emoji: "", names: ["arrows_counterclockwise"], tags: ["sync"], description: "counterclockwise arrows button", category: "Symbols" }, { emoji: "", names: ["back"], tags: [], description: "BACK arrow", category: "Symbols" }, { emoji: "", names: ["end"], tags: [], description: "END arrow", category: "Symbols" }, { emoji: "", names: ["on"], tags: [], description: "ON! arrow", category: "Symbols" }, { emoji: "", names: ["soon"], tags: [], description: "SOON arrow", category: "Symbols" }, { emoji: "", names: ["top"], tags: [], description: "TOP arrow", category: "Symbols" }, { emoji: "", names: ["place_of_worship"], tags: [], description: "place of worship", category: "Symbols" }, { emoji: "", names: ["atom_symbol"], tags: [], description: "atom symbol", category: "Symbols" }, { emoji: "", names: ["om"], tags: [], description: "om", category: "Symbols" }, { emoji: "", names: ["star_of_david"], tags: [], description: "star of David", category: "Symbols" }, { emoji: "", names: ["wheel_of_dharma"], tags: [], description: "wheel of dharma", category: "Symbols" }, { emoji: "", names: ["yin_yang"], tags: [], description: "yin yang", category: "Symbols" }, { emoji: "", names: ["latin_cross"], tags: [], description: "latin cross", category: "Symbols" }, { emoji: "", names: ["orthodox_cross"], tags: [], description: "orthodox cross", category: "Symbols" }, { emoji: "", names: ["star_and_crescent"], tags: [], description: "star and crescent", category: "Symbols" }, { emoji: "", names: ["peace_symbol"], tags: [], description: "peace symbol", category: "Symbols" }, { emoji: "", names: ["menorah"], tags: [], description: "menorah", category: "Symbols" }, { emoji: "", names: ["six_pointed_star"], tags: [], description: "dotted six-pointed star", category: "Symbols" }, { emoji: "", names: ["khanda"], tags: [], description: "khanda", category: "Symbols" }, { emoji: "", names: ["aries"], tags: [], description: "Aries", category: "Symbols" }, { emoji: "", names: ["taurus"], tags: [], description: "Taurus", category: "Symbols" }, { emoji: "", names: ["gemini"], tags: [], description: "Gemini", category: "Symbols" }, { emoji: "", names: ["cancer"], tags: [], description: "Cancer", category: "Symbols" }, { emoji: "", names: ["leo"], tags: [], description: "Leo", category: "Symbols" }, { emoji: "", names: ["virgo"], tags: [], description: "Virgo", category: "Symbols" }, { emoji: "", names: ["libra"], tags: [], description: "Libra", category: "Symbols" }, { emoji: "", names: ["scorpius"], tags: [], description: "Scorpio", category: "Symbols" }, { emoji: "", names: ["sagittarius"], tags: [], description: "Sagittarius", category: "Symbols" }, { emoji: "", names: ["capricorn"], tags: [], description: "Capricorn", category: "Symbols" }, { emoji: "", names: ["aquarius"], tags: [], description: "Aquarius", category: "Symbols" }, { emoji: "", names: ["pisces"], tags: [], description: "Pisces", category: "Symbols" }, { emoji: "", names: ["ophiuchus"], tags: [], description: "Ophiuchus", category: "Symbols" }, { emoji: "", names: ["twisted_rightwards_arrows"], tags: ["shuffle"], description: "shuffle tracks button", category: "Symbols" }, { emoji: "", names: ["repeat"], tags: ["loop"], description: "repeat button", category: "Symbols" }, { emoji: "", names: ["repeat_one"], tags: [], description: "repeat single button", category: "Symbols" }, { emoji: "", names: ["arrow_forward"], tags: [], description: "play button", category: "Symbols" }, { emoji: "", names: ["fast_forward"], tags: [], description: "fast-forward button", category: "Symbols" }, { emoji: "", names: ["next_track_button"], tags: [], description: "next track button", category: "Symbols" }, { emoji: "", names: ["play_or_pause_button"], tags: [], description: "play or pause button", category: "Symbols" }, { emoji: "", names: ["arrow_backward"], tags: [], description: "reverse button", category: "Symbols" }, { emoji: "", names: ["rewind"], tags: [], description: "fast reverse button", category: "Symbols" }, { emoji: "", names: ["previous_track_button"], tags: [], description: "last track button", category: "Symbols" }, { emoji: "", names: ["arrow_up_small"], tags: [], description: "upwards button", category: "Symbols" }, { emoji: "", names: ["arrow_double_up"], tags: [], description: "fast up button", category: "Symbols" }, { emoji: "", names: ["arrow_down_small"], tags: [], description: "downwards button", category: "Symbols" }, { emoji: "", names: ["arrow_double_down"], tags: [], description: "fast down button", category: "Symbols" }, { emoji: "", names: ["pause_button"], tags: [], description: "pause button", category: "Symbols" }, { emoji: "", names: ["stop_button"], tags: [], description: "stop button", category: "Symbols" }, { emoji: "", names: ["record_button"], tags: [], description: "record button", category: "Symbols" }, { emoji: "", names: ["eject_button"], tags: [], description: "eject button", category: "Symbols" }, { emoji: "", names: ["cinema"], tags: ["film", "movie"], description: "cinema", category: "Symbols" }, { emoji: "", names: ["low_brightness"], tags: [], description: "dim button", category: "Symbols" }, { emoji: "", names: ["high_brightness"], tags: [], description: "bright button", category: "Symbols" }, { emoji: "", names: ["signal_strength"], tags: ["wifi"], description: "antenna bars", category: "Symbols" }, { emoji: "", names: ["wireless"], tags: ["wifi"], description: "wireless", category: "Symbols" }, { emoji: "", names: ["vibration_mode"], tags: [], description: "vibration mode", category: "Symbols" }, { emoji: "", names: ["mobile_phone_off"], tags: ["mute", "off"], description: "mobile phone off", category: "Symbols" }, { emoji: "", names: ["female_sign"], tags: [], description: "female sign", category: "Symbols" }, { emoji: "", names: ["male_sign"], tags: [], description: "male sign", category: "Symbols" }, { emoji: "", names: ["transgender_symbol"], tags: [], description: "transgender symbol", category: "Symbols" }, { emoji: "", names: ["heavy_multiplication_x"], tags: [], description: "multiply", category: "Symbols" }, { emoji: "", names: ["heavy_plus_sign"], tags: [], description: "plus", category: "Symbols" }, { emoji: "", names: ["heavy_minus_sign"], tags: [], description: "minus", category: "Symbols" }, { emoji: "", names: ["heavy_division_sign"], tags: [], description: "divide", category: "Symbols" }, { emoji: "", names: ["heavy_equals_sign"], tags: [], description: "heavy equals sign", category: "Symbols" }, { emoji: "", names: ["infinity"], tags: [], description: "infinity", category: "Symbols" }, { emoji: "", names: ["bangbang"], tags: [], description: "double exclamation mark", category: "Symbols" }, { emoji: "", names: ["interrobang"], tags: [], description: "exclamation question mark", category: "Symbols" }, { emoji: "", names: ["question"], tags: ["confused"], description: "red question mark", category: "Symbols" }, { emoji: "", names: ["grey_question"], tags: [], description: "white question mark", category: "Symbols" }, { emoji: "", names: ["grey_exclamation"], tags: [], description: "white exclamation mark", category: "Symbols" }, { emoji: "", names: ["exclamation", "heavy_exclamation_mark"], tags: ["bang"], description: "red exclamation mark", category: "Symbols" }, { emoji: "", names: ["wavy_dash"], tags: [], description: "wavy dash", category: "Symbols" }, { emoji: "", names: ["currency_exchange"], tags: [], description: "currency exchange", category: "Symbols" }, { emoji: "", names: ["heavy_dollar_sign"], tags: [], description: "heavy dollar sign", category: "Symbols" }, { emoji: "", names: ["medical_symbol"], tags: [], description: "medical symbol", category: "Symbols" }, { emoji: "", names: ["recycle"], tags: ["environment", "green"], description: "recycling symbol", category: "Symbols" }, { emoji: "", names: ["fleur_de_lis"], tags: [], description: "fleur-de-lis", category: "Symbols" }, { emoji: "", names: ["trident"], tags: [], description: "trident emblem", category: "Symbols" }, { emoji: "", names: ["name_badge"], tags: [], description: "name badge", category: "Symbols" }, { emoji: "", names: ["beginner"], tags: [], description: "Japanese symbol for beginner", category: "Symbols" }, { emoji: "", names: ["o"], tags: [], description: "hollow red circle", category: "Symbols" }, { emoji: "", names: ["white_check_mark"], tags: [], description: "check mark button", category: "Symbols" }, { emoji: "", names: ["ballot_box_with_check"], tags: [], description: "check box with check", category: "Symbols" }, { emoji: "", names: ["heavy_check_mark"], tags: [], description: "check mark", category: "Symbols" }, { emoji: "", names: ["x"], tags: [], description: "cross mark", category: "Symbols" }, { emoji: "", names: ["negative_squared_cross_mark"], tags: [], description: "cross mark button", category: "Symbols" }, { emoji: "", names: ["curly_loop"], tags: [], description: "curly loop", category: "Symbols" }, { emoji: "", names: ["loop"], tags: [], description: "double curly loop", category: "Symbols" }, { emoji: "", names: ["part_alternation_mark"], tags: [], description: "part alternation mark", category: "Symbols" }, { emoji: "", names: ["eight_spoked_asterisk"], tags: [], description: "eight-spoked asterisk", category: "Symbols" }, { emoji: "", names: ["eight_pointed_black_star"], tags: [], description: "eight-pointed star", category: "Symbols" }, { emoji: "", names: ["sparkle"], tags: [], description: "sparkle", category: "Symbols" }, { emoji: "", names: ["copyright"], tags: [], description: "copyright", category: "Symbols" }, { emoji: "", names: ["registered"], tags: [], description: "registered", category: "Symbols" }, { emoji: "", names: ["tm"], tags: ["trademark"], description: "trade mark", category: "Symbols" }, { emoji: "#", names: ["hash"], tags: ["number"], description: "keycap: #", category: "Symbols" }, { emoji: "*", names: ["asterisk"], tags: [], description: "keycap: *", category: "Symbols" }, { emoji: "0", names: ["zero"], tags: [], description: "keycap: 0", category: "Symbols" }, { emoji: "1", names: ["one"], tags: [], description: "keycap: 1", category: "Symbols" }, { emoji: "2", names: ["two"], tags: [], description: "keycap: 2", category: "Symbols" }, { emoji: "3", names: ["three"], tags: [], description: "keycap: 3", category: "Symbols" }, { emoji: "4", names: ["four"], tags: [], description: "keycap: 4", category: "Symbols" }, { emoji: "5", names: ["five"], tags: [], description: "keycap: 5", category: "Symbols" }, { emoji: "6", names: ["six"], tags: [], description: "keycap: 6", category: "Symbols" }, { emoji: "7", names: ["seven"], tags: [], description: "keycap: 7", category: "Symbols" }, { emoji: "8", names: ["eight"], tags: [], description: "keycap: 8", category: "Symbols" }, { emoji: "9", names: ["nine"], tags: [], description: "keycap: 9", category: "Symbols" }, { emoji: "", names: ["keycap_ten"], tags: [], description: "keycap: 10", category: "Symbols" }, { emoji: "", names: ["capital_abcd"], tags: ["letters"], description: "input latin uppercase", category: "Symbols" }, { emoji: "", names: ["abcd"], tags: [], description: "input latin lowercase", category: "Symbols" }, { emoji: "", names: ["1234"], tags: ["numbers"], description: "input numbers", category: "Symbols" }, { emoji: "", names: ["symbols"], tags: [], description: "input symbols", category: "Symbols" }, { emoji: "", names: ["abc"], tags: ["alphabet"], description: "input latin letters", category: "Symbols" }, { emoji: "", names: ["a"], tags: [], description: "A button (blood type)", category: "Symbols" }, { emoji: "", names: ["ab"], tags: [], description: "AB button (blood type)", category: "Symbols" }, { emoji: "", names: ["b"], tags: [], description: "B button (blood type)", category: "Symbols" }, { emoji: "", names: ["cl"], tags: [], description: "CL button", category: "Symbols" }, { emoji: "", names: ["cool"], tags: [], description: "COOL button", category: "Symbols" }, { emoji: "", names: ["free"], tags: [], description: "FREE button", category: "Symbols" }, { emoji: "", names: ["information_source"], tags: [], description: "information", category: "Symbols" }, { emoji: "", names: ["id"], tags: [], description: "ID button", category: "Symbols" }, { emoji: "", names: ["m"], tags: [], description: "circled M", category: "Symbols" }, { emoji: "", names: ["new"], tags: ["fresh"], description: "NEW button", category: "Symbols" }, { emoji: "", names: ["ng"], tags: [], description: "NG button", category: "Symbols" }, { emoji: "", names: ["o2"], tags: [], description: "O button (blood type)", category: "Symbols" }, { emoji: "", names: ["ok"], tags: ["yes"], description: "OK button", category: "Symbols" }, { emoji: "", names: ["parking"], tags: [], description: "P button", category: "Symbols" }, { emoji: "", names: ["sos"], tags: ["help", "emergency"], description: "SOS button", category: "Symbols" }, { emoji: "", names: ["up"], tags: [], description: "UP! button", category: "Symbols" }, { emoji: "", names: ["vs"], tags: [], description: "VS button", category: "Symbols" }, { emoji: "", names: ["koko"], tags: [], description: "Japanese here button", category: "Symbols" }, { emoji: "", names: ["sa"], tags: [], description: "Japanese service charge button", category: "Symbols" }, { emoji: "", names: ["u6708"], tags: [], description: "Japanese monthly amount button", category: "Symbols" }, { emoji: "", names: ["u6709"], tags: [], description: "Japanese not free of charge button", category: "Symbols" }, { emoji: "", names: ["u6307"], tags: [], description: "Japanese reserved button", category: "Symbols" }, { emoji: "", names: ["ideograph_advantage"], tags: [], description: "Japanese bargain button", category: "Symbols" }, { emoji: "", names: ["u5272"], tags: [], description: "Japanese discount button", category: "Symbols" }, { emoji: "", names: ["u7121"], tags: [], description: "Japanese free of charge button", category: "Symbols" }, { emoji: "", names: ["u7981"], tags: [], description: "Japanese prohibited button", category: "Symbols" }, { emoji: "", names: ["accept"], tags: [], description: "Japanese acceptable button", category: "Symbols" }, { emoji: "", names: ["u7533"], tags: [], description: "Japanese application button", category: "Symbols" }, { emoji: "", names: ["u5408"], tags: [], description: "Japanese passing grade button", category: "Symbols" }, { emoji: "", names: ["u7a7a"], tags: [], description: "Japanese vacancy button", category: "Symbols" }, { emoji: "", names: ["congratulations"], tags: [], description: "Japanese congratulations button", category: "Symbols" }, { emoji: "", names: ["secret"], tags: [], description: "Japanese secret button", category: "Symbols" }, { emoji: "", names: ["u55b6"], tags: [], description: "Japanese open for business button", category: "Symbols" }, { emoji: "", names: ["u6e80"], tags: [], description: "Japanese no vacancy button", category: "Symbols" }, { emoji: "", names: ["red_circle"], tags: [], description: "red circle", category: "Symbols" }, { emoji: "", names: ["orange_circle"], tags: [], description: "orange circle", category: "Symbols" }, { emoji: "", names: ["yellow_circle"], tags: [], description: "yellow circle", category: "Symbols" }, { emoji: "", names: ["green_circle"], tags: [], description: "green circle", category: "Symbols" }, { emoji: "", names: ["large_blue_circle"], tags: [], description: "blue circle", category: "Symbols" }, { emoji: "", names: ["purple_circle"], tags: [], description: "purple circle", category: "Symbols" }, { emoji: "", names: ["brown_circle"], tags: [], description: "brown circle", category: "Symbols" }, { emoji: "", names: ["black_circle"], tags: [], description: "black circle", category: "Symbols" }, { emoji: "", names: ["white_circle"], tags: [], description: "white circle", category: "Symbols" }, { emoji: "", names: ["red_square"], tags: [], description: "red square", category: "Symbols" }, { emoji: "", names: ["orange_square"], tags: [], description: "orange square", category: "Symbols" }, { emoji: "", names: ["yellow_square"], tags: [], description: "yellow square", category: "Symbols" }, { emoji: "", names: ["green_square"], tags: [], description: "green square", category: "Symbols" }, { emoji: "", names: ["blue_square"], tags: [], description: "blue square", category: "Symbols" }, { emoji: "", names: ["purple_square"], tags: [], description: "purple square", category: "Symbols" }, { emoji: "", names: ["brown_square"], tags: [], description: "brown square", category: "Symbols" }, { emoji: "", names: ["black_large_square"], tags: [], description: "black large square", category: "Symbols" }, { emoji: "", names: ["white_large_square"], tags: [], description: "white large square", category: "Symbols" }, { emoji: "", names: ["black_medium_square"], tags: [], description: "black medium square", category: "Symbols" }, { emoji: "", names: ["white_medium_square"], tags: [], description: "white medium square", category: "Symbols" }, { emoji: "", names: ["black_medium_small_square"], tags: [], description: "black medium-small square", category: "Symbols" }, { emoji: "", names: ["white_medium_small_square"], tags: [], description: "white medium-small square", category: "Symbols" }, { emoji: "", names: ["black_small_square"], tags: [], description: "black small square", category: "Symbols" }, { emoji: "", names: ["white_small_square"], tags: [], description: "white small square", category: "Symbols" }, { emoji: "", names: ["large_orange_diamond"], tags: [], description: "large orange diamond", category: "Symbols" }, { emoji: "", names: ["large_blue_diamond"], tags: [], description: "large blue diamond", category: "Symbols" }, { emoji: "", names: ["small_orange_diamond"], tags: [], description: "small orange diamond", category: "Symbols" }, { emoji: "", names: ["small_blue_diamond"], tags: [], description: "small blue diamond", category: "Symbols" }, { emoji: "", names: ["small_red_triangle"], tags: [], description: "red triangle pointed up", category: "Symbols" }, { emoji: "", names: ["small_red_triangle_down"], tags: [], description: "red triangle pointed down", category: "Symbols" }, { emoji: "", names: ["diamond_shape_with_a_dot_inside"], tags: [], description: "diamond with a dot", category: "Symbols" }, { emoji: "", names: ["radio_button"], tags: [], description: "radio button", category: "Symbols" }, { emoji: "", names: ["white_square_button"], tags: [], description: "white square button", category: "Symbols" }, { emoji: "", names: ["black_square_button"], tags: [], description: "black square button", category: "Symbols" }, { emoji: "", names: ["checkered_flag"], tags: ["milestone", "finish"], description: "chequered flag", category: "Flags" }, { emoji: "", names: ["triangular_flag_on_post"], tags: [], description: "triangular flag", category: "Flags" }, { emoji: "", names: ["crossed_flags"], tags: [], description: "crossed flags", category: "Flags" }, { emoji: "", names: ["black_flag"], tags: [], description: "black flag", category: "Flags" }, { emoji: "", names: ["white_flag"], tags: [], description: "white flag", category: "Flags" }, { emoji: "", names: ["rainbow_flag"], tags: ["pride"], description: "rainbow flag", category: "Flags" }, { emoji: "", names: ["transgender_flag"], tags: [], description: "transgender flag", category: "Flags" }, { emoji: "", names: ["pirate_flag"], tags: [], description: "pirate flag", category: "Flags" }, { emoji: "", names: ["ascension_island"], tags: [], description: "flag: Ascension Island", category: "Flags" }, { emoji: "", names: ["andorra"], tags: [], description: "flag: Andorra", category: "Flags" }, { emoji: "", names: ["united_arab_emirates"], tags: [], description: "flag: United Arab Emirates", category: "Flags" }, { emoji: "", names: ["afghanistan"], tags: [], description: "flag: Afghanistan", category: "Flags" }, { emoji: "", names: ["antigua_barbuda"], tags: [], description: "flag: Antigua & Barbuda", category: "Flags" }, { emoji: "", names: ["anguilla"], tags: [], description: "flag: Anguilla", category: "Flags" }, { emoji: "", names: ["albania"], tags: [], description: "flag: Albania", category: "Flags" }, { emoji: "", names: ["armenia"], tags: [], description: "flag: Armenia", category: "Flags" }, { emoji: "", names: ["angola"], tags: [], description: "flag: Angola", category: "Flags" }, { emoji: "", names: ["antarctica"], tags: [], description: "flag: Antarctica", category: "Flags" }, { emoji: "", names: ["argentina"], tags: [], description: "flag: Argentina", category: "Flags" }, { emoji: "", names: ["american_samoa"], tags: [], description: "flag: American Samoa", category: "Flags" }, { emoji: "", names: ["austria"], tags: [], description: "flag: Austria", category: "Flags" }, { emoji: "", names: ["australia"], tags: [], description: "flag: Australia", category: "Flags" }, { emoji: "", names: ["aruba"], tags: [], description: "flag: Aruba", category: "Flags" }, { emoji: "", names: ["aland_islands"], tags: [], description: "flag: land Islands", category: "Flags" }, { emoji: "", names: ["azerbaijan"], tags: [], description: "flag: Azerbaijan", category: "Flags" }, { emoji: "", names: ["bosnia_herzegovina"], tags: [], description: "flag: Bosnia & Herzegovina", category: "Flags" }, { emoji: "", names: ["barbados"], tags: [], description: "flag: Barbados", category: "Flags" }, { emoji: "", names: ["bangladesh"], tags: [], description: "flag: Bangladesh", category: "Flags" }, { emoji: "", names: ["belgium"], tags: [], description: "flag: Belgium", category: "Flags" }, { emoji: "", names: ["burkina_faso"], tags: [], description: "flag: Burkina Faso", category: "Flags" }, { emoji: "", names: ["bulgaria"], tags: [], description: "flag: Bulgaria", category: "Flags" }, { emoji: "", names: ["bahrain"], tags: [], description: "flag: Bahrain", category: "Flags" }, { emoji: "", names: ["burundi"], tags: [], description: "flag: Burundi", category: "Flags" }, { emoji: "", names: ["benin"], tags: [], description: "flag: Benin", category: "Flags" }, { emoji: "", names: ["st_barthelemy"], tags: [], description: "flag: St. Barthlemy", category: "Flags" }, { emoji: "", names: ["bermuda"], tags: [], description: "flag: Bermuda", category: "Flags" }, { emoji: "", names: ["brunei"], tags: [], description: "flag: Brunei", category: "Flags" }, { emoji: "", names: ["bolivia"], tags: [], description: "flag: Bolivia", category: "Flags" }, { emoji: "", names: ["caribbean_netherlands"], tags: [], description: "flag: Caribbean Netherlands", category: "Flags" }, { emoji: "", names: ["brazil"], tags: [], description: "flag: Brazil", category: "Flags" }, { emoji: "", names: ["bahamas"], tags: [], description: "flag: Bahamas", category: "Flags" }, { emoji: "", names: ["bhutan"], tags: [], description: "flag: Bhutan", category: "Flags" }, { emoji: "", names: ["bouvet_island"], tags: [], description: "flag: Bouvet Island", category: "Flags" }, { emoji: "", names: ["botswana"], tags: [], description: "flag: Botswana", category: "Flags" }, { emoji: "", names: ["belarus"], tags: [], description: "flag: Belarus", category: "Flags" }, { emoji: "", names: ["belize"], tags: [], description: "flag: Belize", category: "Flags" }, { emoji: "", names: ["canada"], tags: [], description: "flag: Canada", category: "Flags" }, { emoji: "", names: ["cocos_islands"], tags: ["keeling"], description: "flag: Cocos (Keeling) Islands", category: "Flags" }, { emoji: "", names: ["congo_kinshasa"], tags: [], description: "flag: Congo - Kinshasa", category: "Flags" }, { emoji: "", names: ["central_african_republic"], tags: [], description: "flag: Central African Republic", category: "Flags" }, { emoji: "", names: ["congo_brazzaville"], tags: [], description: "flag: Congo - Brazzaville", category: "Flags" }, { emoji: "", names: ["switzerland"], tags: [], description: "flag: Switzerland", category: "Flags" }, { emoji: "", names: ["cote_divoire"], tags: ["ivory"], description: "flag: Cte dIvoire", category: "Flags" }, { emoji: "", names: ["cook_islands"], tags: [], description: "flag: Cook Islands", category: "Flags" }, { emoji: "", names: ["chile"], tags: [], description: "flag: Chile", category: "Flags" }, { emoji: "", names: ["cameroon"], tags: [], description: "flag: Cameroon", category: "Flags" }, { emoji: "", names: ["cn"], tags: ["china"], description: "flag: China", category: "Flags" }, { emoji: "", names: ["colombia"], tags: [], description: "flag: Colombia", category: "Flags" }, { emoji: "", names: ["clipperton_island"], tags: [], description: "flag: Clipperton Island", category: "Flags" }, { emoji: "", names: ["costa_rica"], tags: [], description: "flag: Costa Rica", category: "Flags" }, { emoji: "", names: ["cuba"], tags: [], description: "flag: Cuba", category: "Flags" }, { emoji: "", names: ["cape_verde"], tags: [], description: "flag: Cape Verde", category: "Flags" }, { emoji: "", names: ["curacao"], tags: [], description: "flag: Curaao", category: "Flags" }, { emoji: "", names: ["christmas_island"], tags: [], description: "flag: Christmas Island", category: "Flags" }, { emoji: "", names: ["cyprus"], tags: [], description: "flag: Cyprus", category: "Flags" }, { emoji: "", names: ["czech_republic"], tags: [], description: "flag: Czechia", category: "Flags" }, { emoji: "", names: ["de"], tags: ["flag", "germany"], description: "flag: Germany", category: "Flags" }, { emoji: "", names: ["diego_garcia"], tags: [], description: "flag: Diego Garcia", category: "Flags" }, { emoji: "", names: ["djibouti"], tags: [], description: "flag: Djibouti", category: "Flags" }, { emoji: "", names: ["denmark"], tags: [], description: "flag: Denmark", category: "Flags" }, { emoji: "", names: ["dominica"], tags: [], description: "flag: Dominica", category: "Flags" }, { emoji: "", names: ["dominican_republic"], tags: [], description: "flag: Dominican Republic", category: "Flags" }, { emoji: "", names: ["algeria"], tags: [], description: "flag: Algeria", category: "Flags" }, { emoji: "", names: ["ceuta_melilla"], tags: [], description: "flag: Ceuta & Melilla", category: "Flags" }, { emoji: "", names: ["ecuador"], tags: [], description: "flag: Ecuador", category: "Flags" }, { emoji: "", names: ["estonia"], tags: [], description: "flag: Estonia", category: "Flags" }, { emoji: "", names: ["egypt"], tags: [], description: "flag: Egypt", category: "Flags" }, { emoji: "", names: ["western_sahara"], tags: [], description: "flag: Western Sahara", category: "Flags" }, { emoji: "", names: ["eritrea"], tags: [], description: "flag: Eritrea", category: "Flags" }, { emoji: "", names: ["es"], tags: ["spain"], description: "flag: Spain", category: "Flags" }, { emoji: "", names: ["ethiopia"], tags: [], description: "flag: Ethiopia", category: "Flags" }, { emoji: "", names: ["eu", "european_union"], tags: [], description: "flag: European Union", category: "Flags" }, { emoji: "", names: ["finland"], tags: [], description: "flag: Finland", category: "Flags" }, { emoji: "", names: ["fiji"], tags: [], description: "flag: Fiji", category: "Flags" }, { emoji: "", names: ["falkland_islands"], tags: [], description: "flag: Falkland Islands", category: "Flags" }, { emoji: "", names: ["micronesia"], tags: [], description: "flag: Micronesia", category: "Flags" }, { emoji: "", names: ["faroe_islands"], tags: [], description: "flag: Faroe Islands", category: "Flags" }, { emoji: "", names: ["fr"], tags: ["france", "french"], description: "flag: France", category: "Flags" }, { emoji: "", names: ["gabon"], tags: [], description: "flag: Gabon", category: "Flags" }, { emoji: "", names: ["gb", "uk"], tags: ["flag", "british"], description: "flag: United Kingdom", category: "Flags" }, { emoji: "", names: ["grenada"], tags: [], description: "flag: Grenada", category: "Flags" }, { emoji: "", names: ["georgia"], tags: [], description: "flag: Georgia", category: "Flags" }, { emoji: "", names: ["french_guiana"], tags: [], description: "flag: French Guiana", category: "Flags" }, { emoji: "", names: ["guernsey"], tags: [], description: "flag: Guernsey", category: "Flags" }, { emoji: "", names: ["ghana"], tags: [], description: "flag: Ghana", category: "Flags" }, { emoji: "", names: ["gibraltar"], tags: [], description: "flag: Gibraltar", category: "Flags" }, { emoji: "", names: ["greenland"], tags: [], description: "flag: Greenland", category: "Flags" }, { emoji: "", names: ["gambia"], tags: [], description: "flag: Gambia", category: "Flags" }, { emoji: "", names: ["guinea"], tags: [], description: "flag: Guinea", category: "Flags" }, { emoji: "", names: ["guadeloupe"], tags: [], description: "flag: Guadeloupe", category: "Flags" }, { emoji: "", names: ["equatorial_guinea"], tags: [], description: "flag: Equatorial Guinea", category: "Flags" }, { emoji: "", names: ["greece"], tags: [], description: "flag: Greece", category: "Flags" }, { emoji: "", names: ["south_georgia_south_sandwich_islands"], tags: [], description: "flag: South Georgia & South Sandwich Islands", category: "Flags" }, { emoji: "", names: ["guatemala"], tags: [], description: "flag: Guatemala", category: "Flags" }, { emoji: "", names: ["guam"], tags: [], description: "flag: Guam", category: "Flags" }, { emoji: "", names: ["guinea_bissau"], tags: [], description: "flag: Guinea-Bissau", category: "Flags" }, { emoji: "", names: ["guyana"], tags: [], description: "flag: Guyana", category: "Flags" }, { emoji: "", names: ["hong_kong"], tags: [], description: "flag: Hong Kong SAR China", category: "Flags" }, { emoji: "", names: ["heard_mcdonald_islands"], tags: [], description: "flag: Heard & McDonald Islands", category: "Flags" }, { emoji: "", names: ["honduras"], tags: [], description: "flag: Honduras", category: "Flags" }, { emoji: "", names: ["croatia"], tags: [], description: "flag: Croatia", category: "Flags" }, { emoji: "", names: ["haiti"], tags: [], description: "flag: Haiti", category: "Flags" }, { emoji: "", names: ["hungary"], tags: [], description: "flag: Hungary", category: "Flags" }, { emoji: "", names: ["canary_islands"], tags: [], description: "flag: Canary Islands", category: "Flags" }, { emoji: "", names: ["indonesia"], tags: [], description: "flag: Indonesia", category: "Flags" }, { emoji: "", names: ["ireland"], tags: [], description: "flag: Ireland", category: "Flags" }, { emoji: "", names: ["israel"], tags: [], description: "flag: Israel", category: "Flags" }, { emoji: "", names: ["isle_of_man"], tags: [], description: "flag: Isle of Man", category: "Flags" }, { emoji: "", names: ["india"], tags: [], description: "flag: India", category: "Flags" }, { emoji: "", names: ["british_indian_ocean_territory"], tags: [], description: "flag: British Indian Ocean Territory", category: "Flags" }, { emoji: "", names: ["iraq"], tags: [], description: "flag: Iraq", category: "Flags" }, { emoji: "", names: ["iran"], tags: [], description: "flag: Iran", category: "Flags" }, { emoji: "", names: ["iceland"], tags: [], description: "flag: Iceland", category: "Flags" }, { emoji: "", names: ["it"], tags: ["italy"], description: "flag: Italy", category: "Flags" }, { emoji: "", names: ["jersey"], tags: [], description: "flag: Jersey", category: "Flags" }, { emoji: "", names: ["jamaica"], tags: [], description: "flag: Jamaica", category: "Flags" }, { emoji: "", names: ["jordan"], tags: [], description: "flag: Jordan", category: "Flags" }, { emoji: "", names: ["jp"], tags: ["japan"], description: "flag: Japan", category: "Flags" }, { emoji: "", names: ["kenya"], tags: [], description: "flag: Kenya", category: "Flags" }, { emoji: "", names: ["kyrgyzstan"], tags: [], description: "flag: Kyrgyzstan", category: "Flags" }, { emoji: "", names: ["cambodia"], tags: [], description: "flag: Cambodia", category: "Flags" }, { emoji: "", names: ["kiribati"], tags: [], description: "flag: Kiribati", category: "Flags" }, { emoji: "", names: ["comoros"], tags: [], description: "flag: Comoros", category: "Flags" }, { emoji: "", names: ["st_kitts_nevis"], tags: [], description: "flag: St. Kitts & Nevis", category: "Flags" }, { emoji: "", names: ["north_korea"], tags: [], description: "flag: North Korea", category: "Flags" }, { emoji: "", names: ["kr"], tags: ["korea"], description: "flag: South Korea", category: "Flags" }, { emoji: "", names: ["kuwait"], tags: [], description: "flag: Kuwait", category: "Flags" }, { emoji: "", names: ["cayman_islands"], tags: [], description: "flag: Cayman Islands", category: "Flags" }, { emoji: "", names: ["kazakhstan"], tags: [], description: "flag: Kazakhstan", category: "Flags" }, { emoji: "", names: ["laos"], tags: [], description: "flag: Laos", category: "Flags" }, { emoji: "", names: ["lebanon"], tags: [], description: "flag: Lebanon", category: "Flags" }, { emoji: "", names: ["st_lucia"], tags: [], description: "flag: St. Lucia", category: "Flags" }, { emoji: "", names: ["liechtenstein"], tags: [], description: "flag: Liechtenstein", category: "Flags" }, { emoji: "", names: ["sri_lanka"], tags: [], description: "flag: Sri Lanka", category: "Flags" }, { emoji: "", names: ["liberia"], tags: [], description: "flag: Liberia", category: "Flags" }, { emoji: "", names: ["lesotho"], tags: [], description: "flag: Lesotho", category: "Flags" }, { emoji: "", names: ["lithuania"], tags: [], description: "flag: Lithuania", category: "Flags" }, { emoji: "", names: ["luxembourg"], tags: [], description: "flag: Luxembourg", category: "Flags" }, { emoji: "", names: ["latvia"], tags: [], description: "flag: Latvia", category: "Flags" }, { emoji: "", names: ["libya"], tags: [], description: "flag: Libya", category: "Flags" }, { emoji: "", names: ["morocco"], tags: [], description: "flag: Morocco", category: "Flags" }, { emoji: "", names: ["monaco"], tags: [], description: "flag: Monaco", category: "Flags" }, { emoji: "", names: ["moldova"], tags: [], description: "flag: Moldova", category: "Flags" }, { emoji: "", names: ["montenegro"], tags: [], description: "flag: Montenegro", category: "Flags" }, { emoji: "", names: ["st_martin"], tags: [], description: "flag: St. Martin", category: "Flags" }, { emoji: "", names: ["madagascar"], tags: [], description: "flag: Madagascar", category: "Flags" }, { emoji: "", names: ["marshall_islands"], tags: [], description: "flag: Marshall Islands", category: "Flags" }, { emoji: "", names: ["macedonia"], tags: [], description: "flag: North Macedonia", category: "Flags" }, { emoji: "", names: ["mali"], tags: [], description: "flag: Mali", category: "Flags" }, { emoji: "", names: ["myanmar"], tags: ["burma"], description: "flag: Myanmar (Burma)", category: "Flags" }, { emoji: "", names: ["mongolia"], tags: [], description: "flag: Mongolia", category: "Flags" }, { emoji: "", names: ["macau"], tags: [], description: "flag: Macao SAR China", category: "Flags" }, { emoji: "", names: ["northern_mariana_islands"], tags: [], description: "flag: Northern Mariana Islands", category: "Flags" }, { emoji: "", names: ["martinique"], tags: [], description: "flag: Martinique", category: "Flags" }, { emoji: "", names: ["mauritania"], tags: [], description: "flag: Mauritania", category: "Flags" }, { emoji: "", names: ["montserrat"], tags: [], description: "flag: Montserrat", category: "Flags" }, { emoji: "", names: ["malta"], tags: [], description: "flag: Malta", category: "Flags" }, { emoji: "", names: ["mauritius"], tags: [], description: "flag: Mauritius", category: "Flags" }, { emoji: "", names: ["maldives"], tags: [], description: "flag: Maldives", category: "Flags" }, { emoji: "", names: ["malawi"], tags: [], description: "flag: Malawi", category: "Flags" }, { emoji: "", names: ["mexico"], tags: [], description: "flag: Mexico", category: "Flags" }, { emoji: "", names: ["malaysia"], tags: [], description: "flag: Malaysia", category: "Flags" }, { emoji: "", names: ["mozambique"], tags: [], description: "flag: Mozambique", category: "Flags" }, { emoji: "", names: ["namibia"], tags: [], description: "flag: Namibia", category: "Flags" }, { emoji: "", names: ["new_caledonia"], tags: [], description: "flag: New Caledonia", category: "Flags" }, { emoji: "", names: ["niger"], tags: [], description: "flag: Niger", category: "Flags" }, { emoji: "", names: ["norfolk_island"], tags: [], description: "flag: Norfolk Island", category: "Flags" }, { emoji: "", names: ["nigeria"], tags: [], description: "flag: Nigeria", category: "Flags" }, { emoji: "", names: ["nicaragua"], tags: [], description: "flag: Nicaragua", category: "Flags" }, { emoji: "", names: ["netherlands"], tags: [], description: "flag: Netherlands", category: "Flags" }, { emoji: "", names: ["norway"], tags: [], description: "flag: Norway", category: "Flags" }, { emoji: "", names: ["nepal"], tags: [], description: "flag: Nepal", category: "Flags" }, { emoji: "", names: ["nauru"], tags: [], description: "flag: Nauru", category: "Flags" }, { emoji: "", names: ["niue"], tags: [], description: "flag: Niue", category: "Flags" }, { emoji: "", names: ["new_zealand"], tags: [], description: "flag: New Zealand", category: "Flags" }, { emoji: "", names: ["oman"], tags: [], description: "flag: Oman", category: "Flags" }, { emoji: "", names: ["panama"], tags: [], description: "flag: Panama", category: "Flags" }, { emoji: "", names: ["peru"], tags: [], description: "flag: Peru", category: "Flags" }, { emoji: "", names: ["french_polynesia"], tags: [], description: "flag: French Polynesia", category: "Flags" }, { emoji: "", names: ["papua_new_guinea"], tags: [], description: "flag: Papua New Guinea", category: "Flags" }, { emoji: "", names: ["philippines"], tags: [], description: "flag: Philippines", category: "Flags" }, { emoji: "", names: ["pakistan"], tags: [], description: "flag: Pakistan", category: "Flags" }, { emoji: "", names: ["poland"], tags: [], description: "flag: Poland", category: "Flags" }, { emoji: "", names: ["st_pierre_miquelon"], tags: [], description: "flag: St. Pierre & Miquelon", category: "Flags" }, { emoji: "", names: ["pitcairn_islands"], tags: [], description: "flag: Pitcairn Islands", category: "Flags" }, { emoji: "", names: ["puerto_rico"], tags: [], description: "flag: Puerto Rico", category: "Flags" }, { emoji: "", names: ["palestinian_territories"], tags: [], description: "flag: Palestinian Territories", category: "Flags" }, { emoji: "", names: ["portugal"], tags: [], description: "flag: Portugal", category: "Flags" }, { emoji: "", names: ["palau"], tags: [], description: "flag: Palau", category: "Flags" }, { emoji: "", names: ["paraguay"], tags: [], description: "flag: Paraguay", category: "Flags" }, { emoji: "", names: ["qatar"], tags: [], description: "flag: Qatar", category: "Flags" }, { emoji: "", names: ["reunion"], tags: [], description: "flag: Runion", category: "Flags" }, { emoji: "", names: ["romania"], tags: [], description: "flag: Romania", category: "Flags" }, { emoji: "", names: ["serbia"], tags: [], description: "flag: Serbia", category: "Flags" }, { emoji: "", names: ["ru"], tags: ["russia"], description: "flag: Russia", category: "Flags" }, { emoji: "", names: ["rwanda"], tags: [], description: "flag: Rwanda", category: "Flags" }, { emoji: "", names: ["saudi_arabia"], tags: [], description: "flag: Saudi Arabia", category: "Flags" }, { emoji: "", names: ["solomon_islands"], tags: [], description: "flag: Solomon Islands", category: "Flags" }, { emoji: "", names: ["seychelles"], tags: [], description: "flag: Seychelles", category: "Flags" }, { emoji: "", names: ["sudan"], tags: [], description: "flag: Sudan", category: "Flags" }, { emoji: "", names: ["sweden"], tags: [], description: "flag: Sweden", category: "Flags" }, { emoji: "", names: ["singapore"], tags: [], description: "flag: Singapore", category: "Flags" }, { emoji: "", names: ["st_helena"], tags: [], description: "flag: St. Helena", category: "Flags" }, { emoji: "", names: ["slovenia"], tags: [], description: "flag: Slovenia", category: "Flags" }, { emoji: "", names: ["svalbard_jan_mayen"], tags: [], description: "flag: Svalbard & Jan Mayen", category: "Flags" }, { emoji: "", names: ["slovakia"], tags: [], description: "flag: Slovakia", category: "Flags" }, { emoji: "", names: ["sierra_leone"], tags: [], description: "flag: Sierra Leone", category: "Flags" }, { emoji: "", names: ["san_marino"], tags: [], description: "flag: San Marino", category: "Flags" }, { emoji: "", names: ["senegal"], tags: [], description: "flag: Senegal", category: "Flags" }, { emoji: "", names: ["somalia"], tags: [], description: "flag: Somalia", category: "Flags" }, { emoji: "", names: ["suriname"], tags: [], description: "flag: Suriname", category: "Flags" }, { emoji: "", names: ["south_sudan"], tags: [], description: "flag: South Sudan", category: "Flags" }, { emoji: "", names: ["sao_tome_principe"], tags: [], description: "flag: So Tom & Prncipe", category: "Flags" }, { emoji: "", names: ["el_salvador"], tags: [], description: "flag: El Salvador", category: "Flags" }, { emoji: "", names: ["sint_maarten"], tags: [], description: "flag: Sint Maarten", category: "Flags" }, { emoji: "", names: ["syria"], tags: [], description: "flag: Syria", category: "Flags" }, { emoji: "", names: ["swaziland"], tags: [], description: "flag: Eswatini", category: "Flags" }, { emoji: "", names: ["tristan_da_cunha"], tags: [], description: "flag: Tristan da Cunha", category: "Flags" }, { emoji: "", names: ["turks_caicos_islands"], tags: [], description: "flag: Turks & Caicos Islands", category: "Flags" }, { emoji: "", names: ["chad"], tags: [], description: "flag: Chad", category: "Flags" }, { emoji: "", names: ["french_southern_territories"], tags: [], description: "flag: French Southern Territories", category: "Flags" }, { emoji: "", names: ["togo"], tags: [], description: "flag: Togo", category: "Flags" }, { emoji: "", names: ["thailand"], tags: [], description: "flag: Thailand", category: "Flags" }, { emoji: "", names: ["tajikistan"], tags: [], description: "flag: Tajikistan", category: "Flags" }, { emoji: "", names: ["tokelau"], tags: [], description: "flag: Tokelau", category: "Flags" }, { emoji: "", names: ["timor_leste"], tags: [], description: "flag: Timor-Leste", category: "Flags" }, { emoji: "", names: ["turkmenistan"], tags: [], description: "flag: Turkmenistan", category: "Flags" }, { emoji: "", names: ["tunisia"], tags: [], description: "flag: Tunisia", category: "Flags" }, { emoji: "", names: ["tonga"], tags: [], description: "flag: Tonga", category: "Flags" }, { emoji: "", names: ["tr"], tags: ["turkey"], description: "flag: Turkey", category: "Flags" }, { emoji: "", names: ["trinidad_tobago"], tags: [], description: "flag: Trinidad & Tobago", category: "Flags" }, { emoji: "", names: ["tuvalu"], tags: [], description: "flag: Tuvalu", category: "Flags" }, { emoji: "", names: ["taiwan"], tags: [], description: "flag: Taiwan", category: "Flags" }, { emoji: "", names: ["tanzania"], tags: [], description: "flag: Tanzania", category: "Flags" }, { emoji: "", names: ["ukraine"], tags: [], description: "flag: Ukraine", category: "Flags" }, { emoji: "", names: ["uganda"], tags: [], description: "flag: Uganda", category: "Flags" }, { emoji: "", names: ["us_outlying_islands"], tags: [], description: "flag: U.S. Outlying Islands", category: "Flags" }, { emoji: "", names: ["united_nations"], tags: [], description: "flag: United Nations", category: "Flags" }, { emoji: "", names: ["us"], tags: ["flag", "united", "america"], description: "flag: United States", category: "Flags" }, { emoji: "", names: ["uruguay"], tags: [], description: "flag: Uruguay", category: "Flags" }, { emoji: "", names: ["uzbekistan"], tags: [], description: "flag: Uzbekistan", category: "Flags" }, { emoji: "", names: ["vatican_city"], tags: [], description: "flag: Vatican City", category: "Flags" }, { emoji: "", names: ["st_vincent_grenadines"], tags: [], description: "flag: St. Vincent & Grenadines", category: "Flags" }, { emoji: "", names: ["venezuela"], tags: [], description: "flag: Venezuela", category: "Flags" }, { emoji: "", names: ["british_virgin_islands"], tags: [], description: "flag: British Virgin Islands", category: "Flags" }, { emoji: "", names: ["us_virgin_islands"], tags: [], description: "flag: U.S. Virgin Islands", category: "Flags" }, { emoji: "", names: ["vietnam"], tags: [], description: "flag: Vietnam", category: "Flags" }, { emoji: "", names: ["vanuatu"], tags: [], description: "flag: Vanuatu", category: "Flags" }, { emoji: "", names: ["wallis_futuna"], tags: [], description: "flag: Wallis & Futuna", category: "Flags" }, { emoji: "", names: ["samoa"], tags: [], description: "flag: Samoa", category: "Flags" }, { emoji: "", names: ["kosovo"], tags: [], description: "flag: Kosovo", category: "Flags" }, { emoji: "", names: ["yemen"], tags: [], description: "flag: Yemen", category: "Flags" }, { emoji: "", names: ["mayotte"], tags: [], description: "flag: Mayotte", category: "Flags" }, { emoji: "", names: ["south_africa"], tags: [], description: "flag: South Africa", category: "Flags" }, { emoji: "", names: ["zambia"], tags: [], description: "flag: Zambia", category: "Flags" }, { emoji: "", names: ["zimbabwe"], tags: [], description: "flag: Zimbabwe", category: "Flags" }, { emoji: "", names: ["england"], tags: [], description: "flag: England", category: "Flags" }, { emoji: "", names: ["scotland"], tags: [], description: "flag: Scotland", category: "Flags" }, { emoji: "", names: ["wales"], tags: [], description: "flag: Wales", category: "Flags" }]; var bn; (function (n) { n.assertEqual = i => i; function e(i) { } n.assertIs = e; function t(i) { throw new Error } n.assertNever = t, n.arrayToEnum = i => { const a = {}; for (const o of i) a[o] = o; return a }, n.getValidEnumValues = i => { const a = n.objectKeys(i).filter(s => typeof i[i[s]] != "number"), o = {}; for (const s of a) o[s] = i[s]; return n.objectValues(o) }, n.objectValues = i => n.objectKeys(i).map(function (a) { return i[a] }), n.objectKeys = typeof Object.keys == "function" ? i => Object.keys(i) : i => { const a = []; for (const o in i) Object.prototype.hasOwnProperty.call(i, o) && a.push(o); return a }, n.find = (i, a) => { for (const o of i) if (a(o)) return o }, n.isInteger = typeof Number.isInteger == "function" ? i => Number.isInteger(i) : i => typeof i == "number" && isFinite(i) && Math.floor(i) === i; function r(i, a = " | ") { return i.map(o => typeof o == "string" ? `'${o}'` : o).join(a) } n.joinValues = r, n.jsonStringifyReplacer = (i, a) => typeof a == "bigint" ? a.toString() : a })(bn || (bn = {})); var yL; (function (n) { n.mergeShapes = (e, t) => ({ ...e, ...t }) })(yL || (yL = {})); const nt = bn.arrayToEnum(["string", "nan", "number", "integer", "float", "boolean", "date", "bigint", "symbol", "function", "undefined", "null", "array", "object", "unknown", "promise", "void", "never", "map", "set"]), Lu = n => { switch (typeof n) { case "undefined": return nt.undefined; case "string": return nt.string; case "number": return isNaN(n) ? nt.nan : nt.number; case "boolean": return nt.boolean; case "function": return nt.function; case "bigint": return nt.bigint; case "symbol": return nt.symbol; case "object": return Array.isArray(n) ? nt.array : n === null ? nt.null : n.then && typeof n.then == "function" && n.catch && typeof n.catch == "function" ? nt.promise : typeof Map < "u" && n instanceof Map ? nt.map : typeof Set < "u" && n instanceof Set ? nt.set : typeof Date < "u" && n instanceof Date ? nt.date : nt.object; default: return nt.unknown } }, Ve = bn.arrayToEnum(["invalid_type", "invalid_literal", "custom", "invalid_union", "invalid_union_discriminator", "invalid_enum_value", "unrecognized_keys", "invalid_arguments", "invalid_return_type", "invalid_date", "invalid_string", "too_small", "too_big", "invalid_intersection_types", "not_multiple_of", "not_finite"]), gct = n => JSON.stringify(n, null, 2).replace(/"([^"]+)":/g, "$1:"); class Ga extends Error { constructor(e) { super(), this.issues = [], this.addIssue = r => { this.issues = [...this.issues, r] }, this.addIssues = (r = []) => { this.issues = [...this.issues, ...r] }; const t = new.target.prototype; Object.setPrototypeOf ? Object.setPrototypeOf(this, t) : this.__proto__ = t, this.name = "ZodError", this.issues = e } get errors() { return this.issues } format(e) { const t = e || function (a) { return a.message }, r = { _errors: [] }, i = a => { for (const o of a.issues) if (o.code === "invalid_union") o.unionErrors.map(i); else if (o.code === "invalid_return_type") i(o.returnTypeError); else if (o.code === "invalid_arguments") i(o.argumentsError); else if (o.path.length === 0) r._errors.push(t(o)); else { let s = r, l = 0; for (; l < o.path.length;) { const c = o.path[l]; l === o.path.length - 1 ? (s[c] = s[c] || { _errors: [] }, s[c]._errors.push(t(o))) : s[c] = s[c] || { _errors: [] }, s = s[c], l++ } } }; return i(this), r } static assert(e) { if (!(e instanceof Ga)) throw new Error(`Not a ZodError: ${e}`) } toString() { return this.message } get message() { return JSON.stringify(this.issues, bn.jsonStringifyReplacer, 2) } get isEmpty() { return this.issues.length === 0 } flatten(e = t => t.message) { const t = {}, r = []; for (const i of this.issues) i.path.length > 0 ? (t[i.path[0]] = t[i.path[0]] || [], t[i.path[0]].push(e(i))) : r.push(e(i)); return { formErrors: r, fieldErrors: t } } get formErrors() { return this.flatten() } } Ga.create = n => new Ga(n); const Ig = (n, e) => { let t; switch (n.code) { case Ve.invalid_type: n.received === nt.undefined ? t = "Required" : t = `Expected ${n.expected}, received ${n.received}`; break; case Ve.invalid_literal: t = `Invalid literal value, expected ${JSON.stringify(n.expected, bn.jsonStringifyReplacer)}`; break; case Ve.unrecognized_keys: t = `Unrecognized key(s) in object: ${bn.joinValues(n.keys, ", ")}`; break; case Ve.invalid_union: t = "Invalid input"; break; case Ve.invalid_union_discriminator: t = `Invalid discriminator value. Expected ${bn.joinValues(n.options)}`; break; case Ve.invalid_enum_value: t = `Invalid enum value. Expected ${bn.joinValues(n.options)}, received '${n.received}'`; break; case Ve.invalid_arguments: t = "Invalid function arguments"; break; case Ve.invalid_return_type: t = "Invalid function return type"; break; case Ve.invalid_date: t = "Invalid date"; break; case Ve.invalid_string: typeof n.validation == "object" ? "includes" in n.validation ? (t = `Invalid input: must include "${n.validation.includes}"`, typeof n.validation.position == "number" && (t = `${t} at one or more positions greater than or equal to ${n.validation.position}`)) : "startsWith" in n.validation ? t = `Invalid input: must start with "${n.validation.startsWith}"` : "endsWith" in n.validation ? t = `Invalid input: must end with "${n.validation.endsWith}"` : bn.assertNever(n.validation) : n.validation !== "regex" ? t = `Invalid ${n.validation}` : t = "Invalid"; break; case Ve.too_small: n.type === "array" ? t = `Array must contain ${n.exact ? "exactly" : n.inclusive ? "at least" : "more than"} ${n.minimum} element(s)` : n.type === "string" ? t = `String must contain ${n.exact ? "exactly" : n.inclusive ? "at least" : "over"} ${n.minimum} character(s)` : n.type === "number" ? t = `Number must be ${n.exact ? "exactly equal to " : n.inclusive ? "greater than or equal to " : "greater than "}${n.minimum}` : n.type === "date" ? t = `Date must be ${n.exact ? "exactly equal to " : n.inclusive ? "greater than or equal to " : "greater than "}${new Date(Number(n.minimum))}` : t = "Invalid input"; break; case Ve.too_big: n.type === "array" ? t = `Array must contain ${n.exact ? "exactly" : n.inclusive ? "at most" : "less than"} ${n.maximum} element(s)` : n.type === "string" ? t = `String must contain ${n.exact ? "exactly" : n.inclusive ? "at most" : "under"} ${n.maximum} character(s)` : n.type === "number" ? t = `Number must be ${n.exact ? "exactly" : n.inclusive ? "less than or equal to" : "less than"} ${n.maximum}` : n.type === "bigint" ? t = `BigInt must be ${n.exact ? "exactly" : n.inclusive ? "less than or equal to" : "less than"} ${n.maximum}` : n.type === "date" ? t = `Date must be ${n.exact ? "exactly" : n.inclusive ? "smaller than or equal to" : "smaller than"} ${new Date(Number(n.maximum))}` : t = "Invalid input"; break; case Ve.custom: t = "Invalid input"; break; case Ve.invalid_intersection_types: t = "Intersection results could not be merged"; break; case Ve.not_multiple_of: t = `Number must be a multiple of ${n.multipleOf}`; break; case Ve.not_finite: t = "Number must be finite"; break; default: t = e.defaultError, bn.assertNever(n) }return { message: t } }; let Zse = Ig; function vct(n) { Zse = n } function NT() { return Zse } const BT = n => { const { data: e, path: t, errorMaps: r, issueData: i } = n, a = [...t, ...i.path || []], o = { ...i, path: a }; if (i.message !== void 0) return { ...i, path: a, message: i.message }; let s = ""; const l = r.filter(c => !!c).slice().reverse(); for (const c of l) s = c(o, { data: e, defaultError: s }).message; return { ...i, path: a, message: s } }, yct = []; function et(n, e) { const t = NT(), r = BT({ issueData: e, data: n.data, path: n.path, errorMaps: [n.common.contextualErrorMap, n.schemaErrorMap, t, t === Ig ? void 0 : Ig].filter(i => !!i) }); n.common.issues.push(r) } class Ri { constructor() { this.value = "valid" } dirty() { this.value === "valid" && (this.value = "dirty") } abort() { this.value !== "aborted" && (this.value = "aborted") } static mergeArray(e, t) { const r = []; for (const i of t) { if (i.status === "aborted") return Rt; i.status === "dirty" && e.dirty(), r.push(i.value) } return { status: e.value, value: r } } static async mergeObjectAsync(e, t) { const r = []; for (const i of t) { const a = await i.key, o = await i.value; r.push({ key: a, value: o }) } return Ri.mergeObjectSync(e, r) } static mergeObjectSync(e, t) { const r = {}; for (const i of t) { const { key: a, value: o } = i; if (a.status === "aborted" || o.status === "aborted") return Rt; a.status === "dirty" && e.dirty(), o.status === "dirty" && e.dirty(), a.value !== "__proto__" && (typeof o.value < "u" || i.alwaysSet) && (r[a.value] = o.value) } return { status: e.value, value: r } } } const Rt = Object.freeze({ status: "aborted" }), Rm = n => ({ status: "dirty", value: n }), ia = n => ({ status: "valid", value: n }), _L = n => n.status === "aborted", bL = n => n.status === "dirty", B_ = n => n.status === "valid", $_ = n => typeof Promise < "u" && n instanceof Promise; function $T(n, e, t, r) { if (t === "a" && !r) throw new TypeError("Private accessor was defined without a getter"); if (typeof e == "function" ? n !== e || !r : !e.has(n)) throw new TypeError("Cannot read private member from an object whose class did not declare it"); return t === "m" ? r : t === "a" ? r.call(n) : r ? r.value : e.get(n) } function Xse(n, e, t, r, i) { if (r === "m") throw new TypeError("Private method is not writable"); if (r === "a" && !i) throw new TypeError("Private accessor was defined without a setter"); if (typeof e == "function" ? n !== e || !i : !e.has(n)) throw new TypeError("Cannot write private member to an object whose class did not declare it"); return r === "a" ? i.call(n, t) : i ? i.value = t : e.set(n, t), t } var bt; (function (n) { n.errToObj = e => typeof e == "string" ? { message: e } : e || {}, n.toString = e => typeof e == "string" ? e : e == null ? void 0 : e.message })(bt || (bt = {})); var Ny, By; class El { constructor(e, t, r, i) { this._cachedPath = [], this.parent = e, this.data = t, this._path = r, this._key = i } get path() { return this._cachedPath.length || (this._key instanceof Array ? this._cachedPath.push(...this._path, ...this._key) : this._cachedPath.push(...this._path, this._key)), this._cachedPath } } const BW = (n, e) => { if (B_(e)) return { success: !0, data: e.value }; if (!n.common.issues.length) throw new Error("Validation failed but no issues detected."); return { success: !1, get error() { if (this._error) return this._error; const t = new Ga(n.common.issues); return this._error = t, this._error } } }; function Wt(n) { if (!n) return {}; const { errorMap: e, invalid_type_error: t, required_error: r, description: i } = n; if (e && (t || r)) throw new Error(`Can't use "invalid_type_error" or "required_error" in conjunction with custom error map.`); return e ? { errorMap: e, description: i } : { errorMap: (o, s) => { var l, c; const { message: u } = n; return o.code === "invalid_enum_value" ? { message: u ?? s.defaultError } : typeof s.data > "u" ? { message: (l = u ?? r) !== null && l !== void 0 ? l : s.defaultError } : o.code !== "invalid_type" ? { message: s.defaultError } : { message: (c = u ?? t) !== null && c !== void 0 ? c : s.defaultError } }, description: i } } class rn { constructor(e) { this.spa = this.safeParseAsync, this._def = e, this.parse = this.parse.bind(this), this.safeParse = this.safeParse.bind(this), this.parseAsync = this.parseAsync.bind(this), this.safeParseAsync = this.safeParseAsync.bind(this), this.spa = this.spa.bind(this), this.refine = this.refine.bind(this), this.refinement = this.refinement.bind(this), this.superRefine = this.superRefine.bind(this), this.optional = this.optional.bind(this), this.nullable = this.nullable.bind(this), this.nullish = this.nullish.bind(this), this.array = this.array.bind(this), this.promise = this.promise.bind(this), this.or = this.or.bind(this), this.and = this.and.bind(this), this.transform = this.transform.bind(this), this.brand = this.brand.bind(this), this.default = this.default.bind(this), this.catch = this.catch.bind(this), this.describe = this.describe.bind(this), this.pipe = this.pipe.bind(this), this.readonly = this.readonly.bind(this), this.isNullable = this.isNullable.bind(this), this.isOptional = this.isOptional.bind(this) } get description() { return this._def.description } _getType(e) { return Lu(e.data) } _getOrReturnCtx(e, t) { return t || { common: e.parent.common, data: e.data, parsedType: Lu(e.data), schemaErrorMap: this._def.errorMap, path: e.path, parent: e.parent } } _processInputParams(e) { return { status: new Ri, ctx: { common: e.parent.common, data: e.data, parsedType: Lu(e.data), schemaErrorMap: this._def.errorMap, path: e.path, parent: e.parent } } } _parseSync(e) { const t = this._parse(e); if ($_(t)) throw new Error("Synchronous parse encountered promise."); return t } _parseAsync(e) { const t = this._parse(e); return Promise.resolve(t) } parse(e, t) { const r = this.safeParse(e, t); if (r.success) return r.data; throw r.error } safeParse(e, t) { var r; const i = { common: { issues: [], async: (r = t == null ? void 0 : t.async) !== null && r !== void 0 ? r : !1, contextualErrorMap: t == null ? void 0 : t.errorMap }, path: (t == null ? void 0 : t.path) || [], schemaErrorMap: this._def.errorMap, parent: null, data: e, parsedType: Lu(e) }, a = this._parseSync({ data: e, path: i.path, parent: i }); return BW(i, a) } async parseAsync(e, t) { const r = await this.safeParseAsync(e, t); if (r.success) return r.data; throw r.error } async safeParseAsync(e, t) { const r = { common: { issues: [], contextualErrorMap: t == null ? void 0 : t.errorMap, async: !0 }, path: (t == null ? void 0 : t.path) || [], schemaErrorMap: this._def.errorMap, parent: null, data: e, parsedType: Lu(e) }, i = this._parse({ data: e, path: r.path, parent: r }), a = await ($_(i) ? i : Promise.resolve(i)); return BW(r, a) } refine(e, t) { const r = i => typeof t == "string" || typeof t > "u" ? { message: t } : typeof t == "function" ? t(i) : t; return this._refinement((i, a) => { const o = e(i), s = () => a.addIssue({ code: Ve.custom, ...r(i) }); return typeof Promise < "u" && o instanceof Promise ? o.then(l => l ? !0 : (s(), !1)) : o ? !0 : (s(), !1) }) } refinement(e, t) { return this._refinement((r, i) => e(r) ? !0 : (i.addIssue(typeof t == "function" ? t(r, i) : t), !1)) } _refinement(e) { return new Os({ schema: this, typeName: Pt.ZodEffects, effect: { type: "refinement", refinement: e } }) } superRefine(e) { return this._refinement(e) } optional() { return vl.create(this, this._def) } nullable() { return Nd.create(this, this._def) } nullish() { return this.nullable().optional() } array() { return ws.create(this, this._def) } promise() { return Rg.create(this, this._def) } or(e) { return H_.create([this, e], this._def) } and(e) { return U_.create(this, e, this._def) } transform(e) { return new Os({ ...Wt(this._def), schema: this, typeName: Pt.ZodEffects, effect: { type: "transform", transform: e } }) } default(e) { const t = typeof e == "function" ? e : () => e; return new Y_({ ...Wt(this._def), innerType: this, defaultValue: t, typeName: Pt.ZodDefault }) } brand() { return new RB({ typeName: Pt.ZodBranded, type: this, ...Wt(this._def) }) } catch(e) { const t = typeof e == "function" ? e : () => e; return new Z_({ ...Wt(this._def), innerType: this, catchValue: t, typeName: Pt.ZodCatch }) } describe(e) { const t = this.constructor; return new t({ ...this._def, description: e }) } pipe(e) { return Fb.create(this, e) } readonly() { return X_.create(this) } isOptional() { return this.safeParse(void 0).success } isNullable() { return this.safeParse(null).success } } const _ct = /^c[^\s-]{8,}$/i, bct = /^[0-9a-z]+$/, wct = /^[0-9A-HJKMNP-TV-Z]{26}$/, xct = /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/i, Sct = /^[a-z0-9_-]{21}$/i, Tct = /^[-+]?P(?!$)(?:(?:[-+]?\d+Y)|(?:[-+]?\d+[.,]\d+Y$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:(?:[-+]?\d+W)|(?:[-+]?\d+[.,]\d+W$))?(?:(?:[-+]?\d+D)|(?:[-+]?\d+[.,]\d+D$))?(?:T(?=[\d+-])(?:(?:[-+]?\d+H)|(?:[-+]?\d+[.,]\d+H$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:[-+]?\d+(?:[.,]\d+)?S)?)??$/, kct = /^(?!\.)(?!.*\.\.)([A-Z0-9_'+\-\.]*)[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\-]*\.)+[A-Z]{2,}$/i, Cct = "^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$"; let DD; const Act = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/, Ect = /^(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))$/, Mct = /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/, Jse = "((\\d\\d[2468][048]|\\d\\d[13579][26]|\\d\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\d{4}-((0[13578]|1[02])-(0[1-9]|[12]\\d|3[01])|(0[469]|11)-(0[1-9]|[12]\\d|30)|(02)-(0[1-9]|1\\d|2[0-8])))", Oct = new RegExp(`^${Jse}$`); function Qse(n) { let e = "([01]\\d|2[0-3]):[0-5]\\d:[0-5]\\d"; return n.precision ? e = `${e}\\.\\d{${n.precision}}` : n.precision == null && (e = `${e}(\\.\\d+)?`), e } function Dct(n) { return new RegExp(`^${Qse(n)}$`) } function ele(n) { let e = `${Jse}T${Qse(n)}`; const t = []; return t.push(n.local ? "Z?" : "Z"), n.offset && t.push("([+-]\\d{2}:?\\d{2})"), e = `${e}(${t.join("|")})`, new RegExp(`^${e}$`) } function jct(n, e) { return !!((e === "v4" || !e) && Act.test(n) || (e === "v6" || !e) && Ect.test(n)) } class gs extends rn { _parse(e) { if (this._def.coerce && (e.data = String(e.data)), this._getType(e) !== nt.string) { const a = this._getOrReturnCtx(e); return et(a, { code: Ve.invalid_type, expected: nt.string, received: a.parsedType }), Rt } const r = new Ri; let i; for (const a of this._def.checks) if (a.kind === "min") e.data.length < a.value && (i = this._getOrReturnCtx(e, i), et(i, { code: Ve.too_small, minimum: a.value, type: "string", inclusive: !0, exact: !1, message: a.message }), r.dirty()); else if (a.kind === "max") e.data.length > a.value && (i = this._getOrReturnCtx(e, i), et(i, { code: Ve.too_big, maximum: a.value, type: "string", inclusive: !0, exact: !1, message: a.message }), r.dirty()); else if (a.kind === "length") { const o = e.data.length > a.value, s = e.data.length < a.value; (o || s) && (i = this._getOrReturnCtx(e, i), o ? et(i, { code: Ve.too_big, maximum: a.value, type: "string", inclusive: !0, exact: !0, message: a.message }) : s && et(i, { code: Ve.too_small, minimum: a.value, type: "string", inclusive: !0, exact: !0, message: a.message }), r.dirty()) } else if (a.kind === "email") kct.test(e.data) || (i = this._getOrReturnCtx(e, i), et(i, { validation: "email", code: Ve.invalid_string, message: a.message }), r.dirty()); else if (a.kind === "emoji") DD || (DD = new RegExp(Cct, "u")), DD.test(e.data) || (i = this._getOrReturnCtx(e, i), et(i, { validation: "emoji", code: Ve.invalid_string, message: a.message }), r.dirty()); else if (a.kind === "uuid") xct.test(e.data) || (i = this._getOrReturnCtx(e, i), et(i, { validation: "uuid", code: Ve.invalid_string, message: a.message }), r.dirty()); else if (a.kind === "nanoid") Sct.test(e.data) || (i = this._getOrReturnCtx(e, i), et(i, { validation: "nanoid", code: Ve.invalid_string, message: a.message }), r.dirty()); else if (a.kind === "cuid") _ct.test(e.data) || (i = this._getOrReturnCtx(e, i), et(i, { validation: "cuid", code: Ve.invalid_string, message: a.message }), r.dirty()); else if (a.kind === "cuid2") bct.test(e.data) || (i = this._getOrReturnCtx(e, i), et(i, { validation: "cuid2", code: Ve.invalid_string, message: a.message }), r.dirty()); else if (a.kind === "ulid") wct.test(e.data) || (i = this._getOrReturnCtx(e, i), et(i, { validation: "ulid", code: Ve.invalid_string, message: a.message }), r.dirty()); else if (a.kind === "url") try { new URL(e.data) } catch { i = this._getOrReturnCtx(e, i), et(i, { validation: "url", code: Ve.invalid_string, message: a.message }), r.dirty() } else a.kind === "regex" ? (a.regex.lastIndex = 0, a.regex.test(e.data) || (i = this._getOrReturnCtx(e, i), et(i, { validation: "regex", code: Ve.invalid_string, message: a.message }), r.dirty())) : a.kind === "trim" ? e.data = e.data.trim() : a.kind === "includes" ? e.data.includes(a.value, a.position) || (i = this._getOrReturnCtx(e, i), et(i, { code: Ve.invalid_string, validation: { includes: a.value, position: a.position }, message: a.message }), r.dirty()) : a.kind === "toLowerCase" ? e.data = e.data.toLowerCase() : a.kind === "toUpperCase" ? e.data = e.data.toUpperCase() : a.kind === "startsWith" ? e.data.startsWith(a.value) || (i = this._getOrReturnCtx(e, i), et(i, { code: Ve.invalid_string, validation: { startsWith: a.value }, message: a.message }), r.dirty()) : a.kind === "endsWith" ? e.data.endsWith(a.value) || (i = this._getOrReturnCtx(e, i), et(i, { code: Ve.invalid_string, validation: { endsWith: a.value }, message: a.message }), r.dirty()) : a.kind === "datetime" ? ele(a).test(e.data) || (i = this._getOrReturnCtx(e, i), et(i, { code: Ve.invalid_string, validation: "datetime", message: a.message }), r.dirty()) : a.kind === "date" ? Oct.test(e.data) || (i = this._getOrReturnCtx(e, i), et(i, { code: Ve.invalid_string, validation: "date", message: a.message }), r.dirty()) : a.kind === "time" ? Dct(a).test(e.data) || (i = this._getOrReturnCtx(e, i), et(i, { code: Ve.invalid_string, validation: "time", message: a.message }), r.dirty()) : a.kind === "duration" ? Tct.test(e.data) || (i = this._getOrReturnCtx(e, i), et(i, { validation: "duration", code: Ve.invalid_string, message: a.message }), r.dirty()) : a.kind === "ip" ? jct(e.data, a.version) || (i = this._getOrReturnCtx(e, i), et(i, { validation: "ip", code: Ve.invalid_string, message: a.message }), r.dirty()) : a.kind === "base64" ? Mct.test(e.data) || (i = this._getOrReturnCtx(e, i), et(i, { validation: "base64", code: Ve.invalid_string, message: a.message }), r.dirty()) : bn.assertNever(a); return { status: r.value, value: e.data } } _regex(e, t, r) { return this.refinement(i => e.test(i), { validation: t, code: Ve.invalid_string, ...bt.errToObj(r) }) } _addCheck(e) { return new gs({ ...this._def, checks: [...this._def.checks, e] }) } email(e) { return this._addCheck({ kind: "email", ...bt.errToObj(e) }) } url(e) { return this._addCheck({ kind: "url", ...bt.errToObj(e) }) } emoji(e) { return this._addCheck({ kind: "emoji", ...bt.errToObj(e) }) } uuid(e) { return this._addCheck({ kind: "uuid", ...bt.errToObj(e) }) } nanoid(e) { return this._addCheck({ kind: "nanoid", ...bt.errToObj(e) }) } cuid(e) { return this._addCheck({ kind: "cuid", ...bt.errToObj(e) }) } cuid2(e) { return this._addCheck({ kind: "cuid2", ...bt.errToObj(e) }) } ulid(e) { return this._addCheck({ kind: "ulid", ...bt.errToObj(e) }) } base64(e) { return this._addCheck({ kind: "base64", ...bt.errToObj(e) }) } ip(e) { return this._addCheck({ kind: "ip", ...bt.errToObj(e) }) } datetime(e) { var t, r; return typeof e == "string" ? this._addCheck({ kind: "datetime", precision: null, offset: !1, local: !1, message: e }) : this._addCheck({ kind: "datetime", precision: typeof (e == null ? void 0 : e.precision) > "u" ? null : e == null ? void 0 : e.precision, offset: (t = e == null ? void 0 : e.offset) !== null && t !== void 0 ? t : !1, local: (r = e == null ? void 0 : e.local) !== null && r !== void 0 ? r : !1, ...bt.errToObj(e == null ? void 0 : e.message) }) } date(e) { return this._addCheck({ kind: "date", message: e }) } time(e) { return typeof e == "string" ? this._addCheck({ kind: "time", precision: null, message: e }) : this._addCheck({ kind: "time", precision: typeof (e == null ? void 0 : e.precision) > "u" ? null : e == null ? void 0 : e.precision, ...bt.errToObj(e == null ? void 0 : e.message) }) } duration(e) { return this._addCheck({ kind: "duration", ...bt.errToObj(e) }) } regex(e, t) { return this._addCheck({ kind: "regex", regex: e, ...bt.errToObj(t) }) } includes(e, t) { return this._addCheck({ kind: "includes", value: e, position: t == null ? void 0 : t.position, ...bt.errToObj(t == null ? void 0 : t.message) }) } startsWith(e, t) { return this._addCheck({ kind: "startsWith", value: e, ...bt.errToObj(t) }) } endsWith(e, t) { return this._addCheck({ kind: "endsWith", value: e, ...bt.errToObj(t) }) } min(e, t) { return this._addCheck({ kind: "min", value: e, ...bt.errToObj(t) }) } max(e, t) { return this._addCheck({ kind: "max", value: e, ...bt.errToObj(t) }) } length(e, t) { return this._addCheck({ kind: "length", value: e, ...bt.errToObj(t) }) } nonempty(e) { return this.min(1, bt.errToObj(e)) } trim() { return new gs({ ...this._def, checks: [...this._def.checks, { kind: "trim" }] }) } toLowerCase() { return new gs({ ...this._def, checks: [...this._def.checks, { kind: "toLowerCase" }] }) } toUpperCase() { return new gs({ ...this._def, checks: [...this._def.checks, { kind: "toUpperCase" }] }) } get isDatetime() { return !!this._def.checks.find(e => e.kind === "datetime") } get isDate() { return !!this._def.checks.find(e => e.kind === "date") } get isTime() { return !!this._def.checks.find(e => e.kind === "time") } get isDuration() { return !!this._def.checks.find(e => e.kind === "duration") } get isEmail() { return !!this._def.checks.find(e => e.kind === "email") } get isURL() { return !!this._def.checks.find(e => e.kind === "url") } get isEmoji() { return !!this._def.checks.find(e => e.kind === "emoji") } get isUUID() { return !!this._def.checks.find(e => e.kind === "uuid") } get isNANOID() { return !!this._def.checks.find(e => e.kind === "nanoid") } get isCUID() { return !!this._def.checks.find(e => e.kind === "cuid") } get isCUID2() { return !!this._def.checks.find(e => e.kind === "cuid2") } get isULID() { return !!this._def.checks.find(e => e.kind === "ulid") } get isIP() { return !!this._def.checks.find(e => e.kind === "ip") } get isBase64() { return !!this._def.checks.find(e => e.kind === "base64") } get minLength() { let e = null; for (const t of this._def.checks) t.kind === "min" && (e === null || t.value > e) && (e = t.value); return e } get maxLength() { let e = null; for (const t of this._def.checks) t.kind === "max" && (e === null || t.value < e) && (e = t.value); return e } } gs.create = n => { var e; return new gs({ checks: [], typeName: Pt.ZodString, coerce: (e = n == null ? void 0 : n.coerce) !== null && e !== void 0 ? e : !1, ...Wt(n) }) }; function Pct(n, e) { const t = (n.toString().split(".")[1] || "").length, r = (e.toString().split(".")[1] || "").length, i = t > r ? t : r, a = parseInt(n.toFixed(i).replace(".", "")), o = parseInt(e.toFixed(i).replace(".", "")); return a % o / Math.pow(10, i) } class Id extends rn { constructor() { super(...arguments), this.min = this.gte, this.max = this.lte, this.step = this.multipleOf } _parse(e) { if (this._def.coerce && (e.data = Number(e.data)), this._getType(e) !== nt.number) { const a = this._getOrReturnCtx(e); return et(a, { code: Ve.invalid_type, expected: nt.number, received: a.parsedType }), Rt } let r; const i = new Ri; for (const a of this._def.checks) a.kind === "int" ? bn.isInteger(e.data) || (r = this._getOrReturnCtx(e, r), et(r, { code: Ve.invalid_type, expected: "integer", received: "float", message: a.message }), i.dirty()) : a.kind === "min" ? (a.inclusive ? e.data < a.value : e.data <= a.value) && (r = this._getOrReturnCtx(e, r), et(r, { code: Ve.too_small, minimum: a.value, type: "number", inclusive: a.inclusive, exact: !1, message: a.message }), i.dirty()) : a.kind === "max" ? (a.inclusive ? e.data > a.value : e.data >= a.value) && (r = this._getOrReturnCtx(e, r), et(r, { code: Ve.too_big, maximum: a.value, type: "number", inclusive: a.inclusive, exact: !1, message: a.message }), i.dirty()) : a.kind === "multipleOf" ? Pct(e.data, a.value) !== 0 && (r = this._getOrReturnCtx(e, r), et(r, { code: Ve.not_multiple_of, multipleOf: a.value, message: a.message }), i.dirty()) : a.kind === "finite" ? Number.isFinite(e.data) || (r = this._getOrReturnCtx(e, r), et(r, { code: Ve.not_finite, message: a.message }), i.dirty()) : bn.assertNever(a); return { status: i.value, value: e.data } } gte(e, t) { return this.setLimit("min", e, !0, bt.toString(t)) } gt(e, t) { return this.setLimit("min", e, !1, bt.toString(t)) } lte(e, t) { return this.setLimit("max", e, !0, bt.toString(t)) } lt(e, t) { return this.setLimit("max", e, !1, bt.toString(t)) } setLimit(e, t, r, i) { return new Id({ ...this._def, checks: [...this._def.checks, { kind: e, value: t, inclusive: r, message: bt.toString(i) }] }) } _addCheck(e) { return new Id({ ...this._def, checks: [...this._def.checks, e] }) } int(e) { return this._addCheck({ kind: "int", message: bt.toString(e) }) } positive(e) { return this._addCheck({ kind: "min", value: 0, inclusive: !1, message: bt.toString(e) }) } negative(e) { return this._addCheck({ kind: "max", value: 0, inclusive: !1, message: bt.toString(e) }) } nonpositive(e) { return this._addCheck({ kind: "max", value: 0, inclusive: !0, message: bt.toString(e) }) } nonnegative(e) { return this._addCheck({ kind: "min", value: 0, inclusive: !0, message: bt.toString(e) }) } multipleOf(e, t) { return this._addCheck({ kind: "multipleOf", value: e, message: bt.toString(t) }) } finite(e) { return this._addCheck({ kind: "finite", message: bt.toString(e) }) } safe(e) { return this._addCheck({ kind: "min", inclusive: !0, value: Number.MIN_SAFE_INTEGER, message: bt.toString(e) })._addCheck({ kind: "max", inclusive: !0, value: Number.MAX_SAFE_INTEGER, message: bt.toString(e) }) } get minValue() { let e = null; for (const t of this._def.checks) t.kind === "min" && (e === null || t.value > e) && (e = t.value); return e } get maxValue() { let e = null; for (const t of this._def.checks) t.kind === "max" && (e === null || t.value < e) && (e = t.value); return e } get isInt() { return !!this._def.checks.find(e => e.kind === "int" || e.kind === "multipleOf" && bn.isInteger(e.value)) } get isFinite() { let e = null, t = null; for (const r of this._def.checks) { if (r.kind === "finite" || r.kind === "int" || r.kind === "multipleOf") return !0; r.kind === "min" ? (t === null || r.value > t) && (t = r.value) : r.kind === "max" && (e === null || r.value < e) && (e = r.value) } return Number.isFinite(t) && Number.isFinite(e) } } Id.create = n => new Id({ checks: [], typeName: Pt.ZodNumber, coerce: (n == null ? void 0 : n.coerce) || !1, ...Wt(n) }); class Ld extends rn { constructor() { super(...arguments), this.min = this.gte, this.max = this.lte } _parse(e) { if (this._def.coerce && (e.data = BigInt(e.data)), this._getType(e) !== nt.bigint) { const a = this._getOrReturnCtx(e); return et(a, { code: Ve.invalid_type, expected: nt.bigint, received: a.parsedType }), Rt } let r; const i = new Ri; for (const a of this._def.checks) a.kind === "min" ? (a.inclusive ? e.data < a.value : e.data <= a.value) && (r = this._getOrReturnCtx(e, r), et(r, { code: Ve.too_small, type: "bigint", minimum: a.value, inclusive: a.inclusive, message: a.message }), i.dirty()) : a.kind === "max" ? (a.inclusive ? e.data > a.value : e.data >= a.value) && (r = this._getOrReturnCtx(e, r), et(r, { code: Ve.too_big, type: "bigint", maximum: a.value, inclusive: a.inclusive, message: a.message }), i.dirty()) : a.kind === "multipleOf" ? e.data % a.value !== BigInt(0) && (r = this._getOrReturnCtx(e, r), et(r, { code: Ve.not_multiple_of, multipleOf: a.value, message: a.message }), i.dirty()) : bn.assertNever(a); return { status: i.value, value: e.data } } gte(e, t) { return this.setLimit("min", e, !0, bt.toString(t)) } gt(e, t) { return this.setLimit("min", e, !1, bt.toString(t)) } lte(e, t) { return this.setLimit("max", e, !0, bt.toString(t)) } lt(e, t) { return this.setLimit("max", e, !1, bt.toString(t)) } setLimit(e, t, r, i) { return new Ld({ ...this._def, checks: [...this._def.checks, { kind: e, value: t, inclusive: r, message: bt.toString(i) }] }) } _addCheck(e) { return new Ld({ ...this._def, checks: [...this._def.checks, e] }) } positive(e) { return this._addCheck({ kind: "min", value: BigInt(0), inclusive: !1, message: bt.toString(e) }) } negative(e) { return this._addCheck({ kind: "max", value: BigInt(0), inclusive: !1, message: bt.toString(e) }) } nonpositive(e) { return this._addCheck({ kind: "max", value: BigInt(0), inclusive: !0, message: bt.toString(e) }) } nonnegative(e) { return this._addCheck({ kind: "min", value: BigInt(0), inclusive: !0, message: bt.toString(e) }) } multipleOf(e, t) { return this._addCheck({ kind: "multipleOf", value: e, message: bt.toString(t) }) } get minValue() { let e = null; for (const t of this._def.checks) t.kind === "min" && (e === null || t.value > e) && (e = t.value); return e } get maxValue() { let e = null; for (const t of this._def.checks) t.kind === "max" && (e === null || t.value < e) && (e = t.value); return e } } Ld.create = n => { var e; return new Ld({ checks: [], typeName: Pt.ZodBigInt, coerce: (e = n == null ? void 0 : n.coerce) !== null && e !== void 0 ? e : !1, ...Wt(n) }) }; class F_ extends rn { _parse(e) { if (this._def.coerce && (e.data = !!e.data), this._getType(e) !== nt.boolean) { const r = this._getOrReturnCtx(e); return et(r, { code: Ve.invalid_type, expected: nt.boolean, received: r.parsedType }), Rt } return ia(e.data) } } F_.create = n => new F_({ typeName: Pt.ZodBoolean, coerce: (n == null ? void 0 : n.coerce) || !1, ...Wt(n) }); class Yh extends rn { _parse(e) { if (this._def.coerce && (e.data = new Date(e.data)), this._getType(e) !== nt.date) { const a = this._getOrReturnCtx(e); return et(a, { code: Ve.invalid_type, expected: nt.date, received: a.parsedType }), Rt } if (isNaN(e.data.getTime())) { const a = this._getOrReturnCtx(e); return et(a, { code: Ve.invalid_date }), Rt } const r = new Ri; let i; for (const a of this._def.checks) a.kind === "min" ? e.data.getTime() < a.value && (i = this._getOrReturnCtx(e, i), et(i, { code: Ve.too_small, message: a.message, inclusive: !0, exact: !1, minimum: a.value, type: "date" }), r.dirty()) : a.kind === "max" ? e.data.getTime() > a.value && (i = this._getOrReturnCtx(e, i), et(i, { code: Ve.too_big, message: a.message, inclusive: !0, exact: !1, maximum: a.value, type: "date" }), r.dirty()) : bn.assertNever(a); return { status: r.value, value: new Date(e.data.getTime()) } } _addCheck(e) { return new Yh({ ...this._def, checks: [...this._def.checks, e] }) } min(e, t) { return this._addCheck({ kind: "min", value: e.getTime(), message: bt.toString(t) }) } max(e, t) { return this._addCheck({ kind: "max", value: e.getTime(), message: bt.toString(t) }) } get minDate() { let e = null; for (const t of this._def.checks) t.kind === "min" && (e === null || t.value > e) && (e = t.value); return e != null ? new Date(e) : null } get maxDate() { let e = null; for (const t of this._def.checks) t.kind === "max" && (e === null || t.value < e) && (e = t.value); return e != null ? new Date(e) : null } } Yh.create = n => new Yh({ checks: [], coerce: (n == null ? void 0 : n.coerce) || !1, typeName: Pt.ZodDate, ...Wt(n) }); class FT extends rn { _parse(e) { if (this._getType(e) !== nt.symbol) { const r = this._getOrReturnCtx(e); return et(r, { code: Ve.invalid_type, expected: nt.symbol, received: r.parsedType }), Rt } return ia(e.data) } } FT.create = n => new FT({ typeName: Pt.ZodSymbol, ...Wt(n) }); class z_ extends rn { _parse(e) { if (this._getType(e) !== nt.undefined) { const r = this._getOrReturnCtx(e); return et(r, { code: Ve.invalid_type, expected: nt.undefined, received: r.parsedType }), Rt } return ia(e.data) } } z_.create = n => new z_({ typeName: Pt.ZodUndefined, ...Wt(n) }); class V_ extends rn { _parse(e) { if (this._getType(e) !== nt.null) { const r = this._getOrReturnCtx(e); return et(r, { code: Ve.invalid_type, expected: nt.null, received: r.parsedType }), Rt } return ia(e.data) } } V_.create = n => new V_({ typeName: Pt.ZodNull, ...Wt(n) }); class Lg extends rn { constructor() { super(...arguments), this._any = !0 } _parse(e) { return ia(e.data) } } Lg.create = n => new Lg({ typeName: Pt.ZodAny, ...Wt(n) }); class Oh extends rn { constructor() { super(...arguments), this._unknown = !0 } _parse(e) { return ia(e.data) } } Oh.create = n => new Oh({ typeName: Pt.ZodUnknown, ...Wt(n) }); class Bc extends rn { _parse(e) { const t = this._getOrReturnCtx(e); return et(t, { code: Ve.invalid_type, expected: nt.never, received: t.parsedType }), Rt } } Bc.create = n => new Bc({ typeName: Pt.ZodNever, ...Wt(n) }); class zT extends rn { _parse(e) { if (this._getType(e) !== nt.undefined) { const r = this._getOrReturnCtx(e); return et(r, { code: Ve.invalid_type, expected: nt.void, received: r.parsedType }), Rt } return ia(e.data) } } zT.create = n => new zT({ typeName: Pt.ZodVoid, ...Wt(n) }); class ws extends rn { _parse(e) { const { ctx: t, status: r } = this._processInputParams(e), i = this._def; if (t.parsedType !== nt.array) return et(t, { code: Ve.invalid_type, expected: nt.array, received: t.parsedType }), Rt; if (i.exactLength !== null) { const o = t.data.length > i.exactLength.value, s = t.data.length < i.exactLength.value; (o || s) && (et(t, { code: o ? Ve.too_big : Ve.too_small, minimum: s ? i.exactLength.value : void 0, maximum: o ? i.exactLength.value : void 0, type: "array", inclusive: !0, exact: !0, message: i.exactLength.message }), r.dirty()) } if (i.minLength !== null && t.data.length < i.minLength.value && (et(t, { code: Ve.too_small, minimum: i.minLength.value, type: "array", inclusive: !0, exact: !1, message: i.minLength.message }), r.dirty()), i.maxLength !== null && t.data.length > i.maxLength.value && (et(t, { code: Ve.too_big, maximum: i.maxLength.value, type: "array", inclusive: !0, exact: !1, message: i.maxLength.message }), r.dirty()), t.common.async) return Promise.all([...t.data].map((o, s) => i.type._parseAsync(new El(t, o, t.path, s)))).then(o => Ri.mergeArray(r, o)); const a = [...t.data].map((o, s) => i.type._parseSync(new El(t, o, t.path, s))); return Ri.mergeArray(r, a) } get element() { return this._def.type } min(e, t) { return new ws({ ...this._def, minLength: { value: e, message: bt.toString(t) } }) } max(e, t) { return new ws({ ...this._def, maxLength: { value: e, message: bt.toString(t) } }) } length(e, t) { return new ws({ ...this._def, exactLength: { value: e, message: bt.toString(t) } }) } nonempty(e) { return this.min(1, e) } } ws.create = (n, e) => new ws({ type: n, minLength: null, maxLength: null, exactLength: null, typeName: Pt.ZodArray, ...Wt(e) }); function Cm(n) { if (n instanceof sr) { const e = {}; for (const t in n.shape) { const r = n.shape[t]; e[t] = vl.create(Cm(r)) } return new sr({ ...n._def, shape: () => e }) } else return n instanceof ws ? new ws({ ...n._def, type: Cm(n.element) }) : n instanceof vl ? vl.create(Cm(n.unwrap())) : n instanceof Nd ? Nd.create(Cm(n.unwrap())) : n instanceof Ml ? Ml.create(n.items.map(e => Cm(e))) : n } class sr extends rn { constructor() { super(...arguments), this._cached = null, this.nonstrict = this.passthrough, this.augment = this.extend } _getCached() { if (this._cached !== null) return this._cached; const e = this._def.shape(), t = bn.objectKeys(e); return this._cached = { shape: e, keys: t } } _parse(e) { if (this._getType(e) !== nt.object) { const c = this._getOrReturnCtx(e); return et(c, { code: Ve.invalid_type, expected: nt.object, received: c.parsedType }), Rt } const { status: r, ctx: i } = this._processInputParams(e), { shape: a, keys: o } = this._getCached(), s = []; if (!(this._def.catchall instanceof Bc && this._def.unknownKeys === "strip")) for (const c in i.data) o.includes(c) || s.push(c); const l = []; for (const c of o) { const u = a[c], d = i.data[c]; l.push({ key: { status: "valid", value: c }, value: u._parse(new El(i, d, i.path, c)), alwaysSet: c in i.data }) } if (this._def.catchall instanceof Bc) { const c = this._def.unknownKeys; if (c === "passthrough") for (const u of s) l.push({ key: { status: "valid", value: u }, value: { status: "valid", value: i.data[u] } }); else if (c === "strict") s.length > 0 && (et(i, { code: Ve.unrecognized_keys, keys: s }), r.dirty()); else if (c !== "strip") throw new Error("Internal ZodObject error: invalid unknownKeys value.") } else { const c = this._def.catchall; for (const u of s) { const d = i.data[u]; l.push({ key: { status: "valid", value: u }, value: c._parse(new El(i, d, i.path, u)), alwaysSet: u in i.data }) } } return i.common.async ? Promise.resolve().then(async () => { const c = []; for (const u of l) { const d = await u.key, f = await u.value; c.push({ key: d, value: f, alwaysSet: u.alwaysSet }) } return c }).then(c => Ri.mergeObjectSync(r, c)) : Ri.mergeObjectSync(r, l) } get shape() { return this._def.shape() } strict(e) { return bt.errToObj, new sr({ ...this._def, unknownKeys: "strict", ...e !== void 0 ? { errorMap: (t, r) => { var i, a, o, s; const l = (o = (a = (i = this._def).errorMap) === null || a === void 0 ? void 0 : a.call(i, t, r).message) !== null && o !== void 0 ? o : r.defaultError; return t.code === "unrecognized_keys" ? { message: (s = bt.errToObj(e).message) !== null && s !== void 0 ? s : l } : { message: l } } } : {} }) } strip() { return new sr({ ...this._def, unknownKeys: "strip" }) } passthrough() { return new sr({ ...this._def, unknownKeys: "passthrough" }) } extend(e) { return new sr({ ...this._def, shape: () => ({ ...this._def.shape(), ...e }) }) } merge(e) { return new sr({ unknownKeys: e._def.unknownKeys, catchall: e._def.catchall, shape: () => ({ ...this._def.shape(), ...e._def.shape() }), typeName: Pt.ZodObject }) } setKey(e, t) { return this.augment({ [e]: t }) } catchall(e) { return new sr({ ...this._def, catchall: e }) } pick(e) { const t = {}; return bn.objectKeys(e).forEach(r => { e[r] && this.shape[r] && (t[r] = this.shape[r]) }), new sr({ ...this._def, shape: () => t }) } omit(e) { const t = {}; return bn.objectKeys(this.shape).forEach(r => { e[r] || (t[r] = this.shape[r]) }), new sr({ ...this._def, shape: () => t }) } deepPartial() { return Cm(this) } partial(e) { const t = {}; return bn.objectKeys(this.shape).forEach(r => { const i = this.shape[r]; e && !e[r] ? t[r] = i : t[r] = i.optional() }), new sr({ ...this._def, shape: () => t }) } required(e) { const t = {}; return bn.objectKeys(this.shape).forEach(r => { if (e && !e[r]) t[r] = this.shape[r]; else { let a = this.shape[r]; for (; a instanceof vl;)a = a._def.innerType; t[r] = a } }), new sr({ ...this._def, shape: () => t }) } keyof() { return tle(bn.objectKeys(this.shape)) } } sr.create = (n, e) => new sr({ shape: () => n, unknownKeys: "strip", catchall: Bc.create(), typeName: Pt.ZodObject, ...Wt(e) }); sr.strictCreate = (n, e) => new sr({ shape: () => n, unknownKeys: "strict", catchall: Bc.create(), typeName: Pt.ZodObject, ...Wt(e) }); sr.lazycreate = (n, e) => new sr({ shape: n, unknownKeys: "strip", catchall: Bc.create(), typeName: Pt.ZodObject, ...Wt(e) }); class H_ extends rn { _parse(e) { const { ctx: t } = this._processInputParams(e), r = this._def.options; function i(a) { for (const s of a) if (s.result.status === "valid") return s.result; for (const s of a) if (s.result.status === "dirty") return t.common.issues.push(...s.ctx.common.issues), s.result; const o = a.map(s => new Ga(s.ctx.common.issues)); return et(t, { code: Ve.invalid_union, unionErrors: o }), Rt } if (t.common.async) return Promise.all(r.map(async a => { const o = { ...t, common: { ...t.common, issues: [] }, parent: null }; return { result: await a._parseAsync({ data: t.data, path: t.path, parent: o }), ctx: o } })).then(i); { let a; const o = []; for (const l of r) { const c = { ...t, common: { ...t.common, issues: [] }, parent: null }, u = l._parseSync({ data: t.data, path: t.path, parent: c }); if (u.status === "valid") return u; u.status === "dirty" && !a && (a = { result: u, ctx: c }), c.common.issues.length && o.push(c.common.issues) } if (a) return t.common.issues.push(...a.ctx.common.issues), a.result; const s = o.map(l => new Ga(l)); return et(t, { code: Ve.invalid_union, unionErrors: s }), Rt } } get options() { return this._def.options } } H_.create = (n, e) => new H_({ options: n, typeName: Pt.ZodUnion, ...Wt(e) }); const tc = n => n instanceof W_ ? tc(n.schema) : n instanceof Os ? tc(n.innerType()) : n instanceof K_ ? [n.value] : n instanceof Rd ? n.options : n instanceof q_ ? bn.objectValues(n.enum) : n instanceof Y_ ? tc(n._def.innerType) : n instanceof z_ ? [void 0] : n instanceof V_ ? [null] : n instanceof vl ? [void 0, ...tc(n.unwrap())] : n instanceof Nd ? [null, ...tc(n.unwrap())] : n instanceof RB || n instanceof X_ ? tc(n.unwrap()) : n instanceof Z_ ? tc(n._def.innerType) : []; class LC extends rn { _parse(e) { const { ctx: t } = this._processInputParams(e); if (t.parsedType !== nt.object) return et(t, { code: Ve.invalid_type, expected: nt.object, received: t.parsedType }), Rt; const r = this.discriminator, i = t.data[r], a = this.optionsMap.get(i); return a ? t.common.async ? a._parseAsync({ data: t.data, path: t.path, parent: t }) : a._parseSync({ data: t.data, path: t.path, parent: t }) : (et(t, { code: Ve.invalid_union_discriminator, options: Array.from(this.optionsMap.keys()), path: [r] }), Rt) } get discriminator() { return this._def.discriminator } get options() { return this._def.options } get optionsMap() { return this._def.optionsMap } static create(e, t, r) { const i = new Map; for (const a of t) { const o = tc(a.shape[e]); if (!o.length) throw new Error(`A discriminator value for key \`${e}\` could not be extracted from all schema options`); for (const s of o) { if (i.has(s)) throw new Error(`Discriminator property ${String(e)} has duplicate value ${String(s)}`); i.set(s, a) } } return new LC({ typeName: Pt.ZodDiscriminatedUnion, discriminator: e, options: t, optionsMap: i, ...Wt(r) }) } } function wL(n, e) { const t = Lu(n), r = Lu(e); if (n === e) return { valid: !0, data: n }; if (t === nt.object && r === nt.object) { const i = bn.objectKeys(e), a = bn.objectKeys(n).filter(s => i.indexOf(s) !== -1), o = { ...n, ...e }; for (const s of a) { const l = wL(n[s], e[s]); if (!l.valid) return { valid: !1 }; o[s] = l.data } return { valid: !0, data: o } } else if (t === nt.array && r === nt.array) { if (n.length !== e.length) return { valid: !1 }; const i = []; for (let a = 0; a < n.length; a++) { const o = n[a], s = e[a], l = wL(o, s); if (!l.valid) return { valid: !1 }; i.push(l.data) } return { valid: !0, data: i } } else return t === nt.date && r === nt.date && +n == +e ? { valid: !0, data: n } : { valid: !1 } } class U_ extends rn { _parse(e) { const { status: t, ctx: r } = this._processInputParams(e), i = (a, o) => { if (_L(a) || _L(o)) return Rt; const s = wL(a.value, o.value); return s.valid ? ((bL(a) || bL(o)) && t.dirty(), { status: t.value, value: s.data }) : (et(r, { code: Ve.invalid_intersection_types }), Rt) }; return r.common.async ? Promise.all([this._def.left._parseAsync({ data: r.data, path: r.path, parent: r }), this._def.right._parseAsync({ data: r.data, path: r.path, parent: r })]).then(([a, o]) => i(a, o)) : i(this._def.left._parseSync({ data: r.data, path: r.path, parent: r }), this._def.right._parseSync({ data: r.data, path: r.path, parent: r })) } } U_.create = (n, e, t) => new U_({ left: n, right: e, typeName: Pt.ZodIntersection, ...Wt(t) }); class Ml extends rn { _parse(e) { const { status: t, ctx: r } = this._processInputParams(e); if (r.parsedType !== nt.array) return et(r, { code: Ve.invalid_type, expected: nt.array, received: r.parsedType }), Rt; if (r.data.length < this._def.items.length) return et(r, { code: Ve.too_small, minimum: this._def.items.length, inclusive: !0, exact: !1, type: "array" }), Rt; !this._def.rest && r.data.length > this._def.items.length && (et(r, { code: Ve.too_big, maximum: this._def.items.length, inclusive: !0, exact: !1, type: "array" }), t.dirty()); const a = [...r.data].map((o, s) => { const l = this._def.items[s] || this._def.rest; return l ? l._parse(new El(r, o, r.path, s)) : null }).filter(o => !!o); return r.common.async ? Promise.all(a).then(o => Ri.mergeArray(t, o)) : Ri.mergeArray(t, a) } get items() { return this._def.items } rest(e) { return new Ml({ ...this._def, rest: e }) } } Ml.create = (n, e) => { if (!Array.isArray(n)) throw new Error("You must pass an array of schemas to z.tuple([ ... ])"); return new Ml({ items: n, typeName: Pt.ZodTuple, rest: null, ...Wt(e) }) }; class G_ extends rn { get keySchema() { return this._def.keyType } get valueSchema() { return this._def.valueType } _parse(e) { const { status: t, ctx: r } = this._processInputParams(e); if (r.parsedType !== nt.object) return et(r, { code: Ve.invalid_type, expected: nt.object, received: r.parsedType }), Rt; const i = [], a = this._def.keyType, o = this._def.valueType; for (const s in r.data) i.push({ key: a._parse(new El(r, s, r.path, s)), value: o._parse(new El(r, r.data[s], r.path, s)), alwaysSet: s in r.data }); return r.common.async ? Ri.mergeObjectAsync(t, i) : Ri.mergeObjectSync(t, i) } get element() { return this._def.valueType } static create(e, t, r) { return t instanceof rn ? new G_({ keyType: e, valueType: t, typeName: Pt.ZodRecord, ...Wt(r) }) : new G_({ keyType: gs.create(), valueType: e, typeName: Pt.ZodRecord, ...Wt(t) }) } } class VT extends rn { get keySchema() { return this._def.keyType } get valueSchema() { return this._def.valueType } _parse(e) { const { status: t, ctx: r } = this._processInputParams(e); if (r.parsedType !== nt.map) return et(r, { code: Ve.invalid_type, expected: nt.map, received: r.parsedType }), Rt; const i = this._def.keyType, a = this._def.valueType, o = [...r.data.entries()].map(([s, l], c) => ({ key: i._parse(new El(r, s, r.path, [c, "key"])), value: a._parse(new El(r, l, r.path, [c, "value"])) })); if (r.common.async) { const s = new Map; return Promise.resolve().then(async () => { for (const l of o) { const c = await l.key, u = await l.value; if (c.status === "aborted" || u.status === "aborted") return Rt; (c.status === "dirty" || u.status === "dirty") && t.dirty(), s.set(c.value, u.value) } return { status: t.value, value: s } }) } else { const s = new Map; for (const l of o) { const c = l.key, u = l.value; if (c.status === "aborted" || u.status === "aborted") return Rt; (c.status === "dirty" || u.status === "dirty") && t.dirty(), s.set(c.value, u.value) } return { status: t.value, value: s } } } } VT.create = (n, e, t) => new VT({ valueType: e, keyType: n, typeName: Pt.ZodMap, ...Wt(t) }); class Zh extends rn { _parse(e) { const { status: t, ctx: r } = this._processInputParams(e); if (r.parsedType !== nt.set) return et(r, { code: Ve.invalid_type, expected: nt.set, received: r.parsedType }), Rt; const i = this._def; i.minSize !== null && r.data.size < i.minSize.value && (et(r, { code: Ve.too_small, minimum: i.minSize.value, type: "set", inclusive: !0, exact: !1, message: i.minSize.message }), t.dirty()), i.maxSize !== null && r.data.size > i.maxSize.value && (et(r, { code: Ve.too_big, maximum: i.maxSize.value, type: "set", inclusive: !0, exact: !1, message: i.maxSize.message }), t.dirty()); const a = this._def.valueType; function o(l) { const c = new Set; for (const u of l) { if (u.status === "aborted") return Rt; u.status === "dirty" && t.dirty(), c.add(u.value) } return { status: t.value, value: c } } const s = [...r.data.values()].map((l, c) => a._parse(new El(r, l, r.path, c))); return r.common.async ? Promise.all(s).then(l => o(l)) : o(s) } min(e, t) { return new Zh({ ...this._def, minSize: { value: e, message: bt.toString(t) } }) } max(e, t) { return new Zh({ ...this._def, maxSize: { value: e, message: bt.toString(t) } }) } size(e, t) { return this.min(e, t).max(e, t) } nonempty(e) { return this.min(1, e) } } Zh.create = (n, e) => new Zh({ valueType: n, minSize: null, maxSize: null, typeName: Pt.ZodSet, ...Wt(e) }); class tg extends rn { constructor() { super(...arguments), this.validate = this.implement } _parse(e) { const { ctx: t } = this._processInputParams(e); if (t.parsedType !== nt.function) return et(t, { code: Ve.invalid_type, expected: nt.function, received: t.parsedType }), Rt; function r(s, l) { return BT({ data: s, path: t.path, errorMaps: [t.common.contextualErrorMap, t.schemaErrorMap, NT(), Ig].filter(c => !!c), issueData: { code: Ve.invalid_arguments, argumentsError: l } }) } function i(s, l) { return BT({ data: s, path: t.path, errorMaps: [t.common.contextualErrorMap, t.schemaErrorMap, NT(), Ig].filter(c => !!c), issueData: { code: Ve.invalid_return_type, returnTypeError: l } }) } const a = { errorMap: t.common.contextualErrorMap }, o = t.data; if (this._def.returns instanceof Rg) { const s = this; return ia(async function (...l) { const c = new Ga([]), u = await s._def.args.parseAsync(l, a).catch(h => { throw c.addIssue(r(l, h)), c }), d = await Reflect.apply(o, this, u); return await s._def.returns._def.type.parseAsync(d, a).catch(h => { throw c.addIssue(i(d, h)), c }) }) } else { const s = this; return ia(function (...l) { const c = s._def.args.safeParse(l, a); if (!c.success) throw new Ga([r(l, c.error)]); const u = Reflect.apply(o, this, c.data), d = s._def.returns.safeParse(u, a); if (!d.success) throw new Ga([i(u, d.error)]); return d.data }) } } parameters() { return this._def.args } returnType() { return this._def.returns } args(...e) { return new tg({ ...this._def, args: Ml.create(e).rest(Oh.create()) }) } returns(e) { return new tg({ ...this._def, returns: e }) } implement(e) { return this.parse(e) } strictImplement(e) { return this.parse(e) } static create(e, t, r) { return new tg({ args: e || Ml.create([]).rest(Oh.create()), returns: t || Oh.create(), typeName: Pt.ZodFunction, ...Wt(r) }) } } class W_ extends rn { get schema() { return this._def.getter() } _parse(e) { const { ctx: t } = this._processInputParams(e); return this._def.getter()._parse({ data: t.data, path: t.path, parent: t }) } } W_.create = (n, e) => new W_({ getter: n, typeName: Pt.ZodLazy, ...Wt(e) }); class K_ extends rn { _parse(e) { if (e.data !== this._def.value) { const t = this._getOrReturnCtx(e); return et(t, { received: t.data, code: Ve.invalid_literal, expected: this._def.value }), Rt } return { status: "valid", value: e.data } } get value() { return this._def.value } } K_.create = (n, e) => new K_({ value: n, typeName: Pt.ZodLiteral, ...Wt(e) }); function tle(n, e) { return new Rd({ values: n, typeName: Pt.ZodEnum, ...Wt(e) }) } class Rd extends rn { constructor() { super(...arguments), Ny.set(this, void 0) } _parse(e) { if (typeof e.data != "string") { const t = this._getOrReturnCtx(e), r = this._def.values; return et(t, { expected: bn.joinValues(r), received: t.parsedType, code: Ve.invalid_type }), Rt } if ($T(this, Ny, "f") || Xse(this, Ny, new Set(this._def.values), "f"), !$T(this, Ny, "f").has(e.data)) { const t = this._getOrReturnCtx(e), r = this._def.values; return et(t, { received: t.data, code: Ve.invalid_enum_value, options: r }), Rt } return ia(e.data) } get options() { return this._def.values } get enum() { const e = {}; for (const t of this._def.values) e[t] = t; return e } get Values() { const e = {}; for (const t of this._def.values) e[t] = t; return e } get Enum() { const e = {}; for (const t of this._def.values) e[t] = t; return e } extract(e, t = this._def) { return Rd.create(e, { ...this._def, ...t }) } exclude(e, t = this._def) { return Rd.create(this.options.filter(r => !e.includes(r)), { ...this._def, ...t }) } } Ny = new WeakMap; Rd.create = tle; class q_ extends rn { constructor() { super(...arguments), By.set(this, void 0) } _parse(e) { const t = bn.getValidEnumValues(this._def.values), r = this._getOrReturnCtx(e); if (r.parsedType !== nt.string && r.parsedType !== nt.number) { const i = bn.objectValues(t); return et(r, { expected: bn.joinValues(i), received: r.parsedType, code: Ve.invalid_type }), Rt } if ($T(this, By, "f") || Xse(this, By, new Set(bn.getValidEnumValues(this._def.values)), "f"), !$T(this, By, "f").has(e.data)) { const i = bn.objectValues(t); return et(r, { received: r.data, code: Ve.invalid_enum_value, options: i }), Rt } return ia(e.data) } get enum() { return this._def.values } } By = new WeakMap; q_.create = (n, e) => new q_({ values: n, typeName: Pt.ZodNativeEnum, ...Wt(e) }); class Rg extends rn { unwrap() { return this._def.type } _parse(e) { const { ctx: t } = this._processInputParams(e); if (t.parsedType !== nt.promise && t.common.async === !1) return et(t, { code: Ve.invalid_type, expected: nt.promise, received: t.parsedType }), Rt; const r = t.parsedType === nt.promise ? t.data : Promise.resolve(t.data); return ia(r.then(i => this._def.type.parseAsync(i, { path: t.path, errorMap: t.common.contextualErrorMap }))) } } Rg.create = (n, e) => new Rg({ type: n, typeName: Pt.ZodPromise, ...Wt(e) }); class Os extends rn { innerType() { return this._def.schema } sourceType() { return this._def.schema._def.typeName === Pt.ZodEffects ? this._def.schema.sourceType() : this._def.schema } _parse(e) { const { status: t, ctx: r } = this._processInputParams(e), i = this._def.effect || null, a = { addIssue: o => { et(r, o), o.fatal ? t.abort() : t.dirty() }, get path() { return r.path } }; if (a.addIssue = a.addIssue.bind(a), i.type === "preprocess") { const o = i.transform(r.data, a); if (r.common.async) return Promise.resolve(o).then(async s => { if (t.value === "aborted") return Rt; const l = await this._def.schema._parseAsync({ data: s, path: r.path, parent: r }); return l.status === "aborted" ? Rt : l.status === "dirty" || t.value === "dirty" ? Rm(l.value) : l }); { if (t.value === "aborted") return Rt; const s = this._def.schema._parseSync({ data: o, path: r.path, parent: r }); return s.status === "aborted" ? Rt : s.status === "dirty" || t.value === "dirty" ? Rm(s.value) : s } } if (i.type === "refinement") { const o = s => { const l = i.refinement(s, a); if (r.common.async) return Promise.resolve(l); if (l instanceof Promise) throw new Error("Async refinement encountered during synchronous parse operation. Use .parseAsync instead."); return s }; if (r.common.async === !1) { const s = this._def.schema._parseSync({ data: r.data, path: r.path, parent: r }); return s.status === "aborted" ? Rt : (s.status === "dirty" && t.dirty(), o(s.value), { status: t.value, value: s.value }) } else return this._def.schema._parseAsync({ data: r.data, path: r.path, parent: r }).then(s => s.status === "aborted" ? Rt : (s.status === "dirty" && t.dirty(), o(s.value).then(() => ({ status: t.value, value: s.value })))) } if (i.type === "transform") if (r.common.async === !1) { const o = this._def.schema._parseSync({ data: r.data, path: r.path, parent: r }); if (!B_(o)) return o; const s = i.transform(o.value, a); if (s instanceof Promise) throw new Error("Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead."); return { status: t.value, value: s } } else return this._def.schema._parseAsync({ data: r.data, path: r.path, parent: r }).then(o => B_(o) ? Promise.resolve(i.transform(o.value, a)).then(s => ({ status: t.value, value: s })) : o); bn.assertNever(i) } } Os.create = (n, e, t) => new Os({ schema: n, typeName: Pt.ZodEffects, effect: e, ...Wt(t) }); Os.createWithPreprocess = (n, e, t) => new Os({ schema: e, effect: { type: "preprocess", transform: n }, typeName: Pt.ZodEffects, ...Wt(t) }); class vl extends rn { _parse(e) { return this._getType(e) === nt.undefined ? ia(void 0) : this._def.innerType._parse(e) } unwrap() { return this._def.innerType } } vl.create = (n, e) => new vl({ innerType: n, typeName: Pt.ZodOptional, ...Wt(e) }); class Nd extends rn { _parse(e) { return this._getType(e) === nt.null ? ia(null) : this._def.innerType._parse(e) } unwrap() { return this._def.innerType } } Nd.create = (n, e) => new Nd({ innerType: n, typeName: Pt.ZodNullable, ...Wt(e) }); class Y_ extends rn { _parse(e) { const { ctx: t } = this._processInputParams(e); let r = t.data; return t.parsedType === nt.undefined && (r = this._def.defaultValue()), this._def.innerType._parse({ data: r, path: t.path, parent: t }) } removeDefault() { return this._def.innerType } } Y_.create = (n, e) => new Y_({ innerType: n, typeName: Pt.ZodDefault, defaultValue: typeof e.default == "function" ? e.default : () => e.default, ...Wt(e) }); class Z_ extends rn { _parse(e) { const { ctx: t } = this._processInputParams(e), r = { ...t, common: { ...t.common, issues: [] } }, i = this._def.innerType._parse({ data: r.data, path: r.path, parent: { ...r } }); return $_(i) ? i.then(a => ({ status: "valid", value: a.status === "valid" ? a.value : this._def.catchValue({ get error() { return new Ga(r.common.issues) }, input: r.data }) })) : { status: "valid", value: i.status === "valid" ? i.value : this._def.catchValue({ get error() { return new Ga(r.common.issues) }, input: r.data }) } } removeCatch() { return this._def.innerType } } Z_.create = (n, e) => new Z_({ innerType: n, typeName: Pt.ZodCatch, catchValue: typeof e.catch == "function" ? e.catch : () => e.catch, ...Wt(e) }); class HT extends rn { _parse(e) { if (this._getType(e) !== nt.nan) { const r = this._getOrReturnCtx(e); return et(r, { code: Ve.invalid_type, expected: nt.nan, received: r.parsedType }), Rt } return { status: "valid", value: e.data } } } HT.create = n => new HT({ typeName: Pt.ZodNaN, ...Wt(n) }); const Ict = Symbol("zod_brand"); class RB extends rn { _parse(e) { const { ctx: t } = this._processInputParams(e), r = t.data; return this._def.type._parse({ data: r, path: t.path, parent: t }) } unwrap() { return this._def.type } } class Fb extends rn { _parse(e) { const { status: t, ctx: r } = this._processInputParams(e); if (r.common.async) return (async () => { const a = await this._def.in._parseAsync({ data: r.data, path: r.path, parent: r }); return a.status === "aborted" ? Rt : a.status === "dirty" ? (t.dirty(), Rm(a.value)) : this._def.out._parseAsync({ data: a.value, path: r.path, parent: r }) })(); { const i = this._def.in._parseSync({ data: r.data, path: r.path, parent: r }); return i.status === "aborted" ? Rt : i.status === "dirty" ? (t.dirty(), { status: "dirty", value: i.value }) : this._def.out._parseSync({ data: i.value, path: r.path, parent: r }) } } static create(e, t) { return new Fb({ in: e, out: t, typeName: Pt.ZodPipeline }) } } class X_ extends rn { _parse(e) { const t = this._def.innerType._parse(e), r = i => (B_(i) && (i.value = Object.freeze(i.value)), i); return $_(t) ? t.then(i => r(i)) : r(t) } unwrap() { return this._def.innerType } } X_.create = (n, e) => new X_({ innerType: n, typeName: Pt.ZodReadonly, ...Wt(e) }); function nle(n, e = {}, t) { return n ? Lg.create().superRefine((r, i) => { var a, o; if (!n(r)) { const s = typeof e == "function" ? e(r) : typeof e == "string" ? { message: e } : e, l = (o = (a = s.fatal) !== null && a !== void 0 ? a : t) !== null && o !== void 0 ? o : !0, c = typeof s == "string" ? { message: s } : s; i.addIssue({ code: "custom", ...c, fatal: l }) } }) : Lg.create() } const Lct = { object: sr.lazycreate }; var Pt; (function (n) { n.ZodString = "ZodString", n.ZodNumber = "ZodNumber", n.ZodNaN = "ZodNaN", n.ZodBigInt = "ZodBigInt", n.ZodBoolean = "ZodBoolean", n.ZodDate = "ZodDate", n.ZodSymbol = "ZodSymbol", n.ZodUndefined = "ZodUndefined", n.ZodNull = "ZodNull", n.ZodAny = "ZodAny", n.ZodUnknown = "ZodUnknown", n.ZodNever = "ZodNever", n.ZodVoid = "ZodVoid", n.ZodArray = "ZodArray", n.ZodObject = "ZodObject", n.ZodUnion = "ZodUnion", n.ZodDiscriminatedUnion = "ZodDiscriminatedUnion", n.ZodIntersection = "ZodIntersection", n.ZodTuple = "ZodTuple", n.ZodRecord = "ZodRecord", n.ZodMap = "ZodMap", n.ZodSet = "ZodSet", n.ZodFunction = "ZodFunction", n.ZodLazy = "ZodLazy", n.ZodLiteral = "ZodLiteral", n.ZodEnum = "ZodEnum", n.ZodEffects = "ZodEffects", n.ZodNativeEnum = "ZodNativeEnum", n.ZodOptional = "ZodOptional", n.ZodNullable = "ZodNullable", n.ZodDefault = "ZodDefault", n.ZodCatch = "ZodCatch", n.ZodPromise = "ZodPromise", n.ZodBranded = "ZodBranded", n.ZodPipeline = "ZodPipeline", n.ZodReadonly = "ZodReadonly" })(Pt || (Pt = {})); const Rct = (n, e = { message: `Input not instance of ${n.name}` }) => nle(t => t instanceof n, e), rle = gs.create, ile = Id.create, Nct = HT.create, Bct = Ld.create, ale = F_.create, $ct = Yh.create, Fct = FT.create, zct = z_.create, Vct = V_.create, Hct = Lg.create, Uct = Oh.create, Gct = Bc.create, Wct = zT.create, Kct = ws.create, qct = sr.create, Yct = sr.strictCreate, Zct = H_.create, Xct = LC.create, Jct = U_.create, Qct = Ml.create, eut = G_.create, tut = VT.create, nut = Zh.create, rut = tg.create, iut = W_.create, aut = K_.create, out = Rd.create, sut = q_.create, lut = Rg.create, $W = Os.create, cut = vl.create, uut = Nd.create, dut = Os.createWithPreprocess, fut = Fb.create, hut = () => rle().optional(), put = () => ile().optional(), mut = () => ale().optional(), gut = { string: n => gs.create({ ...n, coerce: !0 }), number: n => Id.create({ ...n, coerce: !0 }), boolean: n => F_.create({ ...n, coerce: !0 }), bigint: n => Ld.create({ ...n, coerce: !0 }), date: n => Yh.create({ ...n, coerce: !0 }) }, vut = Rt; var yut = Object.freeze({ __proto__: null, defaultErrorMap: Ig, setErrorMap: vct, getErrorMap: NT, makeIssue: BT, EMPTY_PATH: yct, addIssueToContext: et, ParseStatus: Ri, INVALID: Rt, DIRTY: Rm, OK: ia, isAborted: _L, isDirty: bL, isValid: B_, isAsync: $_, get util() { return bn }, get objectUtil() { return yL }, ZodParsedType: nt, getParsedType: Lu, ZodType: rn, datetimeRegex: ele, ZodString: gs, ZodNumber: Id, ZodBigInt: Ld, ZodBoolean: F_, ZodDate: Yh, ZodSymbol: FT, ZodUndefined: z_, ZodNull: V_, ZodAny: Lg, ZodUnknown: Oh, ZodNever: Bc, ZodVoid: zT, ZodArray: ws, ZodObject: sr, ZodUnion: H_, ZodDiscriminatedUnion: LC, ZodIntersection: U_, ZodTuple: Ml, ZodRecord: G_, ZodMap: VT, ZodSet: Zh, ZodFunction: tg, ZodLazy: W_, ZodLiteral: K_, ZodEnum: Rd, ZodNativeEnum: q_, ZodPromise: Rg, ZodEffects: Os, ZodTransformer: Os, ZodOptional: vl, ZodNullable: Nd, ZodDefault: Y_, ZodCatch: Z_, ZodNaN: HT, BRAND: Ict, ZodBranded: RB, ZodPipeline: Fb, ZodReadonly: X_, custom: nle, Schema: rn, ZodSchema: rn, late: Lct, get ZodFirstPartyTypeKind() { return Pt }, coerce: gut, any: Hct, array: Kct, bigint: Bct, boolean: ale, date: $ct, discriminatedUnion: Xct, effect: $W, enum: out, function: rut, instanceof: Rct, intersection: Jct, lazy: iut, literal: aut, map: tut, nan: Nct, nativeEnum: sut, never: Gct, null: Vct, nullable: uut, number: ile, object: qct, oboolean: mut, onumber: put, optional: cut, ostring: hut, pipeline: fut, preprocess: dut, promise: lut, record: eut, set: nut, strictObject: Yct, string: rle, symbol: Fct, transformer: $W, tuple: Qct, undefined: zct, union: Zct, unknown: Uct, void: Wct, NEVER: vut, ZodIssueCode: Ve, quotelessJson: gct, ZodError: Ga }); const _ut = {}, but = { width: "16", height: "16", viewBox: "0 0 16 16", fill: "none", xmlns: "http://www.w3.org/2000/svg" }; function wut(n, e) { return Z(), ye("svg", but, e[0] || (e[0] = [re("path", { "fill-rule": "evenodd", "clip-rule": "evenodd", d: "M1.99756 4.12305C1.99756 3.8469 2.22142 3.62305 2.49756 3.62305H5V4.5875C5 4.86364 5.22386 5.0875 5.5 5.0875C5.77614 5.0875 6 4.86364 6 4.5875V3.62305L13.5023 3.62305C13.7784 3.62305 14.0023 3.84691 14.0023 4.12305V5.53459C12.9897 5.91326 12.2683 6.88902 12.2683 8.03388C12.2683 9.17875 12.9897 10.1545 14.0023 10.5332V11.8766C14.0023 12.1527 13.7784 12.3766 13.5023 12.3766H6V11.4125C6 11.1364 5.77614 10.9125 5.5 10.9125C5.22386 10.9125 5 11.1364 5 11.4125V12.3766H2.49756C2.22142 12.3766 1.99756 12.1527 1.99756 11.8766V10.5332C3.01017 10.1545 3.73152 9.17875 3.73152 8.03388C3.73152 6.88816 3.01009 5.91306 1.99756 5.53456L1.99756 4.12305ZM2.49756 2.62305C1.66913 2.62305 0.997559 3.29462 0.997559 4.12305L0.997559 5.90978C0.997559 6.14752 1.16496 6.35238 1.39793 6.39975C2.15906 6.55451 2.73152 7.22751 2.73152 8.03388C2.73152 8.83951 2.15894 9.51328 1.39793 9.66802C1.16496 9.71539 0.997559 9.92025 0.997559 10.158L0.997559 11.8766C0.997559 12.705 1.66913 13.3766 2.49756 13.3766H13.5023C14.3307 13.3766 15.0023 12.705 15.0023 11.8766V10.158C15.0023 9.92025 14.8349 9.71539 14.6019 9.66802C13.8409 9.51328 13.2683 8.83951 13.2683 8.03388C13.2683 7.22826 13.8409 6.55449 14.6019 6.39975C14.8349 6.35238 15.0023 6.14752 15.0023 5.90978V4.12305C15.0023 3.29462 14.3307 2.62305 13.5023 2.62305L2.49756 2.62305ZM6 6.5375C6 6.26136 5.77614 6.0375 5.5 6.0375C5.22386 6.0375 5 6.26136 5 6.5375V9.4625C5 9.73864 5.22386 9.9625 5.5 9.9625C5.77614 9.9625 6 9.73864 6 9.4625V6.5375Z", fill: "currentColor" }, null, -1)])) } const xut = yn(_ut, [["render", wut]]); function uft(n) { return /^(([^<>()[\]\\.,;:\s@"]+(\.[^<>()[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/.test(n) } function dft(n) { return yut.string().email().safeParse(n).success } function fft(n, e) { return q1e(n, e || "DD-MM-YYYY HH:mm:ss").value } function hft(n) { return ywe(n).value } const pft = "ddd, MMM D, YYYY h:mm A"; function mft(n) { const e = Math.floor(n / 86400), t = Math.floor(n % (3600 * 24) / 3600), r = Math.floor(n % 3600 / 60), i = Math.floor(n % 60); let a = ""; return e > 0 && (a += `${e}d `), (t > 0 || e > 0) && (a += `${t}h `), (r > 0 || t > 0 || e > 0) && (a += `${r}m `), a += `${i}s`, a.trim() } const Sut = he(!1); async function gft(n = "", e = "Copied to clipboard") { if (navigator.clipboard && window.isSecureContext) await navigator.clipboard.writeText(n); else { let t = document.createElement("input"); document.querySelector("body").appendChild(t), t.value = n, t.select(), document.execCommand("copy"), t.remove() } fs.success(e) } const vft = ["Paragraph", ["Heading 2", "Heading 3", "Heading 4", "Heading 5", "Heading 6"], "Separator", "Bold", "Italic", "Separator", "Bullet List", "Numbered List", "Separator", "Align Left", "Align Center", "Align Right", "FontColor", "Separator", "Image", "Video", "Link", "Blockquote", "Code", "Horizontal Rule", ["InsertTable", "AddColumnBefore", "AddColumnAfter", "DeleteColumn", "AddRowBefore", "AddRowAfter", "DeleteRow", "MergeCells", "SplitCell", "ToggleHeaderColumn", "ToggleHeaderRow", "ToggleHeaderCell", "DeleteTable"]]; function yft(n) { return new DOMParser().parseFromString(n, "text/html").body.textContent === "" } function _ft() { return "ontouchstart" in document.documentElement } function Tut(n) { return mct.map(t => t.emoji).includes(n) } function bft(n) { return Tut(n) ? Gt("div", n) : n || dn(xut) } function wft(n) { const e = NW(), t = NW.tz(n), r = e.diff(t, "second"), i = e.diff(t, "minute"), a = e.diff(t, "hour"), o = e.diff(t, "day"), s = e.diff(t, "week"), l = e.diff(t, "month"), c = e.diff(t, "year"); return r < 60 ? `${r} s` : i < 60 ? `${i} m` : a < 24 ? `${a} h` : o < 7 ? `${o} d` : s < 4 ? `${s} w` : l < 12 ? `${l} M` : `${c}Y` } function kut(n) { return /[\u0600-\u06FF]/.test(n) } function xft(n) { const e = { default: "!font-[InterVar]", arabic: "!font-[system-ui]" }; let t = "default"; return kut(n) && (t = "arabic"), e[t] } const { isMobileView: Cut } = fct(), NB = "/login?redirect-to=/helpdesk", Aut = [{ path: "/", name: "Home", redirect: "/tickets" }, { path: "/tickets", name: "TicketsAgent", component: () => _n(() => import("./Tickets-3f26a831.js"), ["assets/Tickets-3f26a831.js", "assets/more-horizontal-b561c647.js", "assets/dayjs-8f71cd34.js", "assets/more-horizontal-93e77833.css", "assets/knowledgeBase-de4d1c97.js", "assets/ListViewBuilder.vue_vue_type_script_setup_true_lang-23f24b4c.js", "assets/Dropdown.vue_vue_type_script_setup_true_lang-20398480.js", "assets/StarRating.vue_vue_type_script_setup_true_lang-87d7ba3b.js", "assets/FadedScrollableDiv.vue_vue_type_script_setup_true_lang-897d9728.js", "assets/Avatar.vue_vue_type_script_setup_true_lang-33c4215a.js", "assets/DateRangePicker.vue_vue_type_script_setup_true_lang-fc0fa242.js", "assets/Link-5130f40e.js", "assets/globalStore-842ad0ec.js", "assets/EmptyState.vue_vue_type_script_setup_true_lang-93f57bdf.js", "assets/ticketStatus-b2a972bb.js", "assets/Dropdown-a6c1fbb4.js"]) }, { path: "/tickets/:ticketId", name: "TicketAgent", component: () => dct(Object.assign({ "../pages/ticket/MobileTicketAgent.vue": () => _n(() => import("./MobileTicketAgent-c728ad52.js"), ["assets/MobileTicketAgent-c728ad52.js", "assets/TicketFeedback.vue_vue_type_script_setup_true_lang-525e5c2e.js", "assets/StarRating.vue_vue_type_script_setup_true_lang-87d7ba3b.js", "assets/TicketAgentFields-bddea162.js", "assets/Dropdown.vue_vue_type_script_setup_true_lang-20398480.js", "assets/more-horizontal-b561c647.js", "assets/dayjs-8f71cd34.js", "assets/more-horizontal-93e77833.css", "assets/knowledgeBase-de4d1c97.js", "assets/AttachmentItem.vue_vue_type_script_setup_true_lang-f98cb03f.js", "assets/FileUploader-3bc7c8ba.js", "assets/TextEditor-bf30f06f.js", "assets/UserAvatar.vue_vue_type_script_setup_true_lang-73349f36.js", "assets/Avatar.vue_vue_type_script_setup_true_lang-33c4215a.js", "assets/Autocomplete-3aa3344b.js", "assets/EmailContent-821cc341.js", "assets/FadedScrollableDiv.vue_vue_type_script_setup_true_lang-897d9728.js", "assets/Link-5130f40e.js", "assets/TicketAgentFields-f6f36d7f.css", "assets/formCustomisation-44f18b9b.js", "assets/Breadcrumbs.vue_vue_type_script_setup_true_lang-04848fc3.js", "assets/ticketStatus-b2a972bb.js", "assets/globalStore-842ad0ec.js", "assets/merge-149ec802.js"]), "../pages/ticket/TicketAgent.vue": () => _n(() => import("./TicketAgent-dedfc1d3.js"), ["assets/TicketAgent-dedfc1d3.js", "assets/formCustomisation-44f18b9b.js", "assets/Dropdown.vue_vue_type_script_setup_true_lang-20398480.js", "assets/Breadcrumbs.vue_vue_type_script_setup_true_lang-04848fc3.js", "assets/TicketAgentFields-bddea162.js", "assets/more-horizontal-b561c647.js", "assets/dayjs-8f71cd34.js", "assets/more-horizontal-93e77833.css", "assets/knowledgeBase-de4d1c97.js", "assets/AttachmentItem.vue_vue_type_script_setup_true_lang-f98cb03f.js", "assets/FileUploader-3bc7c8ba.js", "assets/TextEditor-bf30f06f.js", "assets/TicketFeedback.vue_vue_type_script_setup_true_lang-525e5c2e.js", "assets/StarRating.vue_vue_type_script_setup_true_lang-87d7ba3b.js", "assets/UserAvatar.vue_vue_type_script_setup_true_lang-73349f36.js", "assets/Avatar.vue_vue_type_script_setup_true_lang-33c4215a.js", "assets/Autocomplete-3aa3344b.js", "assets/EmailContent-821cc341.js", "assets/FadedScrollableDiv.vue_vue_type_script_setup_true_lang-897d9728.js", "assets/Link-5130f40e.js", "assets/TicketAgentFields-f6f36d7f.css", "assets/ticketStatus-b2a972bb.js", "assets/globalStore-842ad0ec.js", "assets/Dropdown-a6c1fbb4.js", "assets/merge-149ec802.js", "assets/TicketAgent-9693e332.css"]), "../pages/ticket/TicketBreadcrumbs.vue": () => _n(() => import("./TicketBreadcrumbs-04cc82ac.js"), ["assets/TicketBreadcrumbs-04cc82ac.js", "assets/Breadcrumbs.vue_vue_type_script_setup_true_lang-04848fc3.js", "assets/Dropdown.vue_vue_type_script_setup_true_lang-20398480.js", "assets/more-horizontal-b561c647.js", "assets/dayjs-8f71cd34.js", "assets/more-horizontal-93e77833.css", "assets/knowledgeBase-de4d1c97.js", "assets/symbols-7dbf6ecf.js"]), "../pages/ticket/TicketCommunication.vue": () => _n(() => import("./TicketCommunication-f9351f42.js"), ["assets/TicketCommunication-f9351f42.js", "assets/TicketCommunication.vue_vue_type_script_setup_true_lang-513143c6.js", "assets/EmailContent-821cc341.js", "assets/AttachmentItem.vue_vue_type_script_setup_true_lang-f98cb03f.js", "assets/more-horizontal-b561c647.js", "assets/dayjs-8f71cd34.js", "assets/more-horizontal-93e77833.css", "assets/UserAvatar.vue_vue_type_script_setup_true_lang-73349f36.js", "assets/Avatar.vue_vue_type_script_setup_true_lang-33c4215a.js", "assets/knowledgeBase-de4d1c97.js", "assets/index-587a74f3.js"]), "../pages/ticket/TicketConversation.vue": () => _n(() => import("./TicketConversation-4cb06631.js"), ["assets/TicketConversation-4cb06631.js", "assets/TicketConversation.vue_vue_type_script_setup_true_lang-a31c238b.js", "assets/dayjs-8f71cd34.js", "assets/Avatar.vue_vue_type_script_setup_true_lang-33c4215a.js", "assets/TicketCommunication.vue_vue_type_script_setup_true_lang-513143c6.js", "assets/EmailContent-821cc341.js", "assets/AttachmentItem.vue_vue_type_script_setup_true_lang-f98cb03f.js", "assets/more-horizontal-b561c647.js", "assets/more-horizontal-93e77833.css", "assets/UserAvatar.vue_vue_type_script_setup_true_lang-73349f36.js", "assets/knowledgeBase-de4d1c97.js", "assets/index-587a74f3.js", "assets/symbols-7dbf6ecf.js"]), "../pages/ticket/TicketCustomer.vue": () => _n(() => import("./TicketCustomer-a1b8310f.js"), ["assets/TicketCustomer-a1b8310f.js", "assets/formCustomisation-44f18b9b.js", "assets/Dropdown.vue_vue_type_script_setup_true_lang-20398480.js", "assets/Breadcrumbs.vue_vue_type_script_setup_true_lang-04848fc3.js", "assets/more-horizontal-b561c647.js", "assets/dayjs-8f71cd34.js", "assets/more-horizontal-93e77833.css", "assets/knowledgeBase-de4d1c97.js", "assets/globalStore-842ad0ec.js", "assets/TicketFeedback.vue_vue_type_script_setup_true_lang-525e5c2e.js", "assets/StarRating.vue_vue_type_script_setup_true_lang-87d7ba3b.js", "assets/symbols-7dbf6ecf.js", "assets/Avatar.vue_vue_type_script_setup_true_lang-33c4215a.js", "assets/TicketConversation.vue_vue_type_script_setup_true_lang-a31c238b.js", "assets/TicketCommunication.vue_vue_type_script_setup_true_lang-513143c6.js", "assets/EmailContent-821cc341.js", "assets/AttachmentItem.vue_vue_type_script_setup_true_lang-f98cb03f.js", "assets/UserAvatar.vue_vue_type_script_setup_true_lang-73349f36.js", "assets/index-587a74f3.js", "assets/TicketCustomerTemplateFields.vue_vue_type_script_setup_true_lang-980b5ad0.js", "assets/TicketFeedback.vue_vue_type_script_setup_true_lang-ca6ffb0e.js", "assets/TicketTextEditor.vue_vue_type_script_setup_true_lang-d737e6e9.js", "assets/FileUploader-3bc7c8ba.js", "assets/TextEditor-bf30f06f.js"]), "../pages/ticket/TicketCustomerTemplateFields.vue": () => _n(() => import("./TicketCustomerTemplateFields-651dc4a2.js"), ["assets/TicketCustomerTemplateFields-651dc4a2.js", "assets/TicketCustomerTemplateFields.vue_vue_type_script_setup_true_lang-980b5ad0.js", "assets/symbols-7dbf6ecf.js", "assets/dayjs-8f71cd34.js"]), "../pages/ticket/TicketFeedback.vue": () => _n(() => import("./TicketFeedback-1e7fead9.js"), ["assets/TicketFeedback-1e7fead9.js", "assets/TicketFeedback.vue_vue_type_script_setup_true_lang-ca6ffb0e.js", "assets/more-horizontal-b561c647.js", "assets/dayjs-8f71cd34.js", "assets/more-horizontal-93e77833.css", "assets/StarRating.vue_vue_type_script_setup_true_lang-87d7ba3b.js", "assets/knowledgeBase-de4d1c97.js", "assets/symbols-7dbf6ecf.js"]), "../pages/ticket/TicketNew.vue": () => _n(() => import("./TicketNew-64253468.js"), ["assets/TicketNew-64253468.js", "assets/formCustomisation-44f18b9b.js", "assets/Dropdown.vue_vue_type_script_setup_true_lang-20398480.js", "assets/Breadcrumbs.vue_vue_type_script_setup_true_lang-04848fc3.js", "assets/more-horizontal-b561c647.js", "assets/dayjs-8f71cd34.js", "assets/more-horizontal-93e77833.css", "assets/knowledgeBase-de4d1c97.js", "assets/Autocomplete-3aa3344b.js", "assets/Link-5130f40e.js", "assets/globalStore-842ad0ec.js", "assets/index-587a74f3.js", "assets/SearchArticles.vue_vue_type_script_setup_true_lang-a1e3621d.js", "assets/TicketTextEditor.vue_vue_type_script_setup_true_lang-d737e6e9.js", "assets/AttachmentItem.vue_vue_type_script_setup_true_lang-f98cb03f.js", "assets/FileUploader-3bc7c8ba.js", "assets/TextEditor-bf30f06f.js", "assets/UserAvatar.vue_vue_type_script_setup_true_lang-73349f36.js", "assets/Avatar.vue_vue_type_script_setup_true_lang-33c4215a.js"]), "../pages/ticket/TicketTextEditor.vue": () => _n(() => import("./TicketTextEditor-a13ba1ca.js"), ["assets/TicketTextEditor-a13ba1ca.js", "assets/TicketTextEditor.vue_vue_type_script_setup_true_lang-d737e6e9.js", "assets/AttachmentItem.vue_vue_type_script_setup_true_lang-f98cb03f.js", "assets/more-horizontal-b561c647.js", "assets/dayjs-8f71cd34.js", "assets/more-horizontal-93e77833.css", "assets/FileUploader-3bc7c8ba.js", "assets/TextEditor-bf30f06f.js", "assets/UserAvatar.vue_vue_type_script_setup_true_lang-73349f36.js", "assets/Avatar.vue_vue_type_script_setup_true_lang-33c4215a.js", "assets/knowledgeBase-de4d1c97.js"]), "../pages/ticket/Tickets.vue": () => _n(() => import("./Tickets-3f26a831.js"), ["assets/Tickets-3f26a831.js", "assets/more-horizontal-b561c647.js", "assets/dayjs-8f71cd34.js", "assets/more-horizontal-93e77833.css", "assets/knowledgeBase-de4d1c97.js", "assets/ListViewBuilder.vue_vue_type_script_setup_true_lang-23f24b4c.js", "assets/Dropdown.vue_vue_type_script_setup_true_lang-20398480.js", "assets/StarRating.vue_vue_type_script_setup_true_lang-87d7ba3b.js", "assets/FadedScrollableDiv.vue_vue_type_script_setup_true_lang-897d9728.js", "assets/Avatar.vue_vue_type_script_setup_true_lang-33c4215a.js", "assets/DateRangePicker.vue_vue_type_script_setup_true_lang-fc0fa242.js", "assets/Link-5130f40e.js", "assets/globalStore-842ad0ec.js", "assets/EmptyState.vue_vue_type_script_setup_true_lang-93f57bdf.js", "assets/ticketStatus-b2a972bb.js", "assets/Dropdown-a6c1fbb4.js"]) }), `../pages/ticket/${Eut("TicketAgent")}.vue`), props: !0 }, { path: "/tickets/new/:templateId?", name: "TicketAgentNew", component: () => _n(() => import("./TicketNew-64253468.js"), ["assets/TicketNew-64253468.js", "assets/formCustomisation-44f18b9b.js", "assets/Dropdown.vue_vue_type_script_setup_true_lang-20398480.js", "assets/Breadcrumbs.vue_vue_type_script_setup_true_lang-04848fc3.js", "assets/more-horizontal-b561c647.js", "assets/dayjs-8f71cd34.js", "assets/more-horizontal-93e77833.css", "assets/knowledgeBase-de4d1c97.js", "assets/Autocomplete-3aa3344b.js", "assets/Link-5130f40e.js", "assets/globalStore-842ad0ec.js", "assets/index-587a74f3.js", "assets/SearchArticles.vue_vue_type_script_setup_true_lang-a1e3621d.js", "assets/TicketTextEditor.vue_vue_type_script_setup_true_lang-d737e6e9.js", "assets/AttachmentItem.vue_vue_type_script_setup_true_lang-f98cb03f.js", "assets/FileUploader-3bc7c8ba.js", "assets/TextEditor-bf30f06f.js", "assets/UserAvatar.vue_vue_type_script_setup_true_lang-73349f36.js", "assets/Avatar.vue_vue_type_script_setup_true_lang-33c4215a.js"]), props: !0, meta: { onSuccessRoute: "TicketAgent", parent: "TicketsAgent" } }, { path: "/notifications", name: "Notifications", component: () => _n(() => import("./MobileNotifications-7e95fc11.js"), ["assets/MobileNotifications-7e95fc11.js", "assets/more-horizontal-b561c647.js", "assets/dayjs-8f71cd34.js", "assets/more-horizontal-93e77833.css", "assets/Breadcrumbs.vue_vue_type_script_setup_true_lang-04848fc3.js", "assets/Dropdown.vue_vue_type_script_setup_true_lang-20398480.js", "assets/knowledgeBase-de4d1c97.js", "assets/bell-07c9731c.js", "assets/UserAvatar.vue_vue_type_script_setup_true_lang-73349f36.js", "assets/Avatar.vue_vue_type_script_setup_true_lang-33c4215a.js"]) }, { path: "/kb", name: "AgentKnowledgeBase", component: () => _n(() => import("./KnowledgeBaseAgent-43a197da.js"), ["assets/KnowledgeBaseAgent-43a197da.js", "assets/knowledgeBase-de4d1c97.js", "assets/ListViewBuilder.vue_vue_type_script_setup_true_lang-23f24b4c.js", "assets/Dropdown.vue_vue_type_script_setup_true_lang-20398480.js", "assets/more-horizontal-b561c647.js", "assets/dayjs-8f71cd34.js", "assets/more-horizontal-93e77833.css", "assets/StarRating.vue_vue_type_script_setup_true_lang-87d7ba3b.js", "assets/FadedScrollableDiv.vue_vue_type_script_setup_true_lang-897d9728.js", "assets/Avatar.vue_vue_type_script_setup_true_lang-33c4215a.js", "assets/DateRangePicker.vue_vue_type_script_setup_true_lang-fc0fa242.js", "assets/Link-5130f40e.js", "assets/globalStore-842ad0ec.js", "assets/EmptyState.vue_vue_type_script_setup_true_lang-93f57bdf.js", "assets/MoveToCategoryModal.vue_vue_type_script_setup_true_lang-5a7b3c6a.js", "assets/merge-149ec802.js"]) }, { path: "/kb/articles/:articleId", name: "Article", component: () => _n(() => import("./Article-235b9918.js"), ["assets/Article-235b9918.js", "assets/globalStore-842ad0ec.js", "assets/knowledgeBase-de4d1c97.js", "assets/MoveToCategoryModal.vue_vue_type_script_setup_true_lang-5a7b3c6a.js", "assets/more-horizontal-b561c647.js", "assets/dayjs-8f71cd34.js", "assets/more-horizontal-93e77833.css", "assets/Link-5130f40e.js", "assets/Avatar.vue_vue_type_script_setup_true_lang-33c4215a.js", "assets/Breadcrumbs.vue_vue_type_script_setup_true_lang-04848fc3.js", "assets/Dropdown.vue_vue_type_script_setup_true_lang-20398480.js", "assets/TextEditor-bf30f06f.js"]), props: !0 }, { path: "/articles/new/:id", name: "NewArticle", component: () => _n(() => import("./NewArticle-f72715a7.js"), ["assets/NewArticle-f72715a7.js", "assets/Link-5130f40e.js", "assets/Breadcrumbs.vue_vue_type_script_setup_true_lang-04848fc3.js", "assets/Dropdown.vue_vue_type_script_setup_true_lang-20398480.js", "assets/TextEditor-bf30f06f.js", "assets/more-horizontal-b561c647.js", "assets/dayjs-8f71cd34.js", "assets/more-horizontal-93e77833.css", "assets/UserAvatar.vue_vue_type_script_setup_true_lang-73349f36.js", "assets/Avatar.vue_vue_type_script_setup_true_lang-33c4215a.js", "assets/knowledgeBase-de4d1c97.js", "assets/globalStore-842ad0ec.js"]), props: !0 }, { path: "/customers", name: "CustomerList", component: () => _n(() => import("./Customers-bf4ab84c.js"), ["assets/Customers-bf4ab84c.js", "assets/knowledgeBase-de4d1c97.js", "assets/ListViewBuilder.vue_vue_type_script_setup_true_lang-23f24b4c.js", "assets/Dropdown.vue_vue_type_script_setup_true_lang-20398480.js", "assets/more-horizontal-b561c647.js", "assets/dayjs-8f71cd34.js", "assets/more-horizontal-93e77833.css", "assets/StarRating.vue_vue_type_script_setup_true_lang-87d7ba3b.js", "assets/FadedScrollableDiv.vue_vue_type_script_setup_true_lang-897d9728.js", "assets/Avatar.vue_vue_type_script_setup_true_lang-33c4215a.js", "assets/DateRangePicker.vue_vue_type_script_setup_true_lang-fc0fa242.js", "assets/Link-5130f40e.js", "assets/globalStore-842ad0ec.js", "assets/EmptyState.vue_vue_type_script_setup_true_lang-93f57bdf.js", "assets/FileUploader-3bc7c8ba.js"]) }, { path: "/contacts", name: "ContactList", component: () => _n(() => import("./Contacts-48fa879c.js"), ["assets/Contacts-48fa879c.js", "assets/Avatar.vue_vue_type_script_setup_true_lang-33c4215a.js", "assets/more-horizontal-b561c647.js", "assets/dayjs-8f71cd34.js", "assets/more-horizontal-93e77833.css", "assets/knowledgeBase-de4d1c97.js", "assets/ListViewBuilder.vue_vue_type_script_setup_true_lang-23f24b4c.js", "assets/Dropdown.vue_vue_type_script_setup_true_lang-20398480.js", "assets/StarRating.vue_vue_type_script_setup_true_lang-87d7ba3b.js", "assets/FadedScrollableDiv.vue_vue_type_script_setup_true_lang-897d9728.js", "assets/DateRangePicker.vue_vue_type_script_setup_true_lang-fc0fa242.js", "assets/Link-5130f40e.js", "assets/globalStore-842ad0ec.js", "assets/EmptyState.vue_vue_type_script_setup_true_lang-93f57bdf.js", "assets/FileUploader-3bc7c8ba.js", "assets/dialogState-e18b28cc.js"]) }, { path: "/agents", name: "AgentList", redirect: "/tickets" }, { path: "/teams", name: "Teams", redirect: "/tickets" }, { path: "/teams/:teamId", name: "Team", redirect: "/tickets" }, { path: "/canned-responses", name: "CannedResponses", component: () => _n(() => import("./CannedResponses-71620722.js"), ["assets/CannedResponses-71620722.js", "assets/UserAvatar.vue_vue_type_script_setup_true_lang-73349f36.js", "assets/Avatar.vue_vue_type_script_setup_true_lang-33c4215a.js", "assets/Breadcrumbs.vue_vue_type_script_setup_true_lang-04848fc3.js", "assets/Dropdown.vue_vue_type_script_setup_true_lang-20398480.js", "assets/TextEditor-bf30f06f.js", "assets/more-horizontal-b561c647.js", "assets/dayjs-8f71cd34.js", "assets/more-horizontal-93e77833.css", "assets/knowledgeBase-de4d1c97.js", "assets/EmptyState.vue_vue_type_script_setup_true_lang-93f57bdf.js", "assets/CannedResponses-dc275faf.css"]) }, { path: "/dashboard", name: "Dashboard", component: () => _n(() => import("./Dashboard-42c2d101.js"), ["assets/Dashboard-42c2d101.js", "assets/users-ff29ac86.js", "assets/knowledgeBase-de4d1c97.js", "assets/Dropdown.vue_vue_type_script_setup_true_lang-20398480.js", "assets/DateRangePicker.vue_vue_type_script_setup_true_lang-fc0fa242.js", "assets/more-horizontal-b561c647.js", "assets/dayjs-8f71cd34.js", "assets/more-horizontal-93e77833.css", "assets/Link-5130f40e.js", "assets/Dashboard-33626cc0.css"]) }, { path: "/my-tickets", name: "TicketsCustomer", component: () => _n(() => import("./Tickets-3f26a831.js"), ["assets/Tickets-3f26a831.js", "assets/more-horizontal-b561c647.js", "assets/dayjs-8f71cd34.js", "assets/more-horizontal-93e77833.css", "assets/knowledgeBase-de4d1c97.js", "assets/ListViewBuilder.vue_vue_type_script_setup_true_lang-23f24b4c.js", "assets/Dropdown.vue_vue_type_script_setup_true_lang-20398480.js", "assets/StarRating.vue_vue_type_script_setup_true_lang-87d7ba3b.js", "assets/FadedScrollableDiv.vue_vue_type_script_setup_true_lang-897d9728.js", "assets/Avatar.vue_vue_type_script_setup_true_lang-33c4215a.js", "assets/DateRangePicker.vue_vue_type_script_setup_true_lang-fc0fa242.js", "assets/Link-5130f40e.js", "assets/globalStore-842ad0ec.js", "assets/EmptyState.vue_vue_type_script_setup_true_lang-93f57bdf.js", "assets/ticketStatus-b2a972bb.js", "assets/Dropdown-a6c1fbb4.js"]), meta: { public: !0, auth: !0 } }, { path: "/my-tickets/:ticketId", name: "TicketCustomer", component: () => _n(() => import("./TicketCustomer-a1b8310f.js"), ["assets/TicketCustomer-a1b8310f.js", "assets/formCustomisation-44f18b9b.js", "assets/Dropdown.vue_vue_type_script_setup_true_lang-20398480.js", "assets/Breadcrumbs.vue_vue_type_script_setup_true_lang-04848fc3.js", "assets/more-horizontal-b561c647.js", "assets/dayjs-8f71cd34.js", "assets/more-horizontal-93e77833.css", "assets/knowledgeBase-de4d1c97.js", "assets/globalStore-842ad0ec.js", "assets/TicketFeedback.vue_vue_type_script_setup_true_lang-525e5c2e.js", "assets/StarRating.vue_vue_type_script_setup_true_lang-87d7ba3b.js", "assets/symbols-7dbf6ecf.js", "assets/Avatar.vue_vue_type_script_setup_true_lang-33c4215a.js", "assets/TicketConversation.vue_vue_type_script_setup_true_lang-a31c238b.js", "assets/TicketCommunication.vue_vue_type_script_setup_true_lang-513143c6.js", "assets/EmailContent-821cc341.js", "assets/AttachmentItem.vue_vue_type_script_setup_true_lang-f98cb03f.js", "assets/UserAvatar.vue_vue_type_script_setup_true_lang-73349f36.js", "assets/index-587a74f3.js", "assets/TicketCustomerTemplateFields.vue_vue_type_script_setup_true_lang-980b5ad0.js", "assets/TicketFeedback.vue_vue_type_script_setup_true_lang-ca6ffb0e.js", "assets/TicketTextEditor.vue_vue_type_script_setup_true_lang-d737e6e9.js", "assets/FileUploader-3bc7c8ba.js", "assets/TextEditor-bf30f06f.js"]), meta: { public: !0, auth: !0 }, props: !0 }, { path: "/my-tickets/new", name: "TicketNew", component: () => _n(() => import("./TicketNew-64253468.js"), ["assets/TicketNew-64253468.js", "assets/formCustomisation-44f18b9b.js", "assets/Dropdown.vue_vue_type_script_setup_true_lang-20398480.js", "assets/Breadcrumbs.vue_vue_type_script_setup_true_lang-04848fc3.js", "assets/more-horizontal-b561c647.js", "assets/dayjs-8f71cd34.js", "assets/more-horizontal-93e77833.css", "assets/knowledgeBase-de4d1c97.js", "assets/Autocomplete-3aa3344b.js", "assets/Link-5130f40e.js", "assets/globalStore-842ad0ec.js", "assets/index-587a74f3.js", "assets/SearchArticles.vue_vue_type_script_setup_true_lang-a1e3621d.js", "assets/TicketTextEditor.vue_vue_type_script_setup_true_lang-d737e6e9.js", "assets/AttachmentItem.vue_vue_type_script_setup_true_lang-f98cb03f.js", "assets/FileUploader-3bc7c8ba.js", "assets/TextEditor-bf30f06f.js", "assets/UserAvatar.vue_vue_type_script_setup_true_lang-73349f36.js", "assets/Avatar.vue_vue_type_script_setup_true_lang-33c4215a.js"]), props: !0, meta: { onSuccessRoute: "TicketCustomer", parent: "TicketsCustomer", public: !0, auth: !0 } }, { path: "/kb-public", name: "CustomerKnowledgeBase", component: () => _n(() => import("./KnowledgeBaseCustomer-7fcf9a4b.js"), ["assets/KnowledgeBaseCustomer-7fcf9a4b.js", "assets/more-horizontal-b561c647.js", "assets/dayjs-8f71cd34.js", "assets/more-horizontal-93e77833.css", "assets/knowledgeBase-de4d1c97.js", "assets/SearchArticles.vue_vue_type_script_setup_true_lang-a1e3621d.js"]), meta: { public: !0, auth: !0 } }, { path: "/kb-public/:categoryId", name: "Articles", component: () => _n(() => import("./Articles-1804942d.js"), ["assets/Articles-1804942d.js", "assets/knowledgeBase-de4d1c97.js", "assets/Breadcrumbs.vue_vue_type_script_setup_true_lang-04848fc3.js", "assets/Dropdown.vue_vue_type_script_setup_true_lang-20398480.js", "assets/Avatar.vue_vue_type_script_setup_true_lang-33c4215a.js", "assets/dayjs-8f71cd34.js"]), props: !0, meta: { public: !0, auth: !0 } }, { path: "/kb-public/articles/:articleId", name: "ArticlePublic", component: () => _n(() => import("./Article-235b9918.js"), ["assets/Article-235b9918.js", "assets/globalStore-842ad0ec.js", "assets/knowledgeBase-de4d1c97.js", "assets/MoveToCategoryModal.vue_vue_type_script_setup_true_lang-5a7b3c6a.js", "assets/more-horizontal-b561c647.js", "assets/dayjs-8f71cd34.js", "assets/more-horizontal-93e77833.css", "assets/Link-5130f40e.js", "assets/Avatar.vue_vue_type_script_setup_true_lang-33c4215a.js", "assets/Breadcrumbs.vue_vue_type_script_setup_true_lang-04848fc3.js", "assets/Dropdown.vue_vue_type_script_setup_true_lang-20398480.js", "assets/TextEditor-bf30f06f.js"]), props: !0, meta: { public: !0, auth: !0 } }, { path: "/:pathMatch(.*)*", name: "Invalid Page", component: () => _n(() => import("./InvalidPage-eb3fa3c5.js"), []) }], Eut = n => Cut.value ? `Mobile${n}` : n, RC = s1e({ history: Nbe("/helpdesk/"), routes: Aut }); RC.beforeEach(async (n, e, t) => { const r = BB(); if (Sut.value = n.meta.public || !1, r.isLoggedIn && await r.init(), !r.isLoggedIn) window.location.href = NB; else if (!n.meta.public && !r.hasDeskAccess) t({ name: "TicketsCustomer" }); else if (n.name === "TicketAgent" && !r.isAgent) { const i = n.params.ticketId; t({ name: "TicketCustomer", params: { ticketId: i } }) } else t() }); RC.afterEach(async n => { if (n.meta.public) return; const { users: e } = hct(); e != null && e.fetched || await e.fetch() }); const Mut = "login", Out = "logout", Dut = "terrasuitehelpdesk.api.auth.get_user", BB = IC("auth", () => { const n = Yr({ url: Dut }), e = async () => { n.fetched || await n.fetch() }, t = n.reload, r = ne(() => n.data || {}), i = ne(() => r.value.has_desk_access), a = ne(() => r.value.is_admin), o = ne(() => r.value.is_agent), s = ne(() => r.value.is_manager), l = ne(() => r.value.user_id), c = ne(() => r.value.user_image), u = ne(() => r.value.user_first_name), d = ne(() => r.value.user_name), f = ne(() => r.value.username), h = ne(() => r.value.time_zone); function p() { let v = new URLSearchParams(document.cookie.split("; ").join("&")).get("user_id"); return v === "Guest" && (v = null), v } const m = he(p()), g = ne(() => !!m.value), y = Yr({ url: Mut, onError() { throw new Error("Invalid email or password") }, onSuccess() { m.value = p(), y.reset(), RC.replace({ path: "/" }) } }); function b() { m.value = null, sst(Out).then(() => { window.location.href = NB }) } return { hasDeskAccess: i, init: e, isAdmin: a, isAgent: o, isManager: s, isLoggedIn: g, login: y, reloadUser: t, userFirstName: u, userId: l, userImage: c, userName: d, username: f, timezone: h, user: m, logout: b } }), jut = We({ __name: "App", setup(n) { Xlt(), un(() => { window.addEventListener("online", () => { fs.create({ message: "You are now online", icon: Gt(sct) }) }), window.addEventListener("offline", () => { fs.create({ message: "You are now offline", icon: Gt(uct) }) }) }); const e = Em(() => _n(() => import("./AgentRoot-b51d7d03.js"), [])), t = Em(() => _n(() => import("./CustomerPortalRoot-6f8fa5fa.js"), [])), r = ne(() => { const i = BB(); return i.hasDeskAccess && i.isAgent ? e : t }); return cr(() => { rct() }), (i, a) => (Z(), ye(Qt, null, [$e(X(j4e), null, { default: Ue(() => [$e(X(r))]), _: 1 }), $e(qlt), $e(X(Mlt))], 64)) } }); const FW = { Badge: MY, Button: ed, Dialog: _Z, ErrorMessage: bR, FeatherIcon: vc, FormControl: V2e, Input: X2e, Tooltip: as, TextInput: vR }; vZ("resourceFetcher", Sst); vZ("fallbackErrorHandler", n => { const e = n.exc_type ? (n.messages || n.message || []).join(", ") : n.message; fs.error(e) }); const Put = Slt(), Kd = R0(jut); Kd.use(xst); Kd.use(Put); Kd.use(RC); Kd.use(ict); for (const n in FW) Kd.component(n, FW[n]); Kd.config.globalProperties.$socket = Kse; Kd.config.globalProperties.$dialog = Olt; Kd.mount("#app"); export { Or as $, he as A, mct as B, ut as C, Eo as D, Mo as E, Qt as F, Wa as G, _Z as H, Gt as I, MY as J, Sut as K, as as L, un as M, oft as N, Kn as O, mY as P, bft as Q, fs as R, vc as S, xut as T, K3e as U, rk as V, hct as W, Yr as X, cr as Y, sst as Z, _n as _, BB as a, D1e as a$, V2e as a0, Tut as a1, Sn as a2, gst as a3, Ct as a4, gft as a5, Kse as a6, N0 as a7, IS as a8, Pq as a9, g0e as aA, v0e as aB, p0e as aC, ag as aD, Nlt as aE, hft as aF, fft as aG, pft as aH, nE as aI, zdt as aJ, mft as aK, Uge as aL, Xlt as aM, ed as aN, Wse as aO, cft as aP, ab as aQ, ek as aR, Du as aS, Idt as aT, ck as aU, $dt as aV, PS as aW, dn as aX, _k as aY, X2e as aZ, _st as a_, Bn as aa, Ut as ab, oa as ac, ub as ad, $d as ae, zn as af, vd as ag, Mi as ah, ts as ai, Mq as aj, KL as ak, Fc as al, Ky as am, Ou as an, Pr as ao, Fdt as ap, uft as aq, o4e as ar, vft as as, xft as at, yft as au, IC as av, Ndt as aw, X4 as ax, m0e as ay, Dh as az, fct as b, ch as b$, bR as b0, yut as b1, lN as b2, tb as b3, Oq as b4, zq as b5, li as b6, $0e as b7, O0e as b8, qq as b9, Bdt as bA, _ft as bB, wft as bC, ift as bD, aft as bE, Vdt as bF, Mx as bG, V0e as bH, lj as bI, Pdt as bJ, rY as bK, NSe as bL, dft as bM, lft as bN, U3e as bO, kge as bP, kK as bQ, mr as bR, wdt as bS, qW as bT, zut as bU, mdt as bV, Yut as bW, yS as bX, Vm as bY, ldt as bZ, rb as b_, Nq as ba, jq as bb, Dq as bc, y0e as bd, ak as be, yy as bf, L0e as bg, Hye as bh, Vt as bi, r0e as bj, Hq as bk, i0e as bl, jdt as bm, vR as bn, Udt as bo, Gdt as bp, Wdt as bq, Rdt as br, USe as bs, aa as bt, dq as bu, $g as bv, pY as bw, Q_ as bx, eb as by, kr as bz, ne as c, Zut as c$, Nut as c0, Cdt as c1, But as c2, WL as c3, Fut as c4, xs as c5, nb as c6, Ta as c7, CL as c8, $o as c9, Wut as cA, fdt as cB, Edt as cC, Dve as cD, OL as cE, ul as cF, dd as cG, ddt as cH, jo as cI, hd as cJ, Wge as cK, Lge as cL, IL as cM, Rge as cN, Vge as cO, zge as cP, Fge as cQ, $ge as cR, LL as cS, gge as cT, Hut as cU, hK as cV, Vut as cW, SS as cX, ba as cY, udt as cZ, tj as c_, bdt as ca, R0 as cb, lve as cc, adt as cd, sve as ce, Mye as cf, XT as cg, pye as ch, Jut as ci, Qut as cj, ndt as ck, edt as cl, Xut as cm, Sdt as cn, tdt as co, gdt as cp, Iut as cq, YW as cr, $ut as cs, jL as ct, Bg as cu, eve as cv, Adt as cw, Gut as cx, qut as cy, Kut as cz, We as d, hl as d$, _dt as d0, j0 as d1, M4 as d2, vdt as d3, fd as d4, dK as d5, Op as d6, Fa as d7, uve as d8, ydt as d9, wn as dA, xn as dB, vt as dC, Qh as dD, qX as dE, ht as dF, jX as dG, KX as dH, VX as dI, HX as dJ, IX as dK, FX as dL, Hg as dM, LX as dN, RX as dO, UX as dP, YX as dQ, rJ as dR, GX as dS, BX as dT, zX as dU, ZX as dV, eJ as dW, QX as dX, t2 as dY, _t as dZ, iJ as d_, Lut as da, $y as db, M0 as dc, Po as dd, cdt as de, p4 as df, kdt as dg, xdt as dh, gye as di, RD as dj, dve as dk, Tdt as dl, TK as dm, yq as dn, Tye as dp, _q as dq, bq as dr, jve as ds, pdt as dt, GK as du, fve as dv, odt as dw, rdt as dx, hdt as dy, Uut as dz, Z as e, Be as e0, Qe as e1, tJ as e2, nJ as e3, wR as e4, nd as e5, Br as e6, Hr as e7, Dl as e8, n0e as e9, i$ as ea, Ti as eb, Ddt as ec, Odt as ed, NW as ee, Ye as f, $e as g, X as h, Em as i, yn as j, ye as k, re as l, idt as m, sdt as n, Bge as o, vr as p, Ldt as q, Cc as r, Fo as s, Ht as t, c1e as u, dl as v, Ue as w, Tt as x, mt as y, ar as z };
//# sourceMappingURL=index-54e545bb.js.map
